<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/16/大型网站系统与中间件实践读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/16/大型网站系统与中间件实践读书笔记/" itemprop="url">大型网站系统与中间件实践读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-16T11:22:37+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式系统介绍"><a href="#分布式系统介绍" class="headerlink" title="分布式系统介绍"></a>分布式系统介绍</h2><h3 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h3><p>1.组件分布在网络计算机上；<br>2.组件之间仅仅通过消息传递来通信并协调行动</p>
<h3 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h3><p>1.升级单机处理能力的性价比越来越低<br>2.单机处理能力存在瓶颈<br>3.出于稳定性和可用性的考虑</p>
<h3 id="线程和进程的执行模式"><a href="#线程和进程的执行模式" class="headerlink" title="线程和进程的执行模式"></a>线程和进程的执行模式</h3><h4 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h4><p>s(N)=1/(1-p+p/n);n代表核数，p代表并行部分在单核占的时间</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第八周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第八周周报/" itemprop="url">云取证第八周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T19:54:42+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。<br>首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次。2.显示云测试的总体上下文；3.提供了包括Guidance EnCase和AccesData Forensic Toolkit在内的流行取证获取工具。<br>云计算使取证不同，特别是考虑到证据的远程性质，缺乏实体访问权限以及完整性和真实性所需的信任。虽然取证检查员的目标与以前相同，但非传统困难的问题包括：远程数据的取证知识获取，大量传播，分布式数据，监管链和数据所有权。检获和获取数字文物是取证进程的初步步骤。存在两种可能的情况：远程调查员可以从源头自己收集取证证据，或者提供者可以提供证据。每个场景需要对所返回数据的不同程度的信任。此外，每种情况都使用不同的技术实现来恢复数据。主要工作有亚马逊弹性计算云（EC2）在公共云中执行持续和非持久性数据收集的现有工具的三个实验结果。对于使用客户机操作系统的数据采集不够信任的情况，分析基础设施堆栈较低级别的取证方法。演示如何使用虚拟机内省来注入远程取证代理进行远程采集。用不受信任的管理程序探索取证数据采集的四个策略。<table><tr><td>Layer</td><td>Cloud layer</td><td>Acquisition method</td><td>Trust required</td></tr><br>    <tr><td>6</td><td>Guest application/data</td><td>Depends on data</td><td>Guest operating system (OS), hypervisor, host OS, hardware, network</td></tr>  <tr><td>5</td><td>Guest OS</td><td>Remote forensic software</td><td>Guest OS, hypervisor, host OS, hardware, network</td></tr><tr><td>4</td><td>Virtualization</td><td>Introspection</td><td>Hypervisor, host OS, hardware, network</td></tr><tr><td>3</td><td>Access virtual disk</td><td>Access virtual disk</td><td>Host OS, hardware, network</td></tr><tr><td>2</td><td>Physical hardware</td><td>Access physical disk</td><td>Hardware, network</td></tr><tr><td>1</td><td>Network</td><td>Packet capture </td><td>Network</td></tr></table><br>  在IaaS中，尽管没有物理访问，消费者仍保留对第5层（访客操作系统）和6（访客应用程序）的管理控制权。此外，各层次的取证行为将不同。每一层需要不同的信任，即该层是安全和信任的;堆栈越远，累积的信任就越少。在公共云中，所有层都需要提供商的一些信任，特别是对恶意内部人员的信任。防伪策略，病毒检测器应在多层次上检查证据。调查人员可以选择云层的哪一层进行取证处理。关于这一决定的考虑首先围绕在该级别进行取证的技术能力，再次对所返回数据的信任。该层还影响可用于收集的哪些类型的取证数据，例如第1层（网络）上的数据包捕获，第2层物理文件（物理硬件）或第3层（主机操作系统）上的虚拟文件。对于每种数据类型，数据必须遵守严格的监管链，并且必须包括完整性检查机制。云计算引入了一个强大的新选项：虚拟机快照。利用虚拟化的许多云实现可以拍摄正在运行的计算机的快照，然后像现在一样将该快照恢复并运行。这提供了创造历史记录的能力，以及事后做“活”取证。</p>
<p>  接下来就是实验。能够远程获取aharddrive和内存映像。分析EnCase Forensic和FTK Investigator中的这些映像分别正确显示了活动的时间表，包括安装Apache和网页创建和删除。分析显示虚拟环境的异常现象，也没有任何明显的异议，引起对数据完整性的怀疑。采集过程的速度受到我们学习如何使用远程代理和网络带宽传输数据的限制。每个EnCase和FTK大约12小时，使用我们大学的OC-12连接传输30 GB磁盘映像和2 GB内存映像。实验2成功地形成了驱动器的完整图像和正确的时间线。 VM内省是取证学的强大工具，允许人的实时调查，而不会显露调查人员的存在。然而，内省是云服务提供商必须实施的一个特殊功能。这是我们能够验证图像完整性的唯一实验，因为我们可以访问物理磁盘，并且可以比较EnCase映像和原始磁盘的散列值。实验3中的AWS导出过程也成功地返回了驱动器的完整映像。我们能够将驱动器加载到EnCase和FTK中，没有任何困难，并验证了驱动器的内容。这种方法的另外一个好处是，AWS会为导出的每个文件生成一个具有元数据的日志报告。此报告包含以下每个文件：传输的日期和时间，存储设备上的位置，MD5校验和和字节数。使用快速运输，花了五天时间收到我们的数据，费用为125美元。我们设想这个过程将会严格地模仿AWS在遵守搜索令或传票时所采取的步骤。 EnCase和FTK最容易使用。尽管使用远程功能需要安装和学习时间，但工具的功能是熟悉且易于执行的。检索磁盘映像所需的12小时时间远远少于此数据卷的AWS导出过程所需的120小时。下载数据平均每小时2.5 GB。 AWSExport花了4小时加载了我们的数据，而剩下的116小时在运输过程中花费了时间。按照这些速率，最有效的选择是导出过程，当超过240 GB的数据将被检索。</p>
<p>  A forensically robust method for acquisition of iCloud data主要讲一种方法，不仅使得下载数据到验证的计算机上然后验证数据的完整性，还可以定位到数据的来源。首先是采集云服务中存储的数据变得越来越重要数字取证调查。 苹果公司不断扩大其云端的功能服务，iCloud。 因此，确定取证获取的有效手段是至关重要的，来自该服务的数据的定义及其对原始文件数据和元数据的影响。本研究通过本机Mac OS X检查从iCloud服务获取的文件系统与服务同步。 目标是确定操作系统iCloud同步文件的位置。 一旦找到，次要目标是确定是否文件哈希值与原始文件匹配，特别是文件元数据时间戳，被改变。</p>
<p>  研究人员使用不同的技术去获取数据。有两种技术是先是通过虚拟机创建镜像，然后用FTK工具去分析这些镜像。还有一种是根据AWS去导出数据。导出的还包括包括“日期和时间传输，存储设备上的位置，MD5校验和，和字节数“。如果哈希值相同则代表数据并未改变。接下来是实验，有两台虚拟机，第一台在整个过程进行快照拍摄，并且数据与云服务同步，第二台新创建的iCloud帐户。然后进行分析以定位iCloud 。下载的文件是与原始文件进行比较以确定文件是否相符<br>  和元数据是一样的，如果不是，初始化配置。</p>
<p>  Side channels in cloud services, the case of deduplication in cloud storage云存储服务通常使用重复数据删除，通过仅存储每个文件或块的单个副本来消除冗余数据。重复数据删除减少了数据存储服务的空间和带宽需求，并且在跨多个用户应用时是最有效的，这是云存储产品的常见做法。我们研究跨用户重复数据删除的隐私含义。我们演示如何使用重复数据删除作为侧面通道，显示有关其他用户的文件内容的信息。在不同的情况下，重复数据删除可以用作隐藏通道，恶意软件可以通过该渠道与其控制中心进行通信，而不管受攻击机器上的任何防火墙设置如何。由于跨用户重复数据删除所带来的高额节省，云存储提供商不可能停止使用此技术。因此，我们提出了简单的机制，可以跨用户重复数据删除，同时大大降低数据泄露的风险。<br>  有两种主要的重复数据删除策略：（1）文件级重复数据删除，其中只存储每个文件的单个副本。如果两个或多个文件具有相同的哈希值，则它们将被标识为相同。这是一种非常受欢迎的多种产品提供的服务; （2）块级重复数据删除，将文件分割成块并仅存储每个块的单个副本。系统可以使用固定大小的块或可变大小的块。</p>
<p>  我们描述的攻击可以应用于在文件级别或块级执行的重复数据删除（具体来说，我们假设从现在开始，在文件级别执行重复数据删除）。但是，重复数据删除服务有两个对攻击至关重要的功能：•基于源的重复数据删除。也就是说，重复数据消除必须在客户端进行。如上所述，此版本的重复数据删除功能节省了带宽，因此常用。应用此方法的结果是，客户端可以观察某个文件或块是否被重复数据删除（或简称为“重复数据删除”）。这可以通过检查通过网络传输的数据量，或通过观察存储软件的日志（如果该软件提供此类报告）来完成。 •对攻击至关重要的第二个功能是跨用户重复数据删除。也就是说，将每个文件或块与其他用户的数据进行比较，如果在服务器上已经可以使用相同的副本，则将其重新排除。这种方法是受欢迎的，因为它不仅在单个用户具有相同数据的多个副本时，而且当不同的用户存储数据的副本时，可以节省存储和带宽。 （企业客户端通常存储相同或相似数据的多个副本，我们发现即使对于私人客户也是如此：几乎每个常用的软件手册或我们试图使用流行备份服务进行备份的媒体文件都已经可以使用请注意，这些是巨大的文件，因此重复数据删除为服务提供商节省了巨大的成本。）识别易受攻击的存储提供商：我们进行了以下测试，以确定执行基于源和跨平台的服务，用户重复数据删除（测试可以由任何读者重复，他选择的存储服务）：（1）我们在两台不同的计算机上安装了该服务的客户端软件，并创建了两个不同的用户帐户; （2）我们使用一个帐号上传文件（在我们的测试中，这个文件是Sun的VirtualBox软件，大小接近73M）; （3）我们使用第二个帐号再次上传同一个文件，检查是否确实上传了。当文件没有通过网络重新发送时，我们得出结论，备份服务执行基于源的跨用户重复数据删除。 （事实上​​，当检查流行的存储服务时，不需要使用两个帐号，因为如上所述，在网络上发现的任何流行的文件很可能存在于服务器上，因为它以前是由其他用户上传的，因此测试可以包括从Web下载流行的文件，将其上传到服务并检查重复数据删除是否发生。）我们确定了三个领先的备份和文件同步提供程序的服务，它们执行跨用户，基于源的重复数据删除。这些服务是（1）DropBox，一种流行的文件共享和备份服务，超过了300万用户里程碑; 2 2）Mozy是面向消费者和企业的在线备份的领先提供商，为超过一百万客户和50,000名业务用户提供备份，并存储超过25 PB; 3和（3）备份审查作为欧洲最佳在线备份服务的Memopal，每天有近1000个新用户4值得注意的是，大多数供应商并不试图隐藏重复数据删除的事实，在我们的测试中容易地以几种简单的方式检测：（1）检查历史记录或日志文件（此方法与MozyHome 5配合使用）; （2）根据上传状态消息，上传和重复数据删除的文件有所不同（此方法与Memopal 6配合使用）; （3）根据上传速度，检查文件上传是否在比客户机上传带宽所需的时间短得多的时间内完成（DropBox 7就是这样）; （4）最终，最常用的重复数据删除检测方法适用于所有服务，无论其接口如何，都是监控网络流量并测量传输数据量。我们注意到，大多数服务具有额外的客户端 - 服务器通信流量，但与上传大型文件时传输的大量数据相比，可以忽略不计。<br>  第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。此第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。假设有一个攻击者，爱丽丝，谁想要了解有关Bob，云存储服务的用户的信息。那么显然，如果爱丽丝怀疑鲍勃有一些不太可能拥有任何其他用户的特定敏感文件X，她可以使用重复数据删除来检查这个猜想是否正确。 Alice应该做的是尝试备份X的副本，并检查是否发生重复数据删除。作为一个具体的例子，假设有一个文件证明一些非法活动（例如记录暴力事件，或者是具有一些被盗的敏感信息的文件，或与儿童色情相关的材料）。执法机关一旦掌握该文件的副本，就可以将文件上传到不同的云存储提供商，并识别存储文件副本的存储服务。然后，他们可以要求法院命令，要求服务提供商披露上传文件的用户的身份。 （如果文件被认为对于识别拥有该用户的用户来说太敏感，则如上所述，当局上传该文件的过程可以在确定是否在开始之后立即终止重复数据删除应用于此文件。）2.2攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。但是，攻击者可能会将此攻击应用于同一文件的多个版本，对本文件内容的所有可能的值基本上执行强力攻击。例如，假设Alice和Bob在同一家公司工作，该公司使用云备份服务来备份所有员工的机器。每年一次，所有员工将收到一份新的标准合同副本，其中包含其更新的薪水。爱丽丝好奇地找到了鲍勃的新工资，这可能是$ 500- $ 200,000之间的$ 500的倍数。所有Alice必须做的是生成一个Bob的合同模板，Bob的名字和新合同的日期，然后为Bob的每个可能的工资（总共301个文件）生成合同的副本。然后，她运行备份到她和Bob使用的公司备份服务。发生重复数据删除的单个文件是包含Bob实际工资的单个文件。只要目标文件的可能版本数量适中，就可以应用此攻击。这对于企业环境来说似乎非常有用，通常文件是标准模板的小变体。请考虑以下三个示例：•网上银行服务向客户发送一个包含其登录名和PIN的文档，这是一个4位数字。因此，爱丽丝可以使用登录名“Bob”和PIN的所有可能值生成10,000个文档，并检查其中哪些文件已被存储。本文档对应于Bob的实际PIN码。相同的攻击可以应用于任意密码，如果它们来自中等大小的域。请注意，与在线字典攻击不同，受到攻击的银行服务不会注意到某人正在尝试某个用户的所有潜在密码。 •假设一个详细描述Bob的医学检查结果的文件存储在他的计算机上。爱丽丝可以使用这种攻击来查找测试的结果，这通常来自一个小域（例如，对于遗传性疾病的发生或怀孕测试的结果是一个是/否的答案，或来自一个范围，例如胆固醇测试的一百个可能的值）。转诊医生的姓名和转诊日期可能是爱丽丝所知，或者可能来自一个小领域。即使是测试的序列号，如果存在这样一个数字，可能会被Alice猜出，如果她有一个类似日期的测试结果的例子。 •假设爱丽丝和鲍勃都参与拍卖，要求投标人以包含其名称和出价的标准表格提交投标（这实际上是许多拍卖和采购流程中的常见做法）。如果爱丽丝可以推测出鲍勃的10,000个最有可能的出价值，她可以使用相同的攻击来查找鲍勃的实际出价，然后相应地设置出价。<br>  攻击III：隐蔽通道假设爱丽丝设法在Bob的机器上安装了一些恶意软件。然而，Bob运行防火墙，防止未经授权的程序连接到外部世界。即使这样的防火墙没有运行，Alice 3可能希望隐藏恶意软件与其命令和控制服务器之间的通信）。如果Bob正在使用使用跨用户重复数据删除的在线存储服务，则Alice可以使用重复数据删除攻击来建立从恶意软件到由其运行的远程控制中心的隐蔽通道。 （隐藏通道的存在可能是二次攻击，也可能有其他方法建立隐蔽通道，但是通过利用跨用户的重复数据删除来检查隐藏通道是如何建立起来的。我们先来描述一个位如何传输：软件生成文件的两个版本之一X 0或X 1，并将其保存在Bob的机器上。如果要传送消息“0”，则保存文件X 0;否则保存文件X 1。这些文件必须是足够随机的，因此任何其他用户不可能生成相同的文件。在某些时间点（例如每天），Bob运行备份并将文件存储在在线存储服务中。 Alice然后执行与Bob相同的服务的备份，并且学习以前存储哪些文件X 0或X 1，也就是说，她将学习软件发送的消息。隐藏通道可用于通过使软件保存多于一个文件，并为每个文件的内容使用两个以上的选项来传输任意长的消息。此方法的详细性能分析超出了本文的范围。我们在这里描述了恶意软件如何向其命令和控制中心发送消息。如果恶意软件有可能检查备份的日志文件，并在进行重复数据删除时进行观察，则可以使用相同的技术来发送相反方向的消息。</p>
<p>  重复数据删除的安全风险源于以下事实：文件的重复数据删除会发生，如果并且只有此文件已经上传到存储服务。通过削弱重复数据删除与存储服务中文件的存在之间的相关性，可以降低风险。这是通过为每个文件分配一个随机阈值，并且只有当文件的副本超过此阈值时才执行重复数据删除。在更详细地检查此解决方案之前，要检查类似的方法，这是不安全的：这里，服务器设置全局阈值t（例如，t = 10），并且只有至少在文件中执行重复数据删除t文件的副本已上传。在这种情况下，确实，Alice上传文件的单个副本并不能显示Bob先前是否已经上传过该文件。然而，Alice可以上传许多文件副本（甚至使用多个用户身份），并检查是否在t或t-1之后重复数据删除，文件副本由她上传。后一种情况表示该文件的副本以前由其他用户上传。 （我们可以放心地假设爱丽丝知道阈值t，因为她可以进行简单的实验来揭示t的价值。）解决方案：现在让我们更详细地描述随机解。对于每个文件X，存储服务器分配在[2，d]范围内随机均匀选择的阈值t X，其中d是可能是公共的参数。 （例如，假设d = 20）重要的是，除了服务器之外，没有人可以计算t X，即使X的内容是已知的。实现此属性的一种方式是服务器随机选择t X并私有存储该值。另一种方法是使用秘密密钥的服务器，并且根据文件的内容或其散列值和密钥的计算阈值。即，计算t X = F（X，s）。在这种情况下，不需要显式存储X的阈值，因为服务器可以轻松地重新计算它。现在，对于每个文件X，服务器保留先前已经上传X副本的客户端数量的计数器X.当上传文件的新副本时，如果存在以下两个条件之一，则在客户端进行重复数据删除保持：（1）c X≥t X，或（2）由以前上传过X的客户端上传副本。否则不会发生重复数据删除。请注意，重复数据删除的最小份数为2，因为在上传文件的第一个副本时，不可能执行5次重复数据删除。该解决方案在X上传的第一个t X - 1次中隐藏了用户重复数据删除的发生，因为该文件被上传，就像在服务器上没有可用的副本一样。然而，一旦将数据传输到服务器端，就可以执行重复数据删除。因此，此解决方案提供的整体磁盘空间节省与基本重复数据删除方案完全相同。唯一的赔偿是带宽利用率较小，因为与tp重复数据删除解决方案相比，（t X -1）·X个文件的多个副本被上传。图1说明了提出的解决方案及其数据流。处理删除：文件删除也必须加以修饰。当删除发生时，减少文件副本的计数器c X似乎是很自然的。但是，此设置可以进行以下攻击：Alice上传文件X的副本，并注意到t副本上传后会发生重复数据删除。然后，她再次从在线存储中删除X的两个副本，并再次上传这两个副本。如果在其中一个测试中，她注意到在上传两个副本中只有一个之后发生重复数据删除，则必须是其他用户刚刚上传了X的副本。同样，如果重复数据删除在上传三个之后发生，而不是两个，X的副本，那么另一个用户必须删除这个文件的副本。这种攻击并不实用，因为在删除后，在线存储服务通常会保留已删除文件的副本一段时间。例如，包括Mozy，DropBox和Memopal在内的大多数服务的策略是删除文件至少要保留30天。因此，攻击的每次迭代都需要至少30天才能执行。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第七周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第七周周报/" itemprop="url">云取证第七周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T19:54:30+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。</p>
<p>云计算安全研究主要讲云计算的趋势、云安全挑战、云安全现状、云计算安全框架的建议、云安全的技术研究。这里面我觉得这几点是比较重要的，例如云安全的挑战和云计算安全关键技术研究。<br>首先在于云安全的挑战，在于以下三点：1.建立以数据安全和隐私保护为主要目标的云安全技术框架，具体体现在：云计算服务计算模式所引发的安全问题、云计算的动态虚拟化管理方式引发的安全问题、 云计算中多层服务模式引发的安全问题；2.建立以安全目标验证、安全服务等级测评为核心的云计算安全标准及其测评体系；3.建立可控的云计算安全监管体系，具体体现在：实现基于云计算的安全攻击的快速识别、预警与防护；实现云计算内容监控的难度；识别并防止基于云计算的密码类犯罪活动。<br>接着是云计算安全关键技术研究，主要有以下几点：1.可信访问控制；2.密文检索与处理；3.数据存在与可使用性证明；4.数据隐私保护；5.虚拟安全技术；6.云资源访问控制；7.可信云计算；</p>
<p>云计算:系统实例与研究现状主要讲了针对云计算这样一个范畴综述了当前云计算所采用的技术,剖析其背后的技术含义以及当前云计算参与企业所采用的云计算实现方案。现有的云计算实现使用的技术体现了以下 3 个方面的特征:1) 硬件基础设施架构在大规模的廉价服务器集群之上.2) 应用程序与底层服务协作开发,最大限度地利用资源.3) 通过多个廉价服务器之间的冗余,使用软件获得高可用性.这里面讲了一下几个项目：清华大学透明计算平台、Google的云计算平台、IBM“蓝云”计算平台、Amazon的弹性计算云。.从平台技术构建来看,云计算具有3 个基本特征,即系统建立在大规模的廉价服务器集群之上,通过基础设施与上层应用程序的协同构建以达到最大效率利用硬件资源的目的,以及通过软件的方法容忍多个节点的错误.通过云计算对这 3 个方面基本特征的体现,达到了分布式系统两个方面的目标,即系统的可扩展性和可靠性。</p>
<p>Dependability in the Cloud: Challenges and Opportunitie主要讲了几个比较流行的问题，监控大量应用程序的能力可以使“人群智慧”方法提供更强大的安全性，其方式与网络提供商能够进行蠕虫和DDoS攻击相同，其中一些例子如下：几个大型云基础架构提供商的环境不仅增加了影响大量应用程序的103次共模中断的风险，而且为攻击者提供了高度可见的目标。社区驱动的网站，如主要云提供商的跟踪中断，并记录了过去两年影响数百个互联网站点的一些中断和安全漏洞。从事广泛的行为，并采用不同程度的最佳做法可以暴露云应用提高风险水平。例如，2008年4月26日，亚马逊的弹性云（EC2）在几个实例中出现了中断，原因是单个客户应用了一大批异常的防火墙规则，同时实例化了大量实例引发亚马逊分布式防火墙中的性能下降错误。</p>
<p>The Challenge of Cloud Control主要讨论了资源优化云数据中心的一些主要挑战。我们提出了一个称为云控制的新研究领域，这是一系列云管理问题的控制理论方法，旨在将当今的静态和能耗云数据中心转变为自我管理，动态和可靠的基础设施。<br>第一个挑战是性能模型，这对设计和开发至关重要稳健的控制系统。值得注意的是，云数据中心的规模大大增加，工作量动态变化比以前的电信和互联网系统多。服务器系统上的以前的结果表明，可以使用黑匣子方法和相当简单的队列模型或使用流模型。第二个挑战是服务准入控制，这在本质上是长期容量规划，控制系统根据预期的利润决定是否接受服务。此外，弹性控制器应该为正在运行的应用程序分配足够的资源，以提供可接受的QoS，同时避免昂贵的过度配置。这些解决方案分为三大类：基于机器学习算法的解决方案，基于控制理论的解决方案和基于统计工作负载分析的解决方案。此外，还有一些VM安置问题需要解决，以确定哪些部署新的VM以及要关闭的VM 。鉴于云的动态性质，随着需求和供应的变化随着时间的推移发生重大变化，VM布局决策需要频繁更新。最近关于重新布置的工作包括通过限制可以同时迁移的VM数量来实现VM迁移和性能转向的性能建模。其他动态方法包括使用随机整数规划来处理不确定性和遗传算法，以减少负载波动时的重新迁移。另一个挑战是提供云服务的大型数据中心不仅具有购买设备的成本，而且能源成本大幅提高，这意味着能源优化将至关重要。</p>
<p>首先，服务准入控制器决定是否接受弹性服务，随着时间的推移可能会有很大的变化。云提供商必须确定要承认的最佳服务数量，以最大限度地发挥其效用（收入，利用率等），而不会危及已提供服务的服务水平协议（SLA）。服务增加了云基础设施的随机负载。因此，需要接纳管制计划，以评估新服务的长期影响，具体取决于他们估计的工作量。第二，弹性控制系统的目标是分配足够的所谓的计算单位（CU），以便符合某些控制目标，以系统的性能期望为目标。我们提出定义CU术语，以便满足能力需求的要求，这与维护虚拟机的定义无关。后续的CU将被映射到合适的VM。如果假定系统状态和工作负荷可以用一定的精度来估计，则控制器设计基本上成为随机的最优控制问题。第三，VM布局控制器都执行从CU到适当的VM集的映射，以在本地或远程数据中心运行，并确定物理机器上的虚拟机的打包。在将VM分配到数据中心内的PM之前，我们考虑从CU到VM和从VM到数据中心的映射。可以制定的这些容量分配（分配）问题，例如作为限制线性问题，用于优化成本受制于容量和可能的其他约束，从而实现特定的负载平衡亲和力和抗亲和力的客观或要求（例如，在同一数据中心（或主机）中，而不是在相同的数据中心）。第四，数据中心能源优化器模型，优化机房定位决策的机房能量温度相互作用。能量优化将需要一个网络身体的看法。最后，整体管理系统监控整个系统的行为，并优化管理工具在整体数据中心管理目标方面的协同运作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第六周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第六周周报/" itemprop="url">云取证第六周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T12:44:53+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。</p>
<p>首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件系统的源文件来收集系统级别的来源。虽然这种方法是有效的，但是它具有两个显着的缺点：内核的每个新版本都需要重新整合PASS变化，其稳定性必须不断测试; 同样，使用可堆叠的文件系统使得很难在根卷上收集来源，特别是在早期引导过程中。所通过以Xen虚拟机管理程序运行的虚拟客户机收集系统级别来源的方法可以有效解决这两个缺点。</p>
<p>PASS拦截execve，fork，exit，read，readv，write，writev，mmap，open，pipe以及内核操作drop inode。这些调用足以捕获Linux文件，管道和进程之间丰富的祖先关系。这种原始的“原始来源”转向观察者，将原始来源转化为证明记录。例如，当进程P读取文件A时，观察器生成包含P取决于A的事实的记录。接着是修改Xen虚拟机管理程序的方法（Xen 是一个开放源代码虚拟机监视器）。</p>
<p>首先是前提假设。假设目标虚拟机（我们将收集来源的目标虚拟机）正在运行一个PV密钥，但是也可以针对未修改的内核（如Windows）。 Linux，Minix，GNU Hurd，OpenSolaris，NetBSD和FreeBSD都支持PV内核。本文的其余部分假定我们正在运行Linux访客内核;假设Dom0和DomU密钥以及Xen管理程序本身是不妥协的，以便我们可以信任和验证任何生成的证明。我们的方法通过在Xen的系统调用进入机制中放置适当的钩子来拦截DomU系统调用。 该挂钩为拦截器提供系统调用号及其数值参数。 拦截器又通过查找表中的系统调用来确定哪些参数是数字，哪些是用户空间中的数据结构和字符串的指针。然后继续创建一个系统调用记录。用户空间守护程序在特权域中运行，定期地：1.消耗来自环形缓冲区的记录，2.使用来源分析器处理它们，3.输出源日志，4.并将日志提供给Waldo。我们可以在多处理器/多核系统中的专用CPU /内核上运行此过程，以提高访客性能。用户空间守护程序以及其他支持软件通过专用的超级呼叫与Xen的来源子系统进行通信，只能在特权域中访问。拦截器与源极分析仪的耦合使我们能够将CPU密集型分析转移到另一个CPU或核心上，从而使客户的单线程性能受到最小的影响。更重要的是，我们将不会担心可堆叠文件系统引用的API的更改;这些变化往往会经常发生，相当可观。我们的方法的一个障碍是拦截器需要一个大的环形缓冲区来保存分析器尚未消耗的所有系统调用的记录。<strong>典型的Linux客户机每秒产生数十个读/写系统调用，涉及标准输入和输出流。我们无法轻易地将其过滤掉在拦截器上，因为这些流可能已被重新排列到文件或管道。除了消耗大量内存之外，缓冲区操作通常会增加处理器高速缓存的压力。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/云取证第五周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/云取证第五周周报/" itemprop="url">云取证第五周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T20:50:47+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。</p>
<p>首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询SELECT taskname,datacenter FROM systemlog.today WHERE severity=’warning’，扫描的数据量有100GB级别的数据量，但是查询时间仅仅需要10秒左右。BigQuery旨在分析数十亿行近似的数据，使用类SQL语法。它并不是完全符合SQL数据库的替代，并不适用于交易处理应用。BigQuery支持分析交互风格。使用SELECT命令构建查询，对于任何SQL开发者都应该很熟悉。<strong>因为我以前在做数据交换平台的时候，对于非基于lucene的全文检索的传统数据库，例如mysql查询时候，对于上百万或者上千万条甚至在上亿条数据量的查询，即使是针对索引列的查询也会很慢，更不用说数据量达到pb级别的数据量</strong>。查了下资料，总体而言，BigQuery 在大规模数据（数十亿行）上查询有很好得速度、适合快速分析大规模数据，不支持数据修改；BigQuery是OLAP系统，通过CSV格式将数据导入BigQuery，数据以弱关系型存储与云上。BigQuery 不是一个数据库系统， 1. 不支持表索引和其他关系数据库特性 2. BigQuery支持SQL得一个子集，不支持update,delete操作 3.BigQuery得join只在一张表远比另一张表小时有效（也就是不支持两张大表得join）。BigQuery 支持REST接口。</p>
<p>其次是对于Regeneration of events using system snapshots for cloud forensic analysis。 这篇论文主要讲述了在这个一种新的云攻击分析方法通过事件再生。 VNsnaps用于定期进行虚拟网络环境（VNE）的快照通过使用模糊聚类检测的云攻击技术。 然后恢复这些快照以重新生成攻击事件。首先是对于公司来说，云安全依然是在云计算里面最关心的问题。 AAA协议大致将这些尝试分为三个阶段：认证，授权和会计。云取证专注于会计，并用于分析和调查云攻击的本质，试图恢复从他们的伤害。几个输入，如日志文件和孤立的系统快照用于提取信息关于袭击。然而，这些方法只能导致一个模糊的事件视图。另外，由于网络定时协议不适用于云计算，我们是不可避免的客户和CSP的时间戳差异这使得更难于将各种实例相关联两端因此，传统技术无法明确图片的整个操作顺序的数据和涉及的过程我们的工作，通过一系列定期的快照，旨在提供具体和顺序证明所有事件对安全构成威胁数据的隐私和委托云的计算。</p>
<p>通过使用一种检测攻击的技术来解决问题正确标注其开始和结束。我们实现这个使用模糊聚类算法的“距离”概念。 VNsnap：我们使用VNsnap，一个中建立的系统来采取系统来自虚拟机外部的整个VNE的快照（VM），从而提供所有信息关于有关组件。为全球一致快照，VNsnap使用Mattern的分布式快照算法基于消息着色。另外，VM快照操作与VM的正常操作同时进行操作因此隐藏来自用户的快照延迟应用程序和减少系统停机时间（少于一个）即使在最坏的情况下）。另一个优点VNsnap是不需要任何修改在虚拟机内运行的软件，从而与之配合使用未修改的应用程序和操作系统内置快照支持。B.正确记录攻击：在我们的工作中，我们假设有足够的文档可用关于以前采取的云攻击放在各种类似的环境中。一般来说，这些记录的攻击是使用硬聚类分类的。</p>
<p>技术如分区聚类、层次聚类，这意味着每次新的攻击都被放在现有的攻击中<br>“分区”或“细分”取决于一些固定的或预定特性。，学习后云攻击的复杂性，我们发现需要考虑新攻击与全部攻击之间的相似程度现有的集合而不是完整的任务之一固定集或攻击群集。因此，我们愿意依靠将决定程度的算法每个现有集合的新实体的归属而不是将它分配给只有一个的那些预定套。由于模糊聚类是一个软聚类将一组成员级别与之联系起来的技术每个新实体，通过这样做，我们实际上考虑到整体影响所有类似的攻击，从而确保更好的准确性结果。</p>
<p>快照可以给出：<br>A. 将攻击定义为群集 关于以前的攻击的可用文档应该是 首先被组织成小型的原始操作 每个组合都可以作为个人攻击。我们对待每一个这些攻击是单点（或单对象）集群。每个点或攻击随后以n维向量来表示，每个维度代表可量化的特征，如内存使用，处理能力要求，带宽使用，复杂度等。 因此，每个攻击Xp可以被假设为具有n维度的空间向（xp1，xp2，…，xpn）。<br>B.为尺寸分配权重： 同样重要的是我们考虑到这一点 在空间中定义的每个维度的相关性。因此， 我们将一个权重wi分配给第i个维度来量化它 确定相似性（或不相似性）的重要性 两个代码之间。这个权重应该通过实验确定。例如，如果我们找到相似性的顺序 复杂度是内存相似度的两倍,那么分配到复杂度的权重将是两倍分配给内存使用的权重。<br>C.当前代码模块距离：在每个VM中，首先确定执行中的代码模块。 这些模块中的每一个基于其自身的特性再次被分配在相同的n维空间中。 但是，请注意，在这种情况下，这些代码模块是时间的函数，它们的坐标也是这样。 例如，第q个VM中的代码模块Y q（t）将具有坐标：（y q1（t），y q2（t），…，y qn（t））。 然后我们从每个集群（攻击）中计算代码模块的距离。 攻击X p和代码模块Y q（t）之间的距离为：D pq i（t）=√（Σ（wi（x pi - y qi（t）））2）… i 1到n。注意，该距离表示第t个攻击与第t个虚拟机的代码模块在时间t的不相似性。 通过为维度分配权重，我们确保了关于测量的相似程度或不相似性的推论是正确的。<br>D.阈值：我们需要确定攻击和代码模块之间的距离的阈值，在该模块之下系统可能受到损害。为此，我们从实验中找出应该保持的最小距离<br>为了使系统安全起见。这个实验涉及：<br>1.常见攻击的模拟（文档中提供）<br>2.观察其所有特征（以其坐标的形式）的量化值，如内存使用量，带宽使用量，处理能力要求等<br>3.对VM上的无数代码模块进行仿真，并将其坐标与步骤2中获得的坐标进行比较<br>4.查找代码模块和每个维度中的攻击之间的最小差异。说，无害代码模块与维度“i”的攻击之间的最小差异是mi，那么我们为所有n个维度获得以下值：m1，m2，… mn。<br>5.计算阈值：<br>阈值=√Σ（wi*mi）2 … i从1到n不等。<br>以下是通过上述步骤获得的阈值的预期特性：<br>1.阈值足够高，以确保与攻击的意外相似性一般不予以考虑。<br>2.该值足够低以确保跟踪恶意代码模块的最大概率。<br>当前代码模块与已记录攻击的比较提出的技术的有效性在很大程度上取决于阈值的正确确定。 在获得一致的阈值时，我们的方法可以证明是足够可靠的，以便最终决定代码模块的有害性。<br>接着是再生事件的产生，我们使用连续运行的计算器来测量所有VM中的代码模块与攻击集合之间的时间依赖距离（如方程式）当使用VNsnap的任何时间点的距离开始使用VNsnap在时间循环中以编程方式定期执行快照一些攻击的代码模块降低到阈值以下，当所有距离都超过阈值时停止进程，因此记录了整个攻击。<br>可以通过将系统恢复到每个快照（以编程方式再次）按照与其创建顺序相同的顺序来重新生成攻击。但是，在该再生过程之前应该采取系统的孤立快照，以便一旦重播攻击就可以将系统恢复到原来的位置.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/云取证第四周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/11/云取证第四周周报/" itemprop="url">云取证第四周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-11T20:10:43+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周我主要做的工作有，将云取证收集文章看了一些，印象深刻的是Cloud application logging for forensics，即用于取证的云应用程序日志记录。这篇文章重点从日志的重要性、云的日志分析和取证相关的挑战、日志重点的记录方向以及日志的一些标准等这些方面论述。</p>
<p>首先是关于日志在云取证的重要性。日志是基于云的服务基础设施中最重要的分析数据之一。在任何时候，服务所有者和运营商都需要了解每个基础架构组件的状态，以进行故障监控，评估功能使用情况和监控业务流程。软件开发生命周期，用例按以下顺序：调试和取证、故障监控、故障排除、功能使用、绩效监测、安全/事件检测。监管和标准合规性这些用例都可以利用日志分析来完全解决或至少帮助大大加快和简化用例的解决方案。</p>
<p>基于云的日志分析和取证相关的挑战有：<strong>原木分散化、日志波动、多层和层、存档和保留、日志的可访问性、不存在日志、在日志中缺少关键信息等</strong>。不兼容/随机日志格式基于云的应用程序将日志存储在多个服务器和多个日志文件中。这些资源的易变性使日志文件只能在一段时间内可用。云应用程序堆栈中的每个层都生成日志，网络，操作系统，应用程序，数据库，网络服务等。一旦日志收集，他们需要在规定的时间内保持一段特定的时间，支持调查。我们需要向多个选区提供日志;应用程序开发人员，系统管理员，安全分析人员等。他们都需要访问，但只能访问一个子集而不是所有日志。平台即服务（PaaS）提供商通常不会将日志提供给他们的平台用户。尝试分析应用程序问题时，这可能是一个重大问题。例如，Amazon 不会使负载平衡器日志对他们的用户可用。最后，关键组件不能或不能正确地检测到生成必要的日志来回答具体问题。即使有日志可用，它们也有各种不同的格式，通常难以处理和分析。前五个挑战可以通过日志管理来解决。剩下的三个是更内在的问题，必须通过定义记录指南和标准来解决.</p>
<p>日志框架的功能列表：<strong>集中所有日志、可扩展日志存储、快速数据访问和检索、支持任何日志格式、运行数据分析作业（例如，map reduce）、保留日志记录、归档旧日志并按要求恢复、通过访问控制隔离数据访问、保存日志完整性</strong>。然而，它们并没有解决失踪和非标准化日志记录的挑战。 1例如，如果机器处于非常高的负载下，则可以启动新机器，如果不预先警告，则不再需要机器。 2请注意，在某些情况下，无法更改关于日志记录行为的任何内容，因为我们无法控制第三方应用程序的代码。 2.2日志记录如果没有为日志记录定义常见的准则或标准，会发生什么在很多情况下，应用程序开发者不会记录太多。有时候，日志记录是不完整的，如下例所示：3月16日08:09:58内核：[0.000000]普通1048576 - &gt; 1048576此日志中没有太多信息来确定实际发生了什么是正常。因此我们需要对一些操作进行日志处理以及标准化日志。</p>
<p>首先是重点记录方向：业务相关日志记录、基于操作的日志记录以及安全（取证）相关日志。云应用应该集中在以下用例：<strong>登录/注销（本地和远程）、密码更改/授权更改、资源访问失败（拒绝授权）</strong>。特权帐户执行的所有活动特权帐户，管理员或根用户都是对系统或应用程序的控制权。他们有权改变应用程序中的大部分参数。因此，对于安全目的来说，密切关注这些帐户正在做什么至关重要。</p>
<p>最后是日志的标准化.至少在日志记录中必须存在以下字段：<strong>时间戳记，应用程序，用户，会话ID，严重性，原因，分类</strong>。这些领域有助于回答问题：何时，什么，谁以及为什么。此外，它们负责提供我们的用例所规定的所有信息。需要一个时间戳来识别日志记录器记录的事件何时发生。时间戳记以标准格式记录[18]。应用程序字段标识日志条目的生成器。需要用户字段来确定哪个用户已经触发了一个活动。使用唯一的用户名或ID来区分用户彼此。 sessionID有助于跟踪跨不同应用程序和层次的单个请求。挑战是在整个组件中共享相同的ID。记录严重性以根据其重要性过滤日志。需要建立严重性系统。例如：debug，info，warn，error和crit。 sameschema应该在所有应用程序和层次中使用。通常情况下，需要找出原因来确定为什么会出现某些事情。例如，由于密码不足或密码错误，访问被拒绝。原因确定为什么。作为最后一组必填字段，类别或分类字段应该被记录。分类是通常用于在日志记录中增加信息以允许以常见方式处理类似事件的方法。这在例如报告中非常有用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/云取证第三周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/云取证第三周周报/" itemprop="url">云取证第三周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T20:44:36+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周我主要做的工作有，对云取证综述文章以及一些分析文章看了一些。接下来谈谈阅读Impact of Cloud Computing on Traditional Digital Forensic Investigations 的理解。</p>
<p>文章首先提出云取证的困难在于因为多个客户的日志记录和数据可能位于同一位置，也可能分布在不断变化的主机和数据中心集合中。如果有没有合同承诺支持具体形式的调查，那么调查和发现请求可能是不可能的。数字证据本身就非常脆弱。不正确的处理或检查可能会更改，损坏或毁坏。为此，必须采取预防措施来记录，收集，保存和检查此类证据。<strong>而在这点上我的一个想法是，能不能比如根据取得的证据例如云环境日志来复现操作顺序来达到重现犯罪现场进行案情重组的过程。比如说在初始环境1，经过若干步操作，变成环境2，环境2通过逆向操作，恢复成还原环境1，在还原过程中，其实也是对云攻击过程的一个模拟复原。当然这一切的假设都是建立在该云服务的的操作是可逆的。而在还原过程中，有利于对云攻击进行分析。</strong></p>
<p>紧接着，描述一系列有关取证的一些分析手段。例如传统的取证方法允许调查人员从实验室环境的相对安全性中抓取设备并进行调查。这在数字取证领域被称为“死亡分析”。还有一些比较高端的是，调查人员可能使用的最常见的工具包括：Guidance Software [11]的EnCase，Access Data [12]的取证工具包和Helix3 [13]，这是一个开源工具包。还有很多其他的，尽管三个突出显示的是最常用的和行业接受的工具[8]。这些工具非常强大，可以查找证据价值的文物，即使嫌疑人已经删除了被认为是妥协的数据。电子发现和现场取证是数字取证学的两个不断发展的领域，调查人员可以增加他们的武器组合来打击电子犯罪。<strong>这里，我在想是不是可以通过对这几个工具进行了解一下他们的分析方法。</strong></p>
<p>接着，描述了一系列攻击，如黑客攻击，分布式拒绝服务（DDOS）攻击，网络钓鱼，制药，恶意软件，病毒，特洛伊木马，间谍软件和蠕虫的分发。分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。基于现在攻击手段如此多和复杂，云计算问题服务级别协议（SLA）必须是强大的。<strong>然而在网上搜了下，现有应对DDOS已经有比较成熟的技术和方案。</strong></p>
<p>同时看了些关于云取证的一些分析方法，印象比较深刻的是。<strong>有一个使用Hadoop进行日志分析，使用K均值算法针对大数据量进行聚类，找出离群值，IP地址统计方法。汇总日志（存储到HDFS）,先是预处理（转成固定格式），使用MR进行处理分析（分析方法通过K-Means类似的数据挖掘手段），形成可视化结果。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/云取证第二周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/云取证第二周周报/" itemprop="url">云取证第二周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T18:56:11+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周我主要做的工作有，看了几篇论文，主要还是了解现在云取证的一些情况和了解了一下docker这个新兴的技术在云计算中的应用和使用问题，印象比较深的有几篇云取证综述的论文。Cloud forensics State-of-the-art and future directions、cloud computing and digital forensics这两篇。</p>
<p>首先是Cloud forensics State-of-the-art and future directions。本论文主要讲的是在现有阶段下云取证的研究进展所面临的的挑战以及移动云取证的一些研究。首先文章开篇讲了在，美国国家标准与技术研究在“NIST云计算取证科学挑战”草案中，这致力于报告这一新兴调查领域的最新进展和最新进展。而在这里，接受率仅为15.4%。这侧面反应了这个评审的难度，也说明现在的挑战还是很大。其次是在新工具的使用上，文章只是提到了促进多节点Hadoop集群中的取证调查，但并没有进行展开讨论。以此为例引出了如果没有开发根本的新工具和能力，取证专家将面临越来越多的困难和成本。因此，今天的数字侦探不仅与罪犯进行军备竞赛，而且还与未来计算机系统的开发者进行了斗争。文章最后提到移动（云）取证是一个未被研究的主题，特别是从提供高级安全性的设备中获取数据，不仅可以用于静态数据（现在已经在所有智能移动设备中变得司空见惯），而且还通过高级加密的数据。NIST IR 8006将挑战分为九组，涉及架构，数据收集，分析，反取证，事件首次响应者，角色管理，法律话题，标准和培训等问题。我的体会是，首先这篇论文也算是我的看的入门第一篇论文，首先在现在云取证面临的挑战是非常大的，不仅在于理论研究还在于新技术的取证工具。文章最后提到的移动云取证现在还是一个比较新的主题，可以算是一个小小备选方案（但我上周和学长们简单交流了下，他们说现在移动云取证几乎该挖的坑都挖完了，所以在这边还是有分歧，有可能跟时间有问题或者跟看的问题角度有关）。</p>
<p>其次是cloud computing and digital forensics（云取证和数字取证）。这篇论文令我印象深的有这么几点：1.日志这一取证的手段。在网络入侵的情况下，受害者组织普遍存在于准备阶段，为了保护数字犯罪现场，关闭整个网络极少可行。因此，有用的证据可能不再可用，可能难以收集，也许完全不可接触，或者可能没有以法定的方式保存。例如，各种类型的日志在网络入侵调查中可能是非常有价值的，但是许多组织不会收集这些日志或不保留日志超过几天，或者不以确保其完整性的方式存储日志。这给我的体会是可以结合一个场景，将日志这个功能进行完善分析。2. 取证方法的分析，涉及哦取证技术；网络取证工具，内存取证方法和数据库取证方法。里面提到了计算机和智能手机云存储服务留下的痕迹的取证分析，是智能手机中碎片闪存页面的取证分析技术。Fasan和Olivier提出了一种重建存储在数据库中的数字证据的可靠方法（参见“数据库重建算法的正确性证明”）。这是一个重要的话题，因为更多的证据存储在数据库中，包括在云环境中，使得可以将很多证据得以保存，便于以后排查原因入侵者等因素。</p>
<p>关于Docker的研究。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。docker的出现极大了加快了PAAS的发展，企业私有PAAS构建蓬勃发展起来。可以看到PAAS核心是解决软件代码完成后部署运行运维到监控的所有事情。基于Docker的PaaS平台现在逐渐成为主流。关于docker的安全问题有：</p>
<h5 id="1-权限及资源限制。"><a href="#1-权限及资源限制。" class="headerlink" title="1.    权限及资源限制。"></a>1.    权限及资源限制。</h5><p>限制用户运行特权及访问资源。对于多租户应用，不同的容器共享同一主机的资源和环境，普通用户权限的恶意提升将会使宿主主机完全处于被非法操控的险境，而对于用户的合法操作，大量的资源申请也会将主机推向崩溃的编译。因此，有必要对用户权限进行限定，避免根权限的赋予，进而减少主机暴露的攻击面和潜力。同时，在CPU、内存及进程数等资源方面，限定用户在单一容器中的可用配额，来防止恶意的无限资源申请给整体系统带来的破坏。<br>镜像及制作管理</p>
<h5 id="2-对容器的镜像来源进行审核。"><a href="#2-对容器的镜像来源进行审核。" class="headerlink" title="2.对容器的镜像来源进行审核。"></a>2.对容器的镜像来源进行审核。</h5><p>容器镜像制作的简化让用户可以轻而易举的创建自定义的应用镜像，但制作的应用程序千差万别，功能完整性和测试完整性参差不齐。这让用户镜像的产生面临存在众多漏洞的风险，因此需要对镜像的制作过程尽量规范化，对放置的应用程序尽量做到测试完备并符合安全标准，从源头上减少漏洞镜像的生成。而在创建容器过程中，避免使用不受信任的镜像及应用程序，采用标准及合格厂商如时速云的镜像服务mirror，从而保证容器运行时的正规及安全。</p>
<h5 id="3-日志安全审计及升级补丁"><a href="#3-日志安全审计及升级补丁" class="headerlink" title="3.日志安全审计及升级补丁"></a>3.日志安全审计及升级补丁</h5><p>对容器及系统中宿主机进行定期安全检查及漏洞补丁升级。定期针对容器及所在宿主机的网络环境进行渗透安全测试，及时发现可疑容器或危险服务端口。对主机内核及原始镜像进行定时更新，及时修补公开漏洞。在应用层次，收集及检测容器的安全日志，统计监督应用的运行过程，及时发现服务异常。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/云取证第一周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/25/云取证第一周周报/" itemprop="url">云取证第一周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T10:33:03+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周我主要做的工作有，上网查询有关于云计算方面的知识点、云安全的相关知识点以及云取证的一些概念。</p>
<p>首先是对于云计算的一些见解，定义就是，云计算是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。特点是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将与互联网更相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。从我个人角度出发，我认为云这个概念其实就是任何可以通过互联网访问的服务。而这个服务往往通过分布式计算机来协助完成。</p>
<p>然后是云计算的分类，具体是分为IaaS、PaaS、SaaS。IaaS(Infrastructure as a Service，基础架构即服务)通过互联网提供了数据中心、基础架构硬件和软件资源。IaaS可以提供服务器、操作系统、磁盘存储、数据库和/或信息资源。IaaS通常会按照”弹性云”的模式引入其他的使用和计价模式，也就是在任何一个特定的时间，都只使用你需要的服务，并且只为之付费。PaaS(Platform as a Service，平台即服务)提供了基础架构，软件开发者可以在这个基础架构之上建设新的应用，或者扩展已有的应用，同时却不必购买开发、质量控制或生产服务器。这些平台允许公司创建个性化的应用，也允许独立软件厂商或者其他的第三方机构针对垂直细分行业创造新的解决方案。SaaS(Software as a Service，软件即服务)是最为成熟、最出名，也是得到最广泛应用的一种云计算。大家可以将它理解为一种软件分布模式，在这种模式下，应用软件安装在厂商或者服务供应商那里，用户可以通过某个网络来使用这些软件，通常使用的网络是互联网。这种模式通常也被称为”随需应变”软件，这是最成熟的云计算模式，因为这种模式具有高度的灵活性、已经证明可靠的支持服务、强大的可扩展性，因此能够降低客户的维护成本和投入，而且由于这种模式的多宗旨式的基础架构，运营成本也得以降低。</p>
<p>“云安全（Cloud Security）”计划是网络时代信息安全的最新体现，它融合了并行处理、网格计算、未知病毒行为判断等新兴技术和概念，通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。常见的云安全问题有：用户身份安全问题、共享业务安全问题、用户数据安全问题。</p>
<p>术语“云取证”是指从云基础设施采集数字取证数据。例如，本地取证证据包括从日志文件、存储在磁盘上的数据、网络流量和入侵标志物等收集到的信息。本地分析与云服务分析之间的基本区别是，使用本地计算机，通过简单地进入系统，从而可以收集并分析信息。然而，当涉及到云时，机器无法进行物理访问，只有计算机的某些部分，可以通过云应用程序接口进行访问。</p>
<p>我的个人见解是，对于云取证来说，可以从两个方面进行考虑。第一个是怎么取证，也就是取证的手段，换句话说就是在取证的技术或者方式上有所改善或者突破；第二个就是对于获取到的证据如何去分析，也就是在分析证据的手段上有所改善或者突破，我觉得这块可以跟比如数据挖掘或者人工智能联系起来，例如有个论文提到的，用数据挖掘来形成聚类，找出ip的之间的关系，具体是通过kmeans的算法针对原始数据进行聚类，将所有数据划分成不同的数据集；接着在各个聚类后的数据集内部，使用 IP 地址统计方法来捕捉各个数据集特征，从而找出离群值，即可能的入侵者。又比如可以对文件简历索引，通过搜索引擎大大提高海量数据查询的效率，具体做法是集中为每个文件创建唯一标志签名， 该签名会一直跟随文件直到文件被删除， 然后借助分布式任务检测海量数据中符合签名的匹配文件 ， 从而大大提高了文件搜索的效率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/约瑟夫问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/05/约瑟夫问题/" itemprop="url">约瑟夫问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T12:46:56+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。"><a href="#问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。" class="headerlink" title="问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。"></a>问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。</h3><h4 id="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"><a href="#解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新" class="headerlink" title="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"></a>解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining(int n, int m) &#123;</div><div class="line">    <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">        <span class="built_in">return</span> -1;</div><div class="line">    &#125;</div><div class="line">    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        list.add(i);</div><div class="line">    &#125;</div><div class="line">    // 要删除元素的位置</div><div class="line">    int idx = 0;</div><div class="line">    // 开始计数的位置</div><div class="line">    int start = 0;</div><div class="line">    <span class="keyword">while</span> (list.size() &gt; 1) &#123;</div><div class="line">        // 只要移动m-1次就可以移动到下一个要删除的元素上</div><div class="line">        <span class="keyword">for</span> (int i = 1; i &lt; m; i++) &#123;</div><div class="line">            idx = (idx + 1) % list.size(); // 【A】</div><div class="line">        &#125;</div><div class="line">        list.remove(idx);</div><div class="line">        // 确保idx指向每一轮的第一个位置</div><div class="line">        // 下面的可以不用，【A】已经可以保证其正确性了，可以分析n=6，m=6的第一次删除情况</div><div class="line">    //  <span class="keyword">if</span> (idx == list.size()) &#123;</div><div class="line">    //      idx = 0;</div><div class="line">    //  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> list.get(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"><a href="#解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。" class="headerlink" title="解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"></a>解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。</h4><p>首先我们定义一个关于 n 和 m 的方程时，表示每次在 n 个数字 0，1， … ，n-1中每次删除第 m 个数字最后剩下的数字。</p>
<p>在这 n个数字中， 第一个被删除的数字是(m-1)%n。为了简单起见，我们把(m- 1)%n 记为 k，那么删除k之后剩下的 n-1 个数字为 0，1，… ，k-1，k+1，… ，n-1，并且下一次删除从数字 k+1 开始计数。相当于在剩下的序列中， k+1 排在最前面，从而形成 k+1，… ，n- 1，0，I，… ，k-1 。该序列最后剩下的数字也应该是关于 n 和 m 的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从 0 开始的连续序列），因此该函数不同于前面的函数，记为 f’(n-1,m)。最初序列最后剩下的数字 f(n, m）一定是删除一个数字之后的序列最后剩下的数字，即 f(n, m)=f’(n-1, m）。</p>
<p>接下来我们把剩下的这 n-1 个数字的序列 k-1， …，n-1，0，1，… ，k-1 做一个映射，映射的结果是形成一个从 0 到 n-2 的序列：<br><img src="http://wiki.jikexueyuan.com/project/for-offer/images/63.png" alt=""> 　　<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining2(int n, int m) &#123;</div><div class="line">     <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">         <span class="built_in">return</span> -1;</div><div class="line">     &#125;</div><div class="line">     int last = 0;</div><div class="line">     <span class="keyword">for</span> (int i = 2; i &lt;=n ; i++) &#123;</div><div class="line">         last = (last + m)%i;</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">return</span> last;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
