<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/10/面向服务的体系架构-SOA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/面向服务的体系架构-SOA/" itemprop="url">面向服务的体系架构(SOA)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T10:57:29+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/07/hbase架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/07/hbase架构/" itemprop="url">hbase架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T22:19:10+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据查找和存储"><a href="#数据查找和存储" class="headerlink" title="数据查找和存储"></a>数据查找和存储</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树的性质使得能够对主键进行高效的插入、查找以及删除，B+树远好于二叉树的数据划分，大大减少查询特定主键所需要的IO。此外，B+树能够提供高效的范围扫描，由于叶节点相互连接且主键有序，扫描时避免了耗时的遍历树的操作。在很多关系型数据库中，都把该数据结构用做索引。<br>当添加新的索引时，可能会使得页表满了拆分成两个页表，若页表不在一块，在进行范围查询时，需要读取不在一块的页表甚至很远的页表，因此我们需要优化该表，使用optimize table，将B+顺序写，使得范围查找时加快。</p>
<h3 id="LSM树-Log-Structured-Merge"><a href="#LSM树-Log-Structured-Merge" class="headerlink" title="LSM树(Log Structured Merge)"></a>LSM树(Log Structured Merge)</h3><p>输入数据首先存储在日志文件中，这些文件的完全有序，当有日志文件被修改时，对应的更新会保存在内存中，来加速查询。在经历数次数据进行修改后，内存逐渐被占满后，LSM树会把有序的键数据对写入磁盘，同时创建一个新的数据存储文件，并且内存中的数据可以丢弃。存储文件组织与B树相似，不过其为磁盘顺序读取做了优化，所有节点都是满的并按页存储，修改数据文件通过滚动合并完成。如果数据量过于庞大，磁盘中的树相应地也会很大，导致的后果是合并的速度会变慢。一个解决方法是建立各个层次的树，低层次的树都比上一层次的树数据集大。假设内存中的树为c0, 磁盘中的树按照层次一次为c1, c2, c3, … ck-1, ck。合并的顺序是(c0, c1), (c1, c2)…(ck-1, ck)。<br>查询时先查找内存中的存储，然后在查找磁盘文件。删除是一种特殊的更改，当删除标记被存储后，查找时会跳过被删除的键。当页被重写时，有删除标记的键会被丢掉。后台运维可以设定一个TTL，在TTL后，检查时间戳，然后重写丢弃过期的记录。<br><strong>B+树与LSM树对比</strong><br>在没有太多修改（插入或者删除）时，B+树表现得很好，因为这些修改要求执行高性能的优化操作以保证查询能在有限的时间内完成。在任意位置添加的数据规模越大，速度越快，这些页成为碎片的速度越快，最后用户写入的速度比优化重写速度更快，导致碎片化。因而只能多次随机io，导致建立索引速度变慢。<br>LSM树使用日志文件内存存储将随机写变为顺序写，因此也能保证稳定的插入速率，由于读写独立，所以不会存在冲突。由于存储数据布局更优，查询一个键需要的磁盘寻道次数在一个可预测的范围，并且读取与改建连续任意数量的记录都不会引发额外的磁盘寻道。一般来说，有几个存储文件，最多几次寻道。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Hbase主要处理两种文件：1.预写文件(write ahead file,WAL);2.实际数据文件，由HRegionServer管理。基本流程是：客户端首先联系Zookeeper子集群（quorum）查找行健，通过Zookeeper获取含有-ROOT-的region服务器名来完成。通过含有-ROOT-的region服务器可以查询到含有.meta表中对应的region服务器名。这两处内容会被缓存。最终通过.meta服务器获取客户端查询的行键所在region服务器名。一旦知道数据所在的位置，Hbase会缓存信息，后面客户端就不需要查询.meta.</p>
<h3 id="写路径"><a href="#写路径" class="headerlink" title="写路径"></a>写路径</h3><p>当用户向HregionServer发起HTable.put(Put)请求时，其会交给对应的region来处理。第一步是要决定数据是否需要写到HLog类实现的预写日志中，一旦数据被写入WAL中，数据就会放到Memstore中，同时还会检查memstore是否已经满了，如果满了，就会将请求刷新到磁盘里。刷新请求由另外一个RegionServer的线程处理，它会把数据写成HDFS中的一个新HFile，同时保存最后写的序号。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>根级文件<br>一个region服务器所有region共享一个对应的子目录，在Hbase根目录下命名为logs的目录</li>
<li>表级文件<br>每张表都有自己的目录，其位于文件系统中的hbase根目录下，每张表包括一个名为.tableinfo的顶层文件</li>
<li>region级文件<br>每张表的目录里面，每个列族都有单独一个目录。</li>
<li>region拆分<br>region存储文件增长超过配置的大小就会一分为二</li>
<li>region合并<br>合并会把磁盘文件合并成数量更少的体积更大的文件<h3 id="HFile格式"><a href="#HFile格式" class="headerlink" title="HFile格式"></a>HFile格式</h3>存储Hbase的数据，分为Trailer、MetaIndex、DataIndex、FileInfo、Data，Data一般存放Magic和keyvalue，keyvalue可以采用压缩算法压缩数据。<h3 id="keyvalue格式"><a href="#keyvalue格式" class="headerlink" title="keyvalue格式"></a>keyvalue格式</h3>keyvalue的格式：KeyLength、ValueLength、(RowLength、Row、ColumnFamilyLength、ColumnFamily、ColumnQualifier、TimeStamp、KeyType)、value,括号部分是key，可以转化为java实例，就可以通过get方法获取属性。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">System.out.println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>region服务器会将数据保存在内存中，直到积攒足够多的数据刷新到磁盘，但是存储在磁盘中的数据是不稳定的，例如断电时候就会数据丢失，比较常见的解决方案是预写日志(WAL):每次更新都会写入日志，只有当写入成功才会通知客户端操作成功。</p>
<h3 id="HLog"><a href="#HLog" class="headerlink" title="HLog"></a>HLog</h3><p>实现WAL类叫做HLog，当region收到更新操作，就直接把数据保存到一个共享的WAL实例中。</p>
<h3 id="HLog-key"><a href="#HLog-key" class="headerlink" title="HLog key"></a>HLog key</h3><p>存储keyvalue的归属，即region和表名，信息存储在HLogKey中。还存储了序列号，每一条的记录都是递增的，还记录了写入到日志的时间戳。</p>
<h3 id="WalEdit"><a href="#WalEdit" class="headerlink" title="WalEdit"></a>WalEdit</h3><p>每一个修改都会被封装为WalEdit实例。</p>
<h3 id="LogSyncer"><a href="#LogSyncer" class="headerlink" title="LogSyncer"></a>LogSyncer</h3><p>延迟日志刷写标记，如果设置为false，每一次编辑发送到服务器，都会调用写日志的sync。</p>
<h3 id="LogRoller"><a href="#LogRoller" class="headerlink" title="LogRoller"></a>LogRoller</h3><p>在特定时间内滚动日志</p>
<h2 id="读路径"><a href="#读路径" class="headerlink" title="读路径"></a>读路径</h2><p>Hbase的每个列族使用多个存储文件进行数据存储。后台合并将小文件写入到大文件减少文件的数目。墓碑标记是可以标记一个单元格，多个单元格，一整行。</p>
<h2 id="region查找"><a href="#region查找" class="headerlink" title="region查找"></a>region查找</h2><p>为了让客户端查找到包含特定主键的region，Hbase提供两张目录表，一张-ROOT-和.META.。-ROOT-用来查询所有.META.表中region的位置。Hbase的设计时只有一个root region，从而保证类似于B+树结构的三层查找：第一层是Zookeeper中包含root region位置信息的节点。第二层是从-ROOT-中查找对应meta region位置。第三层是从.META.表中查找用户表中对应region的位置。</p>
<h2 id="region的生命周期"><a href="#region的生命周期" class="headerlink" title="region的生命周期"></a>region的生命周期</h2><p>offline、pending open、opening、open、pending close、closing、closed、splitting</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>主要功能有跟踪region服务器、保存root region地址。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Hbase最基本的架构师主推送，一个主集群可以将数据复制到任意数目的从集群。所有的WALEdits都会被复制以保证原子性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/05/慕课网java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/慕课网java/" itemprop="url">慕课网java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T08:49:22+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="程序设计语言基础"><a href="#程序设计语言基础" class="headerlink" title="程序设计语言基础"></a>程序设计语言基础</h2><h2 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象不可变性"><a href="#面向对象不可变性" class="headerlink" title="面向对象不可变性"></a>面向对象不可变性</h3><p>final关键字<br>类申明：类不可集成<br>函数申明：函数不可在派生类重写<br>变量申明：变量不可指向其他对象，但是变量指向对象的内容可以改变<br>习惯性常量 static final 一般大写<br>实现不可变性：<br>1.final关键字无法保证不可变性<br>2.从接口的定义上，类的实现上保证不可变性（例如通过暴露部分变量的接口只能获取部分变量，而不能获取整个类的实例，String类的substring方法和replace方法，都不会改变自身的内容，都是new）<br>3.Collections.unmodifiableXXX(例如：list=Collections.unmodifiable(new ArrayList&lt;&gt;(t)))，编译通过，运行add会抛异常</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型。Java 编译器在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。<br>从List到List<t><br>规定类型只能是类型T，但是实现无所谓T是什么类型。<br>从List到List<t>语法<br>List<string> list=new ArrayList&lt;&gt;();//1.7<br>List<integer> list=LinkedList.of(1,2,3);<br>List<string> list=LinkedList.newEmptyList();<br>java Type erasure<br>1.早期java没有泛型；2.为了兼容性，在运行时将所有泛型擦除<br>运行时：List、List<string>、List<integer>没有区别<br>covariance<br>ArrayList<integer>是List<integer>,但是List<integer>不是List<object><br>将List<integer>转化成List<object>:<br>new ArrayList<object>(intList)或者List<object>(List) intList（危险，先要明确目的为什么转）</object></object></object></integer></object></integer></integer></integer></integer></string></string></integer></string></t></t></p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><h2 id="高级知识点"><a href="#高级知识点" class="headerlink" title="高级知识点"></a>高级知识点</h2><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>并行计算的方法：<br>把数据拆分到每个节点<br>每个节点并行的计算结果<br>把结果汇总<br>k路归并排序。把数据切分成k份，每份内部进行排序（可以用快排或者归并），然后进行k路归并，可以用k最小堆，PriorityQueue,从数据源拿数据需要使用缓存，读一段，可以考虑Iterable接口<br>Iterable<t> merge(List<iterable<t> sortedData&gt;)<br>Iterable接口的next方法，如果缓存区空，读取一段数据到缓存，给出缓存区第一个元素，缓存区元素大小（可配置）</iterable<t></t></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>死锁条件：<br>1.互斥等待<br>2.hold and wait<br>3.循环等待<br>4.无法剥夺的等待<br>解决：<br>1.一次性获取所有资源；2.顺序获取资源（根据资源某个标识顺序加锁）；3.加入超时机制</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>创建线程开销大<br>线程池：预先建立好线程，等待任务派发。</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><p>corePoolSize：线程池初始线程的数量<br>maximumPoolSize：线程中最大允许数量<br>KeepAliveTime：超出corePoolSize的线程如果等待时间超过这个时间就会被回收<br>TimeUnit:时间单位，毫秒、秒微秒，描述KeepAliveTime<br>BlockingQueue<runnable>:<br>资源的连接问题：例如数据库的连接，虽然对象被回收但是资源依然不释放。</runnable></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/04/hbase高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/hbase高级特性/" itemprop="url">hbase高级特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-04T10:29:11+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器简介"><a href="#过滤器简介" class="headerlink" title="过滤器简介"></a>过滤器简介</h3><p>Get和Scan都支持过滤器，过滤器最基本的接口是Filter，所有的过滤器都在服务器生效（谓词下推），可以保证过滤的数据不会传递到客户端。<br>1.过滤器层次结构<br>最底层的过滤器是Filter和FilterBase，定好的过滤器可以传递给get和scan，通过setFilter<br>2.比较运算符<br>CompareFilter多了个compare方法，需要使用传递参数，参数有<br>LESS,LESS_OR_EQUAL,EQUAL,NOT_EQUAL,GREATER_OR_EQUAL,GREATER,NO_OP<br>3.比较器<br>CompareFilter所需要的第二个类型是比较器，比较常用的比较器有：BinaryComparator、NullComparator（判断是否为null）、RegexStringComparator（正则比较）、SubstringComparator（通过contains去操作）、BitComparator（位比较&amp;|^）</p>
<h3 id="比较过滤器"><a href="#比较过滤器" class="headerlink" title="比较过滤器"></a>比较过滤器</h3><p>CompareFilter创建实例需要运算符和比较器，</p>
<h4 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">RowFilter filter = new RowFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-row-1"</span>)));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列族过滤器"><a href="#列族过滤器" class="headerlink" title="列族过滤器"></a>列族过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">FamilyFilter filter = new FamilyFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-family"</span>))); // 列族为 my-family</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列名过滤器-QualifierFilter"><a href="#列名过滤器-QualifierFilter" class="headerlink" title="列名过滤器(QualifierFilter)"></a>列名过滤器(QualifierFilter)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">QualifierFilter filter = new QualifierFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-column"</span>))); // 列名为 my-column</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="值过滤器"><a href="#值过滤器" class="headerlink" title="值过滤器"></a>值过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">BinaryComparator comp = new BinaryComparator(Bytes.toBytes(<span class="string">"xmei"</span>)); //</div><div class="line">ValueFilter filter = new ValueFilter(CompareOp.EQUAL, comp);</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="参考列过滤器"><a href="#参考列过滤器" class="headerlink" title="参考列过滤器"></a>参考列过滤器</h4><p>该过滤器尝试找到该列所在的每一行，并返回该行具有该列相同时间戳的全部键值对。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">DependentColumnFilter filter = new DependentColumnFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h3 id="专用过滤器"><a href="#专用过滤器" class="headerlink" title="专用过滤器"></a>专用过滤器</h3><h4 id="单列值过滤器"><a href="#单列值过滤器" class="headerlink" title="单列值过滤器"></a>单列值过滤器</h4><p>下面一个检测列族 family 下的列 qualifier 的列值和字符串 “my-value” 相等的部分示例代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueFilter filter = new SingleColumnValueFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h4 id="单列排除过滤器"><a href="#单列排除过滤器" class="headerlink" title="单列排除过滤器"></a>单列排除过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueExcludeFilter filter = new SingleColumnValueExcludeFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="前缀过滤器"><a href="#前缀过滤器" class="headerlink" title="前缀过滤器"></a>前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Filter filter=new PrefixFilter(Bytes.toBytes(<span class="string">"row-1"</span>));</div><div class="line">Scan scan=new Scan();</div><div class="line">scan.setFilter(filter);</div><div class="line">ResultScanner result=table.getScanner(scan);</div></pre></td></tr></table></figure>
<h4 id="分页过滤器"><a href="#分页过滤器" class="headerlink" title="分页过滤器"></a>分页过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">long pageSize = 10;</div><div class="line">int totalRowsCount = 0;</div><div class="line">PageFilter filter = new PageFilter(pageSize);</div><div class="line">byte[] lastRow = null;</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line"> Scan scan = new Scan();</div><div class="line"> scan.setFilter(filter);</div><div class="line"> <span class="keyword">if</span>(lastRow != null) &#123;</div><div class="line">  byte[] postfix = Bytes.toBytes(<span class="string">"postfix"</span>);</div><div class="line">  byte[] startRow = Bytes.add(lastRow, postfix);</div><div class="line">  scan.setStartRow(startRow);</div><div class="line">  System.out.println(<span class="string">"start row : "</span> + Bytes.toString(startRow));</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> ResultScanner scanner = _hTable.getScanner(scan);</div><div class="line"> int <span class="built_in">local</span>RowsCount = 0;</div><div class="line"> <span class="keyword">for</span>(Result result : scanner) &#123;</div><div class="line">  System.out.println(<span class="built_in">local</span>RowsCount++ + <span class="string">" : "</span> + result);</div><div class="line">  totalRowsCount++;</div><div class="line">  lastRow = result.getRow(); // ResultScanner 的结果集是排序好的，这样就可以取到最后一个 row 了</div><div class="line"> &#125;</div><div class="line"> scanner.close();</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(<span class="built_in">local</span>RowsCount == 0) <span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"total rows is : "</span> + totalRowsCount);</div></pre></td></tr></table></figure>
<h4 id="行键过滤器"><a href="#行键过滤器" class="headerlink" title="行键过滤器"></a>行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">KeyOnlyFilter filter = new KeyOnlyFilter(); // 只查询每行键值对中有 <span class="string">"键"</span> 元数据信息，不显示值，可以提升扫描的效率</div></pre></td></tr></table></figure>
<h4 id="首次行键过滤器"><a href="#首次行键过滤器" class="headerlink" title="首次行键过滤器"></a>首次行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//该过滤器只查询每个行键的第一个键值对，在统计计数的时候提高效率。（HBase-Coprocessor 做 RowCount 的时候可以提高效率）。</div><div class="line">Scan scan = new Scan();</div><div class="line">FirstKeyOnlyFilter filter = new FirstKeyOnlyFilter(); // 只查询每个行键的第一个键值对</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="包含结束的过滤器"><a href="#包含结束的过滤器" class="headerlink" title="包含结束的过滤器"></a>包含结束的过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//常规的 Scan 包含 start-row 但不包含 stop-row，如果使用该过滤器便可以包含 stop-row。</div><div class="line">Scan scan = new Scan();</div><div class="line">InclusiveStopFilter filter = new InclusiveStopFilter(Bytes.toBytes(<span class="string">"stopRowKey"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="时间戳过滤器"><a href="#时间戳过滤器" class="headerlink" title="时间戳过滤器"></a>时间戳过滤器</h4><h4 id="列计数过滤器"><a href="#列计数过滤器" class="headerlink" title="列计数过滤器"></a>列计数过滤器</h4><h4 id="列分页计数器"><a href="#列分页计数器" class="headerlink" title="列分页计数器"></a>列分页计数器</h4><h4 id="列前缀过滤器"><a href="#列前缀过滤器" class="headerlink" title="列前缀过滤器"></a>列前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//用于列名（Qualifier）前缀过滤，即包含某个前缀的所有列名。</div><div class="line">Scan scan = new Scan();</div><div class="line">  ColumnPrefixFilter filter = new ColumnPrefixFilter(Bytes.toBytes(<span class="string">"my-prefix"</span>)); // 前缀为 my-prefix</div><div class="line">  scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="随机行过滤器"><a href="#随机行过滤器" class="headerlink" title="随机行过滤器"></a>随机行过滤器</h4><h3 id="附加过滤器"><a href="#附加过滤器" class="headerlink" title="附加过滤器"></a>附加过滤器</h3><h4 id="跳转过滤器"><a href="#跳转过滤器" class="headerlink" title="跳转过滤器"></a>跳转过滤器</h4><p>这是一种附加过滤器，其与ValueFilter结合使用，如果发现一行中的某一列不符合条件，那么整行就会被过滤掉：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Filter skf = new SkipFilter(vf); // OK 发现某一行中的一列需要过滤时，整个行就会被过滤掉</div></pre></td></tr></table></figure></p>
<h4 id="全匹配过滤器（whileMatchFilter）"><a href="#全匹配过滤器（whileMatchFilter）" class="headerlink" title="全匹配过滤器（whileMatchFilter）"></a>全匹配过滤器（whileMatchFilter）</h4><p>如果你想要在遇到某种条件数据之前的数据时，就可以使用这个过滤器；当遇到不符合设定条件的数据的时候，整个扫描也就结束了：</p>
<h3 id="filterList"><a href="#filterList" class="headerlink" title="filterList"></a>filterList</h3><p>用于综合使用多个过滤器。其有两种关系：FilterList.Operator.MUST_PASS_ONE和FilterList.Operator.MUST_PASS_ALL，默认的是FilterList.Operator.MUST_PASS_ALL，顾名思义，它们分别是AND和OR的关系，并且FilterList可以嵌套使用FilterList，使我们能够表达更多的需求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();  </div><div class="line">filters.add(rf);  </div><div class="line">filters.add(vf);  </div><div class="line">FilterList fl = new FilterList(FilterList.Operator.MUST_PASS_ALL, filters); // OK 综合使用多个过滤器， AND 和 OR 两种关系</div></pre></td></tr></table></figure></p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="计数器简介"><a href="#计数器简介" class="headerlink" title="计数器简介"></a>计数器简介</h3><p>1.许多收集统计信息的应用有点击流或在线广告意见，这些应用需要收集到日志文件用作后续的分析，用户可以使用计数器做实时统计，从而放弃延时较高的批量处理操作。<br>2.原子操作检查并修改：将当前列当作计数器。<br>即把一个 column 当作一个 counter，这样便于给某些在线应用提供实时统计功能。（PS：比如帖子的实时浏览量：PV）<br>3.如果没有计数器特性：用户需要对一行数据加锁，然后读取数据，再对当前数据做加法，最后写回Hbase并释放该行锁。这样会引起大量的资源竞争，有其是当客户端进程崩溃之后，尚未释放的锁需要等待超时恢复，这会是一个高负载的系统中引起灾难性的后果。<br>4.计数器的增量可以是正数负数，正数代表加，负数代表减。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hbase(main):006:0&gt; create<span class="string">'counters'</span>,<span class="string">'daily'</span>,<span class="string">'weekly'</span>,<span class="string">'monthly'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 2.2260 seconds</div><div class="line">hbase(main):007:0&gt; incr <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 1</div><div class="line">hbase(main):008:0&gt; incr<span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 2</div><div class="line">hbase(main):009:0&gt; get_counter  <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span></div><div class="line">COUNTER VALUE = 2</div></pre></td></tr></table></figure></p>
<p>终端命令为incr ‘tablename’,’row’,’column’,[increment_value]</p>
<h4 id="单计数器"><a href="#单计数器" class="headerlink" title="单计数器"></a>单计数器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void oneCounter(long num) throws IOException&#123;</div><div class="line">long cnt1 = table.incrementColumnValue(Bytes.toBytes(<span class="string">"3100"</span>),</div><div class="line">Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"name"</span>), num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多计数器"><a href="#多计数器" class="headerlink" title="多计数器"></a>多计数器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void moreCounter() throws IOException&#123;</div><div class="line">Increment increment1 = new Increment(Bytes.toBytes(<span class="string">"3100"</span>));</div><div class="line"></div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 20);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 10);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 10);</div><div class="line"></div><div class="line">Result result1 = table.increment(increment1);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result1.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV1: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div><div class="line">Increment increment2 = new Increment(Bytes.toBytes(<span class="string">"3102"</span>));</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 5);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 0);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), -5);</div><div class="line">Result result2 = table.increment(increment2);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result2.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV2: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="协处理器"><a href="#协处理器" class="headerlink" title="协处理器"></a>协处理器</h3><p>协处理器允许用户在region server上运行自己的代码，准确的说是执行region级的操作，并且可以使用关系型数据库的触发器的功能。有很多使用协处理器的场景，使用钩子关联行修改操作来维护一个辅助索引，或维护一些数据间的引用完整性。协处理器主要提供两大类，observer和endpoint。<br>1）Observer（观察者）<br>该类是与RDMS中的触发器类似。回调函数在一些特定的事件发生时被调用。<br>事件包括：用户产生的事件或者服务端内部产生的事件。<br>协处理器框架提供的接口如下：<br>a、RegionObserver：用户可以通过这种处理器来处理数据修改事件，它们与表的Region紧密关联。region级的操作。对应的操作是：put/delete/scan/get<br>b、MasterObserver：可以用作管理或DDL类型的操作，是集群级的操作。对应的操作是：创建、删除、修改表。<br>c、WALObserver：提供控制WAL的钩子函数。(WAL: write ahead log)<br>Observer定义好钩子函数，服务端可以调用。<br>2）endPoint<br>该类的功能类似RDMS中的存储过程。将用户的自定义操作添加到服务器端，endPoint可以通过添加远程过程调用来扩展RPC协议。用户可以将自定义完成某项操作代码部署到服务器端。其中Endpoint可以理解为传统数据库的存储过程操作，比如可以进行某族某列值得加和。无Endpoint特性的情况下需要全局扫描表，通过Endpoint则可以在多台分布有对应表的regionserver上同步加和，在将加和数返回给客户端进行全局加和操作，充分利用了集群资源，增加性能。</p>
<h4 id="coprocessor类"><a href="#coprocessor类" class="headerlink" title="coprocessor类"></a>coprocessor类</h4><p>1）协处理器的执行顺序<br>Coprocessor.Priority枚举类型定义了两个值：SYSTEM、USER。前者优于后者执行，后者定义的按顺序执行。<br>2）协处理器的生命周期<br>协处理器的生命周期是由框架管理的，接口定义两个方法start、stop。这两个方法的参数是：CoprocessorEnvironment。该类提供了访问HBase的版本、Coprocessor版本、协处理器优先级等方法。start/stop方法是被隐式调用的，且关于协处理器的状态的定义是有一个枚举类Coprocessor.State对应的。<br>3）协处理器环境和实例的维护<br>CoprocessorHost类来完成，其有相应的子类来完成维护region、master协处理器的实例和环境。</p>
<h4 id="协处理器加载"><a href="#协处理器加载" class="headerlink" title="协处理器加载"></a>协处理器加载</h4><p>1.从配置中加载，hbase-site.xml;2.从表描述符中加载</p>
<h4 id="RegionObserver类"><a href="#RegionObserver类" class="headerlink" title="RegionObserver类"></a>RegionObserver类</h4><p>1.处理生命周期事件<br>状态1：pendingOpen，region将要被打开的状态。<br>协处理器以实现的方法是：<br>preOpen()/postOpen().完成功能是：搭载或者阻止这次打开过程。<br>preWALRestore()/postWALRestore.完成的功能是：用户可以访问那些记录被修改了，监督那些记录被实施了。<br>状态2：open，这个状态的标志是：region被部署到一个region server上且正常工作时。<br>协处理器可以实现的方法是：<br>void preFlush()/void postFlush()     内存被持久到磁盘<br>void preSpilt()/void postSpilt()          region达到足够大时进行拆分<br>状态3：pendingClose。region将要被关闭时的状态。<br>协处理器可以实现的方法是：<br>void preClose()/void postClose()<br>2.处理客户端API事件<br>这里是指在调用Java API 时，响应的事件。如：<br>void prePut()/void postPut、void preDelete()/postDelete()、void preGet()/void postGet()……..</p>
<h4 id="MasterObserver"><a href="#MasterObserver" class="headerlink" title="MasterObserver"></a>MasterObserver</h4><p>协处理器定义明确为master服务器的所有回调函数。这些回调函数中的操作是类似DDL，创建、删除、修改表。<br>1）MasterCoprocessorEnvironment<br>MasterCoprocessorEnvironment封装了MasterObserver实例，通过该类可以访问MasterService实例。<br>2）BaseMasterServer<br>BaseMasterServer是MasterServer的空实现，可以通过实现相应的pre/post来自定义相关操作。                        例如：  void preCreateTable()/void postCreateTable()  void preDeleteTable()/void postDeleteTable()……</p>
<h4 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h4><p>该接口可以使用户自定义RPC协议，它的实现代码被安装在服务端，在客户端HTable提供调用方法，使用该协议可以和协处理器实例之间通信。</p>
<h2 id="HTablePool"><a href="#HTablePool" class="headerlink" title="HTablePool"></a>HTablePool</h2><p>创建一个HTable实例，然后去复用它，可以通过HTableFactory来创建HTable，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Configuration conf = HBaseConfiguration.create();</div><div class="line">HTablePool pool = new HTablePool(conf, 10);</div><div class="line"></div><div class="line">public void createUser(String username, String firstName, String lastName, String email, String password,String roles) throws IOException &#123;</div><div class="line">　　HTable table = rm.getTable(UserTable.NAME);</div><div class="line">　　Put put = new Put(Bytes.toBytes(username));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.FIRSTNAME,</div><div class="line">　　Bytes.toBytes(firstName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.LASTNAME,</div><div class="line">　　　　Bytes.toBytes(lastName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.EMAIL, Bytes.toBytes(email));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.CREDENTIALS,</div><div class="line">　　　　Bytes.toBytes(password));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.ROLES, Bytes.toBytes(roles));</div><div class="line">　　table.put(put);</div><div class="line">　　table.flushCommits();</div><div class="line">　　rm.putTable(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/hbase-java-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/hbase-java-api/" itemprop="url">hbase java api</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-02T16:29:51+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.hadoop.conf.Configuration;</div><div class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</div><div class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</div><div class="line">import org.apache.hadoop.hbase.HTableDescriptor;</div><div class="line">import org.apache.hadoop.hbase.KeyValue;</div><div class="line">import org.apache.hadoop.hbase.client.Delete;</div><div class="line">import org.apache.hadoop.hbase.client.Get;</div><div class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</div><div class="line">import org.apache.hadoop.hbase.client.HTable;</div><div class="line">import org.apache.hadoop.hbase.client.HTablePool;</div><div class="line">import org.apache.hadoop.hbase.client.Put;</div><div class="line">import org.apache.hadoop.hbase.client.Result;</div><div class="line">import org.apache.hadoop.hbase.client.ResultScanner;</div><div class="line">import org.apache.hadoop.hbase.client.Scan;</div><div class="line">import org.apache.hadoop.hbase.util.Bytes;</div><div class="line"></div><div class="line">public class Hbase &#123;</div><div class="line">    // 声明静态配置</div><div class="line">    static Configuration conf = null;</div><div class="line">    static &#123;</div><div class="line">        conf = HBaseConfiguration.create();</div><div class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"localhost"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 创建表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @family 列族列表</div><div class="line">     */</div><div class="line">    public static void creatTable(String tableName, String[] family)</div><div class="line">            throws Exception &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        HTableDescriptor desc = new HTableDescriptor(tableName);</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; family.length; i++) &#123;</div><div class="line">            desc.addFamily(new HColumnDescriptor(family[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</div><div class="line">            System.out.println(<span class="string">"table Exists!"</span>);</div><div class="line">            System.exit(0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            admin.createTable(desc);</div><div class="line">            System.out.println(<span class="string">"create table Success!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 为表添加数据（适合知道有多少列族的固定表）</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @column1 第一个列族列表</div><div class="line">     *</div><div class="line">     * @value1 第一个列的值的列表</div><div class="line">     *</div><div class="line">     * @column2 第二个列族列表</div><div class="line">     *</div><div class="line">     * @value2 第二个列的值的列表</div><div class="line">     */</div><div class="line">    public static void addData(String rowKey, String tableName,</div><div class="line">            String[] column1, String[] value1, String[] column2, String[] value2)</div><div class="line">            throws IOException &#123;</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));// 设置rowkey</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// HTabel负责跟记录相关的操作如增删改查等//</div><div class="line">                                                                    // 获取表</div><div class="line">        HColumnDescriptor[] columnFamilies = table.getTableDescriptor() // 获取所有的列族</div><div class="line">                .getColumnFamilies();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; columnFamilies.length; i++) &#123;</div><div class="line">            String familyName = columnFamilies[i].getNameAsString(); // 获取列族名</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"article"</span>)) &#123; // article列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column1.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column1[j]), Bytes.toBytes(value1[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"author"</span>)) &#123; // author列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column2.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column2[j]), Bytes.toBytes(value2[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"add data Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 根据rwokey查询</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static Result getResult(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// 获取表</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName, String start_rowkey,</div><div class="line">            String stop_rowkey) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        scan.setStartRow(Bytes.toBytes(start_rowkey));</div><div class="line">        scan.setStopRow(Bytes.toBytes(stop_rowkey));</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void getResultByColumn(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName)); // 获取指定列族和列修饰符对应的列</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 更新表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     *</div><div class="line">     * @value 更新后的值</div><div class="line">     */</div><div class="line">    public static void updateTable(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName, String value)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));</div><div class="line">        put.add(Bytes.toBytes(familyName), Bytes.toBytes(columnName),</div><div class="line">                Bytes.toBytes(value));</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"update table Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询某列数据的多个版本</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void getResultByVersion(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</div><div class="line">        get.setMaxVersions(5);</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">         * List&lt;?&gt; results = table.get(get).list(); Iterator&lt;?&gt; it =</div><div class="line">         * results.iterator(); <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">         * System.out.println(it.next().toString()); &#125;</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void deleteColumn(String tableName, String rowKey,</div><div class="line">            String falilyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteColumn = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        deleteColumn.deleteColumns(Bytes.toBytes(falilyName),</div><div class="line">                Bytes.toBytes(columnName));</div><div class="line">        table.delete(deleteColumn);</div><div class="line">        System.out.println(falilyName + <span class="string">":"</span> + columnName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void deleteAllColumn(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteAll = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        table.delete(deleteAll);</div><div class="line">        System.out.println(<span class="string">"all columns are deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void deleteTable(String tableName) throws IOException &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        admin.disableTable(tableName);</div><div class="line">        admin.deleteTable(tableName);</div><div class="line">        System.out.println(tableName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">        // 创建表</div><div class="line">        String tableName = <span class="string">"blog2"</span>;</div><div class="line">        String[] family = &#123; <span class="string">"article"</span>, <span class="string">"author"</span> &#125;;</div><div class="line">        // creatTable(tableName, family);</div><div class="line"></div><div class="line">        // 为表添加数据</div><div class="line"></div><div class="line">        String[] column1 = &#123; <span class="string">"title"</span>, <span class="string">"content"</span>, <span class="string">"tag"</span> &#125;;</div><div class="line">        String[] value1 = &#123;</div><div class="line">                <span class="string">"Head First HBase"</span>,</div><div class="line">                <span class="string">"HBase is the Hadoop database. Use it when you need random, realtime read/write access to your Big Data."</span>,</div><div class="line">                <span class="string">"Hadoop,HBase,NoSQL"</span> &#125;;</div><div class="line">        String[] column2 = &#123; <span class="string">"name"</span>, <span class="string">"nickname"</span> &#125;;</div><div class="line">        String[] value2 = &#123; <span class="string">"nicholas"</span>, <span class="string">"lee"</span> &#125;;</div><div class="line">        addData(<span class="string">"rowkey1"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey2"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey3"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line"></div><div class="line">        // 遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line">        // 根据row key范围遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line"></div><div class="line">        // 查询</div><div class="line">        getResult(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 更新列</div><div class="line">        updateTable(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>, <span class="string">"bin"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 查询某列的多版本</div><div class="line">        getResultByVersion(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 删除一列</div><div class="line">        deleteColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"nickname"</span>);</div><div class="line"></div><div class="line">        // 删除所有列</div><div class="line">        deleteAllColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 删除表</div><div class="line">        deleteTable(<span class="string">"blog2"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>事实上，许多基于列表的操作，如delete(List <delete> deletes)或者get(List <get> gets)，都是基于batch()方法实现的。它们都是一些为了方便用户使用而保留的方法。如果你是新手，推荐使用batch()方法进行所有操作。<br>下面的客户端API方法提供了批量处理操作。用户可能注意到这里引入了一个新的名为Row的类，它是Put、Get和Delete的祖先，或者是父类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void batch(List&lt;Row&gt; actions,Object[] results) throws IOException,InterruptedException</div><div class="line">Object [] batch(List&lt;Row&gt; actions) throws IOException,InterruptedException</div></pre></td></tr></table></figure></get></delete></p>
<p>使用同样的父类允许在列表中实现多态，即放入以上3种不同的子类。这种调用跟之前介绍的基于列表的调用方法一样简单调用。请注意，不可以将针对同一行的Put和Delete操作放在同一个批量处理请求中，为了保证最好的性能，这些操作的处理顺序可能不同，但是这样会产生不可预料的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void batchDone(HTable hTable,String[] family,String[] column1) throws IOException&#123;</div><div class="line"></div><div class="line">      List&lt;Row&gt; batch = new ArrayList&lt;Row&gt;();</div><div class="line">        Put put = new Put(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        put.add(family[0].getBytes(), column1[1].getBytes(), Bytes.toBytes(<span class="string">"valTest"</span>));</div><div class="line">        batch.add(put);</div><div class="line">        Get get1 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get1.addColumn(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(get1);</div><div class="line">        Delete delete = new Delete(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        delete.deleteColumns(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(delete);</div><div class="line">        Get get2 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get2.addFamily(family[0].getBytes());</div><div class="line">        batch.add(get2);</div><div class="line">        Object[] results = new Object[batch.size()];</div><div class="line">        try &#123;</div><div class="line">            hTable.batch(batch,results);</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; results.length; i++) &#123;</div><div class="line">     System.out.println(results[i]);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>results返回值有<br>null    操作与远程服务器的通信失败<br>EmptyResult    Put与Delete操作成功后的返回结果<br>Result    Get操作成功的返回结果，如果没有匹配的行或列，会返回空的Result<br>Throwable    当服务器端返回一个异常时，这个异常会按原样返回给客户端。用户可以使用这个异常检查哪里出了错，也许可以在自己的代码中自动处理异常<br>void batch(List<row> actions,Object[] results)和Object [] batch(List<row> actions)<br>不同点：后面那个批量操作一旦出现异常，将不会获取到结果<br>相同点：get、delete和put都支持，如果执行时出现问题，客户端将抛出异常并报告问题。</row></row></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>像put、delete、checkAndPut这样的修改操作是独立执行的，这意味者在一个串行方式的执行中，对于每一行必须保证行级别的操作是原子性，region服务器提供了行锁的特性，这个特性保证只有一个客户获得一行数据对应的锁，同时对该行进行修改。使用如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RowLock lock=table.lockRow(row1);</div><div class="line">Put put=new Put(row1,lock);</div><div class="line">table.put(put);</div><div class="line">table.unlockRow(lock);</div></pre></td></tr></table></figure></p>
<p>获取数据也可以加显式锁，历史提供了Get(byte[] row,RowLock lock)，但服务器根本用不到这个方法，首先不说加锁的性能影响，原因在于获取数据时，应用了多版本并发控制保证行级读操作。<br>备注：MVCC算法<br>HBase采用了MVCC算法来避免读操作去获取行锁。<br>对于写操作：<br>(w1) 获取行锁后，每个写操作都立即分配一个写序号<br>(w2) 写操作在保存每个数据cell时都要带上写序号<br>(w3) 写操作需要申明以这个写序号来完成本次写操作（标注该行）<br>对于读操作:<br>(r1) 每个读操作开始都分配一个读序号，也称为读取点<br>(r2) 读取点的值是所有的写操作完成序号中的最大整数(所有的写操作完成序号&lt;=读取点）<br>(r3) 对某个(row,column)的读取操作r来说，结果是满足写序号为“写序号&lt;=读取点这个范围内”的最大整数的所有cell值的组合</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>Put、Delete与Get对象都是Row的子类，从该继承关系中我们就可以了解到Get、Delete与Pu对象本身就只能进行单行的操作，HBase客户端还提供了一套能够进行全表扫描的API，方便用户能够快速对整张表进行扫描，以获取想要的结果—scan</p>
<h3 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h3><p>全表扫描是一种不需要行键值的操作，因此初始化时不需要指定行键值，因此就产生了不同的使用方法<br>1、不进行Scan对象创建的全表扫描<br>在该过程中，Htable对象会在扫描请求发送前隐式的创建一个scan对象，然后传递给Hbase服务器集群。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void scanWithoutInit(String tableName,String family)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            //获取全表扫描  </div><div class="line">            ResultScanner resultScanner=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            //对结果进行显示  </div><div class="line">            Iterator&lt;Result&gt; results=resultScanner.iterator();  </div><div class="line">            <span class="keyword">while</span>(results.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                Result result=results.next();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:result.raw())  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>getScanner()方法时，如果不输入指定的scan对象，则需要输入相应的列簇或者列。因此在不进行scan对象创建的扫描中，需要明确指出列簇或者列，如果需要扫描多个列簇时，该方法就无法起到作用了。<br>2、进行初始化的全表扫描<br>初始化一个scan对象，然后对该对象进行相应的配置过，通过 getScanner(Scan scan) 函数进行全表扫描。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void scanWithInit(String tableName)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建扫描类  </div><div class="line">            Scan scan=new Scan();  </div><div class="line">            scan.setStartRow(Bytes.toBytes(<span class="string">"row-1"</span>));  </div><div class="line">            scan.setStopRow(Bytes.toBytes(<span class="string">"row-9"</span>));  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            ResultScanner rs=table.getScanner(scan);  </div><div class="line">            Result result;  </div><div class="line">            <span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">            &#123;  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();  </div><div class="line">            table.close();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在上段代码中，使用了setStartRow() 与 setStopRow() 两个函数进行调优。Scan有多个函数可以进行对全表扫描做出相应的规范。<br>3、数据遍历与显示ScannerResult<br>通过上述两种方法可以发送对一张表是遍历请求，当发送后，服务器会相应的启动全表扫面程序，从而准备向客户端返回相应的数据。因此根据客户端的遍历需要对数据尽心请求，然后将请求的结果进行返回，客户端拿到后进行展示<br>（1）next()的单行返回数据的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ResultScanner rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">//进项单行获取演示  </div><div class="line">Result result=null;  </div><div class="line"><span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">&#123;  </div><div class="line">    KeyValue[] kvs=result.raw();  </div><div class="line">    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">rs.close();</div></pre></td></tr></table></figure></p>
<p>next()方法会默认想客户端请求发送一行数据请求，刚服务器端的scan程序接收到请求后会将经需要返回的数据封装成一个result对象返回给客户端，因此客户端可以通过result对象去接受该行数据。接收到的数据则跟Get中的result使用方法是相同的。<br>（2）next(int n)的多行返回数据的方法<br>next(int n)：该函数会向服务器发送多个请求，以返回多条数据请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//一次获取多个结果（行数据）进行展示  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Result[] results=null;  </div><div class="line">            <span class="keyword">while</span>((results=rs.next(2))!=null)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">for</span>(Result r:results)  </div><div class="line">                &#123;  </div><div class="line">                    KeyValue[] kvs=r.raw();  </div><div class="line">                    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                    &#123;  </div><div class="line">                        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>next(int n)函数返回的是一个result数组。用户接受到数据后可以进行相应的操作。<br>（3）迭代器遍历<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进行迭代的方式进行输出  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Iterator&lt;Result&gt; resultIterator=rs.iterator();  </div><div class="line">            <span class="keyword">while</span>(resultIterator.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                result=resultIterator.next();  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            //关闭表  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>（4）注意点<br>因为当用户发送一个scan全表扫描后，region服务器会为全表扫描创建扫描资源，因此长时间启用全表扫描的话会占用region服务器的大量资源，所以在要求在使用完scanner扫描器后尽快释放掉资源。<br>rs.close() 会告知服务其扫描器租约已经结束，服务器就会释相应的全局扫描的资源。<br>三、Scan对象<br>（1）setStartRow() / setStopRow<br>设置扫描的开始行与结束行，通过这两个可以直接确scan在扫描的范围，通过缩小范围可以减少扫描到时间，从而提高扫描的效率<br>（2）addFamily() / addColumn()<br>通过这两个函数，可以在列或者列簇上的扫描位置。HBase是面向lie出书的数据库，而同一个列簇的数据全部存放在同一个位置文件中。因此如果可以确定扫描那个一列簇时，可以减少扫描的范围，从而缩短扫描的时间。而在确定到某一个列时也会因为HBase的面向列存储使得其效率提高。<br>（3）setMaxVersion() / setMaxVersion(int version)<br>设置返回的版本数量，默认为返回最新的数据。第一个函数则会返回所有的版本数据，第二个函数可以设置返回的版本数量<br>（4）setTimeStamp(long max)<br>返回该时间戳的数据<br>（5）setTimeRange(long min,long max)<br>设定返回的时间戳的范围，只有版本值在该范围之内的数据才会被返回到客户端<br>（6）setFilter(Filter f)<br>设置过滤器，有时候扫描全表返回的数量过大时，可以通过过滤器将不符合的数据进行过滤，这样可以减少从服务器到客户端的数据传送，挺高扫描效率。<br>（7）setCacheBlocks(boole open)<br>在进行全表扫描过程中，服务器端提供了一个缓存区，该缓存区可以将指定的数据量全部放入到内存中，这样可以提高读取效率。缓存区的打开也可以通过htable客户端进行打开。在开发后用户可以通过 setCache(int n)的方式设置每次缓存的数量为多少。通过调整该函数以提高读取的效率。<br>四、总结<br>scan的全表扫描区别于其他三个操作，虽然获取数据与Get获取的数据是相同的，其与Get也具有形似的属性，可以通过修改这些属性去对数据获取进行调优，从而使得提高数据获取的效率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/hbase简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/hbase简介/" itemprop="url">hbase简介(第一章)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T09:38:49+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="海量数据的黎明"><a href="#海量数据的黎明" class="headerlink" title="海量数据的黎明"></a>海量数据的黎明</h2><p>hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，可以帮助用户分析数据时决定如何解释这些数据，同时允许用户随时更改数据分类的方式；一旦用户更新了算法，只需要重新分析数据。Hadoop是现有数据库的一个补充，提供了数据存储无限的空间，并且针对大文件存储、批量访问和流式访问做了优化。<br>列式存储数据库，以列为单位聚合数据，然后将列值顺序存入磁盘，而行式数据库则是连续存储整行。<br>1.优点是：查询时只有涉及到的列会被读取；投影(projection)很高效；任何列都能作为索引。缺点：选择完成时，被选择的列要重新组装；INSERT/UPDATE比较麻烦。<br>2.更好的进行数据压缩：通过字典表压缩数据。经过字典表进行数据压缩后，表中的字符串才都变成数字了，比如我们的材料名可以用一张材料表，这样子在列存储就可以根据id来关联材料。<br>3.查询性能<br>我们能根据列查询结果通过为运算（&amp;或者|）进行结果合并，加快速度<br>关键步骤如下：<br>1.去字典表里找到字符串对应数字(只进行一次字符串比较)。<br>2.用数字去列表里匹配，匹配上的位置设为1。<br>3.把不同列的匹配结果进行位运算得到符合所有条件的记录下标。<br>4.使用这个下标组装出最终的结果集。<br>Hbase以列式存储的格式存储数据，传统的列式存储比较适合实时存储数据的场景，Hbase比较适合键值对的数据存取或者有序的数据存取。</p>
<h2 id="关系数据库系统的问题"><a href="#关系数据库系统的问题" class="headerlink" title="关系数据库系统的问题"></a>关系数据库系统的问题</h2><p>数据量大时，索引量也大到足以让数据库的性能直线下降。最后能够提供的查询也只剩下主键查询，最后的采取的方案就是数据分区，也就是分库分表。</p>
<h2 id="非关系型数据库系统"><a href="#非关系型数据库系统" class="headerlink" title="非关系型数据库系统"></a>非关系型数据库系统</h2><h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><p>包括数据模型、存储模型、一致性模型、物理模型、读写性能、辅助索引、故障处理、压缩、负载均衡、原子操作的读修改写、加锁等待死锁</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><h3 id="数据库的范式和反范式"><a href="#数据库的范式和反范式" class="headerlink" title="数据库的范式和反范式"></a>数据库的范式和反范式</h3><h2 id="Hbase结构"><a href="#Hbase结构" class="headerlink" title="Hbase结构"></a>Hbase结构</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="表、行、列和单元格"><a href="#表、行、列和单元格" class="headerlink" title="表、行、列和单元格"></a>表、行、列和单元格</h3><p>最基本的单位是列，一列或者多列构成一行，并由唯一的行健来确定存储。反过来，一个表中有若干行，其中每列可能有多个版本，在每个单元格中存储了不同值。行序是按照字典顺序进行排序的，意思是从左到右一次对比每一个键。关于排序：排列顺序如果跟预期的不一样，需要补键，比如  row-1 永远小于 row-2，无论后面是什么，将始终按照这个顺序排列。行健总是唯一的，否则你就是在更新同一行。行健可以是任意的字节数组，但它不一定是人直接可读。<br>一行由若干列组成，若干列构成一个列族，有助于构建语义边界，还有助于给他们设置某些特性（压缩），或者指示他们存储在内存中。一个列族所有列存储在HFile。<br>常用的引用列的格式为family：qualifier，qualifier是任意字节数组。一个列族没有列的数量限制，可以有数百万列。列值没有类型和长度的限制。NUll值在Hbase不占任何空间。<br>每一列的值或者单元格都有时间戳，不同时间戳区分不同的版本值，同一个单元格的不同版本值按照时间戳降序排序，访问时候优先读取最新的值。这样优化使得新值比老值更容易读到。用户可以指定每个值能保存的最大版本数，此外还支持谓词删除（LSM树）。<br>Hbase是一个稀疏的、分布式的、持久化的、多维的映射、由行健列键和时间戳索引。数据存储模式：(Table,RowKey,Family,Column,TimeStamp)-&gt;value</p>
<h3 id="自动分区"><a href="#自动分区" class="headerlink" title="自动分区"></a>自动分区</h3><p>Hbase中扩展和负载均衡的基本单元是region，region本质是以行键排序的连续存储的区间。如果region太大，系统会动态拆分，相反会合并region，减少存储文件数量。<br>一张表初始化只有一个region，用户不断插入数据，当数据量超过配置的最大值，会在中间键处将这个region拆分成两个大致相等的region。每一个region只能由一台regionServer加载，而一台RegionServer可以同时加载多个region。（每台regionServer1加载的最佳数量是10~1000，每个region最佳大小是1GB~2GB）。当某个region服务器由于负载过大等原因导致不可用时，系统会将该region转到其他服务器上。</p>
<h3 id="存储API"><a href="#存储API" class="headerlink" title="存储API"></a>存储API</h3><p>API提供了建表、删表、增加列族、删除列族、修改表、修改列族元数据（压缩，设置块大小）、行键值的增加，删除，查找<br>scan可以限定返回的列或者返回的版本数，可以设置过滤器。系统支持单行事务，进一步实现单行键下存储的数据的 读-修改-写（read-modify-write）序列。单元格的值可以当计数器用，并且支持原子更新，意味着这个计数器可以在一个操作中实现读写，客户端可以基于此实现一个全局强一致的计数器。协处理器(coprocessor): 可以在服务器的地址空间执行来自客户端的代码。用于实现轻量级的批处理作业，或者使用表达式分析或者汇总数据。通过包装器可以将表转换成MapReduce的输入输出目标</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>数据存储在存储文件中，称为HFile，HFile存储的是经过排序的键值映射结构。文件内部由连续的块组成，块的索引信息放在尾部，当打开HFile并加载在内存中，索引信息会优先加载到内存中，每个块的大小为64k。每个HFile都有一个块索引，通过一个磁盘查询就可以实现查询，存储文件写在HDFS中。每次更新数据，都会将数据记录在提交日志中，然后在将数据写入内存memstore,一旦内存超过一定的大小，就会移除内存，作为HFile写入磁盘。移除内存后，就会丢弃提交日志，只保留未持久化的提交日志。数据移出memstore，丢弃提交日志。采用滚动memstore可以实现不阻塞系统读写，即用空的新memstore获取更新数据，将旧的满的memstore转换成一个文件，由于memstore中的数据本来就排序好了，所以存储的时候不用再次排序。删除是在做个删除标记，让客户端无法读取到值。<br>HFile过多的时候有管家机制来处理，合并有两种类型：<br>minor合并：多个小文件合并成一个大文件，由于是多路归并所以速度快<br>major压缩合并：将region中一个列族的若干个HFile重写为一个新HFile。合并扫描所有键值对，顺序重写所有数据，重写数据的过程中会略过做了删除标记的数据。断言删除此时生效。<br>master 负责负载均衡，将繁忙服务器中的region移到负载轻的服务器中。还提供元数据的管理，例如创建表和创建列族。<br>region服务器负责为他们提供的Region提供读写功能<br>数十亿行<em>数百万列</em>数千个版本=TB级别或者PB级别的存储</p>
<h2 id="Hbase：Hadoop数据库"><a href="#Hbase：Hadoop数据库" class="headerlink" title="Hbase：Hadoop数据库"></a>Hbase：Hadoop数据库</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Hbase是一个分布式的、持久性的、强一致性的存储系统，具有近似最优的写性能和出色的读性能。它充分利用磁盘空间，支持特定列族切换可选压缩算法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/elasticSearch初步了解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/elasticSearch初步了解/" itemprop="url">elasticSearch入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T23:10:46+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="elasticSearch简介"><a href="#elasticSearch简介" class="headerlink" title="elasticSearch简介"></a>elasticSearch简介</h2><p>1.基于Apache Lucene构建的开源搜索引擎<br>2.基于java编写，提供简单易用的Resful API<br>3.轻松的横向扩展，可支持PB级别的结构化和非结构化的数据处理</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1.海量数据分析引擎<br>2.站内搜索引擎<br>3.数据仓库<br>备注应用：github站内搜索、维基百科、百度实时日志监控</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>版本历史 1.x-&gt;2.x-&gt;5.x</p>
<h2 id="安装head插件"><a href="#安装head插件" class="headerlink" title="安装head插件"></a>安装head插件</h2><p>安装elasticsearch-head,github地址：<a href="https://github.com/mobz/elasticsearch-head.git，然后进行npm" target="_blank" rel="external">https://github.com/mobz/elasticsearch-head.git，然后进行npm</a> install，在启动head插件（npm run start），<a href="http://localhost:9100。" target="_blank" rel="external">http://localhost:9100。</a><br>同时更改elasticsearch.yml，新增以下内容支持跨域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http.cors.enabled: <span class="literal">true</span></div><div class="line">http.cors.allow-origin: <span class="string">"*"</span></div></pre></td></tr></table></figure></p>
<h2 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h2><p>举个例子，三个节点<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: master</div><div class="line">node.master: <span class="literal">true</span></div><div class="line">network.host: 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>slave节点的配置如下，在elasticsearch.yml修改<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: slave1</div><div class="line">network.host: 127.0.0.1</div><div class="line">http.port: 8200</div><div class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"127.0.0.1"</span>]</div></pre></td></tr></table></figure></p>
<h2 id="集群和节点"><a href="#集群和节点" class="headerlink" title="集群和节点"></a>集群和节点</h2><p>集群有节点组成，每个集群有唯一的名字。 一个节点只是集群的一部分，节点通过集群名字加入集群</p>
<ul>
<li>索引(database)<br>含有相同属性的文档集合</li>
<li>类型(table)<br>索引可以定义一个或者多个类型，文档必须属于一个类型</li>
<li>文档(row)<br>文档是可以被索引的基本数据单位</li>
<li>分片<br>每个索引都有多个分片，每个分片是lucene索引</li>
<li>备份<br>拷贝一份分片就完成了分片的备份<br>备注：es默认五个分片一个备份<h2 id="es的基本用法"><a href="#es的基本用法" class="headerlink" title="es的基本用法"></a>es的基本用法</h2></li>
<li>api的基本格式：http://<ip>:<port>/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</port></ip></li>
<li>常用的动词有：GET/PUT/POST/DELETE<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3>在head插件创建索引<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:book put请求</div><div class="line">&#123;</div><div class="line">  <span class="string">"novel"</span>: &#123;</div><div class="line">    <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"title"</span>: &#123;</div><div class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用postman插件，可视化插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:people put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"settings"</span>:&#123;</div><div class="line">		<span class="string">"number_of_shards"</span>:3,</div><div class="line">		<span class="string">"number_of_replicas"</span>:1</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"mappings"</span>:&#123;</div><div class="line">		<span class="string">"man"</span>:&#123;</div><div class="line">			<span class="string">"properties"</span>:&#123;</div><div class="line">				<span class="string">"name"</span>:&#123;</div><div class="line">					<span class="string">"type"</span>:<span class="string">"text"</span></div><div class="line">				&#125;,</div><div class="line">			    <span class="string">"country"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"keyword"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"age"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"integer"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"date"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"date"</span>,</div><div class="line">			    	<span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss"</span></div><div class="line">			    &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入索引"><a href="#插入索引" class="headerlink" title="插入索引"></a>插入索引</h3><ul>
<li><p>指定文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1 Put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"lirui"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 24,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-09-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自动产生文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man POST请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"李睿"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 25,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-06-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/_update POST请求</div><div class="line">  &#123;</div><div class="line">  	<span class="string">"doc"</span>:&#123;</div><div class="line">       <span class="string">"name"</span>:<span class="string">"kobe_brant"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/ DELETE请求</div></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>使用head插件删除索引或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/ DELETE请求</div></pre></td></tr></table></figure></p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/_search POST</div><div class="line">//查询全部</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_all"</span>:&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//针对查询</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;<span class="string">"name"</span>:<span class="string">"kobe"</span>&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"sort"</span>:[</div><div class="line">    	   &#123;</div><div class="line">    	   	<span class="string">"date"</span>:&#123;</div><div class="line">    	   	  <span class="string">"order"</span>:<span class="string">"desc"</span></div><div class="line">    	   &#125;</div><div class="line">    	   &#125;</div><div class="line">    	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_name"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"country"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ul>
<li>子条件查询<br>特定字段查询所指的特定值<h4 id="query-context"><a href="#query-context" class="headerlink" title="query context"></a>query context</h4>查询过程中，除了判断文档是否满足条件外，es会计算一个_sore来标识匹配程度<br>分为全文本查询（文本类型数据）和字段级别查询（结构化数据如数字、日期）<h4 id="filter-context"><a href="#filter-context" class="headerlink" title="filter context"></a>filter context</h4>在查询时只需要判断文档是否满足条件，只有Yes或者No。</li>
<li>复合条件查询<br>以一定逻辑组合子条件查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line">      <span class="string">"should"</span>:[&#123;</div><div class="line">         <span class="string">"match"</span>:&#123;</div><div class="line">           <span class="string">"author"</span>:<span class="string">"瓦力"</span></div><div class="line">         &#125;</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">          <span class="string">"match"</span>:&#123;</div><div class="line">            <span class="string">"title"</span>:<span class="string">"瓦力"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"term"</span>:&#123;</div><div class="line">          <span class="string">"word_count"</span>:1000</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/构建大型网站的其他要素/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/构建大型网站的其他要素/" itemprop="url">构建大型网站的其他要素（第八章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T13:25:33+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="加速静态内容访问的速度的CDN"><a href="#加速静态内容访问的速度的CDN" class="headerlink" title="加速静态内容访问的速度的CDN"></a>加速静态内容访问的速度的CDN</h2><p>CDN，Content Delivery Network，内容分发网络。CDN的作用是把用户需要的内容分发到离用户近的地方，这样可以从用户能就近获取所需的内容。整个CDN系统分为CDN源站和CDN节点。CDN源站提供CDN节点使用的数据源头，CDN节点部署在离最终用户比较近的地方，加速用户对站点的访问。CDN就是网络缓存技术，一般存放静态文件（js，css，图片，视频，页面框架）。<br>浏览器访问网站的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，获取ip地址；<br>3.浏览器向所得到的ip发送请求；<br>4.浏览器根据返回的内容显示数据<br>有了CDN后的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，由于CDN对域名解析过程做了调整，所以得到该域名对应的CNAME记录。<br>3.对CNAME进行解析得到实际的ip地址。在这次解析中会使用全局负载均衡CDN解析，需要我们根据地理位置以及所在的ISP确定结果，然后获取到具体的IP地址。<br>4.得到实际的ip地址后，我们会向服务器发送请求。<br>5.CDN会根据请求的内容是否在本地缓存进行不同的处理。<br>如果存在，直接返回结果；不存在，则请求CDN源站，获取内容，返回结果。<br>CDN关键的技术：<br>1.全局调度<br>全局调度是完成用户就近访问的第一步，我们需要根据用户地域、接入运营商、以及CDN机房的负载情况去调度。<br>2.缓存技术<br>如果请求不存在CDN节点，则请求CDN源站，获取内容，返回结果。如果命中率不高，加速有限。要提升命中率，首先缓存的容量要足够大，可以使用内存+SSD+硬盘混合存储。还有新增变更数据预加载也能提升命中<br>3.内容分发<br>内容分发主要包括在CDN上不用回源的数据的管理和分发，主要包括静态页面。<br>4.带宽优化<br>只返回必要数据和使用更好的压缩算法</p>
<h2 id="大型网站的存储支持"><a href="#大型网站的存储支持" class="headerlink" title="大型网站的存储支持"></a>大型网站的存储支持</h2><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><p>对一些图片、大文本的存储使用数据库就不合适了。GFS主要由三部分构成：GFS Client、GFS Master、GFS chunkserver</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>应用使用GFS的入口，Client负责从GFS Master上获取要操作的文件在chunkserver中的具体地址，然后直接和chunkserver通信，获取数据或者进行数据写入和更新。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>可以说是整个文件系统的大脑，这里维护了所有的文件系统的元数据，包括名字空间、访问控制信息、文件与chunk的映射信息、chunk的当前位置。Master也控制整个系统范围内的活动，例如，无效的chunk的回收以及chunksever之前的chunk迁移等。Master与chunkServer之间通过周期性的心跳进行通信，检测对方是否在线。</p>
<h4 id="ChunkServer"><a href="#ChunkServer" class="headerlink" title="ChunkServer"></a>ChunkServer</h4><p>这是文件系统存储的地方。在每个chunkserver上会用chunk的方式管理数据。每个chunk是固定大小的文件，超过chunk的文件会被分为多个chunk进行存储，小于chunk的文件则会将多个文件存储在一个chunk中。<br>GFS主要解决单机的存储问题和安全问题，HDFS是java的类GFS的实现。</p>
<h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h3><p>not only sql。基本上处于分布式文件系统和SQL关系型数据库之间的系统都被归为NoSql范畴。<br>在NoSql Data Modeling Techniques文章中，一个NoSql和Sql的基础都来自key value，另外一个NoSql继续发展，就会变成Sql数据库。</p>
<h4 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h4><p>最基础的技术支撑，后续的产品都基于key-value存储发展起来。但是有个问题，没有办法进行高效的范围查询。</p>
<h4 id="ordered-key-value"><a href="#ordered-key-value" class="headerlink" title="ordered key-value"></a>ordered key-value</h4><p>key是有序的，可以解决key的范围查询的效率，但是在这个模型中，value本身的内容和结构是由应用来负责解析和存储的。</p>
<h4 id="Big-Table"><a href="#Big-Table" class="headerlink" title="Big Table"></a>Big Table</h4><p>是google发表的名为BigTable：A Distributed Storage System for Structured Data论文中提到的一个产品，是一个结构化数据的分布式存储系统。BigTable对value进行了schema的支持，value是由多个Column family组成，Column family的内部是Column，ColumnFamily不能动态扩展，但是Column能够动态扩展。（hbase可以是里面的一个实现）</p>
<h4 id="Document-full-text-Search"><a href="#Document-full-text-Search" class="headerlink" title="Document full-text Search"></a>Document full-text Search</h4><p>Document数据库有两个很大的进步，一个是可以在内部任意定义schema，而不再仅仅是map的嵌套；另一个是全文检索的支持。</p>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>图数据库可以看成从有序的key-value数据库发展而来的一个分支，主要是支持图结构的数据模型。<br>这里面讲的Full-Text Search和Graph在一些地方可能不能归为NoSql。<br>Hbase是借鉴Google BigTable的一个java版本的实现，存储到hbase的数据是通过HRegionServer来管理，每个HRegionServer管理了多个HRegion，每个Region管理了具体数据。HMaster管理所有的HRegionServer节点，是一个中心控制结构。还有比较经典的Amazon的Dynamo，它是采用了一致性哈希来进行管理。</p>
<h3 id="缓存系统"><a href="#缓存系统" class="headerlink" title="缓存系统"></a>缓存系统</h3><p>缓存是非持久化，用来加速应用对数据的读取。Redis和Memcache是两个广泛的缓存系统，Redis已经有了对于集群的支持，memcache本身还是一个单机的应用。如果想把多个节点构成一个集群，常见的有一致性哈希。有两个使用缓存的场景<br>首先是使用缓存降低底层读的压力，需要注意缓存和数据一致性的问题。在这种方式中，应用不直接操作缓存，存储由缓存控制。但是这种场景下，因为保证写入缓存后要能写入存储，所以缓存本身的逻辑比较复杂，需要很多操作日志和故障恢复。<br>另一种使用缓存的方式是，应用直接与缓存和存储系统打交道，一般的做法是在写操作时更新缓存，然后失效缓存；而在读数据时先读缓存，如果缓存没有命中，再去读数据，写入缓存。<br>这里重点考虑缓存与存储数据一致性问题，这里指最终一致性。重点考虑缓存没有命中和数据更改的情况，以及更新存储中的数据后没来得及将缓存失效<br>还有就是全数据缓存，当存储的数据变化就直接同步到缓存，这样应用取数据都从缓存中取。用于数据变更通知平台<br>大型网站使用缓存的场景还有对于web应用页面渲染的缓存。以一个页面展示为例，我们队页面进行了分块，其中有静态内容，也有动态内容，如果整个页面采用服务器渲染的方式，我们希望相对静止的内容可以进行缓存而不用每次都要重新渲染。具体的技术有ESI（edge side includes），是通过在返回的页面加上标签，然后标签的内容去用缓存填充的一个过程。处理ESI标签可以放在java应用容器中去处理，也可以放在java应用容器前置的服务器去处理。<br>两种方式对比如下：<br>1.渲染页面和ESI处理在一个进程里，处理效率会提升，当页面内容是内部对象时就可以处理ESI标签，而如果放在前置服务器，需要对内容进行一次扫描，定位到ESI标签后再处理。<br>2.ESI放在Web前置服务器去处理，对于后端来说可以不用去考虑ESI标签问题，例如当后端处理请求为java应用、php 应用时，可以统一把ESI处理放在前置服务器上，这样后端就只用处理请求，不必对每个应用做都去处理ESI工作。</p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>当网站的数据量和访问量很小时候，一些数据的查询可以用数据库的like操作来实现，当然这种操作比较效率很低也不够智能。当数据量和访问量很大时候，就需要在站内使用搜索技术来解决这问题。</p>
<h3 id="爬虫问题"><a href="#爬虫问题" class="headerlink" title="爬虫问题"></a>爬虫问题</h3><p>对于全网搜索来说，我们需要爬虫去获取被检索的网站内容。这里我们要讲更新索引的方式<br>1.定时从数据源中拉取，我们称之为增量dump。这要求数据库有个记录变更时间的字段，否则无法获取一段时间变更的数据，而这个字段需要有索引，否则效率变得很低。增量dump开始前，需要全量dump构造初始化的数据。增量的时间间隔一般在分钟级，这会引起明显延迟。<br>2.通过数据变更的通知，及时通过搜索引擎构建索引及时性会很好不过带来的系统压力会很大。因而这种方式主要用在实时性很高的场景。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引是很重要的一项搜索引擎技术。正向索引可以理解为文章和关键词的映射。相对于正向索引，倒排索引是把值的内容拆分成了索引的key，而原来用做索引的key则变成了值，也就是关键词和文档之间的映射。搜索引擎比数据库高效的原因就在于倒排索引。如何确定倒排索引的关键词，关键在于分词。</p>
<h3 id="查询预处理"><a href="#查询预处理" class="headerlink" title="查询预处理"></a>查询预处理</h3><p>查询表预处理主要负责对用户搜索内容进行分词及分词后的分析，包括同义词的替换和及词后的分析，包括一些同义词的替换和纠错等。这一部分是在使用搜索引擎前对搜索内容的梳理，这部分的工作也最终影响到搜索结果的质量。<br>备注：1、在建立索引时，拆词建索引时就把同义词考虑进去，将同义词的词条加入到索引中，然后检索时，直接根据输入拆词来检索2、在建立索引时，不对同义词进行任何处理，在检索时，先拆词，针对拆分出来的词元（呵呵，自创的称呼）也即关键字，进行同义词匹配，把匹配好的同义词拼成一个新的关键字，搜索索引时根据此关键字来进行检索。个人觉得，方案二更优于方案一，理由如下：在建立索引时，就处理同义词，一方面会增加索引库的容量，导致索引效率的降低；其次，如果后期对同义词进行了扩展，比如原来，一个单词有2个同义词，后面增加到3个，就需要对索引进行重建了，！<br>似,is,are =&gt; 是（一般适用于纠错，格式一表示如果文本中出现了is,are,那么直接替换成是。expand参数对此没有影响。）好人,好心人,热心人（格式二表示如果文本中出现了好人或者好心人或者热心人，当expand=true时，把待替换的文本用好人好心人 热心人替换；当expand=false时，把待替换文本用第一个单词即好人替换。）</p>
<h3 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h3><p>查询在搜索引擎上被执行，对于返回的结果，需要计算和搜索内容的相关度展示给用户，相关度计算是指不指定按照某个字段排序的基础上对结果的排序，排序的原则是被搜索到的内容和搜索内容之间的相关度。<br>相关度的计算方式很多，例如有空间向量模型、概率模型<br><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7981145</a></p>
<h2 id="数据计算支撑"><a href="#数据计算支撑" class="headerlink" title="数据计算支撑"></a>数据计算支撑</h2><h3 id="离线计算"><a href="#离线计算" class="headerlink" title="离线计算"></a>离线计算</h3><p>离线计算是业务产生数据离开生产环境后进行的计算。就是业务数据从在线存储中移动到离线存储中，然后进行数据处理的过程。<br>在离线计算领域里，MapReduce模型十分著名和常用，MapReduce是google在2004发表的论文：MapReduce：simplified Data Processing On Large Clusters.<br>（<a href="http://www.cnblogs.com/fuzhe1989/p/3413457.html）。" target="_blank" rel="external">http://www.cnblogs.com/fuzhe1989/p/3413457.html）。</a><br>主要分为两个阶段，Map阶段和Reduce阶段。在map阶段，我们根据设定的规则，把整体数据集映射给不同的worker来处理，并且生成各自的处理结果。而在reduce阶段，是对前面处理过的数据进行聚合，形成不同的结果，一个任务的处理可能是不止一次MapReduce过程。<br>Hadoop是MapReduce的一个开源实现，Hadoop使用HDFS进行数据存储，Spark提供了基于内存的集群计算的支持，Spark本身是为了集群计算中特定类型工作而设计的。例如机器学习，基于内存的方式使得spark的速度非常快</p>
<h3 id="在线计算"><a href="#在线计算" class="headerlink" title="在线计算"></a>在线计算</h3><p>Storm是在线计算的一个框架<br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。</p>
<h2 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h2><p>当完成应用的开发和测试后，需要使应用上线来为最终用户提供服务。<br>1.分发应用<br>我们需要提供自动高效且容易操作的机制把经过测试的程序包分发到线上的应用，我们一般会采用web的操作方式，通过专用通道把应用程序包从线下环境传送到线上的发布服务器。发布控制台-&gt;多机房-&gt;发布服务器<br>2.启动校验<br>应用重启启动后，需要进行校验从而完成这台应用服务器上的应用发布，对应用的校验通常是应用自身提供一个检测脚本或者页面，发布系统执行这个脚本或者访问页面后来判断返回的结果。<br>停止应用时,需要优雅的关闭，需要在关闭应用前把这个应用从负载均衡或者软负载中心上移除<br>3.灰度发布<br>会对新应用进行分批发布，逐步扩大新应用在整个集群中的比例直至最后全部完成。这里讲的灰度发布主要是针对新应用在用户体验方面完全感知不到的更新.<br>4.产品改版Beta<br>提供新旧应用的共存</p>
<h2 id="应用监控系统"><a href="#应用监控系统" class="headerlink" title="应用监控系统"></a>应用监控系统</h2><p>1.数据监视维度<br>系统数据和应用自身的数据.系统数据指的就是当前应用运行的系统环境的信息，如CPU使用率、内存使用情况、交换分区使用情况、当前系统负载、IO情况等;而应用自身的数据，则是不同应用有不同的数据，一般会是调用次数、成功率、响应时间、异常数量等维度的数据<br>2.数据记录方式<br>系统自身的数据已经被记录到了本地磁盘，应用的数据一般也是存放在应用自身的目录中，便于采集。也有直接把应用日志通过网络发送到采集服务器的情况，可以减轻本地写日志的压力<br>对于应用数据的记录，会考虑用定时统计的方式记录一些量很大的信息.如对于一个提供服务的应用，在没有特别需求时，并不直接记录每次调用的信息，而是会记录一段时间如5s或者一个间隔时间内的总调用次数、总响应时间这样写信息，而对于异常信息则每次都会予以记录;采用统计的方式是为了减小记录的大小以及对本地磁盘的写入压力。<br>3.数据采集方式<br>采集方式有应用服务器主动对同给监控中心以及等待监控中心来拉取两种方式。前者控制权在应用服务器上,可能出现的问题是应用服务器推送的压力超过采集的中心服务器的能力，会造成重试等额外开销并且需要应用服务器上的推送程序控制重试逻辑和当前传送位置等信息。后者把复杂性都放在中心采集服务器上处理，使得应用服务器中支持数据采集的部分变的简单<br>4.展示与警告<br>提供图表的形式可以提供Web页面的展示-&gt;通过手机应用来接收报警-&gt;短信方式好<br>5.控制<br>控制<br>应用启动后在运行期对于应用的行为改变-&gt;对于应用的运维，最低的要求是出现问题时可以通过重启应用解决，但是我们还是需要更加精细化的控制应用-降低和一些切换。降级是我们遇到大量请求且不能扩容的情况时所进行的功能限制的行为-&gt;而切换更多的是当依赖的下层系统出现故障并且需要手工进行切换时的一个管理，这些控制一般都是通过开关，参数设置来完成</p>
<h2 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h2><p>随着网站功能增多，应用的个数迅速增加，应用之间的关系也会越来越复杂，理清这些依赖关系并能够管理这些依赖会非常重要<br>-&gt;一个应用在完成某个功能时到底需要依赖哪些外部系统、这些依赖中哪些是必要依赖，强依赖(登陆验证用户名和密码)，哪些是有了更好没有也可以的依赖，弱依赖（如记录登陆时间和ip等）-&gt;<br>-&gt;动态检测（在系统运行阶段，通过功能的调用来发现应用的依赖关系）和静态检测（分析代码来确定所调用的具体外部应用）-&gt;动态检测的主要检查方式是模拟被调用系统不可用和响应慢的两种情况-&gt;<br>-&gt;Google#Dapper,A Large-Scale Distributed Systems Tracing Infrastructure-&gt;traceId,index-&gt;形成一个调用时序图</p>
<h2 id="多机房问题分析"><a href="#多机房问题分析" class="headerlink" title="多机房问题分析"></a>多机房问题分析</h2><p>同城机房和异地机房<br>同城多个机房中，对于重要的应用系统，会在不止一个机房中部署；而对于数据库系统，则会把主备放在不同机房。尽量避免不必要的跨机房的内部系统调用，为了数据安全，把产生的业务数据都同步到异地的机房。把一些对数据延迟不敏感的系统部署到异地,如只读系统….</p>
<h2 id="系统容量规划"><a href="#系统容量规划" class="headerlink" title="系统容量规划"></a>系统容量规划</h2><p>我们应该知道的信息就是整个系统的容量以及运行时所处的水位。我们把某个应用系统集群能够提供的并发能力和当前的压力比作一个水桶的容量和水位。那么准确知道各个系统的容量和当前高峰时的水位是一件很重要的事情。因为我们还是希望优先通过扩大容量来支持更多的请求而不是首选降级的方案。<br>考虑过去的增长情况并结合人为的判断<br>1.弄清楚当前系统高峰期的水位<br>2.弄清楚当前各个系统的容量<br>3.通过测试，压力测试，设置警戒值，高峰水位搞过警戒值就增加容量，保持高峰的水位是低于警戒值的</p>
<h2 id="内部私有云"><a href="#内部私有云" class="headerlink" title="内部私有云"></a>内部私有云</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/27/软负载中心与集中配置管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/软负载中心与集中配置管理/" itemprop="url">软负载中心与集中配置管理（第七章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T15:39:30+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初始软负载中心"><a href="#初始软负载中心" class="headerlink" title="初始软负载中心"></a>初始软负载中心</h2><p>在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知也是通过软负载中心。<br>软负载中心有两个最基本的职能：<br>1.聚合地址信息；无论是服务框架中需要用到的服务提供者地址还是消息中间件系统中的消息中间件地址，都需要由软负载中心去聚合地址列表，形成一个可供服务调用者及消息发送者、接收者接收的列表。<br>2.生命周期感知；软件负载中心能够对服务上下线自动感知，并且根据这个变化去更新服务地址数据，形成新的地址列表后，把数据传给需要数据的调用者或者消息的发送者和接收者。</p>
<h2 id="软负载中心的结构"><a href="#软负载中心的结构" class="headerlink" title="软负载中心的结构"></a>软负载中心的结构</h2><p>软负载中心包括：一个是软负载中心的服务端，另一个是软负载中心的客户端；服务端主要负责感知提供服务的机器是否在线，聚合提供者的机器信息，并且负责把数据传给使用数据的应用。客户端承载了两个角色，作为服务提供者，客户端主要是把服务提供者提供服务的具体信息主动传给服务端，并且随着提供服务的变化去更新数据；而作为服务使用者，客户端主要向服务端告知自己所需要的数据，并负责去更新数据，还要进行本地缓存，使得每次去请求服务来获取列表都是一个本地操作。<br>软件负载中心内部有三部分重要数据<br>1.聚合数据<br>聚合后的地址列表。对于提供的服务信息，我们使用唯一的dataId来标识，同时dataId支持分组（group），通过dataId和group可以定位到唯一的数据内容，这个内容是通过聚合完成的完整数据，而这个信息在内部就是一个key-value结构。<br>2.订阅关系<br>在软负载中心中，需要数据的应用把自己需要的数据告诉软负载中心，这就是订阅关系，订阅的粒度也是通过dataId和group来确定数据，那么会有dataId和group到数据订阅者的分组ID的一个映射关系，当聚合的数据发生变化，通过订阅关系的数据找到需要通知的数据订阅者，然后去进行数据更新操作。<br>3.连接关系<br>连接到软负载中心的节点和软负载中心已经建立的连接管理。使用软负载中心的应用，无论是发布数据还是订阅数据，都会有一个独立的分组，而连接数据就是用groupId作为key，然后对应管理这个物理连接，采用的是长连接方式。当订阅的数据发生变化，通过订阅关系找到需要通知的groupId，在连接数据这里就能够找到对应的连接，完成对应用的更新。</p>
<h2 id="内容聚合功能的设计"><a href="#内容聚合功能的设计" class="headerlink" title="内容聚合功能的设计"></a>内容聚合功能的设计</h2><p>保证数据的正确性<br>内容聚合主要需要保证的是并发场景下的数据聚合的正确性。另外需要考虑发布数据的机器短时间内上下线的问题，指发布数据刚连接上来，然后就断线了就是断线后又很快上线发布数据。内容聚合主要保证在这些异常又较为复杂的场景中保证数据的正确性<br>高效聚合数据<br>因为软负载中心是系统的中枢，虽然软负载中心不再服务调用或者消息投递的路径上，但是服务提供者以及消息中间件的服务地址列表都是由软负载中心进行管理的，高效聚合数据在软负载中心自身重启或者服务提供者大面积重启带来很大的便利。<br>在这里，我们讨论下实现（前提是java实现），我们可以用map来存储，用dataId和group作为key，value就是聚合后的数据。有几个关键点需要注意<br>1.并发下的数据正确性的保证<br>先看看场景，并发操作会是数据插入、更新、删除三个一起在一起的操作，其中删除、更新主要因同一个数据的不同数据发布者变化产生，而数据插入是由于多个新的dataId有进入到Map结构的需求。（如软件负载中心重启和大量的数据发布者重启时）<br>我们可以用ConcurrentHashMap线程安全管理所有dataId的数据，也可以用linkedlist来操作，但是要在增删或者读加锁，否则线程不安全。<br>2.数据更新、删除的顺序保证<br>所发布数据变化主要有新增、更新和删除，而处理顺序一定要跟真实世界的顺序一致，比较容易出现的问题是在网络断开后删除数据与数据新增和删除的问题。我们采用NIO的方式通信，通过selector感知连接的事件，包括数据可读、数据可写、建立连接、连接断开的事件，然后把这些交给IO线程池中的线程去处理，那么更新、新增数据和连接断开要去删除数据有可能在两个线程中去处理。如果是发布数据很快就断开，那么就有可能会出现先删除再新增。一个解决方案是新增数据时查看下是否连接还存在。<br>3.大量数据的同时插入、更新时的性能保证<br>ConcurrentHashmap在写时候采用分段锁，在读的时候不加锁，但在大量数据也遇到性能问题，改进的方案是：增加任务队列，对应的处理线程，以及对应的数据存储。这样针对同样的数据处理任务都放在同一个线程里，我们可以直接使用线程不安全容器；多线程的请求变成一个顺序的队列操作，交给任务队列处理，任务队列是需要线程安全，但是因为这里的操作主要是任务加入队列和任务从队列取出，都是简单的操作，锁冲突的情况相对之前加锁进行数据处理好多了。数据更新的线程如果需要等待更新结果，那就只要进行等待就可以了；而读取数据则一定需要等待任务执行结束后才能拿到结果。</p>
<h2 id="解决服务上下线的感知"><a href="#解决服务上下线的感知" class="headerlink" title="解决服务上下线的感知"></a>解决服务上下线的感知</h2><p>软负载的可用服务列表，当服务可用时，需要自动把服务加到服务地址列表，而服务不可用，需要自动从列表删除，这也就是上下线感知，这也是与使用硬件负载均衡需要配置服务列表的相比的一大优点<br>服务器的上下线的感知，具体有两种实现<br>1.通过客户端与服务器端的连接感知<br>无论是服务的发布者还是接收者都需要与软负载中心维持一个长连接。对于服务提供者来说，软负载中心可以通过这个长连接的心跳或者数据的发布来判断服务发布者是否在线。如果很久没有心跳或者数据的发布，则判定为不在线，那么就会取出这个发布者发布的数据。而对于新上线的发布者，通过连接建立和数据发布就实现了上线的通知。<br>这个方式有个结构的问题，即软负载中心属于旁路，也就是它不在调用链上，当软负载中心自身的负载很高时，是可能产生误判的。例如软负载中心负载压力很大，处理请求变慢，心跳数据来不及处理，会以为心跳超时而判定服务不在线，会导致原本可用的服务下线。<br>另外可能的问题是，如果服务发布者到软负载中心的网络链路有问题，而服务发布者到服务使用者本身没有问题，也会造成感知的问题，解决方案有在软负载中心的客户端增加逻辑，当收到软负载中心通知的应用下线数据时，需要服务调用者进行验证才能接收这个通知，但是这个方法带来的是对每个服务提供者的一次额外校验。<br>2.通过对于发布数据中提供的地址接口进行连接的检查<br>通过长连接的相关感知判断服务下线，不直接认定这个服务下线，而是交给另一个独立的监控应用去验证这个服务是否已经不在了，方式是通过地址、端口去进行连接验证，这种方法是有缺陷，所以还是需要服务调用者进行最终确认。</p>
<h2 id="软负载中心的数据分发的特点和设计"><a href="#软负载中心的数据分发的特点和设计" class="headerlink" title="软负载中心的数据分发的特点和设计"></a>软负载中心的数据分发的特点和设计</h2><h3 id="数据分发和消息订阅的区别"><a href="#数据分发和消息订阅的区别" class="headerlink" title="数据分发和消息订阅的区别"></a>数据分发和消息订阅的区别</h3><p>第一个差别是：消息中间件需要保证消息不丢失、每条消息都能送到消息订阅者，而软负载中心只需要保证最新的数据送到消息订阅者，不需要保证每次的数据变化都能让最终订阅者感知<br>第二个差别是：关于订阅者的集群，也就是订阅者的分组。在消息中间件中，一个集群的不同机器是分享所有消息，因为只要同一集群的一台机器去处理就好。而软负载中心不同，软负载中心维持的是大家需要的服务数据，所以需要把这个数据分发给所有机器。</p>
<h3 id="提升数据分发性能需要注意的问题"><a href="#提升数据分发性能需要注意的问题" class="headerlink" title="提升数据分发性能需要注意的问题"></a>提升数据分发性能需要注意的问题</h3><p>1.数据压缩<br>数据压缩可以降低数据量，提升网络吞吐量，使用cpu来换带宽。<br>2.全量与增量的选择<br>每次传输全量数据，逻辑简单，但是传输数据量大。使用增量，传输数据小，但实现复杂。建议刚开始数据量小时传输全量，数据量大传输增量</p>
<h2 id="针对服务化的特性支持"><a href="#针对服务化的特性支持" class="headerlink" title="针对服务化的特性支持"></a>针对服务化的特性支持</h2><h3 id="软负载特性分组"><a href="#软负载特性分组" class="headerlink" title="软负载特性分组"></a>软负载特性分组</h3><p>通过dataId和group来唯一确定数据。分组是为了隔离<br>1.根据环境区分<br>比较多的用于线下环境。在线下开发测试的环境中，需要对不同环境项目隔离和区分<br>2.分优先级的隔离<br>更多用于线上，也就是可以把提供同样的服务通过组的概念分开，也就是重要的服务使用者会有专门的组提供服务<br>关于分组，可以采用ip地址自动归组的方式</p>
<h3 id="提供自动感知以外的上下线开关"><a href="#提供自动感知以外的上下线开关" class="headerlink" title="提供自动感知以外的上下线开关"></a>提供自动感知以外的上下线开关</h3><p>1.优雅地停止应用<br>我们先从服务列表中去掉这个机器，然后等待这个机器的服务执行完成，然后再停止应用。通过指令直接从软负载中心使机器下线，是可以帮助做到这一点。<br>2.保持应用场景，用于排错<br>遇到服务的问题，可以把出问题的服务留下一台机器进行故障定位和场景分析，这时需要把这台机器从服务列表中拿下，以免有新的请求进来造成服务失败。</p>
<h3 id="维护路由规则"><a href="#维护路由规则" class="headerlink" title="维护路由规则"></a>维护路由规则</h3><p>路由规则需要统一维护，软负载中心可以管理这些数据。</p>
<h2 id="从单机到集群"><a href="#从单机到集群" class="headerlink" title="从单机到集群"></a>从单机到集群</h2><p>当系统规模不是很大时，可以使用单机加一个备用机器的方式充当软负载中心。<br>对于服务框架而言，用到的场景是服务调用，而服务本身多是无状态的，其中集群处理相对简单；对于消息中间件，如果本身存储系统不在本地，那也就是无状态的集群，如果存储在本地，还要考虑数据的迁移。而软负载中心要走向集群，需要考虑的问题有：<br>1.数据管理问题<br>软负载中心聚合了整个分布式集群中的服务地址信息，首先是信息存放的位置<br>2.连接管理问题</p>
<h3 id="数据统一管理方案"><a href="#数据统一管理方案" class="headerlink" title="数据统一管理方案"></a>数据统一管理方案</h3><p>把数据聚合信息放在同一个地方，那么也就变成了无状态；整个结构分三层：聚合数据这一层就是在管理数据；软负载中心的机器则是无状态的；最下层是数据发布者或者订阅者。此时软负载中心的机器是对等的。我们还可以对这个方案进行改进，把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；</p>
<h3 id="数据对等管理方案"><a href="#数据对等管理方案" class="headerlink" title="数据对等管理方案"></a>数据对等管理方案</h3><p>把数据分散到各个软负载中心的节点上，并且把自己管理的数据分发到其他节点上，从而保证每个节点都有整个集群的数据，并且这些节点的角色是对等的，数据发布者和数据订阅者，只需要去连软负载中心集群的任何一台机器就好，在软负载中心各个节点间会进行数据同步。同步的时候，我们没有必要每次变化都同步，我们可以批量处理更加高效，只要合并这些变化同步一次就好。一种方案是每个负载均衡节点互相同步；另一种是把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；需要同步的是数据推送数据和聚合数据机器。</p>
<h2 id="集中配置管理中心"><a href="#集中配置管理中心" class="headerlink" title="集中配置管理中心"></a>集中配置管理中心</h2><p>软负载中心保存了管理服务地址列表、路由规则、消息的订阅关系，这些数据我们可以从是否持久和是否聚合两个维度分类。<br>持久性是数据本身跟发布者的生命周期无关，典型的是持久订阅关系、路由规则、数据访问层的分库分表规则和数据库配置。非持久指的是与发布者的生命周期有关，例如服务地址列表，此外服务地址列表和订阅关系是需要聚合的，而路由关系不需要聚合</p>
<h3 id="客户端的实现和容灾策略"><a href="#客户端的实现和容灾策略" class="headerlink" title="客户端的实现和容灾策略"></a>客户端的实现和容灾策略</h3><p>客户端通过http协议与集中配置管理中心进行通信，采用长轮询的方式。建立连接并且发送请求，如果有数据，长轮询和普通轮询就会返回；如果没有数据，长轮询就会等待直到有数据或者超时。普通轮询就会直接返回。容灾的考虑，客户端有四个特性：1.数据缓存；2.数据快照；3.本地配置；4.文件格式。</p>
<h3 id="服务端的实现和容灾策略"><a href="#服务端的实现和容灾策略" class="headerlink" title="服务端的实现和容灾策略"></a>服务端的实现和容灾策略</h3><h3 id="数据库策略"><a href="#数据库策略" class="headerlink" title="数据库策略"></a>数据库策略</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/消息中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/消息中间件/" itemprop="url">消息中间件（第六章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T15:23:21+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息中间件的价值"><a href="#消息中间件的价值" class="headerlink" title="消息中间件的价值"></a>消息中间件的价值</h2><h3 id="消息中间件的定义"><a href="#消息中间件的定义" class="headerlink" title="消息中间件的定义"></a>消息中间件的定义</h3><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件</p>
<h3 id="通过示例看消息中间件对应用的解耦"><a href="#通过示例看消息中间件对应用的解耦" class="headerlink" title="通过示例看消息中间件对应用的解耦"></a>通过示例看消息中间件对应用的解耦</h3><h4 id="通过服务调用让其他系统感知事件发生的方式"><a href="#通过服务调用让其他系统感知事件发生的方式" class="headerlink" title="通过服务调用让其他系统感知事件发生的方式"></a>通过服务调用让其他系统感知事件发生的方式</h4><p>假设我们的登录系统，需要支持的一个功能是发短信给用户，如果在增加后续跟其他系统打交道的工作，会让登录系统变得十分复杂。<br>如登陆系统负责向消息中间件发送消息，而其他的系统则向消息中间件来订阅这个消息，然后完成自己的工作。</p>
<h4 id="通过消息中间件解耦服务调用"><a href="#通过消息中间件解耦服务调用" class="headerlink" title="通过消息中间件解耦服务调用"></a>通过消息中间件解耦服务调用</h4><p>从登陆系统的角度来看，这些系统都不是登录系统必须依赖的，登录系统只需要校验用户名和密码，而类似发短信系统不是登录系统必须依赖的系统。所以，我们需要解耦，服务调用会被固定格式的消息所取代。<br>通过消息中间件解耦，登录系统不需要知道有多少个系统需要知道登录成功这件事，也不用关心怎么传递给他们，只需要把登录成功这件事转化成一个消息发送到消息中间件就好。并且各个系统不受影响。</p>
<h2 id="互联网时代的消息中间件"><a href="#互联网时代的消息中间件" class="headerlink" title="互联网时代的消息中间件"></a>互联网时代的消息中间件</h2><p>JMS:Java Message Service-&gt;规范-&gt;Hornetq,ActiveMQ等产品是这个规范的实现</p>
<h3 id="如何解决消息发送的一致性"><a href="#如何解决消息发送的一致性" class="headerlink" title="如何解决消息发送的一致性"></a>如何解决消息发送的一致性</h3><h4 id="消息发送一致性的定义"><a href="#消息发送一致性的定义" class="headerlink" title="消息发送一致性的定义"></a>消息发送一致性的定义</h4><p>消息发送一致性指产生消息的业务动作与消息发送的一致。即如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了；而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去.</p>
<h4 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h4><p>JMS几个比较重要的元素：<br>Destination：消息所走的通道的目标定义，也就是消息从发送方发出后要走的通道，而不是最终接收方。<br>ConnectionFactory：用于创建连接的对象<br>Connection：连接接口，用于创建session<br>Session：会话接口，消息的发送者，消息的接收者以及消息都是由会话创建。<br>MessageConsumer：消息的消费者，用于订阅并处理消息的对象。<br>MessageProvider：消息的生产者，用于发送消息的对象<br>XXXMessage：指各种类型的对象，包括Bytemessage、MapMessage、ObjectMessage、StreamMesssage和TextMessage；<br>在jms的api接口中，有很多XA开头的类，他们是支持XA协议的接口。XA系列的接口集中在ConnectionFactory、Connection和Session上。但也会造成问题：<br>1.引入分布式事务，这会带来开销和复杂性；<br>2.对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起做分布式事务，这会造成限制（凡是参与全局事务的所有资源均应该使用其XA版。特别地，对于JDBC资源，必须使用JDBC XADataSource）。</p>
<h4 id="其他办法"><a href="#其他办法" class="headerlink" title="其他办法"></a>其他办法</h4><p>简单的方案不能保证一致性，但是出现问题的概率也不大；即便做到业务操作都支持XA，如果引入二阶段提交的分布式事务，则有点重。<br>简化流程：<br>1) 业务处理应用首先把消息发给消息中间件，标记消息的状态为待处理.<br>   (2) 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息.<br>   (3)消息中间件返回消息处理的结果，仅是入库的结果，结果是成功或者失败.<br>   (4)业务方收到消息中间件返回的结果并进行处理:<br>a) 如果收到的结果是失败，那么就放弃业务处理，结束<br>b) 如果收到的结果是成功，则进行业务自身的操作<br>   (5)业务操作完成，把业务操作的结果发送给消息中间件<br>   (6)消息中间件收到业务操作结果，根据结果进行处理<br>a) 如果业务失败，则删除消息存储中的消息，结束<br>b)如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递。<br>最终一致性方案的补偿流程:<br>(1)消息中间件询问状态为待处理的消息对应业务操作结果<br>(2)应用即消息发布者对业务操作检查操作结果<br>(3)发送业务处理结果给消息中间件<br>(4)消息中间件更新消息状态，业务成功，消息状态为待发送；业务失败则消息删除</p>
<h3 id="如何解决消息中间件与使用者的强依赖关系"><a href="#如何解决消息中间件与使用者的强依赖关系" class="headerlink" title="如何解决消息中间件与使用者的强依赖关系"></a>如何解决消息中间件与使用者的强依赖关系</h3><p>如果消息系统出现问题，就会导致业务操作无法继续操作。解决的思路如下：<br>1.提供消息中间件系统的可靠性，但是没办法办证百分百可靠；<br>2.对于消息中间件系统中影响业务的部分，其可靠性与业务系统一样；<br>3.提供弱依赖的功能；<br>对于思路一：我们无法保证百分百可靠；<br>对于思路二：把消息中间件所需要的消息表与业务数据表放到同一个业务数据库，业务操作和写入消息作为一个本地事务完成，然后再通知消息中间件有消息可以发送，解决一致性，也可以消息中间件定时去轮询业务数据库找到需要发送的消息，取出内容后进行发送。这个会有三个影响：<br>1.需要业务自己的数据库去承载消息数据；<br>2.需要消息中间件访问业务数据库；<br>3.需要业务操作的对象是数据库，或者说是支持事务的存储，必须这个存储能够支持消息中间件的需求。<br>所以我们有个折中的操作：消息中间件不再直接与业务数据库打交道，将业务操作、写入消息，轮询消息等全部放到业务应用。<br>加一个本地磁盘作为一个消息存储，如果消息中间件崩溃，我们可以把本地磁盘作为存储消息的地方。这有两种用法：1.作为一致性发送消息的解决方案的容灾手段，，平时不工作，出问题才切换。2.直接使用该方式；<br>最后我们看下业务操作与消息一致性带来的两个限制：<br>1.需要确定要发送的消息内容；2.需要实现对业务的检查</p>
<h3 id="消息模型对消息的接收的影响"><a href="#消息模型对消息的接收的影响" class="headerlink" title="消息模型对消息的接收的影响"></a>消息模型对消息的接收的影响</h3><p>在JMS中，有Queue（点对点）和Topic（发布/订阅）两种模型</p>
<h4 id="JMS-Queue模型"><a href="#JMS-Queue模型" class="headerlink" title="JMS Queue模型"></a>JMS Queue模型</h4><p>应用1和应用2发送消息到JMS服务器，这些消息根据到达的顺序形成一个队列，应用3和应用4进行消息的消费;如果Queue里面的消息被一个应用处理了，那么连接到JMS Queue上的另一个应用是收不到这个消息的。即连接到这个JMS Queue上的应用共同消费了所有的消息。消息从发送端发送出来时不能确定最终会被哪个应用消费，但是可以明确的是只有一个应用会去消费这条消息，Peer To Peer方式(PTP)</p>
<h4 id="JMS-Topic模型"><a href="#JMS-Topic模型" class="headerlink" title="JMS Topic模型"></a>JMS Topic模型</h4><p>和Queue模型的最大区别在于消息接收的部分，在该模型中，接收消息的应用3和应用4是可以独立收到所有到达Topic的消息的，Pub/Sub方式</p>
<h4 id="JMS中客户端连接的处理和带来的限制"><a href="#JMS中客户端连接的处理和带来的限制" class="headerlink" title="JMS中客户端连接的处理和带来的限制"></a>JMS中客户端连接的处理和带来的限制</h4><p>在使用JMS时，每个Connection都有一个ClientId，用于标记的唯一性。如果两个应用共建立三个连接，每个连接都会收到所有发送到topic的消息。</p>
<h4 id="我们需要什么样的消息模型"><a href="#我们需要什么样的消息模型" class="headerlink" title="我们需要什么样的消息模型"></a>我们需要什么样的消息模型</h4><p>我们要满足的需求为：<br>消息发送方和接收方都是集群；<br>同一个消息的接收方可能有多个集群进行消息的处理；<br>不同集群对于同一条消息的消息不能互相干扰；<br>现在我们需要每个集群使用topic模式，然后集群的内部使用queue模式；我们可以引入clusterId，用这个id标识不同的集群；集群内各个应用连接使用这个clusterid。当服务器端进行调度时，在不同的集群之间独立投递，而拥有相同的clusterId的共同消费这个消息。<br>还有一种思路是将JMS的topic和queue级联使用，首先最顶层是JMS topic，中间有一层消息中转层，再通过JMS queue，最下层是集群内消费使用。<br>缺点是级联方式过于繁重，处理复杂，好处是使用jms实现。</p>
<h3 id="消息订阅者订阅消息的方式"><a href="#消息订阅者订阅消息的方式" class="headerlink" title="消息订阅者订阅消息的方式"></a>消息订阅者订阅消息的方式</h3><p>分为持久订阅和非持久订阅<br>非持久化订阅指的是消息接收者和消息中间件之间的消息订阅关系的存续，与消息接收者自身运行的状态有直接的关系。<br>持久化订阅指的是消息订阅关系一旦建立，除非应用显式地取消订阅关系，否则订阅关系将一直存在，如果消息接收者应用停止，那么消息会保留，等待下次应用启用后投递给消息接收者。</p>
<h3 id="保证消息可靠性的做法"><a href="#保证消息可靠性的做法" class="headerlink" title="保证消息可靠性的做法"></a>保证消息可靠性的做法</h3><p>持久订阅能够保证消息的可靠性，消息从发送端到接收端，中间需要经历三个阶段可靠：<br>1.消息发送者把消息发送给消息中间件；<br>2.消息中间件把消息存入消息存储；<br>3.消息中间件把消息投递给消息接收端；</p>
<h4 id="消息发送端的可靠"><a href="#消息发送端的可靠" class="headerlink" title="消息发送端的可靠"></a>消息发送端的可靠</h4><p>发送者需要把消息的发送结果准确的传给应用，应用才能进行相关的业务操作。消息从发送者发送到消息中间件，只有消息中间件及时明确地返回成功，才能确认消息可靠地到达消息中间件。返回错误、异常或者超时，都可以认为这个动作失败。</p>
<h4 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h4><p>1.实现基于文件的消息存储<br>主要把消息直接存储在本地磁盘，不需要对额外独立存储。ActiveMQ（kaha db），KahaDB是基于文件的本地数据库储存形式<br>2.使用数据库作为消息存储<br>3.基于双机内存的消息存储<br>磁盘IO的关系，性能会受到影响，内存的速度远超磁盘，但断电会失去数据，正常情况下，消息持久存储不工作，一旦一个机器故障，会停止另一台的写，并把数据写入数据持久存储。</p>
<h4 id="消息系统的扩容"><a href="#消息系统的扩容" class="headerlink" title="消息系统的扩容"></a>消息系统的扩容</h4><p>1.消息中间件自身如何扩容<br>消息中间件本身没有持久态，扩容比较容易，只需要让消息发送者和消息订阅者能够感知到有新的消息中间件机器加入了集群。同一个存储区分存储的消息来自哪个消息中间件应用：增加一个server字段。<br>2.消息存储的扩容处理<br>优势：1.不用保证消息的顺序；2.提供从服务端对消息投递的方式，不支持主动获取消息。<br>首先，消息发送到消息中间件，消息中间件将消息入库，所以消息中间件一定知道消息存在哪。<br>其次，由于内存中进行调度的消息数量有限，因此我们会调度存在数据库的消息，这个调度必然会跨所有库和所有表，需要投递的消息会把相关索引消息加载到内存中，内存调度消息也自然有了存储节点的消息。</p>
<h4 id="消息投递的可靠性保证"><a href="#消息投递的可靠性保证" class="headerlink" title="消息投递的可靠性保证"></a>消息投递的可靠性保证</h4><p>1.消息投递简介<br>消息中间件需要显示地收到接收者确认消息处理完毕，才能删除消息。<br>2.投递处理的优化<br>投递处理第一个可优化的是在进行投递时一定要采用多线程方式处理，每个线程处理一条消息时，会得到需要接收该消息的订阅者集群Id列表，然后从每个订阅者集群Id里选择一个连接来处理，消息投递后会更新消息状态，然后统一更新消息表中的消息状态。如果订阅者集群有一个很慢的订阅者，负责投递的所有线程会慢慢堵死，都需要等待这个慢的订阅者返回。<br>我们还可以采用，采用异步的方式，把消息返回处理的工作放到另外的线程池中操作，保证投递的环节不会被堵死，返回的结果可以放在内存中，等待其他线程进行处理。<br>其次我们还要优化，即一个应用有多个订阅者订阅同样的消息，如果不加以优化，会发送多次同样的消息，我们的优化是：单机共享连接；消息只发送一次，然后传到单机多订阅者生成多个处理实例。</p>
<h3 id="订阅者视角的消息重复的产生和应对"><a href="#订阅者视角的消息重复的产生和应对" class="headerlink" title="订阅者视角的消息重复的产生和应对"></a>订阅者视角的消息重复的产生和应对</h3><h4 id="消息重复产生的原因"><a href="#消息重复产生的原因" class="headerlink" title="消息重复产生的原因"></a>消息重复产生的原因</h4><p>第一类原因是消息发送方重复发送消息<br>1.消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，这是消息中间件出现了问题，导致应用端没有收到消息发送成功的返回，因而进行了重复的发送。<br>2.消息中间件由于负载比较高变得比较慢，成功把消息存储到消息存储后，返回成功结果超时。<br>3.消息中间件收到消息存储后，但由于网络原因，导致应用端收不到消息，进行重试。<br>解决的办法有通过消息id来标识<br>第二类原因是消息中间件对外投递时发生了重复<br>1.消息中间件投递由于网络原因，消息中间件没能收到反馈消息；<br>2.消息接收者处理时间比较长，超时<br>3.消息中间件出现问题，没收到结果消息<br>4.消息存储出现故障，没能更新状态<br>可以采用分布式事务来解决，但是不过这种方式比较复杂，成本也比较高；另一种方式是要求消息消费者来处理这种重复的方式，也就是要求这是幂等操作。</p>
<h4 id="JMS消息确认与消息重复的关系"><a href="#JMS消息确认与消息重复的关系" class="headerlink" title="JMS消息确认与消息重复的关系"></a>JMS消息确认与消息重复的关系</h4><p>AUTO_ACKNOWLEDGE<br>自动确认，当JMS消息接收者接收到消息，JMS的客户端会自动进行确认。但是确认时消息还没来得及处理或者还未处理完成，所以这种确认方式也是不可靠<br>CLIENT-ACKNOWLEDGE<br>客户自己确认的方式，也就是客户端如果要确认消息处理成功，告诉服务器端确认消息，需要主动调用Message接口的acknowledge方法进行消息接收成功的调用；<br>DUPS_OK_ACKNOWLEDGE<br>这种方式是消息接收方的消息处理函数执行结束后确认，一方面保证消息一定是处理结束后才确认，另一方面也不需要客户端调用acknowledge接口<br>消息接收者接收的消息会出现下面两张情况：<br>1.at lease once<br>采用CLIENT-ACKNOWLEDGE或者DUPS_OK_ACKNOWLEDGE并且在消息处理前没有确认的话，就可能产生这种现象。<br>2.at most once<br>采用AUTO_ACKNOWLEDGE或者CLIENT-ACKNOWLEDGE并且在接收消息后立刻确认的情况</p>
<h3 id="消息投递的其他属性支持"><a href="#消息投递的其他属性支持" class="headerlink" title="消息投递的其他属性支持"></a>消息投递的其他属性支持</h3><p>1.消息优先级<br>一般情况下消息先到先投递，消息的优先级属性可以根据优先级确定投递顺序。<br>2.订阅者消息处理顺序和分级订阅<br>消息的多个订阅者之间是独立的，它们对消息的处理并不会相互造成影响。但对于一些场景，对于同样的消息，可能会希望有些订阅者处理结束后再让其他订阅者处理。另一种方案是分级订阅。<br>把优先接收者和一般接收者分开，优先接收者处理成功后主动把消息投递到另外的消息中间件，然后一般接收者接收新产生的消息。<br>3，自定义属性<br>消息自身的创建时间、类型、投递次数等属性属于基础属性，在消息体外，自定义属性会很方便，这种自定义属性类似http的header<br>4.局部顺序<br>局部顺序是指在众多消息中，和某件事情有关的多条消息之间有顺序，而多件事情之间的消息没有顺序。比如我们可以不必保持多个人之间的交易顺序，但是对同一个交易产生的变化需要保持其顺序。<br>比如线上的交易的消息状态依次生死：创建、付款、发货、确认（Kafka发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton和key是可选的。如果你指定了partition，那就是所有消息发往同1个partition，就是有序的。并且在消费端，Kafka保证，1个partition只能被1个consumer消费。）</p>
<h3 id="保证顺序的消息队列的设计"><a href="#保证顺序的消息队列的设计" class="headerlink" title="保证顺序的消息队列的设计"></a>保证顺序的消息队列的设计</h3><p>同一消息订阅者处理不同消息，成功与否跟消息的内容有关（比如手机充值，我们可以看到充值成功与否跟手机号码合法化有关），现在讨论依赖消息订阅者的状态有关（数据复制，只要源数据库可用，则复制一定成功）。<br>在这样场景下，一个吞吐量达且支持顺序的消息中间件是很有价值的，数据变更平台就是这样的一个场景。在这里，由原来的push模式变为pull模式，为了让消息接收者更好的控制消息的接收和处理，消息中间件逻辑也得到了简化。具体实现是消息存储写到文件中，采用顺序写入，消息必须按顺序消费，所以一个消息接收者在每一个他所接收的消息队列上有一个当前消费的位置，之前的位置代表已经消费的消息，不同消费者维护分别维护自己的指针，可以通过指针的回溯来进行消息的补发。接收端拥有比较大的自主权。</p>
<h4 id="单机多序列问题和优化"><a href="#单机多序列问题和优化" class="headerlink" title="单机多序列问题和优化"></a>单机多序列问题和优化</h4><p>单机多队列的隔离完成了对消息的有序支持。如果单的队列数量数量多，性能会下降很大，原因是队列数量大时，写就接近随机写。改进措施有按顺序写入，然后根据队列做个索引。<br>带来的好处是：<br>1.队列轻量化，单个队列数据量少<br>2.对磁盘访问串行化，避免竞争<br>缺点是：<br>1.写虽然是顺序写，但是读是随机读<br>2.读先读逻辑队列在读物理队列，增加开销<br>3.需要保证物理队列与逻辑队列的完全一致。编程复杂</p>
<h4 id="解决本地消息存储的可靠性"><a href="#解决本地消息存储的可靠性" class="headerlink" title="解决本地消息存储的可靠性"></a>解决本地消息存储的可靠性</h4><p>采用消息同步复制的方式解决可靠性的问题<br>把单个消息中间件变为主（master）备（slave）两个节点，slave订阅master所有消息，用来消息备份。不过需要注意这是一个异步操作，slave订阅收到的消息会比master略少一点，存在着丢失信息的可能，类似mysql的replication<br>同样是把单个节点扩展到Master/Slave节点，但是采用的是同步复制，而不是订阅。对于消息更为严格的场景，第二种更为安全可靠</p>
<h4 id="如何支持队列的扩容"><a href="#如何支持队列的扩容" class="headerlink" title="如何支持队列的扩容"></a>如何支持队列的扩容</h4><p>基本的策略是消息发送者能够知道应该把消息写入迁移到新的队列中，并且也让消息订阅者知道，当前队列消费完消息后要去新的队列去消费消息<br>有几个关键点：<br>1.原队列在开始扩容会有个标记，即便有新的消息进来，也不再接收<br>2.通知消息发送端发送新的队列位置<br>3.对于消息接收端，对原来队列的定位会收到新旧两个位置，当旧数据的数据接收完毕后，则只会关心新队列的位置</p>
<h3 id="push和pull方式对比"><a href="#push和pull方式对比" class="headerlink" title="push和pull方式对比"></a>push和pull方式对比</h3><p>1.从数据传输状态；push保存在服务器端，pull保存在消费端<br>2.从传输失败，重试；push要维护每次传输状态，pull不需要<br>3.数据传输的实时性；push非常实时，pull默认的短轮询方式的实时依赖性依赖于pull间隔时间，间隔越大，实时性越低，长轮询的方式实时性与pull一致。<br>4.从流控机制；push方式服务器需要根据订阅者的消费能力做流控，pull方式消费端可以根据自身消费能力决定是否去pull消息</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
