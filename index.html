<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/feign和zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/feign和zuul/" itemprop="url">feign和zuul</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T22:06:30+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>我们在使用Ribbon时，通常会利用它来对RestTemplate的请求拦截来实现对依赖服务的接口调用。RestTemplate已经实现了对http请求的封装处理，形成一套模板化的调用方法。在实际开发中，对服务依赖的调用可能不止一处，往往一个接口会被多处调用，我们需要封装一些客户端类来包装这些依赖服务的调用。在Feign实现下，我们只需要创建一个接口并用注解配置它，即可完成对服务提供方的接口绑定。</p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">      //pom文件</div><div class="line">      &lt;!--feign--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">@EnableFeignClients</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">@FeignClient(<span class="string">"hello-service"</span>)</div><div class="line">public interface HelloService&#123;</div><div class="line">  @RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">  String hello();</div><div class="line">&#125;</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	HelloService helloService;</div><div class="line"></div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">     <span class="built_in">return</span> helloService.hello();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>[<a href="http://blog.didispace.com/spring-cloud-tips-feign-rpc/" target="_blank" rel="external">http://blog.didispace.com/spring-cloud-tips-feign-rpc/</a>]</p>
<h2 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>ribbon.key=value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ribbon.ConnectTimeout=500</div><div class="line">ribbon.readTimeout=5000</div></pre></td></tr></table></figure></p>
<h3 id="指定服务配置"><a href="#指定服务配置" class="headerlink" title="指定服务配置"></a>指定服务配置</h3><p><client>.ribbon.key=value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello-service.ribbon.ConnectTimeout=500</div><div class="line">hello-service.ribbon.readTimeout=5000</div></pre></td></tr></table></figure></client></p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><h3 id="全局配置-1"><a href="#全局配置-1" class="headerlink" title="全局配置"></a>全局配置</h3><p>跟ribbon全局配置一样，使用hystrix.command.default.xxx</p>
<h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3><p>通过feign.hystrix.enabled=false关闭</p>
<h2 id="服务降级配置"><a href="#服务降级配置" class="headerlink" title="服务降级配置"></a>服务降级配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@FeignClient(<span class="string">"hello-service"</span>,fallback=HelloServiceFallback.class)</div><div class="line">public interface HelloService&#123;</div><div class="line">  @RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">  String hello();</div><div class="line">&#125;</div><div class="line">@Component</div><div class="line">public HelloServiceFallback implements HelloService&#123;</div><div class="line">String <span class="function"><span class="title">hello</span></span>()&#123;</div><div class="line">retur <span class="string">"error"</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>大多数情况下，为了保证对外服务的安全性，我们在服务端实现的微服务接口，往往都会有一定的权限验证机制，比如用户登录状态的校验。同时为了防止客户端在发起请求时防止篡改等安全方面的考虑，还会有一些签名验证的机制存在。由于微服务，我们将一个应用拆成多个应用，但这些应用都需要这些校验逻辑，随着微服务规模扩大，校验逻辑冗余越来越多，不便于扩展和优化。<br>API网关是一个更为智能的应用服务器，它的定义有点像设计模式的Facade模式，它的存在就像整个微服务架构系统的门面一样，所有外部客户端访问都需要经过它来进行调度和过滤。它除了要实现请求路由、负载均衡、验证校验等功能，还需要跟服务治理框架、熔断机制的结合。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div><div class="line"></div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">spring.application.name=api-gateway</div><div class="line">server.port=5555</div><div class="line"></div><div class="line">zuul.routes.a.path=/a/**</div><div class="line">zuul.routes.a.url=ribbon-consumer</div><div class="line"></div><div class="line">zuul.routes.b.path=/b/**</div><div class="line">zuul.routes.b.url=feign-consumer</div><div class="line"></div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</div></pre></td></tr></table></figure>
<h2 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class AccessFilter extends ZuulFilter &#123;</div><div class="line"></div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(AccessFilter.class);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String <span class="function"><span class="title">filterType</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="string">"pre"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">filterOrder</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="function"><span class="title">shouldFilter</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        logger.info(<span class="string">"AccessFilter run"</span>);</div><div class="line"></div><div class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">        HttpServletRequest httpServletRequest = requestContext.getRequest();</div><div class="line"></div><div class="line">        logger.info(httpServletRequest.getRequestURI());</div><div class="line"></div><div class="line">        Object accessToken = httpServletRequest.getParameter(<span class="string">"accessToken"</span>);</div><div class="line">        <span class="keyword">if</span>(accessToken == null) &#123;</div><div class="line">            requestContext.setSendZuulResponse(<span class="literal">false</span>);</div><div class="line">            requestContext.setResponseStatusCode(401);</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        logger.info(<span class="string">"access token ok"</span>);</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public AccessFilter <span class="function"><span class="title">accessFilter</span></span>()&#123;</div><div class="line">       <span class="built_in">return</span> new AccessFilter();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>filterType：过滤器的类型，pre代表请求在被路由之前执行<br>filterOrder：过滤器的执行顺序，根据这个返回值来依次执行<br>shouldFilter：判断是否需要被过滤<br>run：过滤的具体逻辑，这里通过requestContext.setSendZuulResponse(false);来过滤请求，不对骑进行路由，通过requestContext.setResponseStatusCode(401);设置返回状态码，也可以通过requestContext.setResponseBody(body);来设置内容</p>
<h2 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h2><h3 id="传统路由配置"><a href="#传统路由配置" class="headerlink" title="传统路由配置"></a>传统路由配置</h3><ul>
<li>单实例配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.url=http://localhost:8080/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对符合/user-service/** 规则的请求路径，转发到<a href="http://localhost:8080/地址的路由规则上，比如，当有一个请求http://localhost:5555/user-service/hello,能够匹配，因而api网关会转发请求到http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/地址的路由规则上，比如，当有一个请求http://localhost:5555/user-service/hello,能够匹配，因而api网关会转发请求到http://localhost:8080/hello</a></p>
<ul>
<li>多实例配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div><div class="line">ribbon.eureka.enabled=<span class="literal">false</span></div><div class="line">user-service.ribbon.listOfServers=http://localhost:8080,http://localhost:8081</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h3><p>在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为serviceId指定具体的服务实例地址，只需要通过zuul.routes.<route>.path与zuul.routes.<route>.serviceId参数对进行配置就好。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div></pre></td></tr></table></figure></route></route></p>
<h2 id="服务路由的默认规则"><a href="#服务路由的默认规则" class="headerlink" title="服务路由的默认规则"></a>服务路由的默认规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div></pre></td></tr></table></figure>
<p>对于这样具备规则性的配置内容，我们总是希望可以自动完成，在zuul构建的网关引入Eureka后，它会为每个服务自动创建一个默认路由规则，这些默认路由会使用serviceId配置的服务名作为请求前缀。<br>由于默认情况下，所有Eureka上的服务都会被Zuul自动创建映射关系进行路由，这会使得我们不希望对外开放的服务也可能被外部访问。这个时候，我们需要使用zuul.ignored-services参数来设置一个匹配表达式来定义不自动创建路由的规则。如果服务名匹配，将不为创建路由规则。</p>
<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>?是匹配任意单个字符，<em> 匹配任意数量字符，*</em> 匹配任意数量字符，支持多级目录。</p>
<h2 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h2><p>全局为路由规则增加前缀信息，提供zuul.prefix参数进行设置。</p>
<h2 id="本地跳转"><a href="#本地跳转" class="headerlink" title="本地跳转"></a>本地跳转</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.api-b.path=/api-b/**</div><div class="line">zuul.routes.api-b.url=forward:/<span class="built_in">local</span></div></pre></td></tr></table></figure>
<h2 id="Cookie与头信息"><a href="#Cookie与头信息" class="headerlink" title="Cookie与头信息"></a>Cookie与头信息</h2><p>zuul在请求路由时，或过滤掉http请求头信息的一些敏感信息。默认的敏感头信息通过zuul.sensitiveHeaders参数定义，包括set-cookie、cookie、Authorization三个属性。</p>
<ul>
<li><p>通过全局设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zuul.sensitiveHeaders=</div></pre></td></tr></table></figure>
</li>
<li><p>通过制定路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zuul.routes.&lt;router&gt;.customSensitiveHeaders=<span class="literal">true</span></div><div class="line">或</div><div class="line">zuul.routes.&lt;router&gt;.sensitiveHeaders=</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重定向问题，避免跳转暴露内部调用细节<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zuul.addHostHeader=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器详解"><a href="#过滤器详解" class="headerlink" title="过滤器详解"></a>过滤器详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public String filterType();</div><div class="line">public int filterOrder();</div><div class="line">public boolean shouldFilter();</div><div class="line">public Object run();</div></pre></td></tr></table></figure>
<p>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<br>pre：路由之前<br>routing：路由之时<br>post： 路由之后<br>error：发送错误调用<br>filterOrder：过滤的顺序，数值越小优先级越高<br>shouldFilter：这里可以写逻辑判断，是否要过滤，true,永远过滤。<br>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</p>
<h3 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h3><p>第一阶段是pre，会被pre过滤器进行处理，该过滤器主要是在请求路由之前做一些前置工作，比如请求校验。<br>第二阶段是routing，路由请求转发阶段，请求会被routing过滤器处理，当服务实例请求结果都返回之后，routing阶段结束。<br>第三阶段是post，此时请求会被post类型的过滤器处理，我们可以对处理结果进行加工或者转换。<br>还有个特殊的阶段error阶段，前面三个阶段发生异常时才会触发。</p>
<h2 id="核心过滤器"><a href="#核心过滤器" class="headerlink" title="核心过滤器"></a>核心过滤器</h2><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// pom</div><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div><div class="line"></div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">    @RefreshScope</div><div class="line">    @ConfigurationProperties(<span class="string">"zuul"</span>)</div><div class="line">    public ZuulProperties <span class="function"><span class="title">zuulProperties</span></span>()&#123;</div><div class="line">      <span class="built_in">return</span> new ZuulProperties();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">spring.application.name=api-gateway</div><div class="line">server.port=5555</div><div class="line">spring.cloud.config.uri=http://localhost:7001/</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</div></pre></td></tr></table></figure>
<p>在git仓库上增加网关配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">zuul.routes.a.path=/a/**</div><div class="line">zuul.routes.a.url=ribbon-consumer</div><div class="line"></div><div class="line">zuul.routes.b.path=/b/**</div><div class="line">zuul.routes.b.url=feign-consumer</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/服务容错保护-Hystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/服务容错保护-Hystrix/" itemprop="url">服务容错保护-Hystrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T11:11:14+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud-微服务实战/" itemprop="url" rel="index">
                    <span itemprop="name">spring cloud 微服务实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在微服务架构中，存在很多单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪。为了解决这个问题，产生了断路器等一系列的服务保护机制。<br>Hystrix实现了断路器、线程隔离等一系列服务保护功能。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并和请求监控<br>[<a href="http://blog.csdn.net/forezp/article/details/69934399" target="_blank" rel="external">http://blog.csdn.net/forezp/article/details/69934399</a>]</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//pom 文件</div><div class="line">      &lt;!--hystrix--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      &lt;!--hystrix-dashboard 监控--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">//开启断路器</div><div class="line">@EnableCircuitBreaker</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	RestTemplate <span class="function"><span class="title">restTemplate</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//改造服务器消费规则，Hystrix默认的超时时间是2000毫秒</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	RestTemplate restTemplate;</div><div class="line"></div><div class="line">	@HystrixCommand(fallbackMethod=<span class="string">"helloFallback"</span>)</div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		String serviceString=<span class="string">"http://PROVIDER-SERVICE/hello"</span>;</div><div class="line">		<span class="built_in">return</span> restTemplate.getForEntity(serviceString,String.class).getBody();</div><div class="line">	&#125;</div><div class="line">  public String <span class="function"><span class="title">helloFallback</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"error"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/22/服务容错保护-Hystrix/hystrix1.png" alt=""></p>
<ol>
<li>创建HystrixCommand或HystrixObservableCommand对象<br>使用命令模式，HystrixCommand用在依赖的服务返回单个操作结果的时候，HystrixObservableCommand用在依赖的服务返回多个操作结果的时候。</li>
<li>命令执行<br>以上存在四种命令的执行方式，HystrixCommand实现两个执行方式，<br>execute:同步执行，从依赖的服务返回一个单一的结果对象或是在发生错误的时候抛出异常。<br>queue：异步执行，直接返回一个Future对象。其中包含一个服务执行结束时要返回的单一结果对象<br>HystrixObservableCommand<br>observer：是一个hot Observable<br>toObservable：cold Observable</li>
<li>结果是否被缓存<br>若当前命令的请求缓存功能被启用，并且该命令缓存命中，那么缓存结果立即以Observable对象的形式返回。</li>
<li>断路器是否打开<br>在命令结果没有缓存命中时，Hystrix需要检测断路器是否打开，如果打开调到第8步，如果没有打开，跳到第5步。</li>
<li>线程池或请求队列或信号量是否占满<br>如果已被占满，则不会执行命令，转向fallback。</li>
<li>HystrixObservable.construct()或HystrixObservable.run()<br>run返回单一结果，construct返回多个结果，如果执行时间超过命令设置的超时阈值，会抛出一个异常，Hystrix就会转向fallback处理逻辑。</li>
<li>计算断路器的健康度<br>Hystrix会将成功、失败、拒绝、超时等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会根据这些数据来决定是否要将断路器打开，来对某个依赖服务进行熔断/短路，直到恢复期结束。</li>
<li>fallback处理<br>当命令执行失败后，Hystrix会进入fallback尝试回退处理，我们也称为服务降级。<br>以下四种情况将触发getFallback调用：<br>(1):run()方法抛出非HystrixBadRequestException异常。<br>(2):run()方法调用超时<br>(3):熔断器开启拦截调用<br>(4):线程池/队列/信号量是否饱满</li>
<li>返回成功的响应</li>
</ol>
<h1 id="断路器原理"><a href="#断路器原理" class="headerlink" title="断路器原理"></a>断路器原理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface HystrixCircuitBreaker &#123;</div><div class="line">      //判断命令的请求是否被执行</div><div class="line">      boolean allowRequest();</div><div class="line">      //判断当前断路器是否被打开</div><div class="line">      boolean isOpen();</div><div class="line">      //用来闭合断路器</div><div class="line">      void markSuccess();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>断路器打开逻辑主要看请求总数、错误百分比，如果QPS大于20或者错误百分比大于50，则打开</p>
<h1 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h1><p>使用舱壁模式实现线程池的隔离，它会为每个依赖服务创建一个独立的线程池，这样就算某个服务延迟过高，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</p>
<h1 id="自定义请求命令"><a href="#自定义请求命令" class="headerlink" title="自定义请求命令"></a>自定义请求命令</h1><p>[<a href="http://blog.csdn.net/u012702547/article/details/78032191?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/u012702547/article/details/78032191?utm_source=tuicool&amp;utm_medium=referral</a>]</p>
<h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><h2 id="开启缓存功能"><a href="#开启缓存功能" class="headerlink" title="开启缓存功能"></a>开启缓存功能</h2><p>Spring Cloud Hystrix 请求缓存的使用非常简单，我们只需要在实现 HystrixCommand 或 HystrixObservableCommand 时，通过重载 getCacheKey()方法来开启请求缓存。</p>
<h2 id="缓存失效功能"><a href="#缓存失效功能" class="headerlink" title="缓存失效功能"></a>缓存失效功能</h2><p>在请求缓存时，如果只是读操作，那么不需要考虑缓存内容是否正确的问题，但是如果请求命令中还有更新数据的写操作，那么缓存中的数据就需要我们在进行写操作时及时处理，以防止读操作的请求命令获取到失效的数据，我们可以使用 HystrixRequestCache.clear 方法来进行缓存清理。<br>可以通过注解开启cache和清除缓存，例如@CacheResult,@CacheRemove</p>
<h1 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h1><p>通过HystrixCollasper来实现请求的合并，以减少通信消耗和线程数的占用。<br>[<a href="http://blog.csdn.net/zhuchuangang/article/details/74663755" target="_blank" rel="external">http://blog.csdn.net/zhuchuangang/article/details/74663755</a>]</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/21/客户端负载均衡-ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/客户端负载均衡-ribbon/" itemprop="url">客户端负载均衡:ribbon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T18:07:05+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud-微服务实战/" itemprop="url" rel="index">
                    <span itemprop="name">spring cloud 微服务实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>例子参考：[<a href="http://blog.csdn.net/forezp/article/details/69934399" target="_blank" rel="external">http://blog.csdn.net/forezp/article/details/69934399</a>]</p>
<h1 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h1><p>负载均衡指的是服务端负载均衡，其中分为硬件负载均衡、软件负载均衡。硬件负载均衡是通过服务器节点之间安装专门用于负载均衡的设备，比如F5等；而软件负载均衡是通过在服务器上安装一些具有均衡负载的模块或软件来完成请求分发工作，比如Nginx。<br>硬件负载均衡设备或是软件负载均衡的软件模块都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求给负载均衡设备时，从维护可用的列表中取出一台服务器的地址，然后进行转发。<br>客户端负载均衡和服务端负载均衡最大不同是在于上面所提到的服务清单所存储的位置。在客户端负载均衡中，所有客户端节点都要维护着自己访问的服务端清单，而这些服务端清单来自于服务注册中心。<br>spring ribbon的封装，使得使用客户端负载均衡调用非常简单，只需两步：</p>
<ul>
<li>服务提供者只需要启动多个实例并注册在一个注册中心或多个相关联的注册中心。</li>
<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。<h1 id="RestTemplate详解"><a href="#RestTemplate详解" class="headerlink" title="RestTemplate详解"></a>RestTemplate详解</h1><h1 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h1>getForEntity函数<br>该方法返回ResponseEntity，该对象是Spring对Http请求响应的封装，其中主要存储了HTTP的几个重要元素，比如说HTTP请求码的枚举对象HttpStatus（404，405，500等错误码），它的父类事HttpEntity中还存储着HTTP请求的头信息对象HttpHeaders以及泛型类型的请求体对象。<br>getForEntity有三种重载的方法：具体例子[<a href="https://www.jianshu.com/p/470a30f493cf" target="_blank" rel="external">https://www.jianshu.com/p/470a30f493cf</a>]<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)</div><div class="line">getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</div><div class="line">getForEntity(URI url, Class&lt;T&gt; responseType)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>也可以通过getForObject</p>
<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>具体也通过postForEntity和postForObject，例子如上链接</p>
<h1 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">put(String url, Object request, Object... uriVariables)</div><div class="line">put(String url, Object request, Map&lt;String, ?&gt; uriVariables)</div><div class="line">put(URI url, Object request)</div></pre></td></tr></table></figure>
<h1 id="Delete请求"><a href="#Delete请求" class="headerlink" title="Delete请求"></a>Delete请求</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">delete(String url, Object... uriVariables)</div><div class="line">delete(String url, Map&lt;String, ?&gt; uriVariables)</div><div class="line">delete(URI url)</div></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>[<a href="http://blog.csdn.net/dyc87112/article/details/73739482" target="_blank" rel="external">http://blog.csdn.net/dyc87112/article/details/73739482</a>]</p>
<h1 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h1><p>当一个请求发送，通过拦截这个请求，随机或者算法到其中的一个服务上去处理<br>那么，这中间关键的一点就是：拦截<br>最精简的LB需求：</p>
<ul>
<li>设置添加和读取后端服务器的列表</li>
<li>能从中选择一个服务器去执行<br>代码实现思路就是：<br>读取后端服务，标记一个服务不可用，最主要是选择一个后端服务来提供服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//使用负载均衡加载服务</div><div class="line">public interface ILoadBalancer &#123;</div><div class="line">void addServers(List var1);向负载均衡器中维护的实例列表增加服务实例。</div><div class="line">Server chooseServer(Object var1);通过某种策略，从负载均衡器中挑选出一个具体的服务实例。</div><div class="line">void markServerDown(Server var1);用来通知和标识负载均衡器中某个具体实例已经停止服务，不然负载均衡器在下一次获取服务实例清单前都会认为服务实例均是正常服务的。</div><div class="line">List getServerList(boolean var1);//目的兼容2.1.3以前的。（之后本方法拆分下面两个）</div><div class="line">List getReachableServers();获取当前正常服务的实例列表。</div><div class="line">List getAllServers();获取所有已知的服务实例列表，包括正常服务和停止服务的实例。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h2><p>是ILoadBalancer的实现，定义了分组枚举类，分别为ALL、STATUS_UP、STATUS_NOT_UP<br><img src="/2018/01/21/客户端负载均衡-ribbon/AbstractLoadBalancer.png" alt=""></p>
<h2 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h2><h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p>服务实例清单在运行期的动态更新，还能过滤</p>
<h2 id="ZoneAwareLoadBalancer"><a href="#ZoneAwareLoadBalancer" class="headerlink" title="ZoneAwareLoadBalancer"></a>ZoneAwareLoadBalancer</h2><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><ul>
<li>RandomRule：随机选择一个server</li>
<li>RoundRobinRule：roundRobin方式轮询选择， 轮询index，选择index对应位置的server</li>
<li>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低</li>
<li>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</li>
<li>BestAvailable：选择一个最小的并发请求的server，逐个考察Server，如果Server被tripped了，则忽略</li>
<li>AvailabilityFilteringRule：过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值） | 使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</li>
<li>ZoneAvoidanceRule：复合判断server所在区域的性能和server的可用性选择server ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule</li>
</ul>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p><img src="/2018/01/21/客户端负载均衡-ribbon/自动化配置.png" alt=""></p>
<h1 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h1><p>由于Eureka实现的服务治理机制强调了CAP原理的AP，即可用性和可靠性，与zookeeper这类强调CP（一致性、可靠性）最大的区别是Eureka为了实现更高的服务可用性，牺牲了一定的一致性，在极端情况下，它宁愿接受故障实例，也不要丢掉健康实例，比如，当服务注册中心发生故障断开时，由于所有的服务实例无法维持续约心跳，在强调AP的服务治理中，将会把所有的服务实例剔除掉，而Eureka则会因为超过百分之85的实例丢失心跳而触发保护机制，注册中心将会保留此时的所有节点，以实现服务间依然可以进行相互调用的场景，即使其中有部分故障节点，但这样做仍然能够保障大多数服务能正常消费。<br>由于在可用性和一致性上的取舍，不论是由于触发了保护机制或是服务剔除的延迟，引起服务调用到失败的实例时候，我们希望还是能够增强对这类问题的容错。所以我们会在服务调用时候加入一些重试机制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spring.cloud.loadbalancer.retry.enabled=<span class="literal">true</span></div><div class="line">xxService.ribbon.ConnectTimeout //请求连接超时时间</div><div class="line">xxService.ribbon.ReadTimeout //请求处理超时时间</div><div class="line">xxxService.ribbon.maxAutoRetriesNextServer //切换实例重试次数</div><div class="line">xxxService.ribbon.maxAutoRetries //重试次数</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/17/服务治理Eureka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/17/服务治理Eureka/" itemprop="url">服务治理Eureka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-17T11:02:50+08:00">
                2018-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud-微服务实战/" itemprop="url" rel="index">
                    <span itemprop="name">spring cloud 微服务实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>通常会构建一个注册中心，每个服务单元向注册中心注册自己的服务，将主机与端口号、版本号、通信协议等一些信息按服务名分类组织服务清单。另外，服务注册中心还需要以心跳的方式监测清单中的服务是否可用，若不可用需要将服务清单剔除，达到排除故障的效果。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务间的调用不再指定具体实例地址来实现，而是通过服务名发起请求调用。</p>
<h1 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h1><p>Eureka用来实现服务注册和发现，既包含了服务端组件，也包含了客户端组件。Eureka服务端的服务治理机制提供了完备的Restful Api，所以也支持非java语言构建的微服务。<br>Eureka服务端，也称服务注册中心，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种故障场景。如果Eureka以集群模式部署，当集群分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障继续提供服务的发现和注册，当故障分片恢复时，集群中其他分片会把他们的状态再次同步回来。以AWS为例，每个可用区域运行一个Eureka服务端，通过他形成集群，不同区域的服务注册中心通过异步模式互相复制各自的状态<br>Eureka客户端主要处理服务的注册和发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka向注册中心注册自身提供的服务并周期性地发送心跳来更新他的服务租约。同时，它能从服务端查询当前的注册服务信息并把他缓存到本地并周期性的刷新服务状态。</p>
<h1 id="搭建服务注册中心"><a href="#搭建服务注册中心" class="headerlink" title="搭建服务注册中心"></a>搭建服务注册中心</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//pom 文件</div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.example&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;cloudserver&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;cloudserver&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div><div class="line">//application.properties配置</div><div class="line">server.port=11111</div><div class="line">eureka.instance.hostname=localhost</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div><div class="line">//java代码启动</div><div class="line">@EnableEurekaServer</div><div class="line">@SpringBootApplication</div><div class="line">public class CloudserverApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new SpringApplicationBuilder(CloudserverApplication.class).web(<span class="literal">true</span>).run(args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/eureka.png" alt=""></p>
<h1 id="注册服务提供者"><a href="#注册服务提供者" class="headerlink" title="注册服务提供者"></a>注册服务提供者</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">          &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line"></div><div class="line">	&lt;/dependencies&gt;</div><div class="line">&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8081</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka</div><div class="line">spring.application.name=provider-service</div><div class="line">//java代码</div><div class="line">@SpringBootApplication</div><div class="line">public class DemoApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(DemoApplication.class, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//新建个web包，提供服务</div><div class="line">@RestController</div><div class="line">@EnableEurekaClient</div><div class="line">public class HelloController &#123;</div><div class="line">	@Value(<span class="string">"<span class="variable">$&#123;server.port&#125;</span>"</span>)</div><div class="line">	String port;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hi"</span>)</div><div class="line">	public String home(@RequestParam String name) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"hi "</span> + name + <span class="string">",i am from port:"</span> + port;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/服务.png" alt=""></p>
<h1 id="高可用注册中心"><a href="#高可用注册中心" class="headerlink" title="高可用注册中心"></a>高可用注册中心</h1><p>在微服务架构中，我们需要充分考虑发生故障的情况，所以在生产环境中必须对各个组件进行高可用部署。Eureka的设计一开始就考虑了搞可用问题，在Eureka的设计中一开始就考虑了高可用问题，在Eureka的服务治理设计中，所有节点既是服务提供方，也是服务消费方，服务注册中心也不例外。例如我们需要让设置两个参数，让服务注册中心不注册自己。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>Eureka的高可用就是将自己作为服务向其他服务中心注册自己，这样形成一组互相注册的服务注册中心，达到高可用。现在构建一个双节点的服务注册集群<br>创建application-peer1-properties作为peer1的服务中心配置。并将serviceUrl指向peer2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11111</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer1</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer2:11112/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>创建application-peer2-properties作为peer2的服务中心配置。并将serviceUrl指向peer1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11112</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer2</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer1:11111/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>接着修改etc/hosts<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1	master-peer1</div><div class="line">127.0.0.1	master-peer2</div></pre></td></tr></table></figure></p>
<p>通过–spring.profiles.active=peer1、–spring.profiles.active=peer2分别启动peer1和peer2然后修改服务提供者客户端的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.port=8888</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=provider-service</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/17/服务治理Eureka/高可用2.png" alt=""><br><img src="/2018/01/17/服务治理Eureka/高可用.png" alt=""></p>
<h1 id="服务发现和消费"><a href="#服务发现和消费" class="headerlink" title="服务发现和消费"></a>服务发现和消费</h1><p>程序是注册在Eureka注册中心上，现在有服务注册中心和服务提供者，还需要服务消费者，它主要完成发现服务和以及消费服务的功能。服务发现的任务由Eureka的客户端完成，而服务消费由Ribbon完成。Ribbon是一个基于http和tcp的客户端均衡器，它可以在通过客户端配置的ribbonServerList服务器列表去轮询访问以达到负载均衡的作用。当Ribbon与Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成Eureka注册中心中获取服务列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8082</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=consumer-invoke</div><div class="line">//java启动类</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	RestTemplate <span class="function"><span class="title">restTemplate</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//访问服务</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	RestTemplate restTemplate;</div><div class="line"></div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		String serviceString=<span class="string">"http://PROVIDER-SERVICE/hello"</span>;</div><div class="line">		<span class="built_in">return</span> restTemplate.getForEntity(serviceString, String.class).getBody();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Eureka详解"><a href="#Eureka详解" class="headerlink" title="Eureka详解"></a>Eureka详解</h1><p>构建Eureka服务治理体系中的三个核心角色：服务注册中心、服务提供者、服务消费者。</p>
<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><ul>
<li>服务注册中心：Eureka提供的服务端，提供服务注册与发现的功能，也就是eureka-server</li>
<li>服务提供者：提供服务的应用，可以是springboot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现。</li>
<li>服务消费者：消费者需要从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。</li>
</ul>
<h1 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h1><p><img src="/2018/01/17/服务治理Eureka/eureka服务治理.png" alt=""></p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><h3 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务提供者在启动时候会通过发送REST请求的方式将自己注册到Eureka Server，同时带上了自身服务的一些元数据信息。Eureka server接收到这个REST请求后，将元数据信息存储在一个双层结构map中，第一层key是服务名，第二层key是具体服务的实例名，在ribbon负载均衡中，Eureka一个服务有多个实例，所以采用了双层map。<br>在服务注册时，需要确认一下eureka.client.register-with-eureka=true,是否正确，该值默认为true，若设置为false将不会注册。</p>
<h3 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h3><p>服务提供者分别注册到两个不同的服务注册中心上，他们的信息分别被两个服务注册中心所维护。由于服务注册中心之间相互注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群相连的其他注册中心。</p>
<h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><p>在注册完服务之后，服务提供者会维护一个心跳来持续告诉Eureka server：我还活着，以防止Eureka Server的剔除任务将该实例从服务列表中排除出去。我们称这个为服务续约。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//服务续约任务调用间隔时间</div><div class="line">eureka.instance.lease-renewal-interval-in-seconds=30</div><div class="line">//服务时效时间</div><div class="line">eureka.instance.lease-expiration-duration-in-seconds=90</div></pre></td></tr></table></figure></p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>当我们启动服务消费者，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。eureka server会维护一份只读的服务清单来返回客户端，同时该缓存清单会每隔30s更新一次。</p>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在ribbon会默认采用轮询的方式调用，从而实现客户端的负载均衡。<br>对于访问实例的选择，Eureka中有region和zone的概念，一个region中可以包含多个zone，每个服务客户端需要被注册一个Zone，所以每个客户端对应一个region和一个zone。</p>
<h3 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h3><p>在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。在客户端程序中，在服务实例进行正常的关闭操作，它会触发一个服务下线的REST请求给Eureka Server，告诉服务中心：我要下线了，服务端在接收请求之后，将该服务状态置为下线，并把该下线时间传播出去。</p>
<h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h3><p>服务器可能由于内存溢出、网络故障等原因使得服务不能正常工作。为了从服务列表中将这些无法提供服务的实例剔除，Eureka在启动时会创建一个定时任务，默认每隔一段时间（60s）将当前清单中超时（默认是90s）没有续约的服务剔除出去。</p>
<h3 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h3><p>自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况：<br>1、Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。<br>2、Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。<br>3、当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。<br>但在本地开发，会使得注册中心维护的服务实例不那么准确，下面关闭保护机制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.server.enable-self-preservation=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>[<a href="https://www.jianshu.com/p/ef2591899597" target="_blank" rel="external">https://www.jianshu.com/p/ef2591899597</a>]</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在Eureka的服务治理体系中，主要分为客户端和服务器端两个不同的角色，服务端为服务注册中心，客户端为各个提供接口的微服务应用。Eureka客户端的配置如下：1.服务注册相关的配置信息。包括服务注册中心的地址、服务获取的间隔时间、可用区域。2.服务实例相关的配置信息。包括服务实例的名称、IP地址、端口号、健康检查路径。</p>
<h1 id="服务注册类配置"><a href="#服务注册类配置" class="headerlink" title="服务注册类配置"></a>服务注册类配置</h1><p>这些配置信息主要以eureka.client为前缀，以指定注册中心为例，主要通过eureka.client.serviceUrl参数实现，默认的值为defaultZone，value为<a href="http://127.0.0.1:8761/eureka/。当然也可以更改" target="_blank" rel="external">http://127.0.0.1:8761/eureka/。当然也可以更改</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div></pre></td></tr></table></figure></p>
<p>也可以是高可用注册中心集群，不同的值用逗号隔开<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/,</div></pre></td></tr></table></figure></p>
<p>为了服务注册中心的安全，可以加入安全认证，在配置serviceUrl时，需要在value值的url加入相应的安全验证信息。比如http://<uusername>:<password>@localhost:1111/eureka</password></uusername></p>
<h1 id="服务实例类配置"><a href="#服务实例类配置" class="headerlink" title="服务实例类配置"></a>服务实例类配置</h1><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据是Eureka客户端在向服务注册中心发送请求时，用来描述自身服务信息的对象，其中包含一些标准化的元数据，比如服务名称、实例名称、实例ip、实例端口等用于服务服务治理的相关信息。以及一些负载均衡策略，或是其他特殊用途的自定义元数据的信息。<br>在使用Eureka的时候，所有的配置信息都通过org.springframework.cloud.Netflix.eureka.EurekaInstanceConfigBean进行加载，但在真正进行注册，还是会包装成instanceInfo发送给服务端，其中使用ConcurrentHashMap来存储。可以通过eureka.instance.<properties>=<value>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.instance.metadataMap.zone=shanghai</div></pre></td></tr></table></figure></value></properties></p>
<h2 id="实例名配置"><a href="#实例名配置" class="headerlink" title="实例名配置"></a>实例名配置</h2><p>实例名即InstanceInfo中的instanceId参数，它是区分同一服务不同实例的唯一标识。在Netflix原生实现中，采用主机名作为默认值，导致同一主机无法启动多个相同的服务实例。现在的cloud Eureka配置，采用的规则是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$&#123;spring.cloud.client.hostname&#125;</span>:<span class="variable">$&#123;spring.application.name&#125;</span>:<span class="variable">$&#123;spring.application.instance_id&#125;</span>:<span class="variable">$&#123;server.port&#125;</span></div><div class="line">eureka.instance.instanceId=<span class="variable">$&#123;spring.application.name&#125;</span>+<span class="variable">$&#123;random.int&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="端点的配置"><a href="#端点的配置" class="headerlink" title="端点的配置"></a>端点的配置</h2><p>在instanceInfo中，我们可以看到URL的配置信息，比如homePageURL、StatusPageUrl、HealthCheckUrl，分别代表着主页、状态检查、健康检查，其中状态和健康由actuator模块提供的info和health端点。</p>
<h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>各个服务实例的健康检测并不是通过health端点来实现，而是依靠客户端的心跳，来保持服务实例的存活。默认的心跳实现方式可以有效检查客户端进程是否正常运作，却无法保证客户端能正常提供服务。spring cloud 配置 health端点</p>
<ul>
<li>在pom包引入spring-boot-starter-actuator依赖</li>
<li>在application.properties加入eureka.client.healthcheck.enabled=true<h1 id="跨平台的支持"><a href="#跨平台的支持" class="headerlink" title="跨平台的支持"></a>跨平台的支持</h1>Eureka的通信机制是通过http的rest接口实现，由于http的平台无关性，虽然server可以通过java实现，但微服务应用并不限于使用java开发。比如python、js也能支持。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/springboot/" itemprop="url">springboot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T15:25:25+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p>springboot的宗旨并非是重写spring或是替代spring，而是希望通过设计大量的自动化配置等方式来简化spring原有样版化的配置，使得开发者可以快速构建应用。<br>除了解决配置问题外，springboot还可以通过一系列starter poms的定义，让我们整合各项功能时，不需要在maven的pom.xml维护那些错综复杂的依赖关系，而是通过类似模块化的starter模块定义来引用，使得依赖管理变得更为简单。<br>springboot除了可以很好的融入docker之外，其自身支持嵌入式的tomcat、jetty等容器。通过springboot构建的应用不需要安装tomcat，只需将springboot应用打成jar包，通过java-jar命令直接运行并启动一个标准化的web应用，这使得应用变得很轻量。<br>整个springboot生态系统都用到了groovy，完全可以通过gradle和groovy来开发springboot应用。</p>
<h1 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.software&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;demo&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;demo&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">    		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>打包的为jar包，parent配置指定spring-boot-starter-parent为1.5.9，该父项定义了springboot版本的基础依赖和一些默认配置内容，比如application.properties的位置等</p>
<ul>
<li>spring-boot-starter-web:全栈web开发模块，包含嵌入式tomcat、spring MVC</li>
<li>spring-boot-starter-test:通用测试模块，包含Junit、Hamcrest、Mockito</li>
<li>spring-boot-starterjdbc或者spring-boot-starter-data-jpa：访问数据库的能力</li>
</ul>
<p>在使用springboot构建应用时，各项功能模块的整合不再像传统spring应用开发一样，需要在pom文件里做大量依赖配置，而是通过starter POMs定义的依赖包，使得功能模块整合变得非常轻巧。</p>
<h1 id="实现Restful接口"><a href="#实现Restful接口" class="headerlink" title="实现Restful接口"></a>实现Restful接口</h1><p>在springboot中创建一个restful api的实现代码同spring mvc应用一样，只是不用做很多配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class HelloController &#123;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"say hello"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>springboot默认的配置文件位置是src/main/resources/application.properties,根据我们引入的不同starter模块，可以在这里定义容器端口号，数据库连接信息，日志级别等各种配置信息。比如添加server.port=8888，指定端口号是8888.springboot除了用传统的properties文件外，还支持现在广泛使用的yaml。<br>yaml配置格式不像properties配置那样以单纯的键值对形式来表示，而是以类似缩进形式表现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">environments:</div><div class="line">   dev:</div><div class="line">      url: http://dev.bar.com</div><div class="line">      name: Developer Setup</div><div class="line">   prod:</div><div class="line">      url: http://foo.bar.com</div><div class="line">      name: My cool app</div><div class="line">等价于properties</div><div class="line">environments.dev.url=http://dev.bar.com</div><div class="line">environments.dev.name=Developer Setup</div><div class="line">environments.prod.url=http://foo.bar.com</div><div class="line">environments.prod.name=My cool app</div></pre></td></tr></table></figure></p>
<h1 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h1><p>除了可以预定义各个starter模块预定义的配置属性，也可以在配置文件中定义一些我们需要定义的属性。比如在application.properties添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">book.name=java并发</div><div class="line">book.author=lr</div><div class="line">//通过@value加载自定义参数</div><div class="line">@Component</div><div class="line">public class Book&#123;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.name&#125;</span>"</span>)</div><div class="line">  private String name;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.author&#125;</span>"</span>)</div><div class="line">  private String author;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h1><p>我们希望有些参数被加载时不是一个固定的值，比如密钥，服务端口。可以使用${random}产生随机的int、long或者String字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//随机字符串</div><div class="line">blog.value=<span class="variable">$&#123;random.value1&#125;</span></div><div class="line">//随机int</div><div class="line">blog.number=<span class="variable">$&#123;random.int&#125;</span></div><div class="line">//随机long</div><div class="line">blog.bignumber=<span class="variable">$&#123;random.long&#125;</span></div><div class="line">//10以内的随机数</div><div class="line">blog.test1=<span class="variable">$&#123;random.int(10)&#125;</span></div><div class="line">//10~20的随机数</div><div class="line">blog.test2=<span class="variable">$&#123;random.int[10,20]&#125;</span></div></pre></td></tr></table></figure></p>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>可以在命令行指定应用的参数，比如设置应用端口java -jar xxx.jar –server.port=8888</p>
<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>通常同一套程序会被应用和安装在不同环境中，比如开发、测试、生产，其中每个环境的数据库地址、服务端口等配置都不同，如果在不同环境打包时都要频繁修改配置文件，那必然十分繁琐。<br>在springboot中，多环境配置的文件名需要满足application-{profile}.properties的格式，其中profile是你的环境标识，例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">application-dev.properties 开发环境</div><div class="line">application-test.properties 测试环境</div><div class="line">application-prod.properties 生产环境</div><div class="line">在application设置spring-profiles-active=dev，默认选择开发</div><div class="line">执行时 java -jar xx.jar --spring-profiles-active=<span class="built_in">test</span> 修改</div></pre></td></tr></table></figure></p>
<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p><img src="/2018/01/16/springboot/加载顺序.png" alt=""></p>
<h1 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h1><p>spring-boot-starter-actuator模块能够为springboot提供监控，spring cloud在实现各个微服务组件时，进一步为该模块做了不少扩展，比如为原生端增加了不少指标和度量信息。</p>
<h1 id="初识actuator"><a href="#初识actuator" class="headerlink" title="初识actuator"></a>初识actuator</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">/health</div><div class="line">&#123;<span class="string">"status"</span>:<span class="string">"UP"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="原生端"><a href="#原生端" class="headerlink" title="原生端"></a>原生端</h1><ul>
<li>应用配置类：获取应用程序的应用配置、环境变量、自动化配置报告</li>
<li>度量指标类：获取运行过程监控的度量指标，比如内存信息、线程池信息、http请求统计。</li>
<li>操作控制类：提供对应用关闭等操作类功能</li>
</ul>
<h2 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h2><ul>
<li>/autoconfig 获取应用自动化配置报告</li>
<li>/beans 获取应用上下文创建的所有bean</li>
<li>/configprops 获取配置的属性信息</li>
<li>/env 环境属性报告，包括环境变量、jvm命令行、应用配置</li>
<li>/mappings 所有spring mvc控制器映射关系</li>
<li>/info 自定义信息</li>
</ul>
<h2 id="指标度量类"><a href="#指标度量类" class="headerlink" title="指标度量类"></a>指标度量类</h2><ul>
<li>metrics 内存信息、线程、垃圾回收</li>
<li>health 各类健康指标</li>
<li>dump 暴露运行中的线程信息</li>
<li>trace 返回基本http跟踪信息</li>
</ul>
<h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/shutdown</div><div class="line">endpoints.shutdown.enabled=<span class="literal">true</span> //修改配置文件</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/线程池和Executor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/线程池和Executor/" itemprop="url">线程池和Executor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T09:53:55+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h1><p>线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:</p>
<ul>
<li>降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>1）线程池判断核心线程池是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已满。如果工作队列没有满，则新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<br><img src="/2018/01/10/线程池和Executor/线程池流程.png" alt=""></p>
<p><img src="/2018/01/10/线程池和Executor/线程池执行.png" alt=""><br>ThreadPoolExecutor执行execute分下面四种情况：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则新建新的线程来执行任务，执行这一步需要全局锁。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务。执行这一步骤需要获取全局锁</li>
<li>如果创建新的线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>采用上述步骤的总体思路是，是为了在执行execute方法时，尽量避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前的运行线程数大于等于corePoolSize），几乎所有的execute方法都是执行步骤2，而步骤2不需要获取全局锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable <span class="built_in">command</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">command</span> == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    // 如果线程数小于基本线程数，则创建线程并执行当前任务</div><div class="line">    <span class="keyword">if</span>(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(<span class="built_in">command</span>)) &#123;</div><div class="line">        // 如线程数大于等于核心线程数或线程创建失败，则将当前任务放到工作队列中。</div><div class="line">        <span class="keyword">if</span>(runState == RUNNING &amp;&amp; workQueue.offer(<span class="built_in">command</span>)) &#123;</div><div class="line">            <span class="keyword">if</span>(runState != RUNNING || poolSize == 0)</div><div class="line">                ensureQueuedTaskHandled(<span class="built_in">command</span>);</div><div class="line">        &#125;</div><div class="line">        // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!addIfUnderMaximumPoolSize(<span class="built_in">command</span>))</div><div class="line">            // 抛出RejectedExecutionException异常</div><div class="line">            reject(<span class="built_in">command</span>); // is shutdown or saturated</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程worker，woker在执行完任务后，还会循环获取工作队列里的任务来执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            try &#123;</div><div class="line">                Runnable task = firstTask;</div><div class="line">                firstTask = null;</div><div class="line">                <span class="keyword">while</span>(task != null || (task =getTask()) != null) &#123;</div><div class="line">                    runTask(task);</div><div class="line">                    task = null;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                workerDone(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/执行任务.png" alt=""><br>线程池执行任务分两种情况：1.在execute方法中创建一个线程时，会让这个线程执行当前任务。2.这个线程执行完任务后，会反复从BlockingQueue获取任务来执行。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>
<ol>
<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，及时其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用prestartAllCoreThreads方法，线程池会提前创建并启动所有线程。</li>
<li>runnableTaskQueue（任务队列）:用于保存等待执行任务的阻塞队列。可选择以下几个阻塞队列：<br>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另外一个线程调用移除操作，否则操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，Executors.newCachedThreadPool使用了这个队列<br>PriorityBlockingQueue：一个具有优先队列的无限阻塞队列</li>
<li>maximumPoolSize（线程池最大数量）：线程允许创建的最大线程数，如果队列满了并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用无界的任务队列这个参数就没意义。</li>
<li><p>ThreadFactory：用来创建线程的工厂，可以通过线程工厂给每个创建的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速地给线程池里的线程设置有意义的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</div></pre></td></tr></table></figure>
</li>
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池满时，说明线程池处于饱和状态，那么必须采用一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理任务时抛异常。<br>AbortPolicy：直接抛出异常<br>CallerRunsPolicy：只用调用者所在线程来运行任务<br>DiscardOldestPolicy：丢弃队列里最后一个任务，来执行当前任务<br>DiscardPolicy：不处理，丢弃掉</p>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行时间都比较短，，可以调大时间，提高cpu的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的时间有Days、HOUSRS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS</li>
</ol>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute和submit方法。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>()&#123;</div><div class="line">  public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>submit方法用于提交需要返回值的任务，线程池会返回一个Future对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成。而使用get(long timeout,TimeUnit unit)则会阻塞当前线程一段时间后立即返回，这时候有可能任务还未执行完。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future=executor.submit(harReturnValuetask);</div><div class="line">try&#123;</div><div class="line">  Object s=future.get();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;finally&#123;</div><div class="line">  executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他的原理是遍历线程池中的工作线程，然后逐个调用线程的interupt方法来中断线程，所以无法中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow是先把线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。而shoutdown只是将线程池的状态设置为shutdown状态，然后中断所有没有正在执行任务的线程。<br>只要调用这两个关闭方法中的其中一个，isshutdown方法就会返回true，当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。<br>任务的性质：CPU密集任务、IO密集任务、混合型任务<br>任务的优先级：高、中、低<br>任务执行的时间：长、中、短<br>任务的依赖性：是否依赖其他系统资源，如数据库连接<br>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应该配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。对于混合型任务，如果可以拆分，将其拆分成CPU密集型任务和IO密集型任务，只要这两个任务执行时间相差不是很大，那么拆分后的吞吐量将高于串行的执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRunTime().availableProcessors()方法获取当前设备的cpu数量。<br>优先级不同可以使用PriorityBlockingQueue来处理，它可以让优先级高的任务先执行。<br>执行时间不同交给不同规模的线程池来处理或者可以使用优先级队列，让执行时间段的任务先执行。<br>依赖数据库连接池任务，因为线程提交SQl后需要等待数据库返回结果，等待的时间越长，cpu的空余时间越长，那么线程数应该设置越大，才能更好地利用cpu。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便出现问题时定位。监控线程池可使用如下属性<br>taskCount：线程需要执行的任务数量<br>completedTaskCount：线程池在运行过程时已完成的任务数量，小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量<br>getPoolSize：线程池的线程数量<br>getActiveCount：获取活动线程数<br>通过扩展线程池进行监控，可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间。这几个方法在线程池里是空方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void beforeExecute(Thread t, Runnable r)&#123; &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>java线程被一对一映射为本地操作系统线程。java线程启动时会创建一个本地操作系统线程；当该线程终止时，这个操作系统线程会被回收。操作系统会调度所有线程并将它们分配给可用的cpu。<br>在上层，java多线程程序通常把应用分解为若干个任务，然后使用用户级调度器(Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。简单的说，应用程序通过Executor框架控制上层的调度，下层的调度通过操作系统内核控制，下层的调度不受应用程序的控制。<br><img src="/2018/01/10/线程池和Executor/二级调度.png" alt=""></p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><h4 id="Executor框架的架构"><a href="#Executor框架的架构" class="headerlink" title="Executor框架的架构"></a>Executor框架的架构</h4><p>Executor框架主要由3大部分组成。</p>
<ul>
<li>任务，包括被执行任务需要实现的接口Runnable或Callable接口。</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口，包括ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>
<p>Executor是一个接口，它是Executor框架的基础，它将任务的提交和任务的执行分离开来。<br>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。比Timer更灵活，功能更强大。<br>Future接口和实现Future接口的实现类FutureTask，代表异步计算的结果。<br>Runnable和Callable的实现类，都可以被ThreadPoolExecutor和ScheduledThreadPoolExecutor执行<br><img src="/2018/01/10/线程池和Executor/class.png" alt=""><br><img src="/2018/01/10/线程池和Executor/#x.png" alt=""><br>主线程首先要创建实现Runnable或者Callable接口的任务对象，工具类Executors可以把一个Runnable对象封装成Callable对象(Executors.callable(Runnble task)或Executors.callable(Runnable task,Object result))。<br>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runable command)),或者可以把Ruunable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit(Callable task))。<br>如果执行ExecutorService.submit(…)，ExecutorService将返回一个Future对象，（目前jdk返回的是FutureTask对象），由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService运行。<br>最后，主线程可以调用FutureTask.get()方法等待任务执行完成，主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)取消任务的运行。</p>
<h4 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h4><p>主要成员有：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建三种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</p>
<h6 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h6><p>创建固定线程数的FixedThreadPool。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h6><p>创建单个线程的SingleThreadExecutor的API<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h6><p>创建一个会根据需要创建新线程的CachedThreadPool<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>通常使用Executors创建，可以创建两种类型的ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor.包含若干线程的ScheduledThreadPoolExecutor<br>SingleThreadScheduledExecutor.包含一个线程的ScheduledThreadPoolExecutor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果，当我们把Callable接口或Runnable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会返回一个FutureTask对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</div><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</div><div class="line">Future&lt;&gt; submit(Runnable task)</div></pre></td></tr></table></figure></p>
<p>目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。在将来的JDK实现中，返回的可能不一定是FutureTask。</p>
<h5 id="Runnable和Callable接口"><a href="#Runnable和Callable接口" class="headerlink" title="Runnable和Callable接口"></a>Runnable和Callable接口</h5><p>Runnable和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。区别是Runnable不会返回结果，而Callable可以返回结果。除了可以创建实现Callable接口的对象外，还可以使用工厂类Executors把一个Runnable接口包装成Callable接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Callable&lt;Object&gt; callable(Runnable task) // 假设返回对象Callable1</div><div class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) // 假设返回对象Callable2</div></pre></td></tr></table></figure></p>
<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。例如，如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p>可重用固定线程数的线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<br>当线程池的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多于的线程将被终止。这里设置为0，意味着多余的线程会被立即终止。<br><img src="/2018/01/10/线程池和Executor/execute.png" alt=""><br>说明：<br>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。<br>2）在线程池预热后，将任务加入LinkedBlockingQueue<br>3）线程执行完1任务后，会在循环中反复从LinkedBlockingQueue获取任务执行<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE)，使用无界队列作为工作队列将会对线程池带来如下影响<br>1）当线程池中的线程数达到corePoolSize，新任务将在无界队列中等待，因此线程池的线程数不会超过corePoolSize，<br>2）由于1，使用无界队列时maximumPoolSize将是无效参数。<br>3）由于1和2，keepAlive将是无效参数<br>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown或shutdownNow）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</p>
<h3 id="SingleThreadExecutor-1"><a href="#SingleThreadExecutor-1" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newSingleThreadExecutor</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">));&#125;</div></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize都设为1，其他参数与fixedThreadPool一样。SingleThreadExecutor使用无界队列LinkedBlickedQueue。<br><img src="/2018/01/10/线程池和Executor/single.png" alt=""></p>
<h3 id="CachedThreadPool-1"><a href="#CachedThreadPool-1" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newCachedThreadPool</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()</div><div class="line">);&#125;</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界，这里把keepalive的时间设置为60L，意味着CachedThreadPool的空余线程等待新任务的最长时间为60s，空余线程超过60s会被终止。<br>CachedThreadPool采用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPoolSize是无界的，这意味者如果主线程提交的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新线程，极端情况下，CachedThreadPool会因为创建过多线程而耗尽cpu和内存资源。<br><img src="/2018/01/10/线程池和Executor/cached_execute.png" alt=""><br>1）首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有空余的时间正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行的offer操作与poll操作配对成功，主线程把任务交给空余的线程执行，execute方法执行完成；否则执行步骤2<br>2）当初始maximumPool为空时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），这种情况下步骤1）将会失败，将会创建一个新线程来执行任务。<br>3）在步骤2新建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空余线程最多在SynchronousQueue中等待60秒，如果60秒内主线程提交了一个任务，这个空余线程将执行主线程提交的任务，否则这个空余线程将会终止。<br>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。</p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承来自ThreadPoolExecutor，它主要用来给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor与Timer类似，但功能更强大且更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义。<br><img src="/2018/01/10/线程池和Executor/scheduled任务传递.png" alt=""><br>ScheduledThreadPoolExecutor的执行分为两个部分：<br>1）当调用scheduleAtFixRate方法或者scheduleWithFixedDelay时，会向DelayQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask<br>2）线程池中的线程从DelayQueue获取ScheduleFutureTask，然后执行任务。<br><img src="/2018/01/10/线程池和Executor/schedule.png" alt=""><br>ScheduleThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了修改：使用DelayQueue作为任务队列；获取任务的方式不同；执行周期任务后，增加了额外处理。</p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduleThreadPoolExecutor会把待调度的任务（ScheduledFutureTask）放到一个DelayQueue里。<br>ScheduledFutureTask有三个参数：<br>long型成员变量time，标识这个任务被执行的时间；<br>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor的序号；<br>long型成员变量period，表示任务执行的周期；<br>DelayQueue封装了一个PriorityQueue，它会对ScheduledFutureTask按照time的大小进行排序，如果time一样，就比较SequenceNumber。<br><img src="/2018/01/10/线程池和Executor/schedule任务执行.png" alt=""><br>1）线程1从DelayQueue中获取已到期的ScheduledFutureTask(delayQueue.take())，到期任务指的是time小于等于当前时间。<br>2）线程1执行这个ScheduledFutureTask<br>3）线程1修改time为下次将要被执行时间<br>4）修改time后将ScheduledFutureTask放回到DelayQueue中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lockInterruptibly(); //1</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            E first = q.peek();</div><div class="line">            <span class="keyword">if</span>(first == null) &#123;</div><div class="line">                available.await();//2.1</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                long delay =  first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                <span class="keyword">if</span>(delay &gt; 0) &#123;</div><div class="line">                    long tl = available.awaitNanos(delay);//2.2</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    E x = q.poll();  //2.3.1</div><div class="line">                    assert x != null;</div><div class="line">                    <span class="keyword">if</span>(q.size() != 0)</div><div class="line">                        available.signalAll(); //2.3.2 wake up other takers</div><div class="line">                    <span class="built_in">return</span> x;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/scheduled_condition.png" alt=""><br>1)获取Lock<br>2）获取周期任务；<br>如果PriorityQueue为空，当前线程到Condition等待，否则执行下面2.2<br>如果如果Priority的头元素的时间比当前时间大，到condition等待time时间，否则执行2.3<br>3）释放锁<br>ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。<br>最后，让我们看看ScheduledThreadPoolExecutor中的线程执行任务的步骤4，把ScheduledFutureTask放入DelayQueue中的过程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();//1</div><div class="line">    try &#123;</div><div class="line">        E first = q.peek();</div><div class="line">        q.offer(e);//2.1</div><div class="line">        <span class="keyword">if</span>(first == null || e.compareTo(first) &lt; 0)</div><div class="line">            available.signalAll();//2.2</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/schedule-delay.png" alt=""><br>1)获取锁<br>2）添加任务；向PriorityQueue添加任务，如果添加的是头元素，则唤醒其他线程<br>3）释放锁</p>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现类FutureTask，代表异步计算的结果</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口还实现了Runnable接口。FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行时机，FutureTask可以处于下面三种状态。<br>1）未启动。FutureTask.run还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，在没有执行run方法之前，处于未启动状态。<br>2）已启动。run方法被执行过程，处于已启动状态<br>3）已完成。执行完正常结束，或被取消(FutureTask.cancel())，或执行run方法过程中抛出异常而异常结束。<br><img src="/2018/01/10/线程池和Executor/FutureTask状态.png" alt=""><br>但FutureTask处于未启动或已启动状态时，执行FutureTask.get()会导致线程阻塞，当FutureTask处于已完成状态，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<br>当FutureTask处于未启动状态时，FutureTask.cancel()将导致任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成)；当FutureTask处于已完成状态时，执行FutureTask.cancel()方法将返回false。<br><img src="/2018/01/10/线程池和Executor/cancel.png" alt=""></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<br>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final  ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = new ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</div><div class="line">	private static String executionTask(final String taskName)</div><div class="line">			throws ExecutionException, InterruptedException &#123;</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">			Future&lt;String&gt; future = taskCache.get(taskName);// 1.1,2.1</div><div class="line">			<span class="keyword">if</span>(future == null) &#123;</div><div class="line">				Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;</div><div class="line">					public String call() throws InterruptedException &#123;</div><div class="line">						<span class="built_in">return</span> taskName;</div><div class="line">					&#125;</div><div class="line">				&#125;; // 1.2创建任务</div><div class="line">				FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(task);</div><div class="line">				future = taskCache.putIfAbsent(taskName, futureTask);// 1.3</div><div class="line">				<span class="keyword">if</span>(future == null) &#123;</div><div class="line">					future = futureTask;</div><div class="line">					futureTask.run();// 1.4执行任务</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				<span class="built_in">return</span> future.get();// 1.5,2.2线程在此等待任务执行完成</div><div class="line">			&#125; catch (CancellationException e) &#123;</div><div class="line">				taskCache.remove(taskName, future);</div><div class="line">			&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/future.png" alt=""><br>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread 2将在2.2等待，直到Thread 1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现是基于AQS，concurrent包中很多阻塞类(ReentrantLock)都是基于阻塞类实现的.AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程。基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、FutureTask<br>每一个基于AQS实现的同步器都会包含两种类型的操作，如下。<br>至少一个acquire操作。这个操作阻塞调用线程，除非直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get/get（long timeout，TimeUnit unit）方法调用。<br>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run方法和cancel（…）方法。<br>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。<br>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br><img src="/2018/01/10/线程池和Executor/FutureTask设计.png" alt=""><br>Sync是一个内部私有类，它继承自AQS，创建FutureTask时会创建Sync，FutureTask的所有共有方法都委托给Sync。<br>FutureTask.get()会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法执行过程如下<br>1）首先会回调在子类Sync的tryAcquireShared方法来判断是否可以成功，acquire成功的条件为：state为执行成功状态或已取消状态，且runner不为null。<br>2）如果成功则在get方法中立即返回，失败了就在等待队列中去等待其他线程执行release操作。<br>3）当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel()）唤醒当前线程。当前线程再次执行tryAcquireShared将返回正值1，当前线程将离开等待队列并且唤醒他的后继线程。<br>4）最后返回计算结果或返回抛出异常。<br>FutureTask.run()执行过程如下：<br>FutureTask.run()的执行过程如下。<br>1）执行在构造函数中指定的任务（Callable.call()）。<br>2）以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。<br>3）AQS.releaseShared（int arg）首先会回调在子类Sync中实的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。<br>4）调用FutureTask.done()。<br>当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程<br><img src="/2018/01/10/线程池和Executor/级联唤醒.png" alt=""><br>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从<br>队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/05/java并发编程6-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/05/java并发编程6-8/" itemprop="url">java并发编程6~8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T21:51:00+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java并发容器和框架"><a href="#java并发容器和框架" class="headerlink" title="java并发容器和框架"></a>java并发容器和框架</h1><h2 id="ConcurrentHashMap实现原理与使用"><a href="#ConcurrentHashMap实现原理与使用" class="headerlink" title="ConcurrentHashMap实现原理与使用"></a>ConcurrentHashMap实现原理与使用</h2><h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p>
<h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">concurrencyLevel = MAX_SEGMENTS;</div><div class="line">int sshift = 0;</div><div class="line">int ssize = 1;</div><div class="line"><span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123;</div><div class="line">++sshift;</div><div class="line">ssize = ssize&lt;&lt;1;</div><div class="line">&#125;</div><div class="line">segmentShift = 32 - sshift;</div><div class="line">segmentMask = ssize - 1;</div><div class="line">this.segments = Segment.newArray(ssize);</div></pre></td></tr></table></figure>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16</p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。SegmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个Segment"><a href="#初始化每个Segment" class="headerlink" title="初始化每个Segment"></a>初始化每个Segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadFactor是每个Segment的负载因子。在构造方法里需要通过这两个参数来初始化数组中的每个Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">int c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">++c;</div><div class="line">int <span class="built_in">cap</span> = 1;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cap</span> &lt; c)</div><div class="line"><span class="built_in">cap</span> &lt;&lt;= 1;</div><div class="line"><span class="keyword">for</span> (int i = 0; i &lt; this.segments.length; ++i)</div><div class="line">this.segments[i] = new Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</div></pre></td></tr></table></figure></p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取数据的时候，必须先通过散列算法定位到Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static int <span class="built_in">hash</span>(int h) &#123;</div><div class="line">h += (h &lt;&lt; 15) ^ 0xffffcd7d;</div><div class="line">h ^= (h &gt;&gt;&gt; 10);</div><div class="line">h += (h &lt;&lt; 3);</div><div class="line">h ^= (h &gt;&gt;&gt; 6);</div><div class="line">h += (h &lt;&lt; 2) + (h &lt;&lt; 14);</div><div class="line"><span class="built_in">return</span> h ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以进行再散列，目的是减少哈希冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存储效率。通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Segment&lt;K,V&gt; segmentFor(int <span class="built_in">hash</span>) &#123;</div><div class="line"><span class="built_in">return</span> segments[(<span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int <span class="built_in">hash</span> = <span class="built_in">hash</span>(key.hashCode());</div><div class="line"><span class="built_in">return</span> segmentFor(<span class="built_in">hash</span>).get(key, <span class="built_in">hash</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get的高效就在于整个get过程中不用加锁，除非读到的值是空的才会加锁重读，ConcurrentHashMap在它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值。但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">transient volatile int count;</div><div class="line">volatile V value;</div></pre></td></tr></table></figure></p>
<p>定位HashEntry和定位Segment的算法虽然一样，都与数组长度减1，定位Segment使用的是元素Hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是hashcode的值，其目的是避免两次散列的值一样。虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的<span class="built_in">hash</span>算法</div><div class="line">int index = <span class="built_in">hash</span> &amp; (tab.length - 1);　　// 定位HashEntry所使用的<span class="built_in">hash</span>算法</div></pre></td></tr></table></figure></p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法需要对共享变量进行写操作，为了线程安全，操作共享变量时必须加锁。put首先定位到Segment，然后在Segment里进行插入操作，插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二部定位添加元素的位置，然后将其放入HashEntry数组中。<br>（1）是否扩容<br>在插入元素前会先判断Segment的HashEntry数组是否超过容量（threadhold），如果超过阈值，则对数组进行扩容。Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量的，如果到达就进行扩容，但是很可能扩容之后没有新元素插入，这时HashMap进行了一次无效的扩容。<br>（2）如何扩容<br>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组中，为了高效，ConcurrentHashMap不会对整个容器扩容，而只对某个Segment进行扩容。</p>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>在并发过程中有时候需要线程安全的队列，如果要实现一个线程安全队列有两种方式：一种是阻塞算法，另一种是非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队使用同一把锁）或者两个锁等方式实现。非阻塞算法可以使用循环CAS方式来实现。<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到尾部，当我们获取一个元素时，它会返回队列头部的元素，。它采用CAS算法实现。<br><img src="/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png" alt=""><br>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient volatile Node&lt;E&gt; tail = head;</div></pre></td></tr></table></figure></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><ol>
<li>入队列的过程</li>
</ol>
<p>入队列就是将入队节点添加到队列尾部。<br><img src="/2018/01/05/java并发编程6-8/添加元素.png" alt=""><br>入队主要做两件事：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null) throw new NullPointerException();</div><div class="line">// 入队前，创建一个入队节点</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line">retry:</div><div class="line">// 死循环，入队不成功反复入队。</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">// 创建一个指向tail节点的引用</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line">// p用来表示队列的尾节点，默认情况下等于tail节点。</div><div class="line">Node&lt;E&gt; p = t;</div><div class="line"><span class="keyword">for</span> (int hops = 0; ; hops++) &#123;</div><div class="line">// 获得p节点的下一个节点。</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</div><div class="line"><span class="keyword">if</span> (next != null) &#123;</div><div class="line">// 循环了两次及其以上，并且当前节点还是不等于尾节点</div><div class="line"><span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</div><div class="line"><span class="built_in">continue</span> retry;</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line">// 如果p是尾节点，则设置p节点的next节点为入队节点。</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(null, n)) &#123;</div><div class="line">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</div><div class="line">更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</div><div class="line">casTail(t, n); // 更新tail节点，允许失败</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">p = succ(p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<ol>
<li>定位尾节点</li>
</ol>
<p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123;</div><div class="line">Node&lt;E&gt; next = p.getNext();</div><div class="line"><span class="built_in">return</span> (p == next) head : next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>设置入队节点为尾节点</li>
</ol>
<p>p.casNext(null,n)方法用于将入队节点设置为当前队列尾节点的next节点，如果当前尾节点的next节点是null时，则代表当前节点为尾节点，如果不为null时，则需要重新获取当前队列的尾节点</p>
<ol>
<li>Hops的设计意图</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null)</div><div class="line">throw new NullPointerException();</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line"><span class="keyword">if</span> (t.casNext(null, n) &amp;&amp; casTail(t, n)) &#123;</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让tail节点永远作为尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列是从队列返回一个节点元素，并清空该节点对该元素的引用。并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。<br><img src="/2018/01/05/java并发编程6-8/出队.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public E <span class="function"><span class="title">poll</span></span>() &#123;</div><div class="line">Node&lt;E&gt; h = head;</div><div class="line">// p表示头节点，需要出队的节点</div><div class="line">Node&lt;E&gt; p = h;</div><div class="line"><span class="keyword">for</span> (int hops = 0;; hops++) &#123;</div><div class="line">// 获取p节点的元素</div><div class="line">E item = p.getItem();</div><div class="line">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</div><div class="line">// 如果成功则返回p节点的元素。</div><div class="line"><span class="keyword">if</span> (item != null &amp;&amp; p.casItem(item, null)) &#123;</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS) &#123;</div><div class="line">// 将p节点下一个节点设置成head节点</div><div class="line">Node&lt;E&gt; q = p.getNext();</div><div class="line">updateHead(h, (q != null) q : p);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> item;</div><div class="line">&#125;</div><div class="line">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</div><div class="line">// 一个线程修改了。那么获取p节点的下一个节点</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// 如果p的下一个节点也为空，说明这个队列已经空了</div><div class="line"><span class="keyword">if</span> (next == null) &#123;</div><div class="line">// 更新头节点。</div><div class="line">updateHead(h, p);</div><div class="line"><span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先获取头节点元素，然后判断头结点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点元素取走，如果不为空，则使用CAS方式将头结点引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列是支持两个附加操作的队列。附加操作指的是支持阻塞的插入和移除。<br>1）支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者消费者场景。生产者是向队列里添加的线程，消费者是从队列里取元素的线程。阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常:当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
<h3 id="java的阻塞队列"><a href="#java的阻塞队列" class="headerlink" title="java的阻塞队列"></a>java的阻塞队列</h3><p>jdk7提供了7个阻塞队列<br>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列<br>DelayBlockingQueue：一个使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：一个不存储元素的阻塞队列<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是用一个数组实现有界的阻塞队列，此队列按照先进先出原则对元素进行排序。默认情况下不保证线程公平访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue fairQueue=new ArrayBlockingQueue(100,<span class="literal">true</span>);</div><div class="line">//公平性是使用可重入锁</div><div class="line">public ArrayBlockingQueue(int capacity,boolean fair)&#123;</div><div class="line">  <span class="keyword">if</span>(capacity&lt;0)&#123;</div><div class="line">    throw  new IllegalArgumentException();</div><div class="line">  &#125;</div><div class="line">  this.items=new Object[capacity];</div><div class="line">  lock=new ReentrantLock(fair);</div><div class="line">  notEmpty=lock.newCondition();</div><div class="line">  notFull=lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，此队列默认最大长度为Integer.MAX_VALUE，此队列按照先进先出的原则。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue来实现。队列中的元素必须实现Delay接口，在创建元素时，可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列提取元素。<br>DelayQueue使用场景：1.缓存系统的设计；可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素，说明缓存有效期到了；2.定时任务调度，使用DelayQueue保存当天会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的<br>如何实现DelayQueue,参考ScheduledThreadPoolExecutor里ScheduledFutureTask：<br>1）在对象创建时候，初始化基本数据，使用time记录当前记录延迟到什么时候可以使用，使用SequenceNumber来标识元素在队列中的先后顺序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static final AtomicLong sequencer = new AtomicLong(0);</div><div class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</div><div class="line">super(r, result);</div><div class="line">this.time = ns;</div><div class="line">this.period = period;</div><div class="line">this.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）实现delay方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public long getDelay(TimeUnit unit) &#123;</div><div class="line">    <span class="built_in">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>3)实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int compareTo(Delayed other) &#123;</div><div class="line">     <span class="keyword">if</span> (other == this) // compare zero ONLY <span class="keyword">if</span> same object</div><div class="line">         <span class="built_in">return</span> 0;</div><div class="line">     <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</div><div class="line">         ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</div><div class="line">         long diff = time - x.time;</div><div class="line">         <span class="keyword">if</span> (diff &lt; 0)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; 0)</div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">     &#125;</div><div class="line">     long d = (getDelay(TimeUnit.NANOSECONDS) -</div><div class="line">               other.getDelay(TimeUnit.NANOSECONDS));</div><div class="line">     <span class="built_in">return</span> (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如何实现延时阻塞队列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                   <span class="keyword">if</span> (delay &lt;= 0)</div><div class="line">                       <span class="built_in">return</span> q.poll();</div><div class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != null)</div><div class="line">                       available.await();</div><div class="line">                   <span class="keyword">else</span> &#123;</div><div class="line">                       Thread thisThread = Thread.currentThread();</div><div class="line">                       leader = thisThread;</div><div class="line">                       try &#123;</div><div class="line">                           available.awaitNanos(delay);</div><div class="line">                       &#125; finally &#123;</div><div class="line">                           <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                               leader = null;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div></pre></td></tr></table></figure></p>
<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能添加。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。<br>SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
<h4 id="LinkedTransformQueue"><a href="#LinkedTransformQueue" class="headerlink" title="LinkedTransformQueue"></a>LinkedTransformQueue</h4><p>LinkedTransformQueue是一个由链表结构组成的无界阻塞TransformQueue队列。，相比较其他阻塞队列，增加了tryTransform和transform方法如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node pred = tryAppend(s, haveData);</div><div class="line"><span class="built_in">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</div></pre></td></tr></table></figure></p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用通知模式实现，所谓的通知模式，就是生产者往满的队列添加元素时会阻塞住生产者，当消费者消费一个队列后，会通知生产者当前队列可用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private final Condition notFull;</div><div class="line">private final Condition notEmpty;</div><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">// 省略其他代码</div><div class="line">notEmpty = lock.newCondition();</div><div class="line">notFull = lock.newCondition();</div><div class="line">&#125;</div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">checkNotNull(e);</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == items.length)</div><div class="line">notFull.await();</div><div class="line">insert(e);</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == 0)</div><div class="line">notEmpty.await();</div><div class="line"><span class="built_in">return</span> extract();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">private void insert(E x) &#123;</div><div class="line">items[putIndex] = x;</div><div class="line">putIndex = inc(putIndex);</div><div class="line">++count;</div><div class="line">notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当队列插入一个元素，如果队列不可用，那么阻塞生产者主要通过Locksupport.park实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(this);</div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="built_in">set</span>Blocker(t, blocker);</div><div class="line">    unsafe.park(<span class="literal">false</span>, 0L);</div><div class="line">    <span class="built_in">set</span>Blocker(t, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.park是个native方法</p>
<h2 id="fork-join任务"><a href="#fork-join任务" class="headerlink" title="fork/join任务"></a>fork/join任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class CountNumber extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private static final int THRESHOLD = 2;</div><div class="line">	private int start;</div><div class="line">	private int end;</div><div class="line"></div><div class="line">	public CountNumber(int start, int end) &#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer <span class="function"><span class="title">compute</span></span>() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		// 如果任务足够小就计算任务</div><div class="line">		boolean canCompute = (end - start) &lt;= THRESHOLD;</div><div class="line">		<span class="keyword">if</span> (canCompute) &#123;</div><div class="line">			<span class="keyword">for</span> (int i = start; i &lt;= end; i++) &#123;</div><div class="line">				sum += i;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 如果任务大于阈值，就分裂成两个子任务计算</div><div class="line">			int middle = (start + end) / 2;</div><div class="line">			CountNumber leftTask = new CountNumber(start, middle);</div><div class="line">			CountNumber rightTask = new CountNumber(middle + 1, end);</div><div class="line">			// 执行子任务</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			// 等待子任务执行完，并得到其结果</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			// 合并子任务</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> sum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		// 生成一个计算任务，负责计算1+2+3+4</div><div class="line">		CountNumber task = new CountNumber(1, 4);</div><div class="line">		// 执行一个任务</div><div class="line">		Future&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ForkJoinTask与一般任务的区别是它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常<br>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>1）当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。<br>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final ForkJoinTask&lt;V&gt; <span class="function"><span class="title">fork</span></span>() &#123;</div><div class="line">((ForkJoinWorkerThread) Thread.currentThread())</div><div class="line">.pushTask(this);</div><div class="line"><span class="built_in">return</span> this;</div><div class="line">&#125;</div><div class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;</div><div class="line">ForkJoinTask&lt;&gt;[] q; int s, m;</div><div class="line"><span class="keyword">if</span> ((q = queue) != null) &#123;　　　　// ignore <span class="keyword">if</span> queue removed</div><div class="line">long u = (((s = queueTop) &amp; (m = q.length - 1)) &lt;&lt; ASHIFT) + ABASE;</div><div class="line">UNSAFE.putOrderedObject(q, u, t);</div><div class="line">queueTop = s + 1;　　　　　　// or use putOrderedInt</div><div class="line"><span class="keyword">if</span> ((s -= queueBase) &lt;= 2)</div><div class="line">pool.signalWork();</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == m)</div><div class="line">growQueue();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)ForkJoinTask的join实现原理<br>join方法主要是阻塞当前线程并等待获取结果,它调用了doJoin()方法，通过doJoin()方法到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public final V <span class="function"><span class="title">join</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">do</span>Join() != NORMAL)</div><div class="line"><span class="built_in">return</span> reportResult();</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private V <span class="function"><span class="title">reportResult</span></span>() &#123;</div><div class="line">int s; Throwable ex;</div><div class="line"><span class="keyword">if</span> ((s = status) == CANCELLED)</div><div class="line">throw new CancellationException();</div><div class="line"><span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)</div><div class="line">UNSAFE.throwException(ex);</div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private int <span class="function"><span class="title">doJoin</span></span>() &#123;</div><div class="line">Thread t; ForkJoinWorkerThread w; int s; boolean completed;</div><div class="line"><span class="keyword">if</span> ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &#123;</div><div class="line"><span class="keyword">if</span> ((s = status) &lt; 0)</div><div class="line"><span class="built_in">return</span> s;</div><div class="line"><span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(this)) &#123;</div><div class="line">try &#123;</div><div class="line">completed = <span class="built_in">exec</span>();</div><div class="line">&#125; catch (Throwable rex) &#123;</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>ExceptionalCompletion(rex);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (completed)</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>Completion(NORMAL);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> w.joinTask(this);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> externalA<span class="built_in">wait</span>Done();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h1 id="java中的13个原子操作类"><a href="#java中的13个原子操作类" class="headerlink" title="java中的13个原子操作类"></a>java中的13个原子操作类</h1><p>java.util.concurrent.atomic提供了一种用法简单、性能高效、线程安全地更新一个变量的方式，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>AtomicBoolean:原子更新布尔类型<br>AtomicInteger：原子更新整数类型<br>AtomicLong：原子更新长整型<br>这三个类提供的方法几乎一模一样，以AtomicInteger为例<br>int addAndGet(int delta)：以原子方式将输入的数值与实例的值相加，并返回结果。<br>boolean compareAndSet(int expect,intupdate):如果输入的值等于预期，则以原子的方式将该值设为输入的值。<br>int getAndIncrement():以原子的方式将当前值加1，这里返回的值是自增前的值。<br>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。<br>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final int <span class="function"><span class="title">getAndIncrement</span></span>() &#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line"><span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line"><span class="built_in">return</span> current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。<br>Atomic包提供了3种基本类型的原子更新，但是java基本类型还有char、float、double，Atomic包是使用unsafe实现的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapObject(Object o,</div><div class="line">long offset,</div><div class="line">Object expected,</div><div class="line">Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">int expected,</div><div class="line">int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,</div><div class="line">long expected,</div><div class="line">long x);</div></pre></td></tr></table></figure></p>
<p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。</p>
<h2 id="原子数组更新"><a href="#原子数组更新" class="headerlink" title="原子数组更新"></a>原子数组更新</h2><p>AtomicIntegerArray：原子更新整型数组里的元素<br>AtomicLongArray：原子更新长整型数组里的元素<br>AtomicReferenceArray：原子更新引用数组里的元素<br>·int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。<br>·boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerArratTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		int[] value=new int[]&#123;1,2,3&#125;;</div><div class="line">		AtomicIntegerArray atomicIntegerArray=new AtomicIntegerArray(value);</div><div class="line">		atomicIntegerArray.set(0, 3);</div><div class="line">		System.out.println(atomicIntegerArray.get(0));</div><div class="line">		System.out.println(value[0]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//3</div><div class="line">//1</div></pre></td></tr></table></figure></p>
<p>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，需要使用这个原子更新引用类型提供的类，Atomic包括以下几个类：<br>AtomicReference：原子更新引用类型<br>AtomicReferenceFieldUpdater：原子更新引用类型的字段<br>AtomicMarkableReference：原子更新带有标记位的引用类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AtomicRefernceTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicReference&lt;User&gt; atomicReference=new AtomicReference&lt;&gt;();</div><div class="line">		User user=new User(<span class="string">"student"</span>, 15);</div><div class="line">		atomicReference.set(user);</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">		atomicReference.compareAndSet(user, new User(<span class="string">"teacher"</span>, 30));</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		private int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>AtomicIntegerFieldUpdater：原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicStampedReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可用于原子更新数据和数据的版本号，可以解决使用CAS进行原子更新时出现的ABA问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerFieldUpdaterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</div><div class="line">        User user=new User(<span class="string">"lr"</span>, 10);</div><div class="line">        atomicIntegerFieldUpdater.getAndIncrement(user);</div><div class="line">        System.out.println(atomicIntegerFieldUpdater.get(user));</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		public volatile int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="java中并发工具类"><a href="#java中并发工具类" class="headerlink" title="java中并发工具类"></a>java中并发工具类</h1><h2 id="等待多线程完成countDownLatch"><a href="#等待多线程完成countDownLatch" class="headerlink" title="等待多线程完成countDownLatch"></a>等待多线程完成countDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。要实现主线程等待所有线程完成任务，最简单的做法是使用join<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class JoinCountDownLatchTest &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * @throws S</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread task1=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        Thread task2=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        task1.start();</div><div class="line">        task2.start();</div><div class="line">        task1.join();</div><div class="line">        task2.join();</div><div class="line">        System.out.println(<span class="string">"total task finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>join用于执行线程等待join执行结束，原理是不同地检查线程是否存活，如果join线程存活则让当前线程永远等待，其中wait（0）是永远等待<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(isAlive())&#123;</div><div class="line">  <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>知道join线程终止后，线程的this.notifyAll()方法会被调用，调用notifyAll方法是在JVM实现的，在JDK看不到<br>并发包CountDownLatch可以实现join功能，并且比join功能更多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		final CountDownLatch countDownLatch = new CountDownLatch(2);</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		countDownLatch.await();</div><div class="line">		System.out.println(<span class="string">"all finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch构造函数接收一个int类型的参数作为计数器，如果你想等N个点完成，就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变为0。我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier字面意思是可循环使用的屏障，它要做的事情是让一组线程到达屏障时被阻塞，直到最后一个线程到达屏障时，屏障才开门，所有被屏障拦截的线程才会继续运行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障要拦截的线程数，每个线程调用await方法告诉CyclicBarrier我已经到达屏障，然后当前线程阻塞<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException, BrokenBarrierException&#123;</div><div class="line">	final CyclicBarrier cyclicBarrier=new CyclicBarrier(2);</div><div class="line">	new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			try &#123;</div><div class="line">				cyclicBarrier.await();</div><div class="line">			&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"1"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">	cyclicBarrier.await();</div><div class="line">	System.out.println(<span class="string">"2"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CyclicBarrier还提供了一个更高级的构造函数，CyclicBarrier(int parties,Runnable action)，用于在线程到达屏障时，优先执行action，方便处理更复杂的业务场景。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2, new A());</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class A implements Runnable &#123;</div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			System.out.println(3);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier应用场景"><a href="#CyclicBarrier应用场景" class="headerlink" title="CyclicBarrier应用场景"></a>CyclicBarrier应用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BankWaterService implements Runnable&#123;</div><div class="line">	/**</div><div class="line">	* 创建4个屏障，处理完之后执行当前类的run方法</div><div class="line">	*/</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	/**</div><div class="line">	* 假设只有4个sheet，所以只启动4个线程</div><div class="line">	*/</div><div class="line">	private ExecutorService executor = Executors.newFixedThreadPool(4);</div><div class="line">	/**</div><div class="line">	* 保存每个sheet计算出的银流结果</div><div class="line">	*/</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt;sheetBankWaterCount = new</div><div class="line">	ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	public void <span class="function"><span class="title">count</span></span>()&#123;</div><div class="line">		<span class="keyword">for</span>(int i=0;i&lt;4;i++)&#123;</div><div class="line">		executor.submit(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		&#125;</div><div class="line">		executor.shutdown();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		int result = 0;</div><div class="line">		<span class="keyword">for</span>(Entry&lt;String,Integer&gt; entry:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result=result+entry.getValue();</div><div class="line">		&#125;</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		new BankWaterService().count();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody>
</table>
<p>CyclicBarrier计数器可以使用reset方法重置，而CountDownLatch的计数器只能使用一次，所以CyclicBarrier可以用在更复杂的业务场景。例如计算错误了，可以重置计数器，让线程重算。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting可以获得阻塞的线程数量，isbroken可以用来了解阻塞的线程是否中断。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">importjava.util.concurrent.BrokenBarrierException;</div><div class="line">importjava.util.concurrent.CyclicBarrier;</div><div class="line">public class CyclicBarrierTest3 &#123;</div><div class="line">staticCyclicBarrier c = new CyclicBarrier(2);</div><div class="line">public static void main(String[] args) throws InterruptedException，</div><div class="line">BrokenBarrierException &#123;</div><div class="line">Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">thread.interrupt();</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">System.out.println(c.isBroken());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class SemophoreTest &#123;</div><div class="line"></div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	private static ExecutorService threadPool = Executors</div><div class="line">			.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</div><div class="line">			final int num=i;</div><div class="line">			threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">				@Override</div><div class="line">				public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						System.out.println(<span class="string">"save data"</span>+num);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Semaphore还提供一些其他方法，具体如下。<br>·int availablePermits()：返回此信号量中当前可用的许可证数。<br>·int getQueueLength()：返回正在等待获取许可证的线程数。<br>·boolean hasQueuedThreads()：是否有线程正在等待获取许可证。<br>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。<br>·Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</p>
<h2 id="线程之间的交换"><a href="#线程之间的交换" class="headerlink" title="线程之间的交换"></a>线程之间的交换</h2><p>Exchanger是一个线程间协作工具类，Exchanger可用来线程间的数据交换。它提供一个同步点，在这个同步点，线程间可以交换彼此的数据，两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程执行exchange方法，当两个线程都到达同步点，这两个线程就可以交换数据，将本线程生产的数据传递给对方。<br>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = <span class="string">"银行流水A"</span>;// A录入银行流水数据</div><div class="line">					exgr.exchange(A);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = <span class="string">"银行流水B"</span>;// B录入银行流水数据</div><div class="line">					String A = exgr.exchange(<span class="string">"B"</span>);</div><div class="line">					System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></div><div class="line">							+ A + <span class="string">"，B录入是："</span> + B);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/01/MySQL性能管理及架构设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/MySQL性能管理及架构设计/" itemprop="url">MySQL性能管理及架构设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-01T22:21:08+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么影响了mysql的性能"><a href="#什么影响了mysql的性能" class="headerlink" title="什么影响了mysql的性能"></a>什么影响了mysql的性能</h1><h2 id="影响性能的几个方面"><a href="#影响性能的几个方面" class="headerlink" title="影响性能的几个方面"></a>影响性能的几个方面</h2><ol>
<li>服务器的硬件</li>
<li>操作系统或参数配置</li>
<li>数据库的存储引擎选择<br>MyIsam：不支持事务，表级锁；Innodb：事务存储引擎，完美支持行级锁，支持事务ACID特性</li>
<li>数据库参数配置</li>
<li>数据库结构设计和sql语句</li>
</ol>
<h2 id="CPU资源和内存大小"><a href="#CPU资源和内存大小" class="headerlink" title="CPU资源和内存大小"></a>CPU资源和内存大小</h2><p>CPU资源和内存大小<br>网络，memcache失效时会产生大量网络传输</p>
<h3 id="考虑cpu"><a href="#考虑cpu" class="headerlink" title="考虑cpu"></a>考虑cpu</h3><p>cpu密集型选择更好的Cpu，mysql暂不支持多cpu对同一sql并发处理</p>
<h3 id="系统的并发量"><a href="#系统的并发量" class="headerlink" title="系统的并发量"></a>系统的并发量</h3><p>QPS：同时处理sql的数量</p>
<h3 id="Mysql的版本"><a href="#Mysql的版本" class="headerlink" title="Mysql的版本"></a>Mysql的版本</h3><p>最新的版本对多核支持，尤其是5.5以后的版本</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存比SSD和Fusion-IO比也要快很多<br>myisam将索引缓存到内存，数据放在通过操作系统缓存<br>innodb同时缓存数据和索引到内存<br>选择内存的主频，频率越高速度越快</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/31/java并发编程4-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/31/java并发编程4-6/" itemprop="url">java并发编程4~5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-31T15:25:57+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java并发编程基础"><a href="#java并发编程基础" class="headerlink" title="java并发编程基础"></a>java并发编程基础</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程时间片用完了就会发生线程调度，等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。<br>Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。<br>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>java线程在运行的生命周期可能处于6中不同的状态，在给定的一个时刻线程只能处于其中一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用start方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，java线程将操作系统中的就绪和运行两种状态笼统地称作运行中</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITTING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（如通知或者中断）</td>
</tr>
<tr>
<td>TIME_WAITTING</td>
<td>超时等待状态，该状态不同于WAITTING，它是可以在指定的时间返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jps <span class="_">-l</span></div><div class="line">jstack pid//查看线程情况</div></pre></td></tr></table></figure>
<p><img src="/2017/12/31/java并发编程4-6/java线程状态变迁.png" alt=""><br>注意　Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个java虚拟机不存在非Daemon线程时，java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个标记位，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了招呼，其他线程调用了该线程的interrupt方法对其进行了中断。<br>线程通过检查自身是否被中断进行响应，通过调用isInterrupted来判断是否被中断，也可以调用静态方法Thread.interrupted对当前线程进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。<br>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<h3 id="过期的suspend、resume、stop"><a href="#过期的suspend、resume、stop" class="headerlink" title="过期的suspend、resume、stop"></a>过期的suspend、resume、stop</h3><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。<br>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="volatile和synchronize关键字"><a href="#volatile和synchronize关键字" class="headerlink" title="volatile和synchronize关键字"></a>volatile和synchronize关键字</h3><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。<br>简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(value != desire) &#123;</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125;</div><div class="line"><span class="keyword">do</span>Something();</div></pre></td></tr></table></figure></p>
<p>1）难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时<br>发现条件已经变化，也就是及时性难以保证。<br>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现<br>条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。<br>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br><img src="/2017/12/31/java并发编程4-6/通知机制.png" alt=""><br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>wait、notify和notifyAll注意细节：</p>
<ul>
<li>使用wait、notify、notifyAll时需要先对对象加锁</li>
<li>调用wait后，线程状态由RUNNING变为WAITING，并将当前线程放到等待队列中</li>
<li>notify和notifyAll调用后，等待线程不会从wait返回，需要等待notify和notifyAll释放锁后，等待线程才有机会从wait中返回。</li>
<li>notify方法将等待队列中的一个线程从等待队列中移出到同步队列，notifyAll是将等待队列中的所有线程移到同步队列中，被移动的线程从waiting变为blocked。</li>
<li>从wait方法中返回前提是获得调用对象锁</li>
</ul>
<p><img src="/2017/12/31/java并发编程4-6/wait_notify.png" alt=""></p>
<h3 id="等待通知的经典范式"><a href="#等待通知的经典范式" class="headerlink" title="等待通知的经典范式"></a>等待通知的经典范式</h3><p>该范式分为两个部分：分别针对等待方和通知方</p>
<h4 id="等待方"><a href="#等待方" class="headerlink" title="等待方"></a>等待方</h4><p>等待方遵守如下规则：</p>
<ol>
<li>获取对象的锁</li>
<li>如果不满足条件，那么调用对象的wait方法，被通知后仍然检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  <span class="keyword">while</span>(条件不满足)&#123;</div><div class="line">    对象.wait();</div><div class="line">  &#125;</div><div class="line">  对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通知方"><a href="#通知方" class="headerlink" title="通知方"></a>通知方</h4><ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  改变条件</div><div class="line">  对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。<br>管道输入输出流包括了如下四种具体实现：PipedOutputStream、PipedInputStream、PipedReader、PipedWriter，前两种面向字节，后两种面向字符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Piped &#123;</div><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">PipedWriter out = new PipedWriter();</div><div class="line">PipedReader <span class="keyword">in</span> = new PipedReader();</div><div class="line">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</div><div class="line">out.connect(<span class="keyword">in</span>);</div><div class="line">Thread <span class="built_in">print</span>Thread = new Thread(new Print(<span class="keyword">in</span>), <span class="string">"PrintThread"</span>);</div><div class="line"><span class="built_in">print</span>Thread.start();</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = System.in.read()) != -1) &#123;</div><div class="line">out.write(receive);</div><div class="line">&#125;</div><div class="line">&#125; finally &#123;</div><div class="line">out.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">static class Print implements Runnable &#123;</div><div class="line">private PipedReader <span class="keyword">in</span>;</div><div class="line">public Print(PipedReader <span class="keyword">in</span>) &#123;</div><div class="line">this.in =<span class="keyword">in</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = in.read()) != -1) &#123;</div><div class="line">System.out.print((char) receive);</div><div class="line">&#125;</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><p>如果一个线程执行了thread.join语句，其含义是当前线程A等待thread线程终止后才从thread.join返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 加锁当前线程对象</div><div class="line">public final synchronized void join() throws InterruptedException &#123;</div><div class="line">// 条件不满足，继续等待</div><div class="line"><span class="keyword">while</span>(isAlive()) &#123;</div><div class="line"> <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div><div class="line">// 条件符合，方法返回</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal是线程变量，是一个以ThreadLocal为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程的值。<br>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p>开发人员经常遇到：调用一个方法等待一段时间后，如果该方法能够在给定时间段内得到结果，那么将结果返回，反之超时返回默认结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 对当前对象加锁</div><div class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line">// 当超时大于0并且result返回值不满足要求</div><div class="line"><span class="keyword">while</span>((result == null) &amp;&amp; remaining &gt; 0) &#123;</div><div class="line"><span class="built_in">wait</span>(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ConnectionPool &#123;</div><div class="line">private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</div><div class="line">public ConnectionPool(int initialSize) &#123;</div><div class="line"><span class="keyword">if</span>(initialSize &gt; 0) &#123;</div><div class="line"><span class="keyword">for</span>(int i = 0; i &lt; initialSize; i++) &#123;</div><div class="line">pool.addLast(ConnectionDriver.createConnection());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void releaseConnection(Connection connection) &#123;</div><div class="line"><span class="keyword">if</span>(connection != null) &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</div><div class="line">pool.addLast(connection);</div><div class="line">pool.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 在mills内无法获取到连接，将会返回null</div><div class="line">public Connection fetchConnection(long mills) throws InterruptedException &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 完全超时</div><div class="line"><span class="keyword">if</span>(mills &lt;= 0) &#123;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty()) &#123;</div><div class="line">pool.wait();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> pool.removeFirst();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</div><div class="line">pool.wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">Connection result = null;</div><div class="line"><span class="keyword">if</span>(!pool.isEmpty()) &#123;</div><div class="line">result = pool.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h1><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock=new ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。<br><img src="/2017/12/31/java并发编程4-6/lock特性.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/lock-api.png" alt=""></p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer是用来构建锁或者其他组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程排队工作。<br>同步器的主要使用方式是继承，子类通过继承父类同步器并实现他的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这就需要对同步器提供的三个方法（getState、setState、compareAndSetState）来进行操作，因为它能保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。<br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方<br>法，而这些模板方法将会调用使用者重写的方法。<br>·getState()：获取当前同步状态。<br>·setState(int newState)：设置当前同步状态。<br>·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。<br><img src="/2017/12/31/java并发编程4-6/同步器重写.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/模板方法.png" alt=""><br>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><p>同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，同步器将当前线程以及等待状态等信息构造称为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。<br><img src="/2017/12/31/java并发编程4-6/节点属性.png" alt=""><br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部<br><img src="/2017/12/31/java并发编程4-6/同步队列结构.png" alt=""><br>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="/2017/12/31/java并发编程4-6/cas设置尾节点.png" alt=""><br>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点<br><img src="/2017/12/31/java并发编程4-6/首节点设置.png" alt=""><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line"><span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">    selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">  Node node = new Node(Thread.currentThread(), mode);</div><div class="line">  // 快速尝试在尾部添加</div><div class="line">  Node pred = tail;</div><div class="line">  <span class="keyword">if</span>(pred != null) &#123;</div><div class="line">    node.prev = pred;</div><div class="line">    <span class="keyword">if</span>(compareAndSetTail(pred, node)) &#123;</div><div class="line">      pred.next = node;</div><div class="line">      <span class="built_in">return</span> node;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  enq(node);</div><div class="line">  <span class="built_in">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">  <span class="keyword">for</span>(;;)&#123;</div><div class="line">    Node t = tail;</div><div class="line">    <span class="keyword">if</span>(t==null)&#123;</div><div class="line">      Node temp=new Node();</div><div class="line">      <span class="keyword">if</span>(compareAndSetHead(temp))</div><div class="line">        tail = head;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      node.prev = t;</div><div class="line">      <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</div><div class="line">        t.next = node;</div><div class="line">        <span class="built_in">return</span> t;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码通过使用compareAndSetTail(Node expect,Node update)方法来确保节点能够被线程安全添加。试想一下：如果使用一个普通的LinkedList来维护节点之间的关系，那么当一个线程获取了同步状态，而其他多个线程由于调用tryAcquire(int arg)方法获取同步状态失败而并发地被添加到LinkedList时，LinkedList将难以保证Node的正确添加，最终的结果可能是节点的数量有偏差，而且顺序也是混乱的。<br>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变得“串行化”了。<br>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">    boolean failed=<span class="literal">true</span>;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(;;)&#123;</div><div class="line">          final Node p = node.predecessor();</div><div class="line">          <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">              <span class="built_in">set</span>Head(node);</div><div class="line">              p.next = null;</div><div class="line">              failed=<span class="literal">false</span>;</div><div class="line">              <span class="built_in">return</span> interrupted;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt)</div><div class="line">              interrupted = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        <span class="keyword">if</span>(failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。<br>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为<br>适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</div><div class="line">      Node h = head;</div><div class="line">      <span class="keyword">if</span>(h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">       unparkSuccessor(h);</div><div class="line">       <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">     <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="共享同步状态获取与释放"><a href="#共享同步状态获取与释放" class="headerlink" title="共享同步状态获取与释放"></a>共享同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况<br><img src="/2017/12/31/java并发编程4-6/共享与独占.png" alt=""><br>左半部分，共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞，右半部分是独占式访问资源时，同一时刻其他访问均被阻塞。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; 0)</div><div class="line">           <span class="keyword">do</span>AcquireShared(arg);</div><div class="line">   &#125;</div><div class="line">private void <span class="keyword">do</span>AcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                final Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= 0) &#123;</div><div class="line">                        <span class="built_in">set</span>HeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        <span class="built_in">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            <span class="keyword">if</span>(failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。<br>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line"><span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">      <span class="keyword">do</span>ReleaseShared();</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。在分析该方法的实现前，先介绍一下响应中断的同步状态获取过程。在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private boolean <span class="keyword">do</span>AcquireNanos(int arg, long nanosTimeout)</div><div class="line">     throws InterruptedException &#123;</div><div class="line">     long lastTime = System.nanoTime();</div><div class="line">     final Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">     boolean failed = <span class="literal">true</span>;</div><div class="line">     try &#123;</div><div class="line">         <span class="keyword">for</span> (;;) &#123;</div><div class="line">             final Node p = node.predecessor();</div><div class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                 <span class="built_in">set</span>Head(node);</div><div class="line">                 p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                 failed = <span class="literal">false</span>;</div><div class="line">                 <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= 0)</div><div class="line">                 <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                 nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                 LockSupport.parkNanos(this, nanosTimeout);</div><div class="line">             long now = System.nanoTime();</div><div class="line">             nanosTimeout -= now - lastTime;</div><div class="line">             lastTime = now;</div><div class="line">             <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                 throw new InterruptedException();</div><div class="line">         &#125;</div><div class="line">     &#125; finally &#123;</div><div class="line">         <span class="keyword">if</span> (failed)</div><div class="line">             cancelAcquire(node);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object blocker,long nanos)方法返回）。如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，同步器会进入无条件的快速自旋。<br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑。acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态，而doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。<br><img src="/2017/12/31/java并发编程4-6/独占超时.png" alt=""></p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，支持重新进入的锁，表示该锁能够支持一个线程对一个资源的重复加锁。该锁还支持获取锁的公平性和非公平性的选择。<br>当一个线程调用Mutex的lock方法获取锁之后，如果再次调用lock方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。简单地说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。<br>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。<br>如果在决定时间下，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之则是不公平的。公平锁也就是等待时间最长的线程最优先获取到锁.ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。公平锁往往没有不公平锁效率高，但是并非任何场景下都是以TPS作为唯一指标，公平锁能够减少饥饿发生的概率，等待越久的线程越是能够得到优先满足。<br>1.实现重进入<br>重进入是是指任意线程获取到锁后再次获取到该锁不会被该锁所阻塞，该特性需要解决两个问题：<br>1）线程再次获取到锁，锁需要去识别获取锁的线程是否是当前占据锁的线程，如果是，再次成功获取<br>2）锁的最终释放，线程重复n次获取到锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。<br>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">int c = getState() - releases;</div><div class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">boolean free = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line">free = <span class="literal">true</span>;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">&#125;</div><div class="line"><span class="built_in">set</span>State(c);</div><div class="line"><span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。<br>2.公平锁与非公平锁的区别<br>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>回顾nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>为什么会出现线程连续获取锁的情况呢？回顾nonfairTryAcquire(int acquires)方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待.<br>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>之前提到的锁基本都是排他锁，这些锁同一时刻只能由一个线程进行访问，而读写锁在同一时刻只允许一个线程进行访问，而读写锁同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了提升。<br>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务、（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。<br>一般情况下，读写锁的性能都会比排它锁性能好，因为大多数场景读是多于写。读写锁比排它锁有更好的并发量和吞吐量。java并发包提供读写锁ReentrantReadWriteLock</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平和公平，吞吐量非公平优于公平</td>
</tr>
<tr>
<td>重进入</td>
<td>该锁支持重进入，以读写线程为例，读线程获取读锁后，能够再次获取读锁，写线程获取写锁后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级称为读锁</td>
</tr>
</tbody>
</table>
<h3 id="读写锁接口与示例"><a href="#读写锁接口与示例" class="headerlink" title="读写锁接口与示例"></a>读写锁接口与示例</h3><p>仅定义了获取读锁和写锁两个方法，即readLock和writeLock<br><img src="/2017/12/31/java并发编程4-6/读写锁监控.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">	static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">	static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">	static Lock r = rwl.readLock();</div><div class="line">	static Lock w = rwl.writeLock();</div><div class="line"></div><div class="line">	// 获取一个key对应的value</div><div class="line">	public static final Object get(String key) &#123;</div><div class="line">		r.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.get(key);</div><div class="line">		&#125; finally &#123;</div><div class="line">			r.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置key对应的value，并返回旧的value</div><div class="line">	public static final Object put(String key, Object value) &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.put(key, value);</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清空所有的内容</div><div class="line">	public static final void <span class="function"><span class="title">clear</span></span>() &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			map.clear();</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性</p>
<h3 id="读写锁实现设计"><a href="#读写锁实现设计" class="headerlink" title="读写锁实现设计"></a>读写锁实现设计</h3><p>主要包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级</p>
<h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果一个整形变量维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量分为两个部分，前十六位表示读，低十六位表示写。<br>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。<br>当S等于零时说明没有锁，当S不等于零时，当写状态(S&amp;0x0000FFFF)等于0时，则读状态不等于0，即读锁已被获取。</p>
<h4 id="写状态的获取与释放"><a href="#写状态的获取与释放" class="headerlink" title="写状态的获取与释放"></a>写状态的获取与释放</h4><p>写锁是一个支持可重入的排它锁，如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">           Thread current = Thread.currentThread();</div><div class="line">           int c = getState();</div><div class="line">           int w = exclusiveCount(c);</div><div class="line">           <span class="keyword">if</span> (c != 0) &#123;</div><div class="line">               // (Note: <span class="keyword">if</span> c != 0 and w == 0 <span class="keyword">then</span> shared count != 0)</div><div class="line">               <span class="keyword">if</span> (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                   <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                   throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">               // Reentrant acquire</div><div class="line">               <span class="built_in">set</span>State(c + acquires);</div><div class="line">               <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">               !compareAndSetState(c, c + acquires))</div><div class="line">               <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">           <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。<br>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount()方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">int c = getState();</div><div class="line">int nextc = c + (1 &lt;&lt; 16);</div><div class="line"><span class="keyword">if</span> (nextc &lt; c)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</div><div class="line"><span class="built_in">return</span> -1;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line"><span class="built_in">return</span> 1;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。<br>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。<br>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">processData</span></span>() &#123;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 必须先释放读锁</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">// 锁降级从写锁获取到开始</div><div class="line">writeLock.lock();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 准备数据的流程（略）</div><div class="line">update = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line">&#125; finally &#123;</div><div class="line">writeLock.unlock();</div><div class="line">&#125;</div><div class="line">// 锁降级完成，写锁降级为读锁</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">// 使用数据的流程（略）</div><div class="line">&#125; finally &#123;</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。<br>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类完成相应工作。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程<br><img src="/2017/12/31/java并发编程4-6/locksupport.png" alt=""><br>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<h2 id="condition接口"><a href="#condition接口" class="headerlink" title="condition接口"></a>condition接口</h2><p>任意一个java对象，都拥有一组监视器方法，主要包括wait、notify、notifyAll方法，这些方法与synchronize同步关键字配合，可以实现等待、通知模式。Condition接口也提供了类似Object监视器方法，与lock配合实现等待通知模式。<br><img src="/2017/12/31/java并发编程4-6/对比.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Lock lock=new ReentrantLock();</div><div class="line">	static Condition condition=lock.newCondition();</div><div class="line">	public static void <span class="function"><span class="title">wait_1</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.await();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void <span class="function"><span class="title">singal</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/31/java并发编程4-6/condition.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BoundedQueue&lt;T&gt; &#123;</div><div class="line">    T[] itemsObjects;</div><div class="line">	int addindex,removeIndex,count;</div><div class="line">	Lock lock=new ReentrantLock();</div><div class="line">	Condition notFull=lock.newCondition();</div><div class="line">	Condition notEmpty=lock.newCondition();</div><div class="line">	public void add(T t)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==itemsObjects.length)&#123;</div><div class="line">				notFull.await();</div><div class="line">			&#125;</div><div class="line">			itemsObjects[addindex]=t;</div><div class="line">			addindex++;</div><div class="line">			<span class="keyword">if</span>(addindex==itemsObjects.length)&#123;</div><div class="line">				addindex=0;</div><div class="line">			&#125;</div><div class="line">			count++;</div><div class="line">			notEmpty.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public T <span class="function"><span class="title">remove</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==0)&#123;</div><div class="line">				notEmpty.await();</div><div class="line">			&#125;</div><div class="line">			T t=itemsObjects[removeIndex];</div><div class="line">			<span class="keyword">if</span>(++removeIndex==itemsObjects.length)</div><div class="line">				removeIndex=0;</div><div class="line">			count--;</div><div class="line">			notFull.signal();</div><div class="line">			<span class="built_in">return</span> t;</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="condition的实现分析"><a href="#condition的实现分析" class="headerlink" title="condition的实现分析"></a>condition的实现分析</h3><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是FIFO的操作，在队列中的每个节点都包含一个线程的引用，该线程就是在Condition对象等待的线程，如果一个对象调用Condition.await，那么线程会释放锁，构造成节点加入等待队列并进入等待状态。点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node<br>一个Condition包含一个等待队列，Condition拥有首节点和尾节点，当前线程调用Condition.await，将会以当前线程构造节点，并将节点从尾部加入等待队列。<br><img src="/2017/12/31/java并发编程4-6/等待队列基本结构.png" alt=""><br>Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向他，并且更新尾节点。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br>在Object的监视器模型上，一个对象拥有一个同步队列和同步队列，而并发包中的Lock拥有一个同步队列和多个等待队列。<br><img src="/2017/12/31/java并发编程4-6/同步与等待.png" alt=""></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await方法中返回时，当前线程一定获取了Condition的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        throw new InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    long savedState = fullyRelease(node);</div><div class="line">    int interruptMode = 0;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步状态中的后继节点，然后当前线程会进入等待</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal方法，将会唤醒等待队列中等待最长的节点，在唤醒节点前，会将节点移到同步队列中。<br><img src="/2017/12/31/java并发编程4-6/唤醒.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void <span class="function"><span class="title">signal</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">Node first = firstWaiter;</div><div class="line"><span class="keyword">if</span> (first != null)</div><div class="line"><span class="keyword">do</span>Signal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。<br>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。<br>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/26/java并发编程前三章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/26/java并发编程前三章/" itemprop="url">java并发编程前三章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-26T17:08:19+08:00">
                2017-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>即使是单核也支持多线程执行代码，cpu通过给每个线程分配cpu时间片来实现这个机制。时间片是cpu分配给每个线程的时间，因为时间片非常短，所以cpu通过不停地切换线程执行，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。<br>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="多线程一定快吗"><a href="#多线程一定快吗" class="headerlink" title="多线程一定快吗"></a>多线程一定快吗</h3><p>当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<h3 id="测试上下文切换的次数"><a href="#测试上下文切换的次数" class="headerlink" title="测试上下文切换的次数"></a>测试上下文切换的次数</h3><p>使用Lmbench3可以测量上下文切换的时长，使用vmstat可以测量上下文切换的次数。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。<br>·无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。<br>·CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<br>·使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。<br>·协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h3 id="减少上下文切换实战"><a href="#减少上下文切换实战" class="headerlink" title="减少上下文切换实战"></a>减少上下文切换实战</h3><p>第一步用jstack命令dump线程信息<br>第二步统计所有线程分别处于什么状态<br>第三步打开dump文件查看处于waiting的线程在做什么<br>第四步根据查看发现很多线程都在waiting，调整线程池配置<br>第五步重启服务器再统计</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>避免死锁的方法：<br>避免一个线程同时获得多个锁；<br>避免一个锁内同时占用多个资源，尽量保证一个锁只占用一个资源<br>尝试使用定时锁来代替内部锁机制,lock.tryLock(timeout)<br>对于数据库操作，加锁和解锁必须在一个数据库的连接里，否则会出现解锁失败的现象</p>
<h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><h3 id="什么是资源限制"><a href="#什么是资源限制" class="headerlink" title="什么是资源限制"></a>什么是资源限制</h3><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。例如带宽的上传下载速度、硬盘读写速度和cpu的处理速度。软件资源限制有数据库连接数和socket的连接数</p>
<h3 id="资源限制带来的问题"><a href="#资源限制带来的问题" class="headerlink" title="资源限制带来的问题"></a>资源限制带来的问题</h3><p>资源限制引发的问题导致并发可能不会加快，反而变慢，原因在于增加了上下文的切换和资源调度的时间</p>
<h3 id="如何解决资源限制问题"><a href="#如何解决资源限制问题" class="headerlink" title="如何解决资源限制问题"></a>如何解决资源限制问题</h3><p>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制可以使用线程池将socket和数据库连接复用，或者在调用对方webservice接口获取数据时</p>
<h3 id="在资源限制情况下进行并发编程"><a href="#在资源限制情况下进行并发编程" class="headerlink" title="在资源限制情况下进行并发编程"></a>在资源限制情况下进行并发编程</h3><p>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接</p>
<h1 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h1><h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="定义及其实现原理"><a href="#定义及其实现原理" class="headerlink" title="定义及其实现原理"></a>定义及其实现原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">instance = new Singleton();//instance是volatile变量</div><div class="line">//汇编</div><div class="line">0x01a3de1d: movb \<span class="variable">$0</span>×0,0×1104800(%esi);0x01a3de24: lock addl \<span class="variable">$0</span>×0,(%esp);</div></pre></td></tr></table></figure>
<p>lock指令会在多核处理器引发两件事情：</p>
<ol>
<li>将当前的缓存处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使其他cpu缓存该地内存址的数据无效</li>
</ol>
<p><em>缓存一致性协议：在多处理器中，为了保证各个处理器的缓存是一致的，就会实现缓存一致性，每个处理器会通过嗅探在总线传播过来的数据来检查自己缓存的数据是否过期，当处理器发现自己缓存行对应的内存地址被修改时，就会将自己的缓存状态设为失效状态，当处理器对这个数据进行访问时，就会重新从系统内存中把数据读到处理器缓存中。</em></p>
<h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>Linked-TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能<br>一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。<br>为什么追加64字节能够提高并发编程的效率呢？因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。那么是不是在使用volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。<br>·缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。<br>·共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>java中每一个对象都可以成为锁，具体表现形式如下：<br>对于普通的同步方法，锁是当前实例对象<br>对于静态的同步方法，锁是当前类的class对象<br>对于同步方法快，锁是Sychronized括号里配置的对象。<br>JVM基于进入和退出monitor对象实现方法同步和代码块同步，但两个实现细节不一样，代码块同步是通过monitorenter和monitorexit指令实现，方法同步使用另一种方式。<br>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>synchronized用的锁是存在java对象头里。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果非数组，用2字宽存储对象头。<br><img src="/2017/12/26/java并发编程前三章/java对象头.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/锁状态.png" alt=""></p>
<h3 id="锁升级与对比"><a href="#锁升级与对比" class="headerlink" title="锁升级与对比"></a>锁升级与对比</h3><p>java SE1.6中锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量锁状态、重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h5 id="关闭锁"><a href="#关闭锁" class="headerlink" title="关闭锁"></a>关闭锁</h5><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果进程间存在着锁竞争会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋消耗cpu</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程使用不使用自旋，不用消耗cpu</td>
<td>线程阻塞，响应速度非常慢</td>
<td>追求吞吐量。同步块执行时间较长</td>
</tr>
</tbody>
</table>
<h2 id="原子操作实现原理"><a href="#原子操作实现原理" class="headerlink" title="原子操作实现原理"></a>原子操作实现原理</h2><p>原子操作意为不可被中断的一个或一系列操作</p>
<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><p>缓存行、比较并交换、cpu流水线、内存顺序冲突</p>
<h3 id="处理器实现原子操作"><a href="#处理器实现原子操作" class="headerlink" title="处理器实现原子操作"></a>处理器实现原子操作</h3><p>处理器通过总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性</p>
<h4 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h4><p>总线锁就是使用处理器提供的一个lock信号，当一个总线输出此信号时，其他处理器的请求将会被阻塞住，那么该处理器就可以独占共享内存。</p>
<h4 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h4><p>缓存锁定是内存区域如果被缓存在处理器的缓存行中，并且在lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言lock信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性会阻止同时修改由两个以上的处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。<br>但是有两种情况下处理器不会使用缓存锁定。<br>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。<br>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<h4 id="java如何实现原子操作"><a href="#java如何实现原子操作" class="headerlink" title="java如何实现原子操作"></a>java如何实现原子操作</h4><p>java中可以通过使用锁和cas实现原子操作<br>1.使用循环cas操作<br>2.cas实现原子操作的三大问题</p>
<ul>
<li>A-&gt;B-&gt;A问题<br>解决思路是使用版本号，在变量前面追加版本号，每次变量改变版本号加一。这个<br>类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
</ul>
<p>3.使用锁机制实现原子操作<br>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><h2 id="java内存查询的基础"><a href="#java内存查询的基础" class="headerlink" title="java内存查询的基础"></a>java内存查询的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><p>两个关键问题：线程之间如何通信以及线程之间如何同步。线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐性通信。在消息传递的并发模型中，线程没有公共状态，线程必须通过发送信息来显性通信。<br>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h3 id="java内存模型的抽象结构"><a href="#java内存模型的抽象结构" class="headerlink" title="java内存模型的抽象结构"></a>java内存模型的抽象结构</h3><p>在java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程间共享。局部变量、方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题。也不受内存模型的影响。<br>java线程的通信由java内存模型(JMM)控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写的共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br><img src="/2017/12/26/java并发编程前三章/java内存模型.png" alt=""><br>如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。<br>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>2）线程B到主内存中去读取线程A之前已更新过的共享变量。<br><img src="/2017/12/26/java并发编程前三章/线程通信.png" alt=""><br>本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p>重排序分为三类：<br>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="/2017/12/26/java并发编程前三章/重排序.png" alt=""><br>1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>现代处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>在JMM中，如果一个操作执行结果需要对另一个操作可见，那么这两个操作必须存在happens-before关系。这里提到的两个操作可以是一个线程内，也可以是不同线程间。<br>·程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问一个变量，且这两个操作有一个是写操作，那么这两个操作就存在数据依赖性。<br>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<br>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as if serial语义"></a>as if serial语义</h3><p>不管怎么重排序，程序的执行结果不能被改变。</p>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.这时B不一定能观察到线程A的写入。因为两个线程之间没有数据依赖性。</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>数据竞争：在一个线程中写一个变量、在另一个线程中读一个变量、而且写和读之间没有通过同步来排序。<br>如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>两大特性：1.一个线程内的所有操作必须按照程序的顺序来执行。2.所有线程只能看到单一的操作执行顺序。在顺序一致性模型中，每个操作都必须原子执行且立刻对所有线程可见。<br>顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摇摆的开关可以连接到任意一个线程，同时每个线程都按照程序的顺序执行内存的读写操作。<br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性模型"><a href="#同步程序的顺序一致性模型" class="headerlink" title="同步程序的顺序一致性模型"></a>同步程序的顺序一致性模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。<br>JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。为了实现最小安全性，JVM在堆上分配对象，域会默认初始化。<br>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。<br>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。<br>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的<br>操作会按程序的顺序执行<br>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程<br>能看到一致的操作执行顺序。<br>3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><p>理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。<br>锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>volatile变量自身具有下列特性：<br>可见性。对一个volatile变量的读，总能看到任意线程对这个volatile变量的写入。<br>原子性。对任意单个volatile变量的读/写具有原子性。但类似volatile++这种复合操作不具有原子性。</p>
<h3 id="volatile写-读建立的happens-before"><a href="#volatile写-读建立的happens-before" class="headerlink" title="volatile写-读建立的happens-before"></a>volatile写-读建立的happens-before</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class VolatileExample &#123;</div><div class="line"> int a = 0;</div><div class="line"> volatile boolean flag = <span class="literal">false</span>;</div><div class="line"> public void <span class="function"><span class="title">writer</span></span>() &#123;</div><div class="line">    a = 1;　　　　　// 1</div><div class="line">    flag = <span class="literal">true</span>;　　　// 2</div><div class="line"> &#125;</div><div class="line"> public void <span class="function"><span class="title">reader</span></span>() &#123;</div><div class="line">    <span class="keyword">if</span>(flag)&#123;  //3</div><div class="line">      int i=a; //4</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据程序次序规则，1 happens-before 2;3 happens-before 4<br>根据volatile规则，2 happens-before 3<br>根据happens-before的传递性规则，1 happens-before 4</p>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。<br>volatile的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置<br>为无效，线程接下来从主内存中读取共享变量。</p>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p><img src="/2017/12/26/java并发编程前三章/重排序规则.png" alt=""><br>·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。<br>·在每个volatile写操作的前面插入一个StoreStore屏障。<br>·在每个volatile写操作的后面插入一个StoreLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadStore屏障。<br><img src="/2017/12/26/java并发编程前三章/volatile写指令.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/volatile读指令.png" alt=""></p>
<h3 id="jsr-133为什么要增强volatile语句"><a href="#jsr-133为什么要增强volatile语句" class="headerlink" title="jsr-133为什么要增强volatile语句"></a>jsr-133为什么要增强volatile语句</h3><p>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><h3 id="锁的释放获取"><a href="#锁的释放获取" class="headerlink" title="锁的释放获取"></a>锁的释放获取</h3><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MonitorExample &#123;</div><div class="line">int a = 0;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>() &#123;　　　　// 1</div><div class="line">a++;　　　　　　　　　　// 2</div><div class="line">&#125;　　　　　　　　　　　　// 3</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>() &#123;　　　// 4</div><div class="line">int i = a;　　　　　　　　// 5</div><div class="line">……</div><div class="line">&#125;　　　　　　　　　　　　// 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。<br>1）根据程序次序规则，1 happens-before 2,2 happens-before 3;4 happens-before 5,5 happens-before 6。<br>2）根据监视器锁规则，3 happens-before 4。<br>3）根据happens-before的传递性，2 happens-before 5。</p>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取到锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>总结：线程A释放一个锁，实质是线程A向接下来将要获取这个锁的某个线程发出了对共享变量所做修改的消息。线程B获取一个锁，实质是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。<br>线程A释放锁，随后线程B获取这个锁，这个过程实质是线程A通过主内存向线程B发送消息。</p>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">ReentrantLock lock=new ReentrantLock();</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">    lock.lock();</div><div class="line">    try&#123;</div><div class="line">       a++;</div><div class="line">    &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">    &#125;finally&#123;</div><div class="line">      lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  lock.lock();</div><div class="line">  try&#123;</div><div class="line">    int i=a;</div><div class="line">  &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">  &#125;finally&#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer(AQS)，AQS使用一个整形的volatile(state)变量来维护同步状态。<br><img src="/2017/12/26/java并发编程前三章/ReentrantLock类图.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，使用公平锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ReentrantLock:lock();</div><div class="line">FairSync:lock();</div><div class="line">AbstractQueuedSynchronizer:acquire(int arg);</div><div class="line">ReentrantLock:tryAcquire(int acquire);</div><div class="line">FairSync:</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    final Thread current = Thread.currentThread();</div><div class="line">    int c = getState();</div><div class="line">    <span class="keyword">if</span>(c == 0)&#123;</div><div class="line">        <span class="keyword">if</span>(!hasQueuedPredecessors() &amp;&amp;compareAndSetState(0, acquires))&#123;</div><div class="line">            <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</div><div class="line">      int nextc = c + acquires;</div><div class="line">      <span class="keyword">if</span>(nextc &lt; 0)</div><div class="line">          throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">      <span class="built_in">set</span>State(nextc);</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加锁方法首先读volatile变量state<br>在使用公平锁时，解锁方法unlock()调用轨迹如下。<br>1）ReentrantLock:unlock()。<br>2）AbstractQueuedSynchronizer:release(int arg)。<br>3）Sync:tryRelease(int releases)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    int c =getState()- releases;</div><div class="line">    <span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line">    boolean free = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(c == 0) &#123;</div><div class="line">        free = <span class="literal">true</span>;</div><div class="line">        <span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span>State(c);</div><div class="line">    <span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在释放锁的最后写volatile变量state。<br>公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。<br>这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。<br>1）ReentrantLock:lock()。<br>2）NonfairSync:lock()。<br>3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。<br>现在对公平锁和非公平锁的内存语义做个总结。<br>·公平锁和非公平锁释放时，最后都要写一个volatile变量state。<br>·公平锁获取时，首先会去读volatile变量。<br>·非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</p>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>java的CAS同时具有volatile读和volatile写的内存语义，因此java线程之间的通信有了下面四种方式：<br>1）A线程写volatile变量，随后B线程读这个volatile变量。<br>2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。<br>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。<br>首先，声明共享变量为volatile。<br>然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
<h2 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h2><p>对final域的读和写更像是普通的变量访问。</p>
<h3 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h3><p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用<br>变量，这两个操作之间不能重排序。<br>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能<br>重排序。</p>
<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><p>1）JMM禁止编译器把final域的写重排序到构造函数之外；<br>2）编译器会在final域写之后，构造函数return之前，插入一个storestore。这个屏障会禁止处理器把final域的写重排序到构造函数之外。<br>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><p>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。<br>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h3 id="final为引用类型"><a href="#final为引用类型" class="headerlink" title="final为引用类型"></a>final为引用类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FinalReferenceExample &#123;</div><div class="line">final int[] intArray; // final是引用类型</div><div class="line">static FinalReferenceExample obj;</div><div class="line">public <span class="function"><span class="title">FinalReferenceExample</span></span> () &#123; // 构造函数</div><div class="line">intArray = new int[1]; // 1</div><div class="line">intArray[0] = 1; // 2</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerOne</span></span> () &#123; // 写线程A执行</div><div class="line">obj = new FinalReferenceExample (); // 3</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerTwo</span></span> () &#123; // 写线程B执行</div><div class="line">obj.intArray[0] = 2; // 4</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">reader</span></span> () &#123; // 读线程C执行</div><div class="line"><span class="keyword">if</span>(obj != null) &#123; // 5</div><div class="line">int temp1 = obj.intArray[0]; // 6</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader()方法.JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<h3 id="为什么final引用不能从构造函数内“溢出”"><a href="#为什么final引用不能从构造函数内“溢出”" class="headerlink" title="为什么final引用不能从构造函数内“溢出”"></a>为什么final引用不能从构造函数内“溢出”</h3><p>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程#都能看到这个final域在构造函数中被初始化之后的值。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><p>JMM目标：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。<br>JMM保证两点：</p>
<ol>
<li>JMM向程序员提供的happens-before能够保证程序员的需求。JMM的happens-before规则不但简单且易懂，而且向程序员提供了足够强的内存可见性保证。</li>
<li>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实在遵循一个基本原则：只要不改变程序的执行结果，编译器和处理器怎么优化都可以。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ol>
<h3 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h3><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作执行顺序排在第二个操作之前。<br>2）两个操作之间存在着happens-before关系，并不意味着java平台具体实现按照happens-before关系指定的顺序来执行。如果重排序的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法。<br>上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。<br>上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。<br>·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。<br>·as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><ol>
<li>程序顺序规则：一个程序的每个操作，happens-before与该线程的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before与后续对这个volatile的读</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执行操作ThreadB.start,那么A线程的start操作happens-before线程B的任何操作。</li>
<li>join规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ol>
<h2 id="双重检查锁和延迟初始化"><a href="#双重检查锁和延迟初始化" class="headerlink" title="双重检查锁和延迟初始化"></a>双重检查锁和延迟初始化</h2><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<h3 id="双重锁检查锁定的由来"><a href="#双重锁检查锁定的由来" class="headerlink" title="双重锁检查锁定的由来"></a>双重锁检查锁定的由来</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public synchronized static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;</div><div class="line">        single=new Singleton();</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美。<br>·多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。<br>·在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h3 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h3><p>single=new Singleton();创建了一个对象。这一行代码可以分解为如下的3行伪代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div><div class="line">single = memory;　　// 3：设置instance指向刚分配的内存地址</div></pre></td></tr></table></figure></p>
<p>上面3行伪代码中的2和3之间，可能会被重排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">instance = memory;　　// 3：设置instance指向刚分配的内存地址</div><div class="line">// 注意，此时对象还没有被初始化！</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/26/java并发编程前三章/多线程执行时序.png" alt=""></p>
<h3 id="基于volatile解决"><a href="#基于volatile解决" class="headerlink" title="基于volatile解决"></a>基于volatile解决</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当声明对象的引用为volatile后,伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><p>VM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class InstanceFactory&#123;</div><div class="line"></div><div class="line">  private static class InstanceHolder&#123;</div><div class="line">    public static Instance instance=new Instance();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> public static Instance <span class="function"><span class="title">getInstance</span></span>()&#123;</div><div class="line">         <span class="built_in">return</span> InstanceHoleder.instance;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了<br>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。<br>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。<br>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。<br>第4阶段：线程B结束类的初始化处理。<br>第5阶段：线程C执行类的初始化的处理。<br>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。</p>
<h2 id="java内存模型综述"><a href="#java内存模型综述" class="headerlink" title="java内存模型综述"></a>java内存模型综述</h2><h3 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h3><p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。<br>·放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。<br>·在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>·在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了RelaxedMemory Order内存模型（简称为RMO）和PowerPC内存模型。<br>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的<br>JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h3 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h3><p>JMM是一种语言参考模型，处理器内存模型是硬件级的内存模型，顺序一致性模型是一个理论参考模型。<br>常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按照程序类型，java程序的内存可见性保证可以分为3类：</p>
<ul>
<li>单线程程序<br>单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果跟该程序在顺序一致性模型中执行的结果一样。</li>
<li>正确同步的多线程程序<br>正确同步的多线程程序的执行将具有顺序一致性。这是JMM关注的重点。JMM通过限制编译器和处理器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>对于未同步或未正确同步的多线程程序<br>JMM提供了最小安全保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，false，null）</li>
</ul>
<p>最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们“发生”的时间点也不同。最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会无中生<br>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h3 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h3><ul>
<li>增强volatile变量的内存语义。旧内存模型允许volatile变量和普通变量进行重排序。JSR-133严格限制volatile变量与普通变量的重排序，使得volatile的写和读和和锁的释放-获取有相同的语义</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量可能有所不同。为此jsr-133增加两个重排规则，在保证final引用不会从构造函数内溢出的情况，final具有了初始化的安全。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
