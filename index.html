<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/设计模式之禅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/设计模式之禅/" itemprop="url">设计模式之禅</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T23:21:46+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/02/java8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/02/java8/" itemprop="url">java8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-02T15:22:38+08:00">
                2017-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>java8新特性：Lambda（匿名函数）、流、默认方法</p>
<h2 id="java中的函数"><a href="#java中的函数" class="headerlink" title="java中的函数"></a>java中的函数</h2><p>java8新增函数作为值的一种新形式。</p>
<h3 id="方法和-Lambda-作为一等公民"><a href="#方法和-Lambda-作为一等公民" class="headerlink" title="方法和 Lambda 作为一等公民"></a>方法和 Lambda 作为一等公民</h3><p>Java 8的第一个新功能是方法引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> File[] hiddenFiles= new File(<span class="string">"."</span>).listFiles(new <span class="function"><span class="title">FileFilter</span></span>()&#123;</div><div class="line">     public boolean accept(File file)&#123;</div><div class="line">         <span class="built_in">return</span> file.isHidden();</div><div class="line">     &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">File[] hiddenFiles1 = new File(<span class="string">"."</span>).listFiles(File::isHidden);</div></pre></td></tr></table></figure></p>
<h3 id="传递代码"><a href="#传递代码" class="headerlink" title="传递代码"></a>传递代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static boolean isGreenApple(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.color.equals(<span class="string">"green"</span>);</div><div class="line">	&#125;</div><div class="line">	public static boolean isHeavy(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.weight&gt;150;</div><div class="line">	&#125;</div><div class="line">	public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list,Predicate&lt;Apple&gt; p)&#123;</div><div class="line">		List&lt;Apple&gt; result=new ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(Apple apple:list)&#123;</div><div class="line">			<span class="keyword">if</span>(p.test(apple))</div><div class="line">			result.add(apple);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		List&lt;Apple&gt; list=new ArrayList&lt;Apple&gt;();</div><div class="line">		list.add(new Apple(150, <span class="string">"red"</span>));</div><div class="line">		filterApple(list, AppleExample::isHeavy);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从传递方法到Lambda"><a href="#从传递方法到Lambda" class="headerlink" title="从传递方法到Lambda"></a>从传递方法到Lambda</h3><p>不过Java 8也解决了这个问题，它引入了一套新记法（匿名函数或Lambda）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">filterApple(inventory, (Apple a) -&gt; <span class="string">"green"</span>.equals(a.getColor()) );</div><div class="line">filterApple(inventory, (Apple a) -&gt; a.weight &gt; 150 );</div></pre></td></tr></table></figure></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =</div><div class="line">transactions.stream()</div><div class="line">.filter((Transaction t) -&gt; t.getPrice() &gt; 1000)</div><div class="line">.collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<p>Stream允许并提倡并行处理一个 Stream 中的元素。虽然可能乍看上去有点儿怪，但筛选一个 Collection （filterApples 应用在一个List 上）的最快方法常常是将其转换为 Stream ，进行并行处理，然后再转换回 List<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//顺序处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.stream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div><div class="line">//并行处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div></pre></td></tr></table></figure></p>
<p>库会负责分块，即把大的流分成几个小的流，以便并行处理。其次，流提供的这个几乎免费的并行，只有在传递给 filter 之类的库方法的方法不会互动（比方说有可变的共享对象）时才能工作。</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8的解决方法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名<br>了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现） ，而不是由实现类提供。<br>这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明<br>中使用新的 default 关键字来表示这一点。例如，在Java 8里，你现在可以直接对 List 调用 sort 方法。它是用Java 8  List 接口中如下所示的默认方法实现的，它会调用 Collections.sort 静态方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">Collections.sort(this, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这意味着 List 的任何实体类都不需要显式实现 sort ，而在以前的Java版本中，除非提供了sort 的实现，否则这些实体类在重新编译时都会失败。</p>
<h1 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h1><h2 id="应对不断变化的需求"><a href="#应对不断变化的需求" class="headerlink" title="应对不断变化的需求"></a>应对不断变化的需求</h2><h3 id="初试牛刀：筛选绿苹果"><a href="#初试牛刀：筛选绿苹果" class="headerlink" title="初试牛刀：筛选绿苹果"></a>初试牛刀：筛选绿苹果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把颜色作为参数"><a href="#把颜色作为参数" class="headerlink" title="把颜色作为参数"></a>把颜色作为参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory,String color) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(color.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三次尝试对属性做筛选"><a href="#第三次尝试对属性做筛选" class="headerlink" title="第三次尝试对属性做筛选"></a>第三次尝试对属性做筛选</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span> (Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>((flag&amp;&amp;apple.getColor().equals(color))||(!flag&amp;&amp;apple.getWeight()&gt;150))&#123;</div><div class="line">      result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h2><p>1.传递代码/行为，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt;inventory, ApplePredicate p)&#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">   <span class="keyword">if</span>(p.test(apple))&#123;</div><div class="line">      result.add(apple);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">  ApplePredicate p=new AppleRedAndHeavyPredicate();</div><div class="line">  List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.多种行为，一种参数<br>行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应用的行为区分开来。这样你可以重复使用同一个方法，给它不同的行为来达到不同的目的。<br><img src="/2017/12/02/java8/行为参数化.PNG" alt=""></p>
<h2 id="对付啰嗦"><a href="#对付啰嗦" class="headerlink" title="对付啰嗦"></a>对付啰嗦</h2><p>当要把新的行为传递给filterApples方法的时候，你不得不声明好几个实现 ApplePredicate接口的类，然后实例化好几个只会提到一次的ApplePredicate对象.</p>
<h3 id="使用匿名类"><a href="#使用匿名类" class="headerlink" title="使用匿名类"></a>使用匿名类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new <span class="function"><span class="title">ApplePredicate</span></span>() &#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>匿名类在GUI经常用到，但是有缺点：1.很笨重；2.用起来费解。</p>
<h3 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; result=filterApples(list,(Apple a)-&gt;<span class="string">"red"</span>.equals(a.color));</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/参数化和值参数化.PNG" alt=""></p>
<h3 id="List抽象化"><a href="#List抽象化" class="headerlink" title="List抽象化"></a>List抽象化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">   boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list,Predicate&lt;T&gt; p)&#123;</div><div class="line">   List&lt;T&gt; result=new ArrayList&lt;T&gt;();</div><div class="line">   <span class="keyword">for</span>(T t:list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(t))&#123;</div><div class="line">       result.add(t);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="真实的例子"><a href="#真实的例子" class="headerlink" title="真实的例子"></a>真实的例子</h2><h3 id="使用Comparator排序"><a href="#使用Comparator排序" class="headerlink" title="使用Comparator排序"></a>使用Comparator排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a,Apple b)-&gt; a.getWeight().compareTo(b.getWeight()));</div></pre></td></tr></table></figure>
<h3 id="用runnable执行代码块"><a href="#用runnable执行代码块" class="headerlink" title="用runnable执行代码块"></a>用runnable执行代码块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=new Thread(()-&gt;System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure>
<h3 id="GUI例子"><a href="#GUI例子" class="headerlink" title="GUI例子"></a>GUI例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnAction((ActionEvent event)-&gt;lable.setText(<span class="string">"hello"</span>));</div></pre></td></tr></table></figure>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h2><p>Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：没有名称、有参数列表函数主体、返回类型、可能还会有可抛出的异常列表。<br>特点：<br>匿名：不像普通方法有明确的名称：写得少而想得多<br>函数：Lambda函数不像方法那样属于某个特定的类。但和方法一样，有参数列表，函数主体，返回类型，还可能有可抛出的异常列表。<br>传递：Lambda表达式可作为参数传递给方法或者存储在变量中<br>简洁：无需像匿名类写很多模板代码<br><img src="/2017/12/02/java8/Lambda表达式.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//有效Lambda表达式</div><div class="line">(String s)-&gt; s.length()</div><div class="line">(Apple a)-&gt; a.weigth&gt;150</div><div class="line">(int x,int y)-&gt;&#123;</div><div class="line">   System.out.println(<span class="string">"result:"</span>);</div><div class="line">   System.out.println(x+y);</div><div class="line">&#125;</div><div class="line">()-&gt;42</div><div class="line">(Apple a1,Apple a2)-&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<p>Lambda语法：(parameters)-&gt;expression或者(parameters)-&gt;{statements;}</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>布尔表达式：(List<string> list)-&gt; list.isEmpty()<br>创建一个对象:()-&gt;new Apple(10):<br>消费一个对象:(Apple a)-&gt;{System.out.println(a.getWeight());}<br>从一个对象中选择或选取:(String s)-&gt; s.length()<br>组合两个值:(int a,int b)-&gt;a*b<br>三比较两个对象:(Apple a1,Apple a2)-&gt; a1.getWeight.compareTo(12.getWeight())</string></p>
<h2 id="在哪里以及如何使用Lambda"><a href="#在哪里以及如何使用Lambda" class="headerlink" title="在哪里以及如何使用Lambda"></a>在哪里以及如何使用Lambda</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只定义一个抽象方法的接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface Runnable&#123;</div><div class="line">  public void run();</div><div class="line">&#125;</div><div class="line">public interface Comparator&lt;T&gt;&#123;</div><div class="line">  public int compare(T o1,T o2);</div><div class="line">&#125;</div><div class="line">public interface Callable&lt;T&gt;&#123;</div><div class="line">  public T call();</div><div class="line">&#125;</div><div class="line">public interface PrivilegedAction&lt;V&gt;&#123;</div><div class="line">  V run();</div><div class="line">&#125;</div><div class="line">public interface ActionListener extends EventListener&#123;</div><div class="line">  void actionPerformed(ActionEvent e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化。</p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫做函数描述符。例如runnable接口是()-&gt;void.<br>如果你用@FunctionalInterface 定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。@FunctionalInter-face不是必需的，但对于为此设计的接口而言,使用它是比较好的做法。它就像是@Override标注表示方法被重写了.</p>
<h2 id="环绕执行模式"><a href="#环绕执行模式" class="headerlink" title="环绕执行模式"></a>环绕执行模式</h2><p>通过一个例子，看看在实践中如何利用Lambda和行为参数化来让代码更为灵活。资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static String processFile() throws IOException &#123;</div><div class="line">  try (BufferedReader br =new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">    <span class="built_in">return</span> br.readLine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="行为参数化-1"><a href="#行为参数化-1" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>你只能读文件的第一行。如果你想要返回头两行？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String result = processFile((BufferedReader br) -&gt;br.readLine() + br.readLine());</div></pre></td></tr></table></figure></p>
<h3 id="使用函数式接口传递行为"><a href="#使用函数式接口传递行为" class="headerlink" title="使用函数式接口传递行为"></a>使用函数式接口传递行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public class BufferedReaderProcessor&#123;</div><div class="line">  String process(BufferedReader reader) throws IOException;</div><div class="line">&#125;</div><div class="line">public static String processFile(BufferedReaderProcessor p) throws IOException&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="执行一个行为"><a href="#执行一个行为" class="headerlink" title="执行一个行为"></a>执行一个行为</h3><p>任何 BufferedReader -&gt; String 形式的Lambda都可以作为参数来传递，因为它们符合BufferedReaderProcessor 接口中定义的 process 方法的签名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static String processFile(BufferedReaderProcessor p) throws</div><div class="line">IOException &#123;</div><div class="line">  try (BufferedReader br =</div><div class="line">      new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">      <span class="built_in">return</span> p.process(br);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="传递Lambda"><a href="#传递Lambda" class="headerlink" title="传递Lambda"></a>传递Lambda</h3><p>现在你就可以通过传递不同的Lambda重用processFile方法，并以不同的方式处理文件了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String oneLine=processFile((BufferedReader br)-&gt; br.readLine());</div><div class="line">String twoLine= processFile((BufferedReader br)-&gt; br.readLine()+br.readLine());</div></pre></td></tr></table></figure></p>
<h2 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h2><p>java Api已经有几个函数式接口，比如Comparable、Runnable和Callable。</p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>java.util.function.Predicate<t> 接口定义了一个名叫test的抽象方法，它接受泛型T对象并返回一个boolean这恰恰和你先前创建的一样，现在就可以直接使用了。在你需要表示一个涉及类型T的布尔表达式时，就可以使用这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">    boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</div><div class="line"> List&lt;T&gt; results = new ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(s))&#123;</div><div class="line">       results.add(s);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> <span class="built_in">return</span> results;</div><div class="line">&#125;</div><div class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt;!s.isEmpty();</div><div class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings,nonEmptyStringPredicate);</div></pre></td></tr></table></figure></t></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>java.util.Consumer<t>定义了一个名为accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用<br>这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Consumer&lt;T&gt;&#123;</div><div class="line">   void accept(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; void <span class="keyword">for</span>Each(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123;</div><div class="line">   <span class="keyword">for</span>(T i: list)&#123;</div><div class="line">       c.accept(i);</div><div class="line">   &#125;</div><div class="line">&#125;  </div><div class="line"><span class="keyword">for</span>Each(Arrays.asList(1,2,3,4,5),(Integer i)-&gt;System.out.println(i));</div></pre></td></tr></table></figure></t></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>java.util.function.Function<t, r=""> 接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Function&lt;T,R&gt;&#123;</div><div class="line">  R apply(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list,Function&lt;T,R&gt; f)&#123;</div><div class="line">  List&lt;R&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">    result.add(f.apply(s));</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">List&lt;Integer&gt; l = map(</div><div class="line">Arrays.asList(<span class="string">"lambdas"</span>,<span class="string">"in"</span>,<span class="string">"action"</span>),</div><div class="line">(String s) -&gt; s.length()</div><div class="line">);</div></pre></td></tr></table></figure></t,></p>
<p>Java类型要么是引用类型（比如Byte、Integer、Object、List），要么是原始类型（比如int、double、byte、char）。但是泛型（比如Consumer<t> 中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的.因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing）。相反的是拆箱操作。</t></p>
<h2 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h2><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>Lambda的类型是从使用Lambda的上下文推断。上下文中Lambda表达式的需要的类型称为目标类型。<br><img src="/2017/12/02/java8/Lambda类型检查.png" alt=""><br>首先，你要找出filter方法的声明。<br>第二，要求它是Predicate<apple>（目标类型）对象的第二个正式参数。<br>第三，Predicate<apple>是一个函数式接口，定义了一个叫作test的抽象方法<br>第四，test 方法描述了一个函数描述符，它可以接受一个 Apple ，并返回一个 boolean 。<br>最后，filter 的任何实际参数都必须匹配这个要求</apple></apple></p>
<h3 id="同样的Lambda，不同的接口"><a href="#同样的Lambda，不同的接口" class="headerlink" title="同样的Lambda，不同的接口"></a>同样的Lambda，不同的接口</h3><p>有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Callable&lt;Integer&gt; c = () -&gt; 42;</div><div class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; 42;</div></pre></td></tr></table></figure></p>
<p>类型检查<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为什么下面的代码不能编译</div><div class="line">Object o = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div><div class="line">答案：Lambda表达式的上下文是 Object （目标类型） 。但 Object 不是一个函数式接口。</div><div class="line">为了解决这个问题，你可以把目标类型改成 Runnable ，它的函数描述符是 () -&gt; void ：</div><div class="line">Runnable r = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。显示类型可读性更高<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div></pre></td></tr></table></figure></p>
<p>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，或事实上是final 。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量 this） 例如，下面的代码无法编译，因为 portNumber变量被赋值两次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div><div class="line">portNumber = 31337</div></pre></td></tr></table></figure></p>
<p>为什么局部变量有这些限制。<br>第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。<br>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式.<br>闭包<br>你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。 这些变量必须是隐式最终的。 可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的） 。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
<h3 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h3><p>如果一个Lambda代表的只是直接调用这个方法，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。<br>当你需要使用方法引用时，目标引用放在分隔符 :: 前，方法的名称放在后面。例如，Apple::getWeight 就是引用了 Apple 类中定义的方法 getWeight，，不需要括号，因为你没有实际调用这个方法。<br>构建方法引用的方式：</p>
<ol>
<li>指向静态方法的引用(Integer.parseInt方法，写做Integer::parseInt)</li>
<li>指向任意实例化类型方法的方法引用，(String的length写做String::length)</li>
<li>指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放 Transaction 类型的对象，它支持实例方法getValue ，那么你就可以写 expensive-Transaction::getValue ）</li>
</ol>
<p>二种和第三种方法引用可能乍看起来有点儿晕。类似于 String::length 的第二种方法引用的思想就是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数。例如，Lambda表达式 (String s) -&gt; s.toUppeCase() 可以写作 String::toUpperCase。但第三种方法引用指的是，你在Lambda中调用一个已经存在的外部对象中的方法。例如，Lambda表达式()-&gt; expensiveTransaction.getValue() 可以写作expensiveTransaction::getValue。<br><img src="/2017/12/02/java8/lambda方法引用.png" alt=""></p>
<h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>你可以利用它的名称和关键字new来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。假设有一个构造函数没有参数，它适合Supplier的签名() -&gt; Apple。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//无参数的构造函数</div><div class="line">Supplier&lt;Apple&gt; c1=Apple::new;</div><div class="line">Apple a=c1.get();</div><div class="line">或者</div><div class="line">Supplier&lt;Apple&gt; c1=()-&gt;new Apple();</div><div class="line">//带参数的构造函数</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=Apple::new;</div><div class="line">等价于</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=(weight)-&gt;new Apple(weight);</div><div class="line">Apple a=function.apply(110);</div><div class="line">//两个参数的构造函数</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=Apple::new;</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=(color,weight)-&gt;new Apple(color,weight);</div><div class="line">Apple a=biFunction.apply(<span class="string">"red"</span>,100);</div></pre></td></tr></table></figure></p>
<h2 id="Lambda和方法引用实战"><a href="#Lambda和方法引用实战" class="headerlink" title="Lambda和方法引用实战"></a>Lambda和方法引用实战</h2><h2 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h2><p>许多函数式接口，比如用<br>于传递Lambda表达式的 Comparator 、Function 和 Predicate 都提供了允许你进行复合的方法。可以让两个谓词之间做一个 or 操作，组合成一个更大的谓词。而且，你还可以让一个函数的结果成为另一个函数的输入。窍门在于，我们即将介绍的方法都是默认方法。</p>
<h3 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h3><h4 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h4><p>按照重量递减排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed());</div></pre></td></tr></table></figure></p>
<h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><p>按照重量递减排序,相同体重的苹果在根据国家排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry));</div></pre></td></tr></table></figure></p>
<h3 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h3><p>谓词接口包括三个接口:negate、and和or，可以让你重用已有的predicate来创建更复杂的谓词。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//苹果不是红的</div><div class="line">Predicate&lt;Apple&gt; notRedApple=redApple.negate();</div><div class="line">//苹果又红又重</div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApples=redApple.and(a-&gt;a.ggetWeight()&gt;150);</div><div class="line">//又红又重的苹果或者绿苹果,a.and(b).or(c),代表(a&amp;b)||c,从左到右确定优先级</div><div class="line">Predicate&lt;Apple&gt; redAndHeadvyOrGreen=redApple.and(a-&gt;a.getWeight()&gt;150).or(a-&gt;a.getColor().equals(<span class="string">"green"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p>可以把Function接口所代表的Lambda表达式复合，Function提供了andThen和compose两个默认方法，它们都返回一个Function的实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</div><div class="line">       Objects.requireNonNull(before);</div><div class="line">       <span class="built_in">return</span> (V v) -&gt; apply(before.apply(v));</div><div class="line">   &#125;</div><div class="line">default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</div><div class="line">     Objects.requireNonNull(after);</div><div class="line">     <span class="built_in">return</span> (T t) -&gt; after.apply(apply(t));</div><div class="line"> &#125;</div><div class="line">Function&lt;Integer, Integer&gt; f= x -&gt; x + 1;</div><div class="line">Function&lt;Integer, Integer&gt; g= x -&gt; x * 2;</div><div class="line">对于g(f(x))</div><div class="line">Function&lt;Integer,Integer&gt; h=f.andThen(g);</div><div class="line">Function&lt;Integer,Integer&gt; h=g.compose(f);</div><div class="line">int result=h.apply(1);</div></pre></td></tr></table></figure></p>
<p>用String表示一封信的文本转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Letter &#123;</div><div class="line">	public static String addHeader(String text) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"From Raoul, Mario and Alan: "</span> + text;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String addFooter(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text + <span class="string">" Kind regards"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String checkSpelling(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</div><div class="line">	&#125;</div><div class="line">  Function&lt;String, String&gt; addHeader =Letter::addHeader;</div><div class="line">  Function&lt;String, String&gt; transformationPipeline=addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h1><h2 id="引入流"><a href="#引入流" class="headerlink" title="引入流"></a>引入流</h2><p>流允许你使用声明性方式处理数据集合，就现在来说，你可以把他们看成遍历数据集的高级迭代器，此外，流可以透明并行处理。下面两段代码都是用来返回低热量的菜肴名称的，并按照卡路里排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//java7</div><div class="line">List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  <span class="keyword">if</span>(d.getCalories() &lt; 400)&#123;</div><div class="line">   lowCaloricDishes.add(d);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() &#123;</div><div class="line">  public int compare(Dish d1, Dish d2)&#123;</div><div class="line">     <span class="built_in">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)&#123;</div><div class="line"> lowCaloricDishesName.add(d.getName());</div><div class="line">&#125;</div><div class="line">//java8</div><div class="line">menu.parallelStream()</div><div class="line">				.filter((Dish d) -&gt; d.getCalories() &lt; 400)</div><div class="line">				.sorted((Dish d1, Dish d2) -&gt; d1.getCalories()</div><div class="line">				- d2.getCalories()).map((Dish d)-&gt;d.name).collect(toList());</div></pre></td></tr></table></figure></p>
<h2 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h2><p>从支持数据处理操作的源生成的元素序列。集合强调的是数据，流强调的是计算</p>
<ul>
<li>元素序列–流提供了一个接口，可以访问特定元素类型的一组有序值。</li>
<li>源–流会使用提供数据的源，如集合、数组或输入输出资源。从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作–流的数据处理功能类似于数据库的操作，如filter、map、reduce、find、match、sort。流操作可以顺序执行，也可以并行执行。<br>流操作的特点</li>
<li>流水线–很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li>
<li>内部迭代–使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.parallelStream()</div><div class="line">				.filter((d) -&gt; d.getCalories() &lt; 500).limit(1)</div><div class="line">				.map((d) -&gt; d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/menu.png" alt=""></p>
<h2 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h2><p>java现有的集合概念和新的流概念都提供了接口，来代表元素型有序值的有序接口。所谓有序，就是我们一般按照顺序取用值，而不是随机取用。<br>集合和流的之间的差异在于什么时候进行计算。集合是内存的数据结构，它包含数据结构目前所有值–集合中每个元素都得算出来才能添加到集合里面。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）流在概念上是固定的数据结构，你不能添加或者删除元素，其元素是按需计算的。类比质数流，尽管质数有无穷多个，但是仅仅从流提取需要的值，这样实现会很简单。这是一种生产者消费者关系，换另外的角度来讲，流就像是个延迟创建的集合：只有在消费者要求的时候才会计算其值。而集合是急切创建的，以质数为例，要想创建一个包含所有质数的集合，那么集合永远创建不完，消费者永远获取不到这个集合。</p>
<h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h3><p>和迭代器类似，流只能遍历一次，遍历完后，这个流就已经被消费掉了，你可以从原始数据源那里在获得一个新的流重新遍历一遍。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; title = Arrays.asList(<span class="string">"Java8"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</div><div class="line">Stream&lt;String&gt; s = title.stream();</div><div class="line">s.forEach(System.out::println);</div><div class="line">//java.lang.IllegalStateException:流已被操作</div><div class="line">或关闭</div><div class="line">s.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h3><h4 id="用for-Each循环外部迭代"><a href="#用for-Each循环外部迭代" class="headerlink" title="用for-Each循环外部迭代"></a>用for-Each循环外部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用背后迭代器"><a href="#用背后迭代器" class="headerlink" title="用背后迭代器"></a>用背后迭代器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line">Iterator&lt;String&gt; iterator = menu.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">   Dish d = iterator.next();</div><div class="line">   names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="流：内部迭代"><a href="#流：内部迭代" class="headerlink" title="流：内部迭代"></a>流：内部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names=menu.stream().map(d-&gt;d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/迭代.png" alt=""></p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; name=menu.stream().filter(d-&gt;d.getCalories()&lt;300).map(d-&gt;g.getName())<span class="built_in">limit</span>(3).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>filter、map、limit可以连成一条流水线，collect触发流水线执行并关闭。可以连起来的流操作称为中间操作，关闭流的操作称为终端操作。</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>诸如filter、sorted等中间操作会返回另外一个流，这让多个操作可以连接起来形成一个查询。除非流水线触发一个终端操作，否则中间操作不会执行任何处理。</p>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p>终端操作会从流的流水线生成结果，其结果是任何不是流的值，比如List、Integer甚至是void。</p>
<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>一个数据源来执行一个查询、一个中间操作链形成一条流的流水线、一个终端形成流水线，并能生成结果。<br>中间操作：<br>filter|Stream<t>|Predicate<t>|T-&gt;boolean<br>map|Stream<t>|Function<t,r>|T-&gt;R<br>limit|Stream<t><br>sorted|Stream<t>|Comparator<t>|(T,T)-&gt;int<br>distinct|Stream<t><br>终端操作<br>forEach 消费流中的每个元素并对其使用应用Lambda。这一操作返回void。<br>count 消费流中的元素个数，返回long<br>collect 把流规约成一个集合，比如list、map甚至是Integer。</t></t></t></t></t,r></t></t></t></p>
<h1 id="使用流-1"><a href="#使用流-1" class="headerlink" title="使用流"></a>使用流</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><p>用谓词筛选，筛选出各不相同的元素，忽略流中的头几个元素，或将流截短至指定长度</p>
<h3 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h3><p>streams支持filter方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.stream().filter(i-&gt;i%2==0).distinct().forEach(System.out::println);</div></pre></td></tr></table></figure>
<h3 id="截断流"><a href="#截断流" class="headerlink" title="截断流"></a>截断流</h3><p>limit(n)，会返回不超过n的流。</p>
<h3 id="跳过流"><a href="#跳过流" class="headerlink" title="跳过流"></a>跳过流</h3><p>skip(n),返回一个扔掉前n个元素的流。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p>
<h3 id="对流中每个元素应用函数"><a href="#对流中每个元素应用函数" class="headerlink" title="对流中每个元素应用函数"></a>对流中每个元素应用函数</h3><p>流支持 map 方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; wordLengths = words.stream().map(String::length).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharacters =words.stream().map(w -&gt;w.split(<span class="string">""</span>)).</div><div class="line">flatMap(Arrays::stream).distinct().collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/flatmap.png" alt=""><br>给定两个数字列表，如何返回所有的数对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);</div><div class="line">List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);</div><div class="line">List&lt;int[]&gt; pairs=numbers1.stream().flatMap(i-&gt;number2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(asList);</div></pre></td></tr></table></figure></p>
<h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><h3 id="检查谓词至少符合一个元素"><a href="#检查谓词至少符合一个元素" class="headerlink" title="检查谓词至少符合一个元素"></a>检查谓词至少符合一个元素</h3><p>anyMatch可以回答流中是否有一个元素匹配给定谓词。nyMatch 方法返回一个boolean ，因此是一个终端操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.stream().anyMatch(Dish::isVegetarian)&#123;</div><div class="line">  System.out.println(<span class="string">"The menu is (somewhat) vegetarian friendly!!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="检查谓词是否都符合所有元素"><a href="#检查谓词是否都符合所有元素" class="headerlink" title="检查谓词是否都符合所有元素"></a>检查谓词是否都符合所有元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean isHealthy = menu.stream().allMatch(d-&gt;d.getCalories() &lt; 1000);</div></pre></td></tr></table></figure>
<h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>确保流中没有任何元素与给定的谓词匹配.anyMatch 、 allMatch 和 noneMatch 这三个操作都用到了我们所谓的短路， 这就是大家熟悉的Java中 &amp;&amp; 和 || 运算符短路在流中的版本。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>isPresent() 将在 Optional 包含值的时候返回 true , 否则返回 false 。<br>ifPresent(Consumer<t> block) 会在值存在的时候执行给定的代码块。Consumer 函数式接口；它让你传递一个接收 T 类型参数，并返回 void 的Lambda<br>表达式。<br>T get() 会在值存在时返回值，否则抛出一个 NoSuchElement 异常。<br>T orElse(T other) 会在值存在时返回值，否则返回一个默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).findAny().ifPresent(d-&gt;System.out.println(d.getName());</div></pre></td></tr></table></figure></t></p>
<h3 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h3><p>findFirst.如果你不关心返回的元素是哪个，请使用 findAny ，因为它在使用并行流<br>时限制较少。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree =someNumbers.stream()</div><div class="line">.map(x -&gt; x * x)</div><div class="line">.filter(x -&gt; x % 3 == 0)</div><div class="line">.findFirst();</div></pre></td></tr></table></figure></p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>你将看到如何把一个流中的元素组合起来，使用reduce操作来表达更复杂的查询</p>
<h3 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</div><div class="line">//reduce 还有一个重载的变体，它不接受初始值，但是会返回一个 Optional 对象：</div><div class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</div></pre></td></tr></table></figure>
<p>Integer 类现在有了一个静态的sum方法来对两个数求和，这恰好是我们想要的，用不着反复用Lambda写同一段代码了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, Integer::sum);</div></pre></td></tr></table></figure></p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; max=numbers.stream().reduce(Integer::max);</div><div class="line">Optional&lt;Integer&gt; min=numbers.stream().reduce(Integer::min);</div></pre></td></tr></table></figure>
<p>诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内部可变状态）。但诸如reduce、sum、max等操作需要内部状态来累积结果。<br><img src="/2017/12/02/java8/stream.png" alt=""></p>
<h2 id="数据值"><a href="#数据值" class="headerlink" title="数据值"></a>数据值</h2><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream 和LongStream ，分别将流中的元素特化为int、long和double ，从而避免了暗含的装箱成本。</p>
<h4 id="映射到数值"><a href="#映射到数值" class="headerlink" title="映射到数值"></a>映射到数值</h4><p>将流转换为特化版本的常用方法是 mapToInt 、mapToDouble和mapToLong.如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如max、min 、 average<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int calories = menu.stream().mapToInt(Dish::getCalories).sum();</div></pre></td></tr></table></figure></p>
<h4 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories)</div><div class="line">.max();</div></pre></td></tr></table></figure>
<h4 id="默认值OptionalInt"><a href="#默认值OptionalInt" class="headerlink" title="默认值OptionalInt"></a>默认值OptionalInt</h4><p>Optional 可以用Integer 、 String 等参考类型来参数化。对于三种原始流特化，也分别有一个 Optional 原始类型特化版本： OptionalInt 、 OptionalDouble 和 OptionalLong 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt max=menu.stream().mapToInt(Dish::getCalories).max();</div><div class="line">int m=max.orElse(1);</div></pre></td></tr></table></figure></p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。 range 是不包含结束值的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntStream evenNumbers = IntStream.rangeClosed(1, 100)</div><div class="line">.filter(n -&gt; n % 2 == 0);</div><div class="line">System.out.println(evenNumbers.count());</div></pre></td></tr></table></figure></p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>);</div></pre></td></tr></table></figure>
<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int[] numbers=&#123;1,2,,3&#125;;</div><div class="line">int sum=Arrays.stream(numbers).sum();</div></pre></td></tr></table></figure>
<h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>java.nio.file.Files 中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines ，它会返回一个由指定文件中的各行构成的字符串流。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long uniqueWords=0;</div><div class="line">try&#123;</div><div class="line">  Stream&lt;String&gt; line=Files.lines(Paths.get(<span class="string">"data.txt"</span>),Charset.defaultCharset());</div><div class="line">  uniqueWords=line.flatMap(i-&gt;Arrays.stream(i.split(<span class="string">" "</span>))).distinct().count();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.iterator(0,n-&gt;n+2).limit.forEach(System.out::println);</div></pre></td></tr></table></figure>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</div></pre></td></tr></table></figure>
<h1 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency,List&lt;Transaction&gt;&gt; transactionsByCurrencies=transactions.stream().collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<h2 id="收集器简介"><a href="#收集器简介" class="headerlink" title="收集器简介"></a>收集器简介</h2><p>多级分组里函数式版本只要再加上一个收集器就可以轻松地增强功能了。</p>
<h3 id="收集器用做高级归约"><a href="#收集器用做高级归约" class="headerlink" title="收集器用做高级归约"></a>收集器用做高级归约</h3><p>Collector会对元素应用一个转换函数（很多时候是不体现任何效果的恒等转换例如toList），并将结果累积在一个数据结构中，从而产生这一过程的最终输出。Collectors实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，只要拿来用就可以了。最直接和最常用的收集器是 toList静态方法，它会把流中所有的元素收集到一个 List 中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Transaction&gt; transactions=transactionStream.collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<h3 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h3><p>Collectors提供的工厂方法groupingBy创建的收集器，主要提供三大功能：把流元素归约和汇总为一个值、元素分组、元素分区</p>
<h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long total=menu.stream().collect(counting());</div></pre></td></tr></table></figure>
<h3 id="寻找流中最小值和最大值"><a href="#寻找流中最小值和最大值" class="headerlink" title="寻找流中最小值和最大值"></a>寻找流中最小值和最大值</h3><p>Collectors.maxBy 和Collectors.minBy ，来计算流中的最大或最小值。这两个收集器接收一个Comparator 参数来比较流中的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</div><div class="line">Comparator.comparingInt(Dish::getCalories);</div><div class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));</div></pre></td></tr></table></figure></p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</div><div class="line">double average=menu.stream().collect(averagingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics menuStatistics =</div><div class="line">menu.stream().collect(summarizingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics&#123;count=9, sum=4300, min=120,average=477.777778, max=800&#125;</div></pre></td></tr></table></figure></p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>joining 工厂方法返回的收集器会把对流中每一个对象应用 toString 方法得到的所有字符串连接成一个字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String shortMenu = menu.stream().collect(joining(<span class="string">", "</span>));</div></pre></td></tr></table></figure></p>
<h3 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//第一个参数是归约操作的起始值,第二个是转换函数，第三个是BinaryOperator，累积函数</div><div class="line">int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j));</div></pre></td></tr></table></figure>
<p>reduce 方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反， collect 方法的设计就是要改变容器，从而累积要输出的结果。使用 reduce 方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏 List 本身。果你想要线程安全，就需要每次分配一个新的 List ，而对象分配又会影响性能。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type,List&lt;Dish&gt;&gt; map=menu.stream().collect(groupingBy(Dish::getType));</div><div class="line">public enum CaloricLevel &#123;</div><div class="line">   DIET, NORMAL, FAT</div><div class="line">&#125;</div><div class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; caloricLevel = menu.stream().collect(</div><div class="line">groupingBy(</div><div class="line">dish-&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(dish.getCalories() &lt;= 400)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= 700)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125;));</div><div class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(groupingBy(</div><div class="line">Dish::getCalories,counting()</div><div class="line">));</div></pre></td></tr></table></figure>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</div><div class="line">menu.stream().collect(groupingBy(Dish::getType,groupingBy(dish -&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(dish.getCalories()&lt;=400)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories()&lt;=700)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125; )</div><div class="line">)</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>由一个谓词作为一个返回函数，分区函数返回一个布尔值，意味着分组Map的键值是boolean，最多可以分成两组-true是一组，false是一组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</div><div class="line">menu.stream().collect(partitioningBy(Dish::isVegetarian));</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/分区.png" alt=""></p>
<h2 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Collector&lt;T, A, R&gt; &#123;</div><div class="line">   Supplier&lt;A&gt; supplier();</div><div class="line">   BiConsumer&lt;A, T&gt; accumulator();</div><div class="line">   Function&lt;A, R&gt; finisher();</div><div class="line">   BinaryOperator&lt;A&gt; combiner();</div><div class="line">   Set&lt;Characteristics&gt; characteristics();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>T 是流中要收集的项目的泛型。<br>A 是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。<br>R 是收集操作得到的对象（通常但并不一定是集合）的类型</p>
<h3 id="理解collector接口声明的方法"><a href="#理解collector接口声明的方法" class="headerlink" title="理解collector接口声明的方法"></a>理解collector接口声明的方法</h3><h4 id="建立新的结果容器-supplier方法"><a href="#建立新的结果容器-supplier方法" class="headerlink" title="建立新的结果容器:supplier方法"></a>建立新的结果容器:supplier方法</h4><p>supplier 方法必须返回一个结果为空的 Supplier ，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> ()-&gt;new ArrayList&lt;T&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="把元素添加到结果容器-accumulator"><a href="#把元素添加到结果容器-accumulator" class="headerlink" title="把元素添加到结果容器:accumulator"></a>把元素添加到结果容器:accumulator</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BiConsumer&lt;List&lt;T&gt; ,T&gt;()&#123;</div><div class="line">  <span class="built_in">return</span> (list,item)-&gt;list.add(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="把结果应用最终转换：finisher"><a href="#把结果应用最终转换：finisher" class="headerlink" title="把结果应用最终转换：finisher"></a>把结果应用最终转换：finisher</h4><p>在遍历完流后， finisher 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line">     <span class="built_in">return</span> Function.identity();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/顺序归约.png" alt=""></p>
<h4 id="合并两个结果容器"><a href="#合并两个结果容器" class="headerlink" title="合并两个结果容器"></a>合并两个结果容器</h4><p>四个方法中的最后一个—— combiner 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line">   <span class="built_in">return</span> (list1, list2) -&gt; &#123;list1.addAll(list2);<span class="built_in">return</span> list1; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/combine规约.png" alt=""></p>
<h4 id="characteristics方法"><a href="#characteristics方法" class="headerlink" title="characteristics方法"></a>characteristics方法</h4><p>characteristics 会返回一个不可变的 Characteristics 集合， 它定义<br>了收集器的行为:<br>UNORDERED ——归约结果不受流中项目的遍历和累积顺序的影响。<br>CONCURRENT —— accumulator 函数可以从多个线程同时调用，且该收集器可以并行归<br>约流。如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约<br>IDENTITY_FINISH ——这表明完成器方法返回的函数是一个恒等函数，可以跳过。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">import java.util.function.*;</div><div class="line">import java.util.stream.Collector;</div><div class="line">import static java.util.stream.Collector.Characteristics.*;</div><div class="line">public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt; &#123;</div><div class="line">@Override</div><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> ArrayList::new;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BiConsumer&lt;List&lt;T&gt;, T&gt; <span class="function"><span class="title">accumulator</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> List::add;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Function.indentity();</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> (list1, list2) -&gt; &#123;</div><div class="line">list1.addAll(list2);</div><div class="line"><span class="built_in">return</span> list1;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Set&lt;Characteristics&gt; <span class="function"><span class="title">characteristics</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Collections.unmodifiableSet(EnumSet.of(</div><div class="line">IDENTITY_FINISH, CONCURRENT));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">List&lt;Dish&gt; dishes = menuStream.collect(</div><div class="line">new ToListCollector&lt;Dish&gt;()</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>###</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/01/高性能网络通讯/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/高性能网络通讯/" itemprop="url">高性能网络通讯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T09:31:02+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简单的RPC调用问题"><a href="#简单的RPC调用问题" class="headerlink" title="简单的RPC调用问题"></a>简单的RPC调用问题</h2><h3 id="简单的远程调用"><a href="#简单的远程调用" class="headerlink" title="简单的远程调用"></a>简单的远程调用</h3><h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HelloService helloService=getProxy(HelloService.class,<span class="string">"127.0.0.1"</span>,<span class="string">"2580"</span>);</div><div class="line">System.out.println(helloService.sayHello(<span class="string">"hi, charles"</span>));</div><div class="line">Public &lt;T&gt; T getProxy(Class&lt;T&gt; interfaceClass, String host, int port)&#123;</div><div class="line"><span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new</div><div class="line">Class&lt;?&gt;[] &#123;interfaceClass&#125;,</div><div class="line">new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</div><div class="line">public Object invoke(Object proxy, Method method, Object[]</div><div class="line">arguments) throws Throwable &#123;</div><div class="line">Socket socket = new Socket(host, port);</div><div class="line">ObjectOutputStream output = new</div><div class="line">ObjectOutputStream(socket.getOutputStream());</div><div class="line">output.writeUTF(method.getName());</div><div class="line">output.writeObject(method.getParameterTypes());</div><div class="line">output.writeObject(arguments);</div><div class="line">ObjectInputStream input = new</div><div class="line">ObjectInputStream(socket.getInputStream());</div><div class="line"><span class="built_in">return</span> input.readObject();&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务器端调用"><a href="#服务器端调用" class="headerlink" title="服务器端调用"></a>服务器端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = new ServerSocket(port);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">   final Socket socket= server.accept();</div><div class="line">   new Thread(new Runnable(</div><div class="line">     public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">       ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</div><div class="line">       String methodName=input.readUTF();</div><div class="line">       Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();</div><div class="line">       Object[] arguments = (Object[])input.readObject();</div><div class="line">       ObjectOutputStream output = new</div><div class="line">       ObjectOutputStream(socket.getOutputStream());</div><div class="line">       Method method = service.getClass().getMethod(methodName,</div><div class="line">       parameterTypes);</div><div class="line">       Object result = method.invoke(service, arguments);</div><div class="line">       output.writeObject(result);</div><div class="line">     &#125;</div><div class="line">   )).start();</div><div class="line">&#125;</div><div class="line">Public String sysHello(String input)&#123;</div><div class="line">  <span class="built_in">return</span> input+<span class="string">":wellcome."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>网络传输方式：BIO</li>
<li>序列化方式：java序列化</li>
<li>线程模型：每次连接每线程</li>
<li>jdk代理</li>
</ol>
<h3 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h3><ol>
<li>协议；用什么数据格式进行传输。双方的约定</li>
<li>传输；用什么样的通道将数据发送给对方</li>
<li>线程；当接收到数据时，如何分发数据进行处理</li>
</ol>
<p><img src="/2017/12/01/高性能网络通讯/dataProtocol.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dataFlow.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dubbohead.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/datahead.png" alt=""></p>
<h3 id="data-Header"><a href="#data-Header" class="headerlink" title="data Header"></a>data Header</h3><p>magic code<br>多协议支持<br>Telnet<br>兼容<br>Long id vs id轮转<br>同步转异步<br>过期策略+id轮转<br>扩展header（拥塞控制&amp;response header增加服务器状态）</p>
<h4 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h4><p>并行发起多个请求，但只使用一个线程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxxService.find();</div><div class="line">Future&lt;Xxx&gt; future=RpcContext.getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/01/高性能网络通讯/asy.png" alt=""></p>
<h4 id="body序列化"><a href="#body序列化" class="headerlink" title="body序列化"></a>body序列化</h4><p>数据大小（传输速度）<br>序列化和反序列速度(CPU资源)<br>兼容性和易用性<br><img src="/2017/12/01/高性能网络通讯/序列化.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/size_dfl.png" alt=""></p>
<ul>
<li>远程服务调用时间主要消耗<br>网络开销主要是数据包大小<br>生产环境某应用容量测试</li>
<li>dubbo序列化主要优化目标：<br>减少数据包大小<br>提高序列化反序列化性能</li>
</ul>
<h2 id="IO-model"><a href="#IO-model" class="headerlink" title="IO model"></a>IO model</h2><p>IO Model、NIO、TCP选项、IRQ</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>IO请求分为两个阶段：<br>等待数据就绪；从内存缓存区拷贝数据到进程缓存区<br>Unix5种IO模型：<br>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO<br><img src="/2017/12/01/高性能网络通讯/io.png" alt=""></p>
<h3 id="NIO的好处"><a href="#NIO的好处" class="headerlink" title="NIO的好处"></a>NIO的好处</h3><ul>
<li>事件驱动模型，避免多线程和单线程处理多任务。</li>
<li>IO读写不再阻塞，而是返回0.</li>
<li>基于block的传输，比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了java网络应用的可伸缩性和实用性</li>
</ul>
<h3 id="NIO-reactor模式"><a href="#NIO-reactor模式" class="headerlink" title="NIO reactor模式"></a>NIO reactor模式</h3><ul>
<li>NIO网络框架典型模式</li>
<li>核心组件<br>同步事件多路复用器(event loop 事件分离)<br>分发器（事件派发，可以多线程）<br>请求处理（事件处理，业务代码）</li>
<li>mina netty都是此模式的实现</li>
</ul>
<p><img src="/2017/12/01/高性能网络通讯/reactor.png" alt=""></p>
<h3 id="NIO优化-TCP选项"><a href="#NIO优化-TCP选项" class="headerlink" title="NIO优化-TCP选项"></a>NIO优化-TCP选项</h3><p>合理设置tcp/ip在某些时候可以起到显著的效果</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><ul>
<li>Socket缓冲区至少应该是连接的MSS的四倍，MSS=MTU+40，一般以太网的MTU等于1500字节，MSS：最大分段大小，MTU：最大传输单元</li>
<li>在以太网上4k是不够的，增加到16k，吞吐量增加40%</li>
<li>对于一次性发送大量数据的应用，增加发送缓冲区到48k、64k才是可能唯一有效提高性能的方式。为了最大化性能，发送缓冲区可能至少要跟BDP（带宽延迟乘积）一样大小。</li>
<li>对于大量接收数据的应用，提高接收缓冲区，能减少发送端的阻塞。</li>
<li>如果应用既发送大量数据，也接收大量数据，recvbuffer和send buffer应该同时增加</li>
</ul>
<h3 id="带宽延迟乘积–BDP"><a href="#带宽延迟乘积–BDP" class="headerlink" title="带宽延迟乘积–BDP"></a>带宽延迟乘积–BDP</h3><p>为了优化TCP 吞吐量（假设为合理的无差错传输路径），发送端应该发送足够的数据包以填满发送端和接收端之间的逻辑管道。<br>逻辑管道的容量计算：BDP= 带宽x RTT</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>nagle算法通过将缓冲区的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。<br>实时性要求较高的应用，需要关闭算法，否则响应时间会受影响。</p>
<h3 id="SO-KeepAlive"><a href="#SO-KeepAlive" class="headerlink" title="SO_KeepAlive"></a>SO_KeepAlive</h3><p>Socket.setKeepAlive(boolean)<br>这是TCP层，而非HTTP协议的keep-alive概念,默认一般为false，用于TCP连接保活，默认间<br>隔2个小时.TCP心跳间隔是全局设置，建议在应用层做心跳</p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断此时都是运行在在硬件中断相应的cpu上。<br>如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>
<h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS (Receive Packet Steering) 基本原理<br>– 根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，<br>– 从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="线程模型内容"><a href="#线程模型内容" class="headerlink" title="线程模型内容"></a>线程模型内容</h3><ul>
<li>Reactor线程模型</li>
<li>序列化线程</li>
<li>业务线程派发策略</li>
</ul>
<h3 id="Reator单线程模型"><a href="#Reator单线程模型" class="headerlink" title="Reator单线程模型"></a>Reator单线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor单线程.png" alt=""></p>
<h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor多线程.png" alt=""></p>
<h3 id="线程派发策略"><a href="#线程派发策略" class="headerlink" title="线程派发策略"></a>线程派发策略</h3><p>五个事件：连接建立（Connection）、连接断开（Disconnection）、消息已接受(MessageReceived)、消息已发送（sent）、异常（Exception  caught）<br>派发策略：1.五个事件共享一个线程池；2.Connection和disconnect使用独立的线程池，size为1；3.全部不派发线程池，IO线程处理</p>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p>有这样一个模块<br>cpu 计算时间 18ms （ running ）<br>查询数据库，网络 io 时间 80ms （ waiting ）<br>解析结果 2ms 如果服务器 2CPU ，大家看看这里多少线程合适<br>充分利用cpu资源：<br>线程数量=100/20*2=10<br>从CPU角度而言<br>线程数量=（cpu时间+cpu等待时间）/cpu时间*cpu数量</p>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p>有这样一个模块：<br>线程同步锁 ( 数据库事务锁 )50ms<br>cpu 时间 18ms<br>查询数据库，网络 io 时间 80ms<br>解析结果 2ms  如果服务器有 2 个 CPU ，这个模块线程多少合适？<br>CPU计算为瓶颈，计算线程数量<br>线程数=(18 + 2 + 50 + 80) /20 *2 = 15<br>以线程同步锁为瓶颈，计算线程数<br>线程数=(50 + 18 + 2 + 80) / 50 * 1/1 = 3<br>公式一：<br>线程数量= （线程总时间/ 瓶颈资源时间）*  瓶颈资源的线程并行数<br>准确的讲<br>瓶颈资源的线程并行数= 瓶颈资源的总份数/ 单次请求占用瓶颈资源的份数<br>约束：<br>在计算的时候，对同一类资源的消耗时间进行合并<br>公式二：<br>QPS=1000/线程总时间*线程数<br>注意：如果线程数不够，则QPS减少。线程本身也要消耗资源，如果线程太多，同样QPS会下降。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>• 其他优化<br>– Lock free data structure（无锁数据结构）<br>– Buffer copy (Zero Copy)：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。一个关键的api是java.nio.channel.FileChannel的transferTo()方法。我们可以用transferTo()来把bytes直接从调用它的channel传输到另一个writable byte channel，中间不会使data经过应用程序。<br>– JVM GC tuning<br>– Context Switch 线程上下文切换<br>– 同步转异步<br>– JavassistProxy改进JDK proxy<br>  注意性能的短板效应，避免过度优化<br>– 优化的代价，通常是牺牲未来的可能性</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/es全文搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/es全文搜索/" itemprop="url">elasticsearch深入搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T10:55:25+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><h2 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h2><h3 id="基于词项查询"><a href="#基于词项查询" class="headerlink" title="基于词项查询"></a>基于词项查询</h3><p>如 term 或 fuzzy 这样的底层查询不需要分析阶段，它们对单个词项进行操作。用 term 查询词项 Foo 只要在倒排索引中查找 准确词项 ，并且用 TF/IDF 算法为每个包含该词项的文档计算相关度评分score 。<br>记住 term 查询只对倒排索引的词项精确匹配，这点很重要，它不会对词的多样性进行处理（如， foo 或 FOO ）。这里，无须考虑词项是如何存入索引的。如果是将 [“Foo”,”Bar”] 索引存入一个不分析的（ not_analyzed ）包含精确值的字段，或者将 Foo Bar 索引到一个带有 whitespace 空格分析器的字段，两者的结果都会是在倒排索引中有 Foo 和 Bar 这两个词。</p>
<h3 id="基于全文查询"><a href="#基于全文查询" class="headerlink" title="基于全文查询"></a>基于全文查询</h3><p>像 match 或 query_string 这样的查询是高层查询，它们了解字段映射的信息：<br>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。<br>如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。<br>但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分。<br>当我们想要查询一个具有精确值的 not_analyzed 未分析字段之前， 需要考虑，是否真的采用评分查询，或者非评分查询会更好。<br>单词项查询通常可以用是、非这种二元问题表示，所以更适合用过滤， 而且这样做可以有效利用缓存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"constant_score"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">          <span class="string">"term"</span>:&#123;</div><div class="line">            <span class="string">"sex"</span>:<span class="string">"男"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h2><p>匹配查询match是核心查询，它是一个高级全文查询 ，这表示它既能处理全文字段，又能处理精确字段。</p>
<h3 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:<span class="string">"quick"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询步骤如下：</p>
<ol>
<li>检查字段类型；标题 title 字段是一个 string 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。</li>
<li>分析查询字符串；将查询的字符串quick传入标准分析器中，输出的结果是单个项 quick 。因为只有一个单词项，所以 match 查询执行的是单个底层 term 查询。</li>
<li>查找匹配文档；用 term 查询在倒排索引中查找 quick 然后获取一组包含该项的文档，本例的结果是文档：1、2 和 3 。</li>
<li>为每个文档评分；用 term 查询计算每个文档相关度评分score ，这是种将 词频（term frequency，即词 quick 在相关文档的 title 字段中出现的频率）和反向文档频率（inverse document frequency，即词 quick 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。<h3 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">        <span class="string">"title"</span>:<span class="string">"BROWN DOG"</span></div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//返回结果解释</div><div class="line">文档 4 最相关，因为它包含词 <span class="string">"brown"</span> 两次以及 <span class="string">"dog"</span> 一次。</div><div class="line">文档 2、3 同时包含 brown 和 dog 各一次，而且它们 title 字段的长度相同，所以具有相同的评分。</div><div class="line">文档 1 也能匹配，尽管它只有 brown 没有 dog 。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 match 查询必须查找两个词（ [“brown”,”dog”] ），它在内部实际上先执行两次 term 查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个 term 查询包入一个 bool 查询中。<br>以上示例告诉我们一个重要信息：即任何文档只要 title 字段里包含 指定词项中的至少一个词 就能匹配，被匹配的词项越多，文档就越相关。</p>
<h3 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h3><p>用 任意 查询词项匹配文档可能会导致结果中出现不相关的长尾。 这是种散弹式搜索。可能我们只想搜索包含 所有 词项的文档，也就是说，不去匹配 brown OR dog ，而通过匹配 brown AND dog 找到所有文档。<br>match 查询还可以接受 operator 操作符作为输入参数，默认情况下该操作符是 or 。我们可以将它修改成 and 让所有指定词项都必须匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:&#123;</div><div class="line">           <span class="string">"query"</span>: <span class="string">"brown dog"</span>,</div><div class="line">           <span class="string">"operator"</span>:<span class="string">"and"</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h3><p>在 所有 与 任意 间二选一有点过于非黑即白。 如果用户给定 5 个查询词项，想查找只包含其中 4 个的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。<br>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。<br>match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">        <span class="string">"query"</span>:<span class="string">"a brown dog"</span>,</div><div class="line">        <span class="string">"minimun_should_match"</span>:<span class="string">"75%"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当给定百分比的时候， minimum_should_match 会做合适的事情：在之前三词项的示例中， 75% 会自动被截断成 66.6% ，即三个里面两个词。无论这个值设置成什么，至少包含一个词项的文档才会被认为是匹配的。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>在 组合过滤器 中，我们讨论过如何使用 bool 过滤器通过 and 、 or 和 not 逻辑组合将多个过滤器进行组合。在查询中， bool 查询有类似的功能，只有一个重要的区别。<br>过滤器做二元判断：文档是否应该出现在结果中？但查询更精妙，它除了决定一个文档是否应该被包括在结果中，还会计算文档的 相关程度 。<br>与过滤器一样， bool 查询也可以接受 must 、 must_not 和 should 参数下的多个查询语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"must"</span>:     &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;,</div><div class="line">      <span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"lazy"</span>  &#125;&#125;,</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h3><p>以上的查询结果返回 title 字段包含词项 quick 但不包含 lazy 的任意文档。目前为止，这与 bool 过滤器的工作方式非常相似。<br>区别就在于两个 should 语句，也就是说：一个文档不必包含 brown 或 dog 这两个词项，但如果一旦包含，我们就认为它们更相关。<br>bool查询会为每个文档计算相关度评分，再将所有匹配must和should语句的分数score求和，最后除以must和should语句总数，must_not不会影响评分，只会将不想关的文档排除。</p>
<h3 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h3><p>所有 must 语句必须匹配，所有 must_not 语句都必须不匹配，但有多少 should 语句应该匹配呢？ 默认情况下，没有 should 语句是必须匹配的，只有一个例外：那就是当没有 must 语句的时候，至少有一个 should 语句必须匹配。<br>就像我们能控制 match 查询的精度 一样，我们可以通过 minimum_should_match 参数控制需要匹配的 should 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ],</div><div class="line">      <span class="string">"minimum_should_match"</span>: 2</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个查询结果会将所有满足以下条件的文档返回： title 字段包含 “brown” AND “fox” 、 “brown” AND “dog” 或 “fox” AND “dog” 。如果有文档包含所有三个条件，它会比只包含两个的文档更相关。</p>
<h2 id="bool匹配"><a href="#bool匹配" class="headerlink" title="bool匹配"></a>bool匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">//以下两两是等价的</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown fox"</span>&#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//must</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>:    <span class="string">"brown fox"</span>,</div><div class="line">            <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"must"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>: <span class="string">"quick brown fox"</span>,</div><div class="line">            <span class="string">"minimum_should_match"</span>: <span class="string">"75%"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"minimum_should_match"</span>: 2</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询语句提升比重"><a href="#查询语句提升比重" class="headerlink" title="查询语句提升比重"></a>查询语句提升比重</h2><p>我们可以通过指定 boost 来控制任何查询语句的相对的权重， boost 的默认值为 1 ，大于 1 会提升一个语句的相对权重。<br>boost 参数被用来提升一个语句的相对权重（ boost 值大于 1 ）或降低相对权重（ boost 值处于 0 到 1 之间），但是这种提升或降低并不是线性的，换句话说，如果一个 boost 值为 2 ，并不能获得两倍的评分score 。<br>相反，新的评分score 会在应用权重提升之后被 归一化 ，每种类型的查询都有自己的归一算法，细节超出了本书的范围，所以不作介绍。简单的说，更高的 boost 值为我们带来更高的评分 score 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    <span class="string">"query"</span>: &#123;</div><div class="line">        <span class="string">"bool"</span>: &#123;</div><div class="line">            <span class="string">"must"</span>: &#123;</div><div class="line">                <span class="string">"match"</span>: &#123;  </div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>:    <span class="string">"full text search"</span>,</div><div class="line">                        <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"should"</span>: [</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Elasticsearch"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 3</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;,</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Lucene"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 2</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="控制分析"><a href="#控制分析" class="headerlink" title="控制分析"></a>控制分析</h2><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>在搜索时，顺序有些许不同：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>有时，在索引时和搜索时使用不同的分析器是合理的。 我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。<br>为了区分，Elasticsearch 也支持一个可选的 search_analyzer 映射，它仅会应用于搜索时（ analyzer 还用于索引时）。还有一个等价的 default_search 映射，用以指定索引层的默认配置。<br>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 search_analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default_search 的分析器，默认为索引设置中名为 default 的分析器，默认为standard 标准分析器</p>
<h2 id="被破坏的相关度！"><a href="#被破坏的相关度！" class="headerlink" title="被破坏的相关度！"></a>被破坏的相关度！</h2><p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。<br>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤： 用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。<br>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。<br>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。<br>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。 相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。<br>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。<br>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。<br>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。<br>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF。不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h1 id="多字段搜索"><a href="#多字段搜索" class="headerlink" title="多字段搜索"></a>多字段搜索</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html</a></p>
<h1 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html</a></p>
<h1 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a>控制相关度</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/dubbo-framework-extensions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/dubbo-framework-extensions/" itemprop="url">dubbo_framework_extensions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T10:41:29+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2017/11/27/dubbo-framework-extensions/do.png" alt="do"></p>
<h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><h3 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h3><p><img src="/2017/11/27/dubbo-framework-extensions/framework1.png" alt="do"><br><img src="/2017/11/27/dubbo-framework-extensions/extension.png" alt="do"></p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p><img src="/2017/11/27/dubbo-framework-extensions/modules.png" alt="do"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="IOC-amp-AOP"><a href="#IOC-amp-AOP" class="headerlink" title="IOC&amp;AOP"></a>IOC&amp;AOP</h3><p>对于扩展实现IOC依赖注入功能：<br>举例来说：接口A，实现者A1、A2。接口B，实现者B1、B2。<br>现在实现者A1含有setB()方法，会自动注入一个接口B的实现者，此时注入B1还是B2呢？都不是，而是注入一个动态生成的接口B的实现者B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能.对扩展采用装饰器模式进行功能增强，类似AOP实现的功能.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//IOC</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private LoadBalance loadbalance;</div><div class="line">   public void <span class="built_in">set</span>LoadBalance(LoadBalance loadbalance) &#123;</div><div class="line">       this.loadbalance = loadbalance;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">//AOP</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private Cluster cluster;</div><div class="line">   public XxxCluster(Cluster cluster) &#123;</div><div class="line">      this.cluster = cluster;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/27/dubbo-framework-extensions/protocol.png" alt="protocol"><br><img src="/2017/11/27/dubbo-framework-extensions/filter.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/proxyFactory.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/javassist.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/cluster.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/remoting.png" alt=""></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//Application shared</div><div class="line">&lt;dubbo:application name=<span class="string">"xxx"</span> /&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"127.0.0.1"</span> /&gt;</div><div class="line">//provider</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"7777"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> /&gt;</div><div class="line">//consumer</div><div class="line">&lt;dubbo:reference interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:consumer timeout /&gt;</div></pre></td></tr></table></figure>
<h3 id="config-type"><a href="#config-type" class="headerlink" title="config type"></a>config type</h3><ul>
<li>Service Identification<br>group<br>version<br>interface</li>
<li>Service Governance<br>deprecated<br>application</li>
<li>performance optimize<br>timeout<br>threads</li>
</ul>
<h3 id="config-Override"><a href="#config-Override" class="headerlink" title="config Override"></a>config Override</h3><p>method 继承 接口 继承缺失，消费者继承服务提供者</p>
<h3 id="编程配置"><a href="#编程配置" class="headerlink" title="编程配置"></a>编程配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServiceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“xxx”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– <span class="built_in">export</span>();</div><div class="line">• ReferenceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“yyy”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– get();</div></pre></td></tr></table></figure>
<h3 id="context-amp-trace"><a href="#context-amp-trace" class="headerlink" title="context&amp;trace"></a>context&amp;trace</h3><p><img src="/2017/11/27/dubbo-framework-extensions/context&amp;trace.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadLocal context</div><div class="line">RpcContext.getContext().getRemoteHost();</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>,<span class="string">"1"</span>);</div><div class="line">RpcContext.getContext().getAttachment(<span class="string">"index"</span>);</div><div class="line">like http cookie</div></pre></td></tr></table></figure></p>
<h3 id="GenericService"><a href="#GenericService" class="headerlink" title="GenericService"></a>GenericService</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// java interface</div><div class="line">MemberService memberService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">memberService.findPeople(memberId);</div><div class="line">//Generic interface POJO需要转化为map</div><div class="line">GenericService genericService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">genericService.invoke(<span class="string">"findPeople"</span>,new String[]&#123;<span class="string">"java.lang.String"</span>&#125;,new Object[]&#123;memberId&#125;);</div><div class="line">//java implement</div><div class="line">public class MemberServiceImpl implements MemberService&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//Generic implement</div><div class="line">public class MemberServiceImpl implement GenericService&#123;</div><div class="line">  public Object invoke(String method,String[] ptypes,Object[] args)&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="local-amp-mock"><a href="#local-amp-mock" class="headerlink" title="local&amp;mock"></a>local&amp;mock</h3><p><img src="/2017/11/27/dubbo-framework-extensions/mock.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dubbo://10.20.153.10?<span class="built_in">local</span>=<span class="literal">true</span>&amp;mock=<span class="literal">true</span></div><div class="line">Constructor:</div><div class="line">public XxxServiceLocal(XxxService xxxService)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public <span class="function"><span class="title">XxxServiceMock</span></span>()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/dubbo功能介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/dubbo功能介绍/" itemprop="url">dubbo功能介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T22:53:33+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="dubbo简要介绍"><a href="#dubbo简要介绍" class="headerlink" title="dubbo简要介绍"></a>dubbo简要介绍</h1><h2 id="dubbo是什么"><a href="#dubbo是什么" class="headerlink" title="dubbo是什么"></a>dubbo是什么</h2><p>它是分布式服务框架，高性能和透明化的RPC远程服务调用方案；SOA服务治理方案</p>
<h2 id="如何使用dubbo"><a href="#如何使用dubbo" class="headerlink" title="如何使用dubbo"></a>如何使用dubbo</h2><p>本地服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>远程服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxInterface"</span> ref=<span class="string">"xxxService"</span>&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span> interface=<span class="string">"xxxInterface"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="dubbo能做什么"><a href="#dubbo能做什么" class="headerlink" title="dubbo能做什么"></a>dubbo能做什么</h2><h3 id="透明化的远程调用"><a href="#透明化的远程调用" class="headerlink" title="透明化的远程调用"></a>透明化的远程调用</h3><p>就像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p>
<h3 id="软负载均衡和容错机制"><a href="#软负载均衡和容错机制" class="headerlink" title="软负载均衡和容错机制"></a>软负载均衡和容错机制</h3><p>可在内网替代F5等硬件负载均衡器</p>
<h3 id="服务自动注册与发现"><a href="#服务自动注册与发现" class="headerlink" title="服务自动注册与发现"></a>服务自动注册与发现</h3><p>不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加和删除服务提供者。</p>
<h2 id="dubbo基本原理"><a href="#dubbo基本原理" class="headerlink" title="dubbo基本原理"></a>dubbo基本原理</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本原理.png" alt="dubbo基本原理"></p>
<h2 id="dubbo-rpc基本功能"><a href="#dubbo-rpc基本功能" class="headerlink" title="dubbo rpc基本功能"></a>dubbo rpc基本功能</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本功能.png" alt="dubbo-rpc 基本功能"></p>
<h3 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h3><p>实际使用中发现服务器比消费者更清楚一个方法的执行时间和是否允许重试等信息，所以增加允许服务提供者为消费者设置缺省值，并采用继承风格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//服务提供者配置</div><div class="line">&lt;dubbo:service timeout=<span class="string">"3000"</span> retries=<span class="string">"0"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=3000&amp;retries=0</div><div class="line">服务提供者提供配置参考值</div><div class="line">//注册中心</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=4000&amp;retries=1</div><div class="line">注册中心可在服务治理过程中修改配置值，如果不修改则使用provider的配置值</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">""</span> interface=<span class="string">""</span> timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=5000&amp;retries=2</div><div class="line">服务消费者如果出现网络慢等因素，可再修改配置值，如果不修改使用前面的配置值</div></pre></td></tr></table></figure></p>
<h3 id="可编程配置"><a href="#可编程配置" class="headerlink" title="可编程配置"></a>可编程配置</h3><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 服务实现</div><div class="line">XxxService xxxService = new XxxServiceImpl();</div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"xxx"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务提供者协议配置</div><div class="line">ProviderConfig provider = new ProviderConfig();</div><div class="line">provider.setProtocol(<span class="string">"dubbo"</span>);</div><div class="line">provider.setPort(12345);</div><div class="line">provider.setThreads(200);</div><div class="line">// 服务提供者暴露服务配置</div><div class="line">ServiceConfig service = new ServiceConfig();</div><div class="line">service.setApplication(application);</div><div class="line">service.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">service.setProvider(provider); // 多个提供者可以用<span class="built_in">set</span>Providers()</div><div class="line">service.setInterfaceClass(XxxService.class);</div><div class="line">service.setRef(xxxService);</div><div class="line">service.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">service.export(); // 触发服务注册</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!--服务实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"com.alibaba.xxx.XxxServiceImpl"</span> /&gt;</div><div class="line">&lt;!--当前应用配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"morgan"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者协议配置 --&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> port=<span class="string">"12345"</span> threads=<span class="string">"200"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者暴露服务配置 --&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> ref=<span class="string">"xxxService"</span> /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"yyy"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务消费者缺省值配置</div><div class="line">ConsumerConfig consumer = new ConsumerConfig();</div><div class="line">consumer.setTimeout(5000);</div><div class="line">consumer.setRetries(2);</div><div class="line">// 引用远程服务</div><div class="line">ReferenceConfig reference = new ReferenceConfig();</div><div class="line">reference.setApplication(application);</div><div class="line">reference.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">reference.setConsumer(consumer);</div><div class="line">reference.setInterfaceClass(XxxService.class);</div><div class="line">reference.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">XxxService xxxService = reference.get(); // 获取远程xxxService代理</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!-- 当前应用信息配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"kylin"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务消费者缺省值配置 --&gt;</div><div class="line">&lt;dubbo:consumer timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">&lt;!-- 引用远程服务 --&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span></div><div class="line">interface=<span class="string">"com.alibaba.xxx.XxxService"</span> version=<span class="string">"1.0.0 /&gt;</span></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h3><p>当一个接口有不同实现，可以用group区分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;dubbo:service group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:service group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"fsService"</span> group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"mservice"</span> group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用<br>一般处理步骤<br>1）在低压力时间段，先升级一半提供者为新版本<br>2）再将所有消费者升级为新版本<br>3）然后将剩下的一半提供者升级为新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">服务提供者</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div><div class="line">服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="指定调用"><a href="#指定调用" class="headerlink" title="指定调用"></a>指定调用</h3><p>点对点直连/指定调用需求（开发/测试环境）。在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表。</p>
<ol>
<li><p>spring配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference interface=<span class="string">"com.alibaba.xxx.XxxService"</span> url=<span class="string">"dubbo://localhost:20890"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>java -D参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>映射文件方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">– java -Ddubbo.resolve.file=xxx.properties</div><div class="line">– com.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>路由方式<br>– 参数匹配 host、clssifier</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//对于所有调用com.foo.BarService接口的消费者，如果消费者的ip是<span class="string">"10.20.153.10"</span>，那么这个消费者将调用ip为<span class="string">"10.20.153.11"</span>的提供者，这样，通过动态配置注册中心的路由规则，就实现了动态指定某个提供者的需求。</div><div class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</div><div class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</div><div class="line">registry.register(URL.valueOf(<span class="string">"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule="</span>+ URL.encode(<span class="string">"http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11"</span>)));</div></pre></td></tr></table></figure>
</li>
<li><p>修改version<br>不推荐</p>
</li>
</ol>
<h3 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h3><p>共用注册中心，开发人员机器上的服务提供者被误调，影响其他开发人员（开发、测试环境）<br>场景：为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p><dubbo:registry register="false"><br><img src="/2017/11/24/dubbo功能介绍/只订阅结构.png" alt="只订阅"></dubbo:registry></p>
<h3 id="集群和容错"><a href="#集群和容错" class="headerlink" title="集群和容错"></a>集群和容错</h3><p><img src="/2017/11/24/dubbo功能介绍/集群容错.png" alt="集群容错"><br>将Directory中的多个Invoker伪装成一个Invoker, 对上层透明，包含集群的容错机制<br>Cluster接口定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SPI(FailoverCluster.NAME)</div><div class="line">public interface Cluster &#123;</div><div class="line">    @Adaptive</div><div class="line">    &lt;T&gt; Invoker&lt;T&gt;join(Directory&lt;T&gt; directory) throws RpcException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cluster可以看做是工厂类， 将目录directory下的invoker合并成一个统一的Invoker，根据不同集群策略的Cluster创建不同的Invoker我们来看下默认的失败转移，当出现失败重试其他服务的策略, 这个Cluster实现很简单就是创建FailoverCluseterInvoker对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FailoverCluster implements Cluster &#123;</div><div class="line">    public final static String NAME =<span class="string">"failover"</span>;</div><div class="line">    public&lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory)throws RpcException&#123;</div><div class="line">        <span class="built_in">return</span> new FailoverClusterInvoker&lt;T&gt;(directory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/集群方案.png" alt="集群方案"><br>1）AvailableCluster: 获取可用的调用。遍历所有Invokers判断Invoker.isAvalible,只要一个有为true直接调用返回，不管成不成功<br>2）BroadcastCluster: 广播调用。遍历所有Invokers, 逐个调用每个调用catch住异常不影响其他invoker调用<br>3）FailbackCluster: 失败自动恢复， 对于invoker调用失败， 后台记录失败请求，任务定时重发, 通常用于通知<br>4）FailfastCluster: 快速失败，只发起一次调用，失败立即保错，通常用于非幂等性操作<br>5）FailoverCluster: 失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟<br>（1）   目录服务directory.list(invocation) 列出方法的所有可调用服务<br>获取重试次数，默认重试两次<br>（2）   根据LoadBalance负载策略选择一个Invoker<br>（3）   执行invoker.invoke(invocation)调用<br>（4）   调用成功返回<br>调用失败小于重试次数，重新执行从3）步骤开始执行<br>       调用次数大于等于重试次数抛出调用失败异常<br>6）FailsafeCluster: 失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。<br>7）ForkingCluster: 并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。<br>8）  MergeableCluster: 分组聚合， 按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。<br>这个还蛮有意思，我们分析下是如何实现的<br>（1）   根据MERGE_KEY从url获取参数值<br>（2）   为空不需要merge， 正常调用<br>（3）   按group分组调用，将返回接口保存到集合中<br>（4）   获取MERGE_KEY如果是默认的话，获取默认merge策略，主要根据返回类型判断<br>（5）   如果不是，获取自定义的merge策略<br>（6）   Merge策略合并调用结果返回<br><img src="/2017/11/24/dubbo功能介绍/merge.png" alt="merge"><br>9）MockClusterWrapper: 具备调用mock功能是其他Cluster包装<br>获取url的MOCK_KEY属性<br>（1）   不存在直接调用其他cluster<br>（2）   存在值startsWith(“force”) 强制mock调用<br>（3）   存在值不是startsWith(“force”) 先正常调用， 出现异常在mock调用<br>集群模式的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:service cluster=<span class="string">"failsafe"</span> /&gt;    服务提供方</div><div class="line">&lt;dubbo:reference cluster=<span class="string">"failsafe"</span> /&gt;  服务消费方</div></pre></td></tr></table></figure></p>
<h3 id="多注册中心引用"><a href="#多注册中心引用" class="headerlink" title="多注册中心引用"></a>多注册中心引用</h3><p>解决CRM需同时调用中文站和国际站PC2相同接口相同版本服务的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">定义多个注册中心：</div><div class="line">&lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"172.29.63.18:9090"</span> /&gt;</div><div class="line">&lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"172.29.61.132:9090"</span> /&gt;</div><div class="line">不同注册中心使用不同引用：</div><div class="line">&lt;dubbo:reference id=<span class="string">"chinaXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"intlXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="graceful-shutdown"><a href="#graceful-shutdown" class="headerlink" title="graceful shutdown"></a>graceful shutdown</h3><p><img src="/2017/11/24/dubbo功能介绍/shutdown.png" alt="shutdown"></p>
<h2 id="dubbo-Rpc高级功能"><a href="#dubbo-Rpc高级功能" class="headerlink" title="dubbo-Rpc高级功能"></a>dubbo-Rpc高级功能</h2><p><img src="/2017/11/24/dubbo功能介绍/高级功能.png" alt="高级功能"></p>
<h3 id="telnet互操作"><a href="#telnet互操作" class="headerlink" title="telnet互操作"></a>telnet互操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\&gt; telnet localhost 20880</div><div class="line">dubbo&gt; <span class="built_in">help</span></div><div class="line">ls <span class="_">-l</span></div><div class="line">ps <span class="_">-l</span></div><div class="line">status <span class="_">-l</span></div><div class="line">trace XxxService 10</div><div class="line">count XxxService</div><div class="line">invoke XxxService.xxxMethod(args)</div><div class="line"><span class="built_in">log</span> 100</div></pre></td></tr></table></figure>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>泛接口调用方式主要用于客户端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过GenericService调用所有服务实现。所谓泛化调用是使用通用服务接口.GenericService来invoke需要调用的服务方法，这种设计无疑是可复用、可扩展之典范。 GenericService只有一个方法Object$invoke(String method,String[] parameterTypes,Object[] args)throwsGenericException;invoke接受三个参数，分别为方法名，参数类型组以及参数值组，其中参数类型和参数值一一对应.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> generic=<span class="string">"true"</span> /&gt;</div><div class="line">GenericService barService = (GenericService) applicationContext.getBean(<span class="string">"barService"</span>);</div><div class="line">Object result = barService.<span class="variable">$invoke</span>(<span class="string">"sayHello"</span>, new String[] &#123; <span class="string">"java.lang.String"</span> &#125;, new Object[] &#123; <span class="string">"World"</span> &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="显示回调"><a href="#显示回调" class="headerlink" title="显示回调"></a>显示回调</h3><p><img src="/2017/11/24/dubbo功能介绍/回调.png" alt="回调"><br>参数回调方式与调用本地callback或listener相同，只需要在Spring的配置文件中声明哪个参数是callback类型即可，Dubbo将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>并行发起多个请求，但只使用一个线程,基于NIO非阻塞实现并行调用，不用开启多线程，开销变小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:method name=<span class="string">"findXxx"</span> async=<span class="string">"true"</span> /&gt;</div><div class="line">xxxService.findXxx();//返回null</div><div class="line">Future&lt;Xxx&gt; future=RpcContext。getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/async.png" alt="async"></p>
<h3 id="框架事件"><a href="#框架事件" class="headerlink" title="框架事件"></a>框架事件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Dubbo:service … ondisconnected= xxx &gt;</div><div class="line">&lt;Dubbo:reference … ondisconnected =xxx&gt;</div></pre></td></tr></table></figure>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>在客户端执行部分代码，比如：<br>– 在客户端缓存已查询过的数据<br>– 当服务器端全部不可用时，伪造容错数据<br><img src="/2017/11/24/dubbo功能介绍/本地执行.png" alt="本地执行"></p>
<h3 id="隐式传参"><a href="#隐式传参" class="headerlink" title="隐式传参"></a>隐式传参</h3><p>隐式传参，比如：<br>– 验权扩展点需要携带一些用户凭证信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">• ThreadLocal Context</div><div class="line">– RpcContext.setAttachment(<span class="string">"password"</span>, <span class="string">"xxx"</span>);</div><div class="line">– RpcContext.getAttachment(<span class="string">"password"</span>);</div><div class="line"></div><div class="line">//Consumer</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"parm"</span>, <span class="string">"嘿嘿"</span>+i);</div><div class="line">//server</div><div class="line">Map&lt;String, String&gt; attachments = RpcContext.getContext()</div><div class="line">               .getAttachments();</div><div class="line">String parm = attachments.get(<span class="string">"parm"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>注册中心路由<br>注册中心根据路由规则挑选服务提供者列表<br>RPC路由<br>根据类、方法、参数级别的路由规则<br>数据sharding<br>– 开发阶段的服务过滤(classifier)<br>– 可扩展的路由接口&amp;基于ScriptEngine的实现<br>• simpleEL<br>• Groovy ..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(invokers,invocation,context)&#123;</div><div class="line">var result = new java.util.ArrayList();</div><div class="line"><span class="keyword">if</span> (invokers.size()&gt;1 &amp;&amp;</div><div class="line">invocation.getMethodName() .equals(<span class="string">"method1"</span>)) &#123;</div><div class="line">result.add(invokers.get(0)) ;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">result.add(invokers.get(1)) ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;;</div><div class="line">route(invokers,invocation,context);</div></pre></td></tr></table></figure></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>actives:consumer并发数限制<br>executes:provider并发数限制<br>connections：consumer连接数限制<br>accept：provider连接数限制<br>短连接是连接上限，长连接则是启用的连接数<br>LeastActive LoadBalance:<br>调用并发数最少的provider，调节provider的并发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">并发控制</div><div class="line">限制com.foo.BarService的每个方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">限制com.foo.BarService的每个方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了actives，&lt;dubbo:reference&gt;优先，参见：配置的覆盖策略。</div><div class="line">Load Balance均衡：</div><div class="line">配置服务的客户端的loadbalance属性为leastactive，此Loadbalance会调用并发数最小的Provider（Consumer端并发数）。</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">连接控制</div><div class="line">限制服务器端接受的连接不能超过10个：（以连接在Server上，所以配置在Provider上）</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">限制客户端服务使用连接连接数：(如果是长连接，比如Dubbo协议，connections表示该服务对每个提供者建立的长连接数)</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了connections，&lt;dubbo:reference&gt;优先</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/elasticsearch权威后续/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/elasticsearch权威后续/" itemprop="url">elasticsearch权威后续</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T21:44:09+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式增删改查"><a href="#分布式增删改查" class="headerlink" title="分布式增删改查"></a>分布式增删改查</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard=<span class="built_in">hash</span>(routing)%number_of_primary_shards</div></pre></td></tr></table></figure>
<p>routing是一个字符串，默认是_id；这也就解释了主分片的数量只能在创建索引时定义且不能修改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档也就永远找不到了</p>
<h2 id="分片交互"><a href="#分片交互" class="headerlink" title="分片交互"></a>分片交互</h2><p>我们能够发送请求给集群中任意一个节点。每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。下面的例子中，我们将发送所有请求给 Node 1  ，这个节点我们将会称之为请求节点</p>
<h2 id="新建、索引、删除文档"><a href="#新建、索引、删除文档" class="headerlink" title="新建、索引、删除文档"></a>新建、索引、删除文档</h2><p>新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。<br>罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：</p>
<ul>
<li>客户端给Node1发送新建、索引或删除请求。</li>
<li>节点使用文档的_id  确定文档属于分片0。它转发请求到 Node3，分片0位于这个节点上</li>
<li>Node3在主分片上执行请求，如果成功，它转发请求到相应的位于 Node1和 Node2的复制节点上当所有的复制节点报告成功,Node 3报告成功到请求的节点，请求的节点再报告给客户端。客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</li>
</ul>
<h3 id="replication（注意在ElasticSearch-5-0开始被废弃）"><a href="#replication（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="replication（注意在ElasticSearch 5.0开始被废弃）"></a>replication（注意在ElasticSearch 5.0开始被废弃）</h3><p>复制默认的值是 sync。这将导致主分片得到复制分片的成功响应后才返回。<br>如果你设置 replication为 async，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。</p>
<h3 id="consistency（注意在ElasticSearch-5-0开始被废弃）"><a href="#consistency（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="consistency（注意在ElasticSearch 5.0开始被废弃）"></a>consistency（注意在ElasticSearch 5.0开始被废弃）</h3><p>默认主分片在尝试写入时需要<strong>规定数量(quorum)或过半的分片（可以是主节点或复制节点）可用。这是防止数据被写入到错的网络分区</strong>。规定的数量计算公式如下：<br>int( (primary + number_of_replicas) / 2 ) + 1<br>consistency允许的值为one（只有一个主分片），all（所有主分片和复制分片）或者默认的quorum或过半分片。<br>注意number_of_replicas是在索引中的的设置，用来定义复制分片的数量，而不是现在活动的复制节点的数量。如果你定义了索引有3个复制节点，那规定数量是：int( (primary + 3 replicas) / 2 ) + 1 = 3<br>但如果你只有2个节点，那你的活动分片不够规定数量，也就不能索引或删除任何文档。<br>注意: 新索引默认有1个复制分片，这意味着为了满足quorum的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在number_of_replicas大于一时才生效。</p>
<h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。默认等待一分钟。如果需要，你可以设置 timeout参数让它终止的更早： 100  表示100毫秒， 30s  表示30秒。</p>
<blockquote>
<p>新索引默认有 1  个复制分片，这意味着为了满足 quorum  的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在 number_of_replicas  大于一时才生效</p>
</blockquote>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><ol>
<li>客户端给Node1发送get请求。</li>
<li>节点使用文档的id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。此时，它转发请求到 Node2。</li>
<li>Node2返回endangered给Node1然后返回给客户端。</li>
</ol>
<p>对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本。可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol>
<li>客户端给Node1发送更新请求。</li>
<li>它转发请求到主分片所在节点Node3。</li>
<li>Node3从主分片检索出文档，修改source字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以retry_on_conflict设置的次数重复步骤3，都未成功则放弃。</li>
<li>如果 Node3成功更新文档，它同时转发文档的新版本到Node1和Node2上的复制节点以重建索引。当所有复制节点报告成功,Node3返回成功给请求节点，然后返回给客户端.<blockquote>
<p>当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本。记住这些修改转发到复制节点是异步的，它们并不能保证到达的顺序与发送相同。如果Elasticsearch转发的仅仅是修改请求，修改的顺序可能是错误的，那得到的就是个损坏的文档。</p>
</blockquote>
</li>
</ol>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget请求检索多个文档的顺序步骤：</p>
<ol>
<li>客户端向Node1发送mget请求。</li>
<li>Node1为每个分片构建一个多条数据检索请求，然后转发到这些请求所需的主分片或复制分片上。当所有回复被接收，Node1构建响应并返回给客户端</li>
</ol>
<p>bulk执行多个create、index、delete和update请求的顺序步骤：</p>
<ol>
<li>客户端向Node1发送bulk请求。</li>
<li>Node1为每个分片构建批量请求，然后转发到这些请求所需的主分片上。</li>
<li>主分片一个接一个的按序执行操作。当一个操作执行完，主分片转发新文档（或者删除部分）给对应的复制节点，然后执行下一个操作。复制节点为报告所有操作完成，节点报告给请求节点，请求节点整理响应并返回给客户端。</li>
</ol>
<p>这里我们可以解释bulk的格式，而不是包装成json格式请求：意味着我们需要解析JSON为数组（包括文档数据，可能非常大）、检查每个请求决定应该到哪个分片上、为每个分片创建一个请求的数组、序列化这些数组为内部传输格式、发送请求到每个分片。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><table>
<thead>
<tr>
<th>概念</th>
<th style="text-align:right">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mappings(映射)</td>
<td style="text-align:right">数据在每个字段中的解释说明</td>
</tr>
<tr>
<td>analysis(分析)</td>
<td style="text-align:right">全文是如何处理的可以被搜索的</td>
</tr>
<tr>
<td>领域特定语句查询(query DSL)</td>
<td style="text-align:right">Elasticsearch使用的灵活的、强大的查询语言</td>
</tr>
</tbody>
</table>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>没有指定任何的查询条件，只返回集群索引中的所有文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure></p>
<h2 id="多索引和多类别"><a href="#多索引和多类别" class="headerlink" title="多索引和多类别"></a>多索引和多类别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/_search  //在所有索引的所有类型中搜索</div><div class="line">/gb/_search //在索引gb的所有类型中搜索</div><div class="line">/gb,us/_search //在索引gb us的所有类型中搜索</div><div class="line">/g*,u*/_search //在索引g或u开头的所有类型中搜索</div><div class="line">/gb/user/_search //在索引 gb的类型user中搜索</div><div class="line">/gb,us/user,tweet/_search //在gb、us的user和tweet类型中搜索</div><div class="line">/_all/user,tweet/_search //在user和tweet类型中搜索</div></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>size默认为10 from默认为0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure></p>
<p>注意：现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长</p>
<h1 id="映射分析"><a href="#映射分析" class="headerlink" title="映射分析"></a>映射分析</h1><h2 id="确切值和全文文本"><a href="#确切值和全文文本" class="headerlink" title="确切值和全文文本"></a>确切值和全文文本</h2><p>确切值是确定的，正如它的名字一样。比如一个date或用户ID，也可以包含更多的字符串比如username或email地址。全文文本，从另一个角度来说是文本化的数据(常常以人类的语言书写)，比如一片推文(Twitter的文章)或邮件正文<br>确切值是很容易查询的，因为结果是二进制的 – 要么匹配，要么不匹配。</p>
<h2 id="分析和分析器"><a href="#分析和分析器" class="headerlink" title="分析和分析器"></a>分析和分析器</h2><p>分析(analysis)是这样一个过程：<br>首先，表征化一个文本块为适用于倒排索引单独的词(term)<br>然后标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><table>
<thead>
<tr>
<th>类型</th>
<th>标识的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
</tr>
<tr>
<td>whole number</td>
<td>byte、short、integer、long</td>
</tr>
<tr>
<td>floating point</td>
<td>float、double</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Date</td>
<td>date</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>field type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean:true,false</td>
<td>“boolean”</td>
</tr>
<tr>
<td>whole number:123</td>
<td>“long”</td>
</tr>
<tr>
<td>floating point:123.45</td>
<td>“double”</td>
</tr>
<tr>
<td>String:”123”</td>
<td>“string”</td>
</tr>
<tr>
<td>string valid date:”2016-05-01”</td>
<td>date”</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这意味着，如果你索引一个带引号的数字—— “123”  ，它将被映射为 “string”  类型，而不是 “long”  类型。然而，如果字段已经被映射为 “long”  类型，Elasticsearch将尝试转换字符串为long，并在转换失败时会抛出异常。</p>
</blockquote>
<h3 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get sjjhpt/_mapping/fwjbl</div></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>analyzed</td>
<td>首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。</td>
</tr>
<tr>
<td>not_analyzed</td>
<td>索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段</td>
</tr>
<tr>
<td>no</td>
<td>不索引这个字段。这个字段不能为搜索到</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="string">"userid"</span>:&#123;</div><div class="line">     <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">     <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line"></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其他简单类型——long、double、date等等——也接受index参数，但相应的值只能是 no和not_analyzed,它们的值不能被分析</p>
</blockquote>
<h3 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PUT /gb/_mapping/tweet</div><div class="line">&#123;</div><div class="line"><span class="string">"properties"</span> : &#123;</div><div class="line"><span class="string">"tag"</span> :&#123;</div><div class="line"><span class="string">"type"</span> : <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复合核心字段类型"><a href="#复合核心字段类型" class="headerlink" title="复合核心字段类型"></a>复合核心字段类型</h2><h3 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h3><p>数组：{ “tag”: [ “search”, “nosql” ]}<br>对于数组不需要特殊的映射。任何一个字段可以包含零个、一个或多个值，同样对于全文字段将被分析并产生多个词。这意味着数组中所有值必须为同一类型。你不能把日期和字符窜混合。如果你创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型。</p>
<h3 id="空字段"><a href="#空字段" class="headerlink" title="空字段"></a>空字段</h3><p>Lucene没法存放null值，所以一个null值的字段被认为是空字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"empty_string"</span>: <span class="string">""</span>,</div><div class="line"><span class="string">"null_value"</span>: null,</div><div class="line"><span class="string">"empty_array"</span>: [],</div><div class="line"><span class="string">"array_with_null_value"</span>: [ null ]</div></pre></td></tr></table></figure></p>
<h3 id="多层对象"><a href="#多层对象" class="headerlink" title="多层对象"></a>多层对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="string">"gb"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123;</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"user"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"id"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"gender"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"age"</span>: &#123; <span class="string">"type"</span>: <span class="string">"long"</span> &#125;,</div><div class="line">      <span class="string">"name"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"full"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"first"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"last"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;</div><div class="line">       &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多层对像user的first，我们需要制定他的完整路径，像”user.name.first”或者tweet.user.name.first，而对于lucene，我们不能检索user或者user.name,我们不能检索复杂的结构体.</p>
<h1 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h1><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 30,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结构化查询-1"><a href="#结构化查询-1" class="headerlink" title="结构化查询"></a>结构化查询</h2><p>使用结构化查询，你需要传递query参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: your_query_here</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">       <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询子句"><a href="#查询子句" class="headerlink" title="查询子句"></a>查询子句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> QUERY_NAME: &#123;</div><div class="line"> ARGUMENT: VALUE</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">  <span class="string">"match"</span>: &#123;</div><div class="line">  <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并多字句"><a href="#合并多字句" class="headerlink" title="合并多字句"></a>合并多字句</h3><p>复合子句(compound)用以合并其他的子句。bool子句允许你合并其他的合法子句，无论是must，must_not还是should<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"> <span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"spam"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#125;&#125;</div><div class="line">],</div><div class="line"><span class="string">"minimum_should_match"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>一条查询语句会计算每个文档与查询语句的相关性，会给出一个相关性评分_score并且按照相关性对匹配到的文档进行排序。这种评分方式非常适用于一个没有完全配置结果的全文本搜索。</p>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p>使用过滤语句得到的结果集 – 一个简单的文档列表，快速匹配运算并存入内存是十分方便的，每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。<br>查询语句不仅要查找相匹配的文档，还需要计算每个文档的相关性，所以一般来说查询语句要比过滤语句更耗时，并且查询结果也不可缓存。<br>原则上来说，使用查询语句做全文本搜索或其他需要进行相关性评分的时候，剩下的全部用过滤语句</p>
<h2 id="查询过滤语句"><a href="#查询过滤语句" class="headerlink" title="查询过滤语句"></a>查询过滤语句</h2><h3 id="term过滤"><a href="#term过滤" class="headerlink" title="term过滤"></a>term过滤</h3><p>term用于精确匹配哪些值，比如数字，日期，布尔值或not_analyzed的字符串(未经分析的文本数据类型)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="terms过滤"><a href="#terms过滤" class="headerlink" title="terms过滤"></a>terms过滤</h3><p>terms允许指定多个匹配条件.如果某个字段指定了多个值，那么文档需要一起去做匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"terms"</span>:&#123;</div><div class="line">      <span class="string">"jkbsf"</span>:[<span class="string">"test"</span>,<span class="string">"test1"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="range过滤"><a href="#range过滤" class="headerlink" title="range过滤"></a>range过滤</h3><p>用于查询范围<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"range"</span>:&#123;</div><div class="line">      <span class="string">"age"</span>:&#123;</div><div class="line">          <span class="string">"gte"</span>:10,</div><div class="line">          <span class="string">"lt"</span>:20</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gt：大于、gte:大于等于、lt:小于、lte：小于等于</p>
<h3 id="exists和missing过滤"><a href="#exists和missing过滤" class="headerlink" title="exists和missing过滤"></a>exists和missing过滤</h3><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"exists"</span>:   &#123;</div><div class="line">        <span class="string">"field"</span>:    <span class="string">"title"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="bool过滤"><a href="#bool过滤" class="headerlink" title="bool过滤"></a>bool过滤</h3><p>bool 过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含一下操作符：<br>must :: 多个查询条件的完全匹配,相当于 and。<br>must_not :: 多个查询条件的相反匹配，相当于 not。<br>should :: 至少有一个查询条件匹配, 相当于 or。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">        <span class="string">"must"</span>:     &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line">        <span class="string">"must_not"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>:    <span class="string">"spam"</span>  &#125;&#125;,</div><div class="line">        <span class="string">"should"</span>: [</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span>   &#125;&#125;,</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"unread"</span>:  <span class="literal">true</span>   &#125;&#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">### match查询</span></div><div class="line">match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它</div><div class="line">如果你使用  match  查询一个全文本字段，它会在真正查询之前用分析器先分析 match  一下查询字符</div><div class="line">``` bash</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"About Search"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 match下指定了一个确切值，在遇到数字，日期，布尔值或者 not_analyzed的字符串时，它将为你搜索你给定的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。</p>
</blockquote>
<h3 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"full text search"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询与bool过滤相似，用于合并多个查询子句。不同的是，bool过滤可以直接给出是否匹配成功，而bool查询要计算每一个查询子句的score（相关性分值）。<br>must  :: 查询指定文档一定要被包含。<br>must_not  :: 查询指定文档一定不要被包含。<br>should  :: 查询指定文档，有则可以为文档相关性加分。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"spam"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"range"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 如果bool查询下没有must子句，那至少应该有一个should子句。但是如果有must子句，那么没有should子句也可以进行查询。</p>
</blockquote>
<h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>查询语句和过滤语句可以放在各自的上下文中。在 ElasticSearch API 中我们会看到许多带有query或 filter的语句。这些语句既可以包含单条 query 语句，也可以包含一条 filter子句。换句话说，这些语句需要首先创建一个query或filter的上下文关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"filtered"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /gb/tweet/_validate/query</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span> : &#123;</div><div class="line"><span class="string">"match"</span> : <span class="string">"really powerful"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="字段值排序"><a href="#字段值排序" class="headerlink" title="字段值排序"></a>字段值排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="默认排序"><a href="#默认排序" class="headerlink" title="默认排序"></a>默认排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//默认以顺序排序，_score以倒序排序</div><div class="line"><span class="string">"sort"</span>: <span class="string">"number_of_children"</span></div></pre></td></tr></table></figure>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: [</div><div class="line">&#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</div></pre></td></tr></table></figure>
<h3 id="多值字段字符串排序"><a href="#多值字段字符串排序" class="headerlink" title="多值字段字符串排序"></a>多值字段字符串排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//改变前的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">//改变后的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span>,</div><div class="line"><span class="string">"fields"</span>: &#123;</div><div class="line"><span class="string">"raw"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//现在，在给数据重建索引后，我们既可以使用  tweet  字段进行全文本搜索，也可以用 tweet.raw  字段进行排序</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></div><div class="line">&#125;</div><div class="line">对analyzed字段进行强制排序会消耗大量内存</div></pre></td></tr></table></figure>
<h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><p>每个文档都有相关性评分，用一个相对的浮点数字段_score来表示,_score的评分越高，相关性越高.fuzzy查询会计算与关键词的拼写相似程度,terms查询会计算 找到的内容与关键词组成部分匹配的百分比，但是一般意义上我们说的全文本搜索是指计算内容与关键词的类似程度。<br>es的相似度算法被定义为TF/IDF,即检索词频率和反向文档频率，<br>检索词频率：检索词在该字段出现的频率；也就是出现频率越高，相关性越高。<br>反向文档频率：每个检索词在索引中出现的频率；频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低，即检验一个检索词在文档中的普遍重要性<br>字段长度准则：长度越长，相关度越低。<br>如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<h3 id="理解评分规则"><a href="#理解评分规则" class="headerlink" title="理解评分规则"></a>理解评分规则</h3><p>explain参数可以让返回结果添加一个_score评分的得来依据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /_search?explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Explain-Api"><a href="#Explain-Api" class="headerlink" title="Explain Api"></a>Explain Api</h3><p> explain  选项加到某一文档上时，它会告诉你为何这个文档会被匹配，以及一个文档为何没有被匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /us/tweet/12/_explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;,</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//response</div><div class="line"><span class="string">"failure to match filter: cache(user_id:[2 TO 2])"</span></div></pre></td></tr></table></figure></p>
<h2 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h2><p>为了提高排序效率，ElasticSearch 会将所有字段的值加载到内存中，这就叫做”数据字段”</p>
<blockquote>
<p>es将所有字段数据加载到内存中并不是匹配到的那部分数据,而是索引下所有文档中的值，包括所有类型</p>
</blockquote>
<p>将所有字段数据加载到内存中是因为从硬盘反向倒排索引是非常缓慢的。尽管你这次请求需要的是某些文档中的部分数据，但你下个请求却需要另外的数据，所以将所有字段数据一次性加载到内存中是十分必要的。<br>ElasticSearch中的字段数据常被应用到以下场景：</p>
<ol>
<li>对一个字段进行排序</li>
<li>对一个字段进行聚合</li>
<li>某些过滤，比如地理位置过滤</li>
<li>某些与字段相关的脚本计算<br>这会消耗掉很多内存，尤其是大量的字符串数据 – string字段可能包含很多不同的值，比如邮件内容。 值得庆幸的是，内存不足是可以通过横向扩展解决的，我们可以增加更多的节点到集群。<h1 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h1>一个CRUD操作只处理一个单独的文档。文档的唯一性由 _index  ,  _type  和 routing-value  （通常默认是该文档的 _id  ）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。但如果针对复杂的搜索模型，由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上）。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。搜索的执行过程分两个阶段，称为查询然后取回（query then fetch）<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2>在初始化查询阶段，查询被向索引中的每个分片或者副本广播，每个分片会在本地执行搜索并建立匹配文档的优先队列。<blockquote>
<p>优先队列<br>一个优先队列（priority queue is）只是一个存有前n个（top-n）匹配document的有序列表。这个优先队列的大小由分页参数from和size决定。例如，下面这个例子中的搜索请求要求优先队列要能够容纳100个document</p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 90,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询阶段包含以下三步：<br>1.客户端发送一个search给node3，node3创建一个from+size的空优先队列；<br>2.node3转发请求到索引中每个分片的原本或者副本，每个分片在本地执行这个查询并且将结果放到一个from+size的优先队列里；<br>3.每个分片返回documentid和它优先队列里所有document的排序值给协调节点node3.协调节点node3把这些值合并到自己的优先队列产生全局排列的结果<br>当一个搜索请求被发送到一个节点node时，这个节点就成了协调节点，这个节点工作是向所有相关的分片广播搜索请求并把他们的响应整合成全局的有序结果集。<br>第一步是向索引里的每个节点的分片副本广播请求。就像document的 GET  请求一样，搜索请求可以被每个分片的原本或任意副本处理。对于后续请求，协调节点会轮询所有的分片副本以分摊负载。<br>每一个分片在本地执行查询和建立一个长度为 from+size  的有序优先队列——这个长度意味着它自己的结果数量就足够满足全局的请求要求。分片返回一个轻量级的结果列表给协调节点。只包含documentID值和排序需要用到的值，例如 _score。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>分布式搜索取回阶段如下：<br>1.协调节点需要辨别哪个document需要取回，并且向相关分片发送GET请求。<br>2.每个分片加载document并根据需要丰富他，然后再将document返回给协调节点。<br>3.一旦所有的document都被取回，协调节点会将结果返回给客户端<br>分片加载document主体—— _source  field。如果需要，还会根据元数据丰富结果和高亮搜索片断。一旦协调节点收到所有结果，会将它们汇集到单一的回答响应里，这个响应将会返回给客户端。  </p>
<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>是机器人或者网络爬虫的行为。它们会持续不断地一页接着一页地获取页面直到服务器到底崩溃的边缘<br>查询然后取回过程虽然支持通过使用 from  和 size  参数进行分页，但是要在有限范围内（within limited）。还记得每个分片必须构造一个长度为 from+size  的优先队列吧，所有这些都要传回协调节点。这意味着协调节点要通过对 分片数量 * (from +size)  个document进行排序来找到正确的 size  个document。</p>
<h2 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h2><h3 id="preference（偏爱）"><a href="#preference（偏爱）" class="headerlink" title="preference（偏爱）"></a>preference（偏爱）</h3><p>preference  参数允许你控制使用哪个分片或节点来处理搜索请求。她接受如下一些参数<br>primary：搜索只在主分片执行搜索请求，副本不参与搜索；性能会打折扣，达不到性能的水平扩展。<br>_primary_first：优先在主分片执行，如果主分片挂掉，会在副本执行请求。<br>_local：搜索请求优先于在本地执行。<br>_only_node:xyz：只在xyz节点执行搜索。<br>_prefer_node:xyz：搜索请求优先在节点xyz执行。<br>_shards:2,3：搜索只在分片2、3执行，可以与_primary参数一起使用如：_shards:2,3;_primary<br>随机字符串：指定一个随机字符串，可以保证同样的请求，被分配到同样的副本上面，从而保证同一请求结果的稳定性。<br>结果震荡<br>想像一下，你正在按照 timestamp  字段来对你的结果排序，并且有两个document有相同的timestamp。由于搜索请求是在所有有效的分片副本间轮询的，这两个document可能在原始分片里是一种顺序，在副本分片里是另一种顺序.这就是被称为结果震荡（bouncing results）的问题：用户每次刷新页面，结果顺序会发生变化。避免这个问题方法是对于同一个用户总是使用同一个分片。方法就是使用一个随机字符串例如用户的会话ID（session ID）来设置 preference  参数</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。<br>timeout参数告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回。返回部分结果总比什么都没有好<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"timed_out"</span>: <span class="literal">true</span>, (1)</div><div class="line"><span class="string">"_shards"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: 5,</div><div class="line"><span class="string">"successful"</span>: 4,</div><div class="line"><span class="string">"failed"</span>: 1 (2)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>在搜索时，你可以指定一个或多个 routing  值来限制只搜索那些分片而不是搜索index里的全部分片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?routing=user_1,user2</div></pre></td></tr></table></figure></p>
<h3 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h3><p>默认的搜索类型是query_then_fetch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?search_type=count</div></pre></td></tr></table></figure></p>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>count（计数）搜索类型只有一个 query（查询）  的阶段。当不需要搜索结果只需要知道满足查询的document的数量时，可以使用这个查询类型。</p>
<h4 id="query-then-fetch-查询并且取回"><a href="#query-then-fetch-查询并且取回" class="headerlink" title="query_then_fetch 查询并且取回"></a>query_then_fetch 查询并且取回</h4><p>query_and_fetch（查询并且取回）  搜索类型将查询和取回阶段合并成一个步骤。这是一个内部优化选项，当搜索请求的目标只是一个分片时可以使用，例如指定了 routing（路由选择）  值时。虽然你可以手动选择使用这个搜索类型，但是这么做基本上不会有什么效果</p>
<h4 id="dfs-query-then-fetch-和-dfs-query-and-fetch"><a href="#dfs-query-then-fetch-和-dfs-query-and-fetch" class="headerlink" title="dfs_query_then_fetch 和 dfs_query_and_fetch"></a>dfs_query_then_fetch 和 dfs_query_and_fetch</h4><p>dfs  搜索类型有一个预查询的阶段，它会从全部相关的分片里取回项目频数来计算全局的项目频数。我们将在relevance-is-broken（相关性被破坏）里进一步讨论这个</p>
<h4 id="scan-扫描"><a href="#scan-扫描" class="headerlink" title="scan(扫描)"></a>scan(扫描)</h4><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API连在一起使用的，可以高效地取回巨大数量的结果。它是通过禁用排序来实现的</p>
<h2 id="扫描和滚屏"><a href="#扫描和滚屏" class="headerlink" title="扫描和滚屏"></a>扫描和滚屏</h2><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价。<br>为了使用scan-and-scroll（扫描和滚屏），需要执行一个搜索请求，将 search_type  设置成 scan  ，并且传递一个 scroll  参数来告诉Elasticsearch滚屏应该持续多长时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl -XGET <span class="string">'localhost:9200/twitter/tweet/_search?scroll=1m'</span> <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query": &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "title" : "elasticsearch"</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    size:1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个请求的应答没有包含任何命中的结果，但是包含了一个Base-64编码的 _scroll_id（滚屏id）  字符串。现在我们可以将 _scroll_id  传递给 _search/scroll  末端来获取第一批结果</div><div class="line">curl -XGET  'localhost:9200/_search/scroll<span class="string">'  -d'</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"scroll"</span> : <span class="string">"1m"</span>,</div><div class="line">    <span class="string">"scroll_id"</span> : <span class="string">"c2Nhbjs2OzM0NDg1ODpzRlBLc0FXNlNyNm5JWUc1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(1) 保持滚屏开启另一分钟。<br>(2)  _scroll_id  可以在body或者URL里传递，也可以被当做查询参数传递。注意，要再次指定 ?scroll=1m  。滚屏的终止时间会在我们每次执行滚屏请求时刷新，所以他只需要给我们足够的时间来处理<br>当前批次的结果而不是所有的匹配查询的document。<br>这个滚屏请求的应答包含了第一批次的结果。虽然指定了一个1000的size，但是获得了更多的document。当扫描时,size被应用到每一个分片上，所以我们在每个批次里最多或获得 size <em> number_of_primary_shards（size</em>主分片数）个document。</p>
<blockquote>
<p>滚屏请求也会返回一个新的_scroll_id  。每次做下一个滚屏请求时，必须传递前一次请求返回的_scroll_id  。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /_index</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"mappings"</span>:&#123;</div><div class="line">    <span class="string">"type_one"</span>:&#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>config/elasticsearch.yml,添加下面的配置来防止自动创建索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action.auto_create_index: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">number_of_shards 定义一个索引的主分片个数，默认值是 `5`。这个配置在索引创建后不能修改。</div><div class="line">number_of_replicas 每个主分片的复制分片个数，默认是 `1`。这个配置可以随时在活跃的索引上修改</div><div class="line">PUT /my_temp_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"number_of_shards"</span> : 1,</div><div class="line"><span class="string">"number_of_replicas"</span> : 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//修改</div><div class="line">PUT /my_temp_index/_settings</div><div class="line">&#123;</div><div class="line"><span class="string">"number_of_replicas"</span>: 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置分词器"><a href="#配置分词器" class="headerlink" title="配置分词器"></a>配置分词器</h2><p>standard分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了这几点<br>standard  分词器，在词层级上分割输入的文本。<br>standard  表征过滤器，被设计用来整理分词器触发的所有表征（但是目前什么都没做）。<br>lowercase  表征过滤器，将所有表征转换为小写。<br>stop  表征过滤器，删除所有可能会造成搜索歧义的停用词，如a、the、and、is  。</p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>字符过滤器、分词器、表征过滤器</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>字符过滤器是让字符串在被分词前变得更加“整洁”。例如，如果我们的文本是 HTML 格式，它可能会包含一些我们不想被索引的 HTML 标签，诸如</p><p>或<div>。我们可以使用html_strip字符过滤器 来删除所有的HTML标签，并且将HTML实体转换成对应的 Unicode字符，比如将&Aacute;  转成Á。一个分析器可能包含零到多个字符过滤器</div></p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>一个分析器必须包含一个分词器。分词器将字符串分割成单独的词（terms）或表征（tokens）。standard分析器使用standard分词器将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。</p>
<h3 id="表征过滤器"><a href="#表征过滤器" class="headerlink" title="表征过滤器"></a>表征过滤器</h3><p>表征过滤器可能修改，添加或删除表征。我们已经提过lowercase和stop表征过滤器，但是 Elasticsearch 中有更多的选择。</p>
<h3 id="创建自定义的分词器"><a href="#创建自定义的分词器" class="headerlink" title="创建自定义的分词器"></a>创建自定义的分词器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123; ... custom character filters ... &#125;,</div><div class="line"><span class="string">"tokenizer"</span>: &#123; ... custom tokenizers ... &#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; ... custom token filters ... &#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123; ... custom analyzers ... &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//实例</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123;</div><div class="line"><span class="string">"&amp;_to_and"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"mapping"</span>,</div><div class="line"><span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"my_stopwords"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"stop"</span>,</div><div class="line"><span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123;</div><div class="line"><span class="string">"my_analyzer"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"custom"</span>,</div><div class="line"><span class="string">"char_filter"</span>: [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</div><div class="line"><span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</div><div class="line"><span class="string">"filter"</span>: [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</div><div class="line">&#125;&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>除非我们告诉es在哪里使用，否则分析器不会起作用。我们可以通过下面的映射将它应用在一个string类型的字段上.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">PUT /_index/_mapping/_type</div><div class="line">&#123;</div><div class="line">  <span class="string">"properties"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">          <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">          <span class="string">"analyzer"</span>:<span class="string">"my_analyzer"</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">## 映射</span></div><div class="line">Lucene 中，一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换成多个值。Lucene 不关心这些值是字符串，数字或日期，所有的值都被当成不透明字节</div><div class="line"><span class="comment">### 预防类型陷阱</span></div><div class="line">想象一下我们的索引中有两种类型： blog_en  表示英语版的博客， blog_es  表示西班牙语版的博客。两种类型都有  title字段，但是其中一种类型使用  english  分析器，另一种使用  spanish  分析器。</div><div class="line">``` bash</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"The quick brown fox"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"blog_en.title"</span>, <span class="string">"blog_es.title"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>多个元数据字段，每一个都以下划线开头，例如  _type  ,  _id  和  _source<br>设置项，控制如何动态处理新的字段，例如analyzer,dynamic_date_formats和dynamic_templates  。其他设置，可以同时应用在根对象和其他object类型的字段上，例如enabled,dynamic和 include_in_all<br>属性重要有三个type、index、analyzer</p>
<h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>默认情况下，Elasticsearch 用 JSON 字符串来表示文档主体保存在  _source  字段中。像其他保存的字段一样,_source字段也会在写入硬盘前压缩<br>需要source的理由：</p>
<ol>
<li>搜索结果中能得到完整的文档 —— 不需要额外去别的数据源中查询文档</li>
<li>如果缺少_source字段，部分更新请求不会起作用</li>
<li>当你的映射有变化，而且你需要重新索引数据时，你可以直接在 Elasticsearch 中操作而不需要重新从别的数据源中取回数据</li>
<li>你可以从  _source  中通过  get  或  search  请求取回部分字段，而不是整个文档</li>
<li>这样容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆ID中猜测他们的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//禁用<span class="built_in">source</span></div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_source"</span>: &#123;</div><div class="line"><span class="string">"enabled"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</div><div class="line"><span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="元数据-all字段"><a href="#元数据-all字段" class="headerlink" title="元数据:_all字段"></a>元数据:_all字段</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//当你还不清楚最终文档的结构时，可以将任何查询用于这个字段</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 禁用_all</div><div class="line">PUT /my_index/_mapping/my_type</div><div class="line">&#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过  include_in_all  选项可以控制字段是否要被包含在_all字段中，默认值是true。</p>
<h2 id="文档id"><a href="#文档id" class="headerlink" title="文档id"></a>文档id</h2><p>文档唯一标识由_index、_type、_id、_uid组成</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>它通过动态映射来确定字段的数据类型且自动将该字段加到类型映射中，通过dynamic设置来控制这些行为，它接受下面几个选项true：自动添加字段（默认）、false：忽略字段、strict：当遇到未知字段时抛出异常<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic"</span>: <span class="string">"strict"</span>, &lt;1&gt;</div><div class="line"><span class="string">"properties"</span>: &#123;</div><div class="line"><span class="string">"title"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</div><div class="line"><span class="string">"stash"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line"><span class="string">"dynamic"</span>: <span class="literal">true</span> &lt;2&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断字符串为日期的规则可以通过dynamic_date_formats配置来修改</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用dynamic_templates，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//es  : 字段名以  _es  结尾需要使用spanish分析器 ;en:所有其他字段使用english分析器。</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic_templates"</span>: [</div><div class="line">自定义动态索引</div><div class="line">日期检测</div><div class="line">动态模板</div><div class="line">&#123; <span class="string">"es"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*_es"</span>, &lt;1&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"spanish"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"en"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*"</span>, &lt;2&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="默认映射"><a href="#默认映射" class="headerlink" title="默认映射"></a>默认映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"_default_"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"blog"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><p>_source字段的一个最大的好处是你已经在 Elasticsearch 中有了完整的文档，你不再需要从数据库中重建你的索引。你可以在同一时间执行多个重新索引的任务，但是你显然不愿意它们的结果有重叠。所以，可以将重建大索引的任务通过日期或时间戳字段拆分成较小的任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"range"</span>: &#123;</div><div class="line"><span class="string">"date"</span>: &#123;</div><div class="line"><span class="string">"gte"</span>: <span class="string">"2014-01-01"</span>,</div><div class="line"><span class="string">"lt"</span>: <span class="string">"2014-02-01"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"size"</span>: 1000</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建一个索引  my_index_v1  ，然后将别名  my_index  指向它</div><div class="line">PUT /my_index_v1 &lt;1&gt;</div><div class="line">PUT /my_index_v1/_alias/my_index &lt;2&gt;</div><div class="line">//你可以检测这个别名指向哪个索引</div><div class="line">GET /*/_alias/my_index</div><div class="line">//哪些别名指向这个索引</div><div class="line">GET /my_index_v1/_alias/*</div><div class="line">//别名可以指向多个索引，所以我们需要在新索引中添加别名的同时从旧索引中删除它</div><div class="line">POST /_aliases</div><div class="line">&#123;</div><div class="line"><span class="string">"actions"</span>: [</div><div class="line">&#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="深入分片"><a href="#深入分片" class="headerlink" title="深入分片"></a>深入分片</h1><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。<br>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：<br>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。<br>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h2 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h2><p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件<br>新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存，不时地, 缓存被提交</li>
<li>不时地, 缓存被 提交 ：<br>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。新的段被开启，让它包含的文档可见以被搜索。内存缓存被清空，等待接收新的文档。</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<h2 id="删除更新"><a href="#删除更新" class="headerlink" title="删除更新"></a>删除更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。<br>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。<br>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。<br>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。<br>但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<h3 id="refresh-api"><a href="#refresh-api" class="headerlink" title="refresh api"></a>refresh api</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST /_refresh //刷新所有索引</div><div class="line">POST /blogs/_refresh //刷新blogs索引</div><div class="line">//正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率</div><div class="line">PUT /my_logs</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>: &#123;</div><div class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> //每30秒刷新 my_logs 索引</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//当你在建立一个大索引时，可以关闭自动刷新</div><div class="line">PUT /my_logs/_settings</div><div class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125;</div></pre></td></tr></table></figure></p>
<h2 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h2><p>1.新的文档被添加到内存缓冲区并且被追加到了事务日志<br>2.刷新（refresh）完成后, 缓存被清空但是事务日志不会<br>3.事务日志不断积累文档<br>4.在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST /blogs/_flush //刷新（flush） blogs 索引</div><div class="line">POST /_flush?wait_for_ongoing //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</div></pre></td></tr></table></figure></p>
<h2 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h2><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。启动段合并不需要你做任何事。进行索引和搜索时会自动进行。步骤如下：</p>
<ol>
<li>两个提交了的段和一个未提交的段正在被合并到一个更大的段</li>
<li>一旦合并结束，老的段被删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</div><div class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索是查询包含内部结构的数据。日期、数字、时间都是结构化的，或者是结构化文本，比如蜡笔的颜色或者博客的标签。通过结构化搜索，你的查询结果始终是 是或非；是否应该属于集合。结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档</p>
<h2 id="查找准确的值"><a href="#查找准确的值" class="headerlink" title="查找准确的值"></a>查找准确的值</h2><p>对于准确值，你需要使用过滤器。过滤器的重要性在于它们非常的快。它们不计算相关性（避过所有计分阶段）而且很容易被缓存。<br>在5里filtered被去掉，放在bool里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"query"</span>:&#123;</div><div class="line">			<span class="string">"filter"</span>:&#123;</div><div class="line">				<span class="string">"terms"</span>:&#123;</div><div class="line">					<span class="string">"jkbsf"</span>:[<span class="string">"tyws-AddCaseTrial"</span>,<span class="string">"mrshjbs tyws-AddCaseTrial"</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SELECT document FROM products WHERE price = 20</div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;</div><div class="line"><span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合过滤"><a href="#组合过滤" class="headerlink" title="组合过滤"></a>组合过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">SELECT product</div><div class="line">FROM products</div><div class="line">WHERE (price = 20 OR productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</div><div class="line">AND (price != 30)</div><div class="line"></div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"bool"</span> : &#123;</div><div class="line"><span class="string">"should"</span> : [</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, &lt;2&gt;</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; &lt;2&gt;</div><div class="line">],</div><div class="line"><span class="string">"must_not"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; &lt;3&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嵌套布尔过滤器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT document</div><div class="line">FROM products</div><div class="line">WHERE productID = <span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">OR ( productID = <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">AND price = 30</div><div class="line"></div><div class="line">&#123;</div><div class="line">   <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"filtered"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">           <span class="string">"bool"</span>:&#123;</div><div class="line">             <span class="string">"should"</span>:[</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"term"</span>:&#123;</div><div class="line">                    <span class="string">"productID"</span>:<span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">                  &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"bool"</span>:&#123;</div><div class="line">                    <span class="string">"must"</span>:[</div><div class="line">                    &#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">                      &#125;</div><div class="line">                    &#125;,&#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"price"</span>: 30</div><div class="line">                      &#125;</div><div class="line">                    &#125;</div><div class="line">                    ]</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">             ]</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询多个准确值"><a href="#查询多个准确值" class="headerlink" title="查询多个准确值"></a>查询多个准确值</h2><p>terms过滤器是term过滤器的复数版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"terms"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"price"</span> : [20, 30]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="包含而不是相等"><a href="#包含而不是相等" class="headerlink" title="包含而不是相等"></a>包含而不是相等</h2><p>假如你有一个 term 过滤器  { “term” : { “tags” : “search” } }  ，它将匹配下面两个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>] &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>假如你真的需要完全匹配这种行为，最好是通过添加另一个字段来实现。在这个字段中，你索引原字段包含值的个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>], <span class="string">"tag_count"</span> : 1 &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="string">"tag_count"</span> : 2</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"filtered"</span>:&#123;</div><div class="line">      <span class="string">"filter"</span>:&#123;</div><div class="line">        <span class="string">"bool"</span>:&#123;</div><div class="line">          <span class="string">"must"</span>:[</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tags"</span>:<span class="string">"search"</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tag_count"</span>:1</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="范围过滤"><a href="#范围过滤" class="headerlink" title="范围过滤"></a>范围过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"price"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : 20,</div><div class="line"><span class="string">"lt"</span> : 40</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用于日期字段时,range过滤器支持日期数学操作。例如，我们想找到所有最近一个小时的文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"now-1h"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日期计算也能用于实际的日期，而不是仅仅是一个像 now 一样的占位符。只要在日期后加上双竖线  ||  ，就能使用日期数学表达式了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"2014-01-01 00:00:00"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"2014-01-01 00:00:00||+1M"</span> &lt;1&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>range  过滤器也可以用于字符串。字符串范围根据字典或字母顺序来计算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"title"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : <span class="string">"a"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"b"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字符串范围适用于一个基数较小的字段，一个唯一短语个数较少的字段。你的唯一短语数越多，搜索就越慢</p>
<h2 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h2><p>本质上来说null[]（空数组）和[null]是相等的。它们都不存在于倒排索引中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"exists"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"missing"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>它们的核心是一个字节集来表示哪些文档符合这个过滤器。Elasticsearch 主动缓存了这些字节集留作以后使用。一旦缓存后，当遇到相同的过滤时，这些字节集就可以被重用，而<br>不需要重新运算整个过滤。<br>缓存的字节集很“聪明”：他们会增量更新。你索引中添加了新的文档，只有这些新文档需要被添加到已存的字节集中，而不是一遍遍重新计算整个缓存的过滤器。过滤器和整个系统的其他部分一样是实时的，你不需要关心缓存的过期时间。<br>独立的过滤缓存<br>每个过滤器都被独立计算和缓存，而不管它们在哪里使用。如果两个不同的查询使用相同的过滤器，则会使用相同的字节集。同样，如果一个查询在多处使用同样的过滤器，只有一个字节集会被计算和重用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这两个过滤器相同，而且会使用同一个字节集</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: [</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;, &lt;1&gt;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"read"</span>: <span class="literal">false</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must_not"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125; &lt;1&gt;</div><div class="line">&#125;,</div><div class="line"><span class="string">"must"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"important"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤顺序"><a href="#过滤顺序" class="headerlink" title="过滤顺序"></a>过滤顺序</h2><p>在  bool  条件中过滤器的顺序对性能有很大的影响。更详细的过滤条件应该被放置在其他过滤器之前，以便在更早的排除更多的文档。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/elasticSearch数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/elasticSearch数据/" itemprop="url">elasticSearch数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T13:41:31+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档元数据如下<br>_index 文档存储的地方；_type文档代表的对象的类；_id 文档的唯一标识*</p>
<h3 id="index"><a href="#index" class="headerlink" title="_index"></a>_index</h3><p>索引(index)类似于关系型数据库里的”数据库”——它是我们存储和索引关联数据的地方。索引名必须是全部小写，不能以下划线开头，不能包含逗号.</p>
<h3 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h3><p>在Elasticsearch中，我们使用相同类型(type)的文档表示相同的”事物”，类似关系型数据库中的表，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引._type 的名字可以是大写或小写，不能包含下划线或逗号。</p>
<h3 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h3><p>唯一标识一个文档，如果不指定，es自动生成</p>
<h2 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h2><p>自动生成的id一般是22个字节长的uuid<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _index/_type/_id 或者 GET _index/_type/_id?pretty 美化字符串</div></pre></td></tr></table></figure>
<p>pretty:在任意的查询字符串中增加 pretty  参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。_source  字段不会被美化，它的样子与我们输入的一致。</p>
<h3 id="检索文档的一部分"><a href="#检索文档的一部分" class="headerlink" title="检索文档的一部分"></a>检索文档的一部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id?_source=field,filed</div></pre></td></tr></table></figure>
<h3 id="只获取元数据"><a href="#只获取元数据" class="headerlink" title="只获取元数据"></a>只获取元数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id/_source</div></pre></td></tr></table></figure>
<h3 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -i -XHEAD http://localhost:9200/website/blog/123</div></pre></td></tr></table></figure>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id //更新后version要改变</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE /_index/_type/_id</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>数据库在并发冲突时提供了悲观锁和乐观锁的机制，es提供的机制是乐观并发控制。每个文档都有个版本号，当修改时version加一，如果指定的version不是现在的就会失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//插入一行记录</div><div class="line">PUT /website/blog/1/_create</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//获取当前数据,可以知道当前版本是1</div><div class="line">GET /website/blog/1</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : <span class="string">"1"</span>,</div><div class="line"><span class="string">"_version"</span> : 1,</div><div class="line"><span class="string">"found"</span> : <span class="literal">true</span>,</div><div class="line"><span class="string">"_source"</span> : &#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//根据当前版本对数据进行修改</div><div class="line">PUT /website/blog/1?version=1</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//如果当前版本不是1则会失败</div></pre></td></tr></table></figure></p>
<h3 id="使用外部版本控制系统"><a href="#使用外部版本控制系统" class="headerlink" title="使用外部版本控制系统"></a>使用外部版本控制系统</h3><p>一种常见的结构是使用一些其他的数据库做为主数据库，然后使用Elasticsearch搜索数据，这意味着所有主数据库发生变化，就要将其拷贝到Elasticsearch中。如果有多个进程负责这些数据的同步，就会遇到上面提到的并发问题。如果主数据库有版本字段——或一些类似于 timestamp  等可以用于版本控制的字段——是你就可以在Elasticsearch的查询字符串后面添加 version_type=external  来使用这些版本号。版本号必须是整数，大于零小于 9.2e+18  ——Java中的正的 long  。<br>外部版本号与之前说的内部版本号在处理的时候有些不同。它不再检查 _version  是否与请求中指定的一致，而是检查是否小于指定的版本。如果请求成功，外部版本号就会被存储到 _version  中。外部版本号不仅在索引和删除请求中指定，也可以在创建(create)新文档中指定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/2?version=5&amp;version_type=external</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first external blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="更新文档-1"><a href="#更新文档-1" class="headerlink" title="更新文档"></a>更新文档</h2><p>update  请求表单接受一个局部文档参数 doc  ，它会合并到现有文档中——对象合并在一起，存在的标量字段被覆盖，新字段被添加。注：更新文档如果不存在，则会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"doc"</span> : &#123;</div><div class="line"><span class="string">"tags"</span> : [ <span class="string">"testing"</span> ],</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span></div><div class="line">&#125;</div><div class="line">//更新不存在的文档，如果有加一，没有初始化为1</div><div class="line">POST /website/pageviews/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更新和冲突"><a href="#更新和冲突" class="headerlink" title="更新和冲突"></a>更新和冲突</h3><p>这些可以通过 retry_on_conflict  参数设置重试次数来自动完成，这样 update  操作将会在发生错误前重试——这个值默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /website/pageviews/1/_update?retry_on_conflict=5</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h2><p>检索多个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : 2</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"pageviews"</span>,</div><div class="line"><span class="string">"_id"</span> : 1,</div><div class="line"><span class="string">"_source"</span>: <span class="string">"views"</span></div><div class="line">&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果你想检索的文档在同一个 _index  中（甚至在同一个 _type  中），你就可以在URL中定义一个默认的 /_index  或者 /_index/_type  </div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123; <span class="string">"_id"</span> : 2 &#125;,</div><div class="line">&#123; <span class="string">"_type"</span> : <span class="string">"pageviews"</span>, <span class="string">"_id"</span> : 1 &#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果所有文档具有相同 _index  和 _type  ，你可以通过简单的 ids  数组来代替完整的 docs 数组</div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"ids"</span> : [ <span class="string">"2"</span>, <span class="string">"1"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><p>bulk  API允许我们使用单一请求来实现多个文档的 create  、 index  、 update  或 delete  。这对索引类似于日志活动这样的数据流非常有用，它们可以以成百上千的数据为一个批次按序进行索引。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div></pre></td></tr></table></figure></p>
<p>注意：1.每行必须以 “\n”  符号结尾，包括最后一行。这些都是作为每行有效的分离而做的标记；2.每一行的数据不能包含未被转义的换行符，它们会干扰分析——这意味着JSON不能被美化打印<br>action: create（创建、若存在则报错）、index（创建或替换）、update（更新）、delete（删除文档）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /_bulk</div><div class="line">&#123; <span class="string">"delete"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125; &lt;1&gt;</div><div class="line">&#123; <span class="string">"create"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My first blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My second blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"update"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span>, <span class="string">"_retry_on_conflict"</span> : 3&#125; &#125;</div><div class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"title"</span> : <span class="string">"My updated blog post"</span>&#125; &#125;</div></pre></td></tr></table></figure></p>
<p>当然，你可以指定index和type，当下面指定时会覆盖掉<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST /website/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"log"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line"></div><div class="line">POST /website/<span class="built_in">log</span>/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123;&#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"Overriding the default type"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>批量最好的批次在5Mb~15Mb</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/14/分布式集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/分布式集群/" itemprop="url">分布式集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T21:22:00+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个节点就是一个elasticsearch实例，一个集群由一个或者多个节点组成，具有相同的cluster.name，它们协同工作，分享数据和负载。<br>集群中的一个节点选举称为master，将临时管理集群级别的一些变更，<strong>例如新建、删除索引、增加或移除节点。主节点不参与文档级别的变更或搜索，意味着在流量增长时，master不会成为瓶颈。</strong></p>
<h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><p>集群健康分为三种：red、yellow、green,green代表所有的主分片和复制分片都可用，yellow代表所有主要分片可用，但是不是所有复制分片可用，red代表不是所有主分片可用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _cluster/health</div></pre></td></tr></table></figure></p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>索引是用来指向一个或者多个分片的逻辑命名空间，一个分片是一个最小级别工作单元。分片可以是主分片或者复制分片，索引的每一个文档属于一个主分片，主分片的数量决定了索引最终存储的数量。复制分片是主分片的一个副本，可以防止硬件故障导致的数据丢失，同时提供读请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PUT /sjjhpt</div><div class="line">//创建三个主分片，一个副本</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line">     <span class="string">"number_of_shards"</span>:3,</div><div class="line">     <span class="string">"number_of_replicas"</span>: 1.</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="增加故障转移"><a href="#增加故障转移" class="headerlink" title="增加故障转移"></a>增加故障转移</h2><p>在单一节点运行会有单点故障的风险，要防止单点故障，要启动另外一个节点。文档首先会在主分片中存储，然后并发复制到其他复制分片，确保主分片和复制分片都会被检索。</p>
<h2 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h2><p>可以增加节点数，最多节点数为(主分片个数)* (副本数量+1)</p>
<h2 id="更多扩展"><a href="#更多扩展" class="headerlink" title="更多扩展"></a>更多扩展</h2><p>当然，只是有更多的复制分片在同样数量的节点上并不能提高我们的性能，因为每个分片都要访问更小比重的节点资源（译者注：大部分请求都聚集到了分片少的节点，导致一个节点吞吐量太大，反而降低性能）。你需要增加硬件来提高吞吐量。<br>不过这些额外的复制节点意味着我们有更多的冗余：通过以上对接点的设置，我们更够承受两个节点故障而不丢失数据.</p>
<h2 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h2><p>当主节点故障后，会重新选举主节点，如果主分片不能正常工作，重新选举的主节点会提升副本分片为主分片</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/14/elasticsearch入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/elasticsearch入门/" itemprop="url">elasticsearch入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T14:16:48+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>elasticSearch是基于Lucene的开源搜索引擎。lucene是现在最先进、性能最好、功能最全的搜索引擎库。但是lucene是一个库，你必须使用java语言集成到你的应用。Lucene通过restful api隐藏Lucene的复杂性。es的特性如下：</p>
<ul>
<li>分布式的实时存储</li>
<li>分布式的实时搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="java-API"><a href="#java-API" class="headerlink" title="java API"></a>java API</h2><h3 id="节点客户端"><a href="#节点客户端" class="headerlink" title="节点客户端"></a>节点客户端</h3><p>节点客户端是以无数据节点加入集群，它自己不存储数据，它知道数据在集群里的具体位置，并且能够直接转发请求到对应节点上</p>
<h3 id="传输客户端"><a href="#传输客户端" class="headerlink" title="传输客户端"></a>传输客户端</h3><p>能够发送请求到远程集群，它自己不加入集群，只是简单转发请求到集群的节点</p>
<h3 id="基于http协议，以json为数据交互格式的Restful-ApI"><a href="#基于http协议，以json为数据交互格式的Restful-ApI" class="headerlink" title="基于http协议，以json为数据交互格式的Restful ApI"></a>基于http协议，以json为数据交互格式的Restful ApI</h3><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>es是面向文档的，他可以存储整个对象或者文档。并且文档可以被索引、搜索、排序、过滤。json是文档序列化的格式。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>es的索引一个文档指的是将一个文档存储到索引里，以便检索和查询，类似数据库的insert。但是如果文档已存在，会覆盖文档。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/1 //索引 类型 文档id</div></pre></td></tr></table></figure>
<h3 id="简单检索"><a href="#简单检索" class="headerlink" title="简单检索"></a>简单检索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search //默认返回前十个数据</div></pre></td></tr></table></figure>
<h3 id="查询字符串查询"><a href="#查询字符串查询" class="headerlink" title="查询字符串查询"></a>查询字符串查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search?q=userid:hxdt</div></pre></td></tr></table></figure>
<h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><p>以json请求体出现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"userid"</span>:<span class="string">"hxdt"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更复杂的搜索"><a href="#更复杂的搜索" class="headerlink" title="更复杂的搜索"></a>更复杂的搜索</h3><p>filter重点在区间查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line"></div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"range"</span>:&#123;</div><div class="line">           <span class="string">"dyrq"</span>:&#123;</div><div class="line">           	  <span class="string">"gt"</span>:<span class="string">"2017-05-06"</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //elkname包含aa或包含bb</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h3><p>搜索确切的匹配若干个单词或者短语<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //询同时包含<span class="string">"aa"</span>和<span class="string">"bb"</span>,并且是相邻的</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_phrase"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"highlight"</span>:&#123;</div><div class="line">  	<span class="string">"pre_tags"</span>: [</div><div class="line">          <span class="string">"&lt;em class=\"c_color\"&gt;"</span></div><div class="line">      ],</div><div class="line">      <span class="string">"post_tags"</span>: [</div><div class="line">        <span class="string">"&lt;/em&gt;"</span></div><div class="line">      ],</div><div class="line">  	<span class="string">"fields"</span>:&#123;</div><div class="line">  		<span class="string">"elkname"</span>:&#123;</div><div class="line"></div><div class="line">  		&#125;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>类比数据库的group by<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>聚合允许分级汇总<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST //查询相同接口标识符的平均id</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;,</div><div class="line">			<span class="string">"aggs"</span>:&#123;</div><div class="line">				<span class="string">"avg_id"</span>:&#123;</div><div class="line">					<span class="string">"avg"</span>:&#123;</div><div class="line">						<span class="string">"field"</span>:<span class="string">"id"</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
