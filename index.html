<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/消息中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/消息中间件/" itemprop="url">消息中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T15:23:21+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/数据访问层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/23/数据访问层/" itemprop="url">数据访问层（第五章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T17:24:31+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据库从单机到分布式的挑战和应对"><a href="#数据库从单机到分布式的挑战和应对" class="headerlink" title="数据库从单机到分布式的挑战和应对"></a>数据库从单机到分布式的挑战和应对</h2><h3 id="从应用使用单机数据库开始"><a href="#从应用使用单机数据库开始" class="headerlink" title="从应用使用单机数据库开始"></a>从应用使用单机数据库开始</h3><p>各种类似ODBC、JDBC的封装、以及ORM的封装都很成熟，我们这里重点考虑数据量和访问量增大的时候，系统要面临的问题和相应的解决方案。</p>
<h3 id="数据库垂直拆分和水平拆分的困难"><a href="#数据库垂直拆分和水平拆分的困难" class="headerlink" title="数据库垂直拆分和水平拆分的困难"></a>数据库垂直拆分和水平拆分的困难</h3><p>垂直拆分会带来的影响：<br>1.单机的ACID保证会被打破；要么放弃单机事务，修改实现，要么引入分布式事务。<br>2.一些join操作会变得比较困难，因为数据已经在两个数据库中，所以不是很方便利用数据库自身的join；<br>3.靠外键进行约束的场景会受限制；<br>水平拆分会带来的影响：<br>1.同样可能ACID会被打破；<br>2.同样join可能会受到影响；<br>3.靠外键进行约束的场景会受限制；<br>4.依靠单库生成递增唯一标识会受影响；<br>5.针对单个逻辑上的表的查询要跨库；</p>
<h3 id="多机事务如何处理"><a href="#多机事务如何处理" class="headerlink" title="多机事务如何处理"></a>多机事务如何处理</h3><h4 id="分布式事务知识"><a href="#分布式事务知识" class="headerlink" title="分布式事务知识"></a>分布式事务知识</h4><h5 id="分布式事务模型与规范"><a href="#分布式事务模型与规范" class="headerlink" title="分布式事务模型与规范"></a>分布式事务模型与规范</h5><p>X/Open组织（the open group）提出了分布式事务规范-XA，分布式事务处理模型-X/Open DTP（distributed transaction processing reference model）模型。定义了三个组件–application  program、Resource manager和transaction manager。<br>AP:应用程序，它定义了事务的边界，并定义了构成该事务的应用程序的特定操作。<br>RM：资源管理器，可以理解为DBMS系统，或者消息服务器管理系统。AP通过RM对资源进行控制，资源必须实现XA接口。资源管理器提供了存储共享资源的支持。<br>TM：事务管理器，负责协调和管理事务，提供给AP接口用来管理RM。事务管理器向事务指定标识，监视他们的进程，并负责处理事务的完成和失败。事务分支标识（XID）用TM指定，标识一个RM的全局事务和特定分支。他是TM日志和RM日志之间的相关标识。两阶段性提交用到XID<br>AP和TM、RM通信，TM和RM之间互相通信，通过XA接口。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交。<br>提交阶段<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)。<br>首先是会有很多日志的操作，以及网络交互的增多引入事务管理器的开销导致整体开销会大。所以在进行垂直或水平拆分时，必要时才引入二阶段式提交。</p>
<h4 id="大型网站一致性理论基础理论–CAP-BASE"><a href="#大型网站一致性理论基础理论–CAP-BASE" class="headerlink" title="大型网站一致性理论基础理论–CAP/BASE"></a>大型网站一致性理论基础理论–CAP/BASE</h4><p>CAP的含义：<br>C：Consistency:一致性，所有节点在同样的时间读到同样的数据。这就是数据上的一致性，也就是当数据写入成功后，所有的节点都能同时看到这个新的数据<br>A：Availability：保证无论是成功还是失败，每个请求都能够收到一个反馈。这就是数据的可用性，这里重点是系统要有响应。<br>P：Partition Tolerance：即便系统有部分问题或者消息丢失，但系统依然能够继续运行。这被称为分区容忍性，也就是系统的一部分出现问题，系统仍能够继续工作。<br>分布式不能同时满足这三项，也就是我们可以选择两个来提升，但另外一个将会受到损失。在系统进行设计和权衡时，也就是在选择CA、CP、AP<br>选择CA：放弃分区容忍性，加强一致性和可用性。传统单机数据库的选择；<br>选择AP：放弃一致性，很多NOSQL系统的选择；<br>选择CP：放弃可用性，这种情况下可用性会很低，网络的问题会让整个系统不可用<br>在分布式系统中，我们一般选择增强可用性和分区容错性而选择牺牲一致性。<br>BASE(Base available 基本可用 soft state 软状态 eventually  consistent 最终一致性 )<br>基本可用指的是分布式系统发生故障，允许损失部分可用性。<br>软状态指的是接受一段时间状态不同步<br>最终一致性指的是强调的是系统中的所有数据副本，在经过一段时间的同步后，最终能够达到一致的状态。</p>
<h4 id="paxos协议"><a href="#paxos协议" class="headerlink" title="paxos协议"></a>paxos协议</h4><h4 id="集群内数据一致性的算法实例"><a href="#集群内数据一致性的算法实例" class="headerlink" title="集群内数据一致性的算法实例"></a>集群内数据一致性的算法实例</h4><p>quorum，它是用来权衡分布式系统的数据一致性和可用性的。<br>N：数据复制节点数量<br>R：成功读操作的最小节点数<br>W：成功写操作的最小节点数<br>如果R+W&gt;N，是可以保证强一致性，而如果R+W&lt;=N，则保证最终一致性。<br>vector clock的思路是对同一份数据的每次修改都要加上&lt;修改者，版本号&gt;，用来记录修改者信息以及版本号。Vector Clock能解决分布式系统多版本合并的问题，但是对于确实发生冲突的版本，它无法合并，而需要用户自己去做合并。</p>
<h2 id="多机的sequence问题与处理"><a href="#多机的sequence问题与处理" class="headerlink" title="多机的sequence问题与处理"></a>多机的sequence问题与处理</h2><p>当转变为水平分库以后，原来单库的sequence以及自增的id都需要改变。我们可以从两个方向去考虑解决这个问题：唯一性和连续性。<br>如果只考虑唯一性，可以考虑用uuid（ip，机器名，mac，时间，本机计数器）生成，但是会导致分布式系统的连续性不好。<br>如果考虑连续性，我们可以把所有的ID集中放在一个地方进行管理，对每一个ID序列进行独立管理，每台机器使用Id都从这个地方去取。这里有几个问题需要解决：<br>性能问题：每次远程取Id会有资源损耗。一种办法是一次取一段Id，然后缓存到本地，这样就不用每次再去取。但也会带来问题，比如，如果机器宕机，那么取的一段Id将不可用。<br>生成器稳定问题：Id生成器是无状态集群，其可用性要靠整个集群保证<br>存储问题：底层存储的选择空间比较大，需要根据不同类型来进行对应的容灾方案。下面介绍两种方式：<br>第一种是底层有一个独立存储记录每个Id序列当前的最大值，并控制并发更新。这样一来生成逻辑就比较简单。第二种是去掉Id生成器，把相关逻辑嵌入到需要生成Id的应用中，而在每个应用中完成生成器要做的工作，即读取可用的ID或者Id段。因为没有中心控制节点，我们不希望生成器之间有通信，所以id并不是严格按照进入数据库的顺序增大。</p>
<h2 id="应对多机的数据查询"><a href="#应对多机的数据查询" class="headerlink" title="应对多机的数据查询"></a>应对多机的数据查询</h2><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><p>解决方案有：1.把原来join操作分成多次数据库操作。2.数据冗余，对一些常用的信息进行冗余，这样就可以把原来的join变为单表查询。3.借助外部系统如搜索引擎来解决。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>如果要对分库后的单库做外键约束，就要求分库后的每个单库都是数据内聚，否则只能在应用层的判断和容错。</p>
<h3 id="跨库查询的问题及解决"><a href="#跨库查询的问题及解决" class="headerlink" title="跨库查询的问题及解决"></a>跨库查询的问题及解决</h3><h4 id="数据库分库分表的演化"><a href="#数据库分库分表的演化" class="headerlink" title="数据库分库分表的演化"></a>数据库分库分表的演化</h4><p>合并查询问题的根源是我们在进行水平分库分表后，把一张表分成了多张物理上的表。我们举个例子，我们有两个库，每个库存了两张用户表。从逻辑上这些表应该一起储存，但随着访问量和数据量的增多，需要经历分库分表，此时，一张逻辑表对应多张物理表，在应用中，对这张逻辑表的查询就要做跨库的跨表的合并了。</p>
<h4 id="从具体例子看分库分表的问题"><a href="#从具体例子看分库分表的问题" class="headerlink" title="从具体例子看分库分表的问题"></a>从具体例子看分库分表的问题</h4><p>如果我们查询一个省的符合年龄的用户。在单表时，这是一个普通的查询。而分库分表后，我们可能会遇到麻烦。如果我们按地域划分，那么问题就退化成为单库单表问题。但是如果我们查询多个省份，这就产生了跨库问题，就需要再查询结果取个并集。但还有更为复杂的操作，如：</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>即多个数据源的数据查询出来，在应用层做排序，如果从数据库查出来的数据已经排好序，那么，只需要做多路归并排序就好；如果查询的数据没有排序，则需要做全排序；</p>
<h5 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a>函数处理</h5><p>使用max min sum count函数，即对多个数据源的值进行函数处理。</p>
<h5 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h5><p>从多个数据源查询时，需要把SQL改为Sum和count，然后对多个数据源求sum和count。</p>
<h5 id="非排序分页"><a href="#非排序分页" class="headerlink" title="非排序分页"></a>非排序分页</h5><p>这里面有两种策略，一种是同等步长的在多个数据源上分页处理；另一种是同等比例地分页处理。同等步长指的是分页中的每一页，来自不同数据源的记录数是一样的；同等比例值得是，来自不同数据源的数据数，占这个数据源符合条件的数据总数的比例是一样的。<br>打个比方，有两个数据源，符合条件的数据数分别有16和8，一页的数量为4，同等步长指的是每次取数据源一2个，数据源二2个。如果是同比例，假设一页数量6，那么是数据源一4个，数据源二2个。因此用相同的次数获取完。</p>
<h5 id="排序分页"><a href="#排序分页" class="headerlink" title="排序分页"></a>排序分页</h5><p>如果我们要取第n页数据，我们需要从各个数据源取前n页数据，然后归并排序。也就是越往后翻页，压力越大。在访问量很大的情况下，我们需要尽量避免这种情况，尤其是排序需要翻很多页的时候。</p>
<h2 id="数据层的设计和实现"><a href="#数据层的设计和实现" class="headerlink" title="数据层的设计和实现"></a>数据层的设计和实现</h2><h3 id="如何对外提供数据访问层功能"><a href="#如何对外提供数据访问层功能" class="headerlink" title="如何对外提供数据访问层功能"></a>如何对外提供数据访问层功能</h3><h4 id="对外提供数据访问层方式"><a href="#对外提供数据访问层方式" class="headerlink" title="对外提供数据访问层方式"></a>对外提供数据访问层方式</h4><p>第一种方式是为用户提供专有API；第二种通用的方式是一般通过jdbc访问数据库。还有是通过基于orm或者类orm接口的方式，如ibatis、hibernate、spring jdbc。</p>
<h4 id="不同提供方式之间合并查询场景下的对比"><a href="#不同提供方式之间合并查询场景下的对比" class="headerlink" title="不同提供方式之间合并查询场景下的对比"></a>不同提供方式之间合并查询场景下的对比</h4><p>比如分页排序，orm会生成很多无效的对象然后丢弃，而jdbc只需要生成响应的对象。再获取后面页内容时，直接基于jdbc的的优势比较明显</p>
<h3 id="按照数据层流程的顺序看数据层设计"><a href="#按照数据层流程的顺序看数据层设计" class="headerlink" title="按照数据层流程的顺序看数据层设计"></a>按照数据层流程的顺序看数据层设计</h3><h4 id="sql解析阶段的处理"><a href="#sql解析阶段的处理" class="headerlink" title="sql解析阶段的处理"></a>sql解析阶段的处理</h4><p>通过sql的解析可以获取表名、字段、where条件，根据参数规则确定目标数据源的连接。</p>
<h4 id="规则处理阶段"><a href="#规则处理阶段" class="headerlink" title="规则处理阶段"></a>规则处理阶段</h4><p>1.采用固定的哈希算法作为规则<br>根据某个字段（例如用户id）取模，然后将数据分散到不同的数据库或表中。除了会根据id取模，还会根据时间维度，例如（天，星期，月，年）等来存储数据，这一般用于数据产生后日期不再修改的场景，否则就要涉及数据迁移。时间取模多用于日志类和其他时间维度密切相关的场景。通常将周期性数据放在一起，这样进行数据备份，迁移或者现有的数据清空都会很方便。 固定哈希的规则和设置都比较简单，但是扩容比较复杂。<br>2.一致性哈希算法<br>一致性哈希所带来的最大变化是把节点的哈希值变为一个范围，而不在是离散的。在一致性哈希中，我们会把哈希值范围定的非常大，然后把这个范围分配给现在节点。如果有新节点加入，那么这个新节点会从原来某个节点分管一部分哈希值。如果这个节点退出，那么这个节点管理的哈希值会分配给下一个节点。但一致性哈希会导致负载不均衡，比如不管是新加一个节点还是减少一个节点，他能造成的影响的范围只有他自己和另外一个节点。<br>3.虚拟节点对一致性哈希的改进<br>4个物理节点可以变成很多个虚拟节点，每个虚拟节点支持连续的哈希环上的一段。而这时如果加入一个物理节点，就会相应加入很多虚拟节点，这些新的虚拟节点是相对均匀地插入到整个哈希环上，这样，就可以很好的分担现有物理节点的压力了；如果减少一个物理节点，对应的很多虚拟节点就会失效，这样，就会有很多剩余的虚拟节点来承担之前虚拟节点的工作，但是对于物理节点来说，增加的负载相对是均衡的。<br>4.映射表与规则自定义计算方式<br>映射表是根据分库分表字段的值的查表法来确定数据源的方法，一般对热点数据的特殊处理，或者在一些场景下对完全不符合规律的规则进行补充。<br>最后定义的计算方式是最灵活的方式，它已经不算是以配置的方式做规则，而是通过复杂的函数来解决数据访问规则，扩展性最强。<br>举例来说，我们id取模分成四个库，然后对于热点数据，单独放到一个库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( id  <span class="keyword">in</span> hotest)&#123;</div><div class="line">  <span class="built_in">return</span> 4;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> id%4;</div></pre></td></tr></table></figure></p>
<h4 id="为甚么要改写sql"><a href="#为甚么要改写sql" class="headerlink" title="为甚么要改写sql"></a>为甚么要改写sql</h4><p>如何设定规则，一般原则是分库后尽量避免跨库查询。举商品为例，我们可以根据商品id取模或者一致性哈希分库，但同个卖家多个商品可能涉及到跨库。如果以卖家id分库那么根据商品id查询就麻烦了，因为不知道商品在哪个库中。具体采用哪种分库需要综合考虑。除了根据规则确定数据源，如果是分表的话，表明还不一样，一般在逻辑表加自增后缀。还有索引名和跨库计算平均值。</p>
<h4 id="如何选择数据源"><a href="#如何选择数据源" class="headerlink" title="如何选择数据源"></a>如何选择数据源</h4><p>在User进行分库分表后，我们会给分库提供一个备库，也就是原来的一个数据库变为一个数据库矩阵，分库就是把数据分到不同的数据分组。除了决定访问哪个数据库组以外，还需决定是分组的哪个库。这些库一般是一写多读，要根据sql的特点（读或者写）以及库的权重规则，计算sql请求访问的数据库。</p>
<h4 id="执行sql和结果处理阶段"><a href="#执行sql和结果处理阶段" class="headerlink" title="执行sql和结果处理阶段"></a>执行sql和结果处理阶段</h4><h4 id="实战经验分享"><a href="#实战经验分享" class="headerlink" title="实战经验分享"></a>实战经验分享</h4><p>1.复杂的连接管理<br>2.三层数据的选择和支持</p>
<h3 id="独立部署的数据库访问层实现方式"><a href="#独立部署的数据库访问层实现方式" class="headerlink" title="独立部署的数据库访问层实现方式"></a>独立部署的数据库访问层实现方式</h3><p>从数据库的物理部署上可以分为jar包和proxy模式，如果是proxy模式的话，那么客户端和proxy之间的协议有数据库协议和私有协议。</p>
<h3 id="读写分离的挑战和应对"><a href="#读写分离的挑战和应对" class="headerlink" title="读写分离的挑战和应对"></a>读写分离的挑战和应对</h3><p>通过读写分离的方案，可以分担主库的读压力。这里面存在一个数据复制问题，也就是把主库（master）的数据复制到备库（slave）去。</p>
<h4 id="主库从库非对称场景"><a href="#主库从库非对称场景" class="headerlink" title="主库从库非对称场景"></a>主库从库非对称场景</h4><p>1.数据结构相同，多从库对应一主库的场景<br>mysql的replication可以解决这个问题，并且延迟比较小。在多从库对应一主库的情况下，业务应用只要根据自身的业务特点，把对数据不敏感的读切换到备库进行即可。首先来看slave，slave采用PC server，和Mysql的方案比较划算的。对于一个主库，需要多台采用mysql的PC Servcer对应原来master中的一部分数据，也就是进行了分库。<br>数据复制有两种方式：<br>比较优雅的方式是通过数据库的日志来进行数据复制；<br>比较不优雅的方式是应用通过数据层访问数据库，通过消息系统对数据库的更新送出消息通知，数据同步服务器获得消息通知后会进行数据的复制工作。分库规则则负责在读数据和数据同步服务器更新分库时让数据层知道分库规则。数据同步服务器和DB主库的交互方式，主要根据修改或者新增的数据主键来获取内容，采用行复制的功能。<br>2.主备分库方式不同的数据复制<br>数据读写分离一般采取的是对称复制，也就是镜像，但也有一些场景下进行非对称复制。这里指的非对称复制是指源数据和目标数据不是镜像规则。打个比方，我们订单可以按照买家进行分库，把所有订单分到四个库中，这保证了一个买家的订单都在同一个库里，但是卖家却不在同一个库中，因而要进行跨库查询。我们可以做一个备库，按照卖家id来查询。这时候需要控制数据的分发，而不是简单地进行镜像复制。<br>3.引入数据变更平台<br>引入Extractor和Applier，Extractor负责把数据源变更的信息加入到数据分发平台中，而Applier的作用是把这些变更应用到相应的目标上，中间的数据分发平台中是由多个管道组成，进入到数据分发平台的变更信息就是标准化、结构化的数据了。例如MySQL推出Applier,可实时复制数据到Hadoop</p>
<h4 id="如何做到数据平滑迁移"><a href="#如何做到数据平滑迁移" class="headerlink" title="如何做到数据平滑迁移"></a>如何做到数据平滑迁移</h4><p>最大挑战是，在迁移的过程中又会有数据的变化(因为很多应用不能接受长时间的停机)，可以考虑的方案是在开始进行数据迁移时记录增量的日志，在迁移结束后，再对增量的变化进行处理，在最后,可以要把要被迁移的数据的写暂停，保证增量日志都处理完毕后，再切换规则，放开所有的写，完成迁移工作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/服务框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/21/服务框架/" itemprop="url">服务框架（第四章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T19:56:11+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网站功能持续丰富后的困境与应对"><a href="#网站功能持续丰富后的困境与应对" class="headerlink" title="网站功能持续丰富后的困境与应对"></a>网站功能持续丰富后的困境与应对</h2><p>网站的功能主要集中在几个大应用上，而且这些应用都直接访问底层的服务，例如数据库、缓存、搜索引擎、分布式存储。随着网站规模扩大，开发人的增多，每个应用变得复杂、臃肿。</p>
<h3 id="把应用拆小"><a href="#把应用拆小" class="headerlink" title="把应用拆小"></a>把应用拆小</h3><p>把庞大的应用拆成多个。这样的好处是相对较快的完成，但是仍然存在一些问题。一方面是数据库的连接数的压力还在，其次是代码的重复问题。</p>
<h3 id="服务化方案"><a href="#服务化方案" class="headerlink" title="服务化方案"></a>服务化方案</h3><p>我们在原来的应用和底层的数据库、缓存系统、文件系统等系统之间增加了服务层。</p>
<h2 id="服务框架的设计和实现"><a href="#服务框架的设计和实现" class="headerlink" title="服务框架的设计和实现"></a>服务框架的设计和实现</h2><h3 id="应用从集中式走向分布式所遇到的问题"><a href="#应用从集中式走向分布式所遇到的问题" class="headerlink" title="应用从集中式走向分布式所遇到的问题"></a>应用从集中式走向分布式所遇到的问题</h3><p>要把单层Web应用的结构改为多层的、有服务层的结构的时，很多人不会直接做一个通用的服务框架，而是为当前要用的服务做一个RPC的功能，为服务使用者提供相关的客户端。而当提供的服务的集群多于一个小时，通用的服务框架就非常重要。服务化会使得把本地调用变为远程调用。研发人员关注的是提高易用性和降低性能损失这两方面。<br>在单机单进程中，程序只需要将寄存器地址改为相应的入口地址就好，而在多机之间，我们需要对调用的请求信息进行编码，然后传给远程的节点，解码后再进行真正的调用。寻址路由是为了让调用方确定哪个实例被调用的，实际定位是指被调用的机器找到对应的实例来进行方法调用，从而实现功能。</p>
<h3 id="通过示例看服务框架原型"><a href="#通过示例看服务框架原型" class="headerlink" title="通过示例看服务框架原型"></a>通过示例看服务框架原型</h3><p>服务框架即包含调用方的逻辑，又包含服务端的逻辑的一个实现。</p>
<h4 id="单机方式"><a href="#单机方式" class="headerlink" title="单机方式"></a>单机方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Calculator&#123;</div><div class="line">     public int add(int a,int b)&#123;</div><div class="line">       <span class="built_in">return</span> a+b;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Calculator calculator =new Calculator();</div><div class="line">calculator.add(2,3);</div></pre></td></tr></table></figure>
<h4 id="实现远程服务的调用客户端"><a href="#实现远程服务的调用客户端" class="headerlink" title="实现远程服务的调用客户端"></a>实现远程服务的调用客户端</h4><p>以单机为例，我们希望实现这个服务的方式和当前的做法一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int add(int a,int b)&#123;</div><div class="line"></div><div class="line">  //获取可用服务列表</div><div class="line">  List&lt;String&gt; l=getAvailableServiceAddresses(<span class="string">"Calculator.add"</span>);</div><div class="line">  //获取调用服务的目标机器</div><div class="line">  String address=chooseTarget();</div><div class="line">  //建立连接</div><div class="line">  Socket socket=new Socket(address);</div><div class="line">  //请求序列化</div><div class="line">  byte[] request=getRequest(a,b);</div><div class="line">  //发送请求</div><div class="line">  socket.getOuputStream().write(request);</div><div class="line">  //接受结果</div><div class="line">  byte[] response=new byte[1024];</div><div class="line">  socket.getInputStream().read(response);</div><div class="line">  int result=getResult(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们解析这段代码，首先是获取服务机器的地址列表，并且从可用的服务地址列表中选取一个要调用的目标机器。<br>如果我们采取的LVS或者硬件负载均衡方案，那么getAvailableServiceAddresses获取的就是获取LVS或者硬件负载均衡器的地址和端口，并且choosTarget会直接返回地址和端口。<br>如果我们采取名称服务，那么getAvailableServiceAddresses返回的是当前的服务的地址列表，参数值用来定位服务，这个一般用做key的服务名字一般采用接口的全名，也就是全限类名，也可以用类名加版本号。<br>如果我们采用规则解析，这种方式更多应用在有状态的场景上。像数据这种状态要求很高的场景，或者缓存这种尽量要有状态的场景，都会用到规则服务器的方式来解决寻址问题。在无状态的场景，则不太用规则服务器的方式处理。<br>构造请求数据包其实就是把对象变为二进制数据，也就是java的序列化。请求后，我们需要等待远程服务的执行和结果的返回，收到结果后，我们会对数据进行java1反序列化，等到结果。</p>
<h4 id="实现服务端"><a href="#实现服务端" class="headerlink" title="实现服务端"></a>实现服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">eventHandler</span></span>()&#123;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    byte[] requestData=receiveRequest();</div><div class="line">    Request request=getRequest(requestData);</div><div class="line">    Object service=getServiceByNameAndVersion(request.getServiceName(),request.getServiceVersion());</div><div class="line">    Object result=callService(service,request.getMethodName(),request.getArgs());</div><div class="line">    byte[] data=getResult(result);</div><div class="line">    request.socket.getOuputStream.write(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段伪代码中，我们需要持续接受请求并进行响应，收到的数据也需要反序列化。在这里，我们关注服务的名称、服务的版本号、调用的方法名称和参数以及调用的连接。当我们拿到请求对象后，我们需要本地定位具体的服务，我们会有个服务注册表，我们可以动态发布服务。得到服务实例后，我们会服务调用，一般通过反射来调用，然后序列化结果，传输给客户端。</p>
<h3 id="服务调用端的设计和实现"><a href="#服务调用端的设计和实现" class="headerlink" title="服务调用端的设计和实现"></a>服务调用端的设计和实现</h3><p>调用过程是调用发起、寻址路由、协议适配/序列化、网络传输、反序列化/协议解析、得到结果返回调用方。</p>
<h4 id="从代码的角度看如何使用服务框架"><a href="#从代码的角度看如何使用服务框架" class="headerlink" title="从代码的角度看如何使用服务框架"></a>从代码的角度看如何使用服务框架</h4><p>客户端的引入是我们首先需要解决的问题，大多数的java开发都会使用spring作为容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ConsumerBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>以上是简单的版本的服务框架，我们先看三个基础的属性</p>
<h5 id="interfaceName"><a href="#interfaceName" class="headerlink" title="interfaceName"></a>interfaceName</h5><p>接口名称，在进程远程通信时ConsumerBean必须要知道调用的接口是哪一个，然后才能生成这个接口的代理，以供本地调用。</p>
<h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>版本号，在实际场景中，接口的变化是可能的。如果直接变化，那么要求所有使用的地方一起修改，一起升级。解决问题的方式有两种，一种是需要修改方法的参数或者返回值，也就是新增一个方法，保持原来方法不变，不过在过渡阶段导致代码臃肿，并且方法名不好取名。第二种是通过版本号进行隔离。</p>
<h5 id="group"><a href="#group" class="headerlink" title="group"></a>group</h5><p>分组。分组属性的好处是如果对同一个接口的远程调用有很多机器，那么我们可以把远程机器分组，然后调用者可以选择不同分组调用，这样就可以把不同调用者对同一服务进行隔离。</p>
<h4 id="运行期服务框架与应用和容器的关系"><a href="#运行期服务框架与应用和容器的关系" class="headerlink" title="运行期服务框架与应用和容器的关系"></a>运行期服务框架与应用和容器的关系</h4><p>有两个比较重要的问题需要解决：1.服务框架本身的部署方式问题；2.实现服务框架所依赖的一些外部包和应用自身依赖的jar包冲突。<br>首先是部署方式；一种方案是把服务框架作为应用的一个依赖包并与应用进行打包。通过这个方式，服务框架就变为应用的一个库，并随应用启动。存在的问题是，如果要升级服务框架，就需要更新应用本身；并且服务框架也没办法接管classloader，也没办法做到隔离和包的实现替换工作。<br>另一种方案是把服务框架作为容器的一部分，那么服务框架就变为一个容器提供远程调用和远程服务的功能。<br>Jar包冲突问题，应用和服务框架的jar包版本冲突；将服务框架的自身用的类和应用用的类都控制在User-defined class loader级别上，这样就实现了相互间的隔离。web容器对多个web应用的处理以及OSGI对bundle处理采用了类似的方法。我们可以看下类加载器的层级关系，最上到下依次是bootstrap class loader($JAVA_HOME/jre/lib/rt.jar)、Extension class Loader($JAVA_HOME/jre/lib/ext/rt.jar)、System class loader($CLASSPATH)、user defined class loader</p>
<h3 id="服务调用者和服务提供者之间通信方式的选择"><a href="#服务调用者和服务提供者之间通信方式的选择" class="headerlink" title="服务调用者和服务提供者之间通信方式的选择"></a>服务调用者和服务提供者之间通信方式的选择</h3><p>服务框架是为了把本地对象之间的方法调用变为远程过程调用，，这就涉及到远程通信问题。</p>
<h4 id="远程通信遇到的问题"><a href="#远程通信遇到的问题" class="headerlink" title="远程通信遇到的问题"></a>远程通信遇到的问题</h4><p>最初的路由寻址过程是把远程的IP和端口号写死在代码中，但是如果是一个集群这种方式就满足不了</p>
<h4 id="采用透明代理与调用者、服务提供者直连的解决方案"><a href="#采用透明代理与调用者、服务提供者直连的解决方案" class="headerlink" title="采用透明代理与调用者、服务提供者直连的解决方案"></a>采用透明代理与调用者、服务提供者直连的解决方案</h4><p>这里面我们通过两种方式，一种是中间代理，另一种是服务注册查找中心；服务注册查找中心只是提供可用的服务提供者列表，调用者会缓存下来地址，然后当地址列表发生改变时在去向中心获取。当客户端拿到地址后，如何对当次进行调用就是路由要做的事情，我们首先要考虑的是集群的负载均衡的实现，比如轮询、随机、权重等方式，可以参考硬件负载均衡机器或者LVS或者HAProxy策略。</p>
<h4 id="引入基于接口、方法、参数的的路由"><a href="#引入基于接口、方法、参数的的路由" class="headerlink" title="引入基于接口、方法、参数的的路由"></a>引入基于接口、方法、参数的的路由</h4><p>一般用接口作为服务的粒度，一个服务也就是一个接口的远程实现。假设服务提供两个接口，分别是接口A，接口B，每个服务又提供了两个方法。一般来说一个请求对应一个线程，而总线程数量有一个限制，一旦并发请求过多，其余的就必须要等待。假设某个方法执行的时间很慢，那么很快如果很多线程请求该方法，那么在进入这个方法时，一旦达到瓶颈值，那么其他线程就在等待。我们可以有两种解决方案，增加机器数，可以减少分到单台机器的请求数。也就是增加资源保证系统的能力超出需要；第二种方案是隔离这些资源，从而使得快慢不同重量级别不同的方法互不影响。而分流策略可以让请求服务A的请求全部在右上方机器，请求服务B的请求全部在右下方机器。我们负载均衡的策略的具体实现是先获取服务框架的规则后进行路由处理，也就是根据服务定位提供服务集群的地址，然后在与接口路由规则中的地址做个交集，得到的地址在进行负载均衡算法，最后得到一个可用的地址进行调用。但是基于接口并未解决这个问题，因为A服务的方法一的瓶颈会影响A服务的方法而，这时我们路由规则可以基于接口名加方法，什么可以基于方法名加方法加参数</p>
<h3 id="多机房场景"><a href="#多机房场景" class="headerlink" title="多机房场景"></a>多机房场景</h3><h3 id="服务调用端的流控处理"><a href="#服务调用端的流控处理" class="headerlink" title="服务调用端的流控处理"></a>服务调用端的流控处理</h3><p>流量控制是为了保证系统的稳定性。我们有两种控制方式，一种是01开关，完全打开和完全不打开；另外一种设定一个固定值，表示每秒可以进行请求的次数。超过这个请求数的就拒接对远程的请求。我们可以从两个维度进行控制：1.根据服务端的接口、方法进行控制；也就是根据不同接口设置不同阈值，这是为了使服务端的不同接口、方法之间的负载不互相影响；根据来源做控制，也就是对同样的接口对不同来源设置不同的限制。</p>
<h3 id="序列化和反序列处理"><a href="#序列化和反序列处理" class="headerlink" title="序列化和反序列处理"></a>序列化和反序列处理</h3><p>对于Java的序列化，需要考虑三个问题：1.跨语言问题；2.序列化和反序列化的性能开销；3.序列化后的长度；我们可以考虑xml或者json作为序列化方式。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>通信方式有BIO、NIO和AIO，BIO是阻塞IO，是一个连接消耗一个线程，但是消耗大。如果是NIO，那么客户端和服务器端之间的连接是可以复用的，而不是一个连接消耗一个线程。我们希望通过一个连接来进行多个并发请求操作。类比公路的职能，每条公路允许多辆汽车行驶而不是只有一辆汽车行驶。NIO提供的是非阻塞方式的IO，需要对外提供的是类似阻塞的同步远程请求方式。我们增加了IO线程，数据队列，通信对象队列，和定时任务。</p>
<h3 id="支持异步服务的调用方式"><a href="#支持异步服务的调用方式" class="headerlink" title="支持异步服务的调用方式"></a>支持异步服务的调用方式</h3><h4 id="oneWay"><a href="#oneWay" class="headerlink" title="oneWay"></a>oneWay</h4><p>oneWay是只管发送不管结果，只需要把要发送的数据放入数据队列，然后继续下面的操作。oneway不关心对方是否收到数据，也不关心返回值。</p>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>这种方式下，请求方发送后会继续执行下面操作，等对方响应会进行一个回调</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>把数据写入队列，把future写入队列，通过future获取结果</p>
<h4 id="可靠的异步"><a href="#可靠的异步" class="headerlink" title="可靠的异步"></a>可靠的异步</h4><p>通过消息中间件</p>
<h3 id="使用Future对远程服务调用的优化"><a href="#使用Future对远程服务调用的优化" class="headerlink" title="使用Future对远程服务调用的优化"></a>使用Future对远程服务调用的优化</h3><p>如果我们在一个请求处理中调用多个远程服务，如果采用同步的方式，那么总时间是全部请求时间求和，如果我们仍然按照顺序把服务的请求依次发给各个服务，但是请求过去后并不等待结果，而是在最后服务发出去后在等待，这样总时间变为单个远程服务时间的最大值。但是这有个前提，所有的服务并没有依赖关系，所以他们可以一起等。</p>
<h2 id="服务端的设计和实现"><a href="#服务端的设计和实现" class="headerlink" title="服务端的设计和实现"></a>服务端的设计和实现</h2><h3 id="如何暴露远程服务"><a href="#如何暴露远程服务" class="headerlink" title="如何暴露远程服务"></a>如何暴露远程服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ProviderBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"target"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>服务端提供的是providerBean，而客户端提供的是ConsumerBean。providerBean的职能是服务需要注册到服务查找中心后才能被服务调用者发现，所以providerBean需要将自己所代表的服务注册到服务注册查找中心。也需要在本机注册服务和对应服务的实例。</p>
<h3 id="服务端对请求处理的流程"><a href="#服务端对请求处理的流程" class="headerlink" title="服务端对请求处理的流程"></a>服务端对请求处理的流程</h3><p>服务框架启动时需要监听端口号，并且等待调用的请求。当服务注册好，监听端口号也准备好，就只需等待服务调用的请求进来。请求处理流程是：网络通信层、协议解析/反序列化、定位服务、调用服务。</p>
<h3 id="执行不同服务的线程池隔离"><a href="#执行不同服务的线程池隔离" class="headerlink" title="执行不同服务的线程池隔离"></a>执行不同服务的线程池隔离</h3><h3 id="服务提供者的流控处理"><a href="#服务提供者的流控处理" class="headerlink" title="服务提供者的流控处理"></a>服务提供者的流控处理</h3><p>在服务提供者看来，不同来源的服务调用者、0-1开关、限制具体数值的QPS方式都需要实现。对不同调用者进行升级，确保优先级高的服务调用者被优先调用</p>
<h3 id="服务升级"><a href="#服务升级" class="headerlink" title="服务升级"></a>服务升级</h3><h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><h4 id="修改调用参数列表"><a href="#修改调用参数列表" class="headerlink" title="修改调用参数列表"></a>修改调用参数列表</h4><p>1.对原来的方法的代码进行修改<br>2.通过版本号来解决<br>3.在设计的方法上考虑参数的扩展。但是不可行，通过map不直观</p>
<h2 id="实战的优化"><a href="#实战的优化" class="headerlink" title="实战的优化"></a>实战的优化</h2><h3 id="服务的拆分"><a href="#服务的拆分" class="headerlink" title="服务的拆分"></a>服务的拆分</h3><h3 id="服务的粒度"><a href="#服务的粒度" class="headerlink" title="服务的粒度"></a>服务的粒度</h3><h3 id="优雅和实用的平衡"><a href="#优雅和实用的平衡" class="headerlink" title="优雅和实用的平衡"></a>优雅和实用的平衡</h3><p>最上层是服务调用者，如果服务调用者调用服务十分频繁，可以写入缓存。没有在调用服务提供者，服务提供者先访问本地缓存，没有在访问数据库</p>
<h3 id="分布式环境下的请求合并"><a href="#分布式环境下的请求合并" class="headerlink" title="分布式环境下的请求合并"></a>分布式环境下的请求合并</h3><p>对于热点数据的处理，如果可以进行一些任务的合并问题，就会明显降低整个系统的负载。首先可以通过缓存，减少数据的读取和计算的工作量。还可以解析完参数，检查是否有线程在在计算相同的数据，如果有，等待结果；没有，进行计算。分布式环境下会涉及到多节点，如果使用分布式锁，则会有额外的开销。但是我们可以使用路由策略，相同参数的服务发送到同一台服务提供者。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/构建java中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/构建java中间件/" itemprop="url">构建java中间件（第三章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:59:08+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java中间件的定义"><a href="#java中间件的定义" class="headerlink" title="java中间件的定义"></a>java中间件的定义</h2><p>基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的服务，中间件不是操作系统的一部分，不是数据库管理的一部分，不是软件应用的一部分，而是能够让软件开发者更方便的处理通信、输入、输出，能够专注在他们自己应用的部分。总体来说，中间件不是最上层应用，也不是最底层的操作系统，是处于中间的组件，起到桥梁的作用，是应用和应用之间，应用和服务之间的桥梁。<br>主要有三个领域的中间件：</p>
<h3 id="远程对象调用和对象访问中间件"><a href="#远程对象调用和对象访问中间件" class="headerlink" title="远程对象调用和对象访问中间件"></a>远程对象调用和对象访问中间件</h3><p>解决分布式的应用互相访问的问题</p>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>解决应用之间的消息传递、解耦、异步的问题</p>
<h3 id="数据访问中间件"><a href="#数据访问中间件" class="headerlink" title="数据访问中间件"></a>数据访问中间件</h3><p>主要解决应用访问数据库的共性问题的组件</p>
<h2 id="构建java中间件的基础知识"><a href="#构建java中间件的基础知识" class="headerlink" title="构建java中间件的基础知识"></a>构建java中间件的基础知识</h2><h3 id="跨平台的运行环境–jvm"><a href="#跨平台的运行环境–jvm" class="headerlink" title="跨平台的运行环境–jvm"></a>跨平台的运行环境–jvm</h3><p>java虚拟机所识别的是统一格式的中间代码也就是java字节码。</p>
<h3 id="垃圾回收与内存堆布局"><a href="#垃圾回收与内存堆布局" class="headerlink" title="垃圾回收与内存堆布局"></a>垃圾回收与内存堆布局</h3><p>java虚拟机是通过垃圾回收方式来回收内存的，而不像C/C++语言那样通过代码显示释放。JVM内存堆布局有新生代、年老代、持久代。对象创建一般在新生代的eden区，也有可能直接分配在年老区。</p>
<h2 id="java并发编程的类、接口和方法"><a href="#java并发编程的类、接口和方法" class="headerlink" title="java并发编程的类、接口和方法"></a>java并发编程的类、接口和方法</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池可以降低创建线程的开销，这是因为线程池在线程结束后进行的是回收操作，而不是销毁线程。在java中，我们主要使用的线程池是ThreadPoolExecutor,此外，我们还有定时线程池scheduledThreadPoolExecutor。需要注意的是ThredPool.newCachedThreadPool()返回的线程池的使用，该方法返回的线程池的线程使用没有上限。因而没办法控制总体线程的数量，因为每个内存都要占用内存，这会造成过多内存的占用。建议不要用这个线程池。而使用有固定线程上限的线程池。</p>
<h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><p>sychronized可以用于声明方法，也可以用于声明代码块。看一下三个使用场景。<br>场景一：<br>在这个类的两个静态方法中，不同线程中，两个方法的调用是互斥的，不仅这样任何两个线程都是互斥的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo1&#123;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo1</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo2</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景二：<br>foo3和foo4是类的两个成员函数，在多线程中，调用同一个对象的foo3和foo4才会互斥，这是同一对象的多线程调用互斥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo2&#123;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo3</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo4</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景三：<br>sychronized用来修饰代码块，后面的参数就是同步锁的对象。sychronized(this) 与Demo3中加sychronized成员方法是互斥，sychronized(Demo3.class)与Demo3中加sychronized静态方法是互斥的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo3&#123;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo5</span></span>()&#123;</div><div class="line">           sychronized(this)&#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo6</span></span>()&#123;</div><div class="line">          sychronized(Demo3.class)&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是java.util.concurrent.locks中的一个类，他的用法类似sychronized类似，但是需要显示unlock。</p>
<h4 id="ReentrantLock提供tryLock"><a href="#ReentrantLock提供tryLock" class="headerlink" title="ReentrantLock提供tryLock"></a>ReentrantLock提供tryLock</h4><p>调用的时候，如果锁被其他线程持有，那么tryLock就会立刻返回，返回结果为false，如果锁没有被其他线程持有，当前线程会持有锁，返回true。</p>
<h4 id="ReentrantLock提供公平锁和抢占锁"><a href="#ReentrantLock提供公平锁和抢占锁" class="headerlink" title="ReentrantLock提供公平锁和抢占锁"></a>ReentrantLock提供公平锁和抢占锁</h4><p>默认是抢占锁，通过参数boolean fair；公平锁的好处是等待锁的线程不会饿死，但是整体效率会降低；非公平锁的好处是整体效率会相对高点，但是有些线程会饿死或者等待很长时间才能获取。公平锁是按照锁的排队顺序需要获取锁，而非公平锁是抢占式的。此外ReentrantLock还提供了ReentrantReadWriteLock，读写锁，主要用于读多写少并且读不需要互斥的场景，这样的锁比全部互斥锁性能会高。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlock写在finally表示一定可以释放锁，ReentrantReadWriteLock与ReentrantLock用法相似，但是通过readLock()和writeLock()两个方法来获取读锁和写锁，这两个锁按照前面的方式进行加锁和解锁。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>sychronized除了有互斥性，还有可见性。可见性是指一个线程修改了变量后，其他线程能够马上看到这个修改值。volatile能够保证变量的可见性，它更多是修饰开关的可见性，它不能保证操作的原子性。</p>
<h3 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h3><p>JDK 1.5增加了java.util.concurrent.atomic包，这些包是以Atomic开头的类，这些类提供了一些原子操作，以AtomicInteger为例，通过jni使用硬件支持的CAS指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Sample &#123;</div><div class="line"></div><div class="line">    private static AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">increment</span></span>() &#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">decrease</span></span>() &#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h3><p>wait、notify和notifyAll是java的object对象的三个方法，wait是用来等待的，notify和notifyAll是用来通知的。在多线程中，可以把某个对象做为事件对象，通过这个对象的wait、notify、notifyAll完成线程的通知。notify和notifyAll都是唤醒调用同一个对象的wait，但不同的是notify会唤醒一个等待线程，notifyAll会唤醒全部等待线程。对wait、notify、notifyAll的调用必须在对象的sychronized中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">testWait</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.wait();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">testNotify</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实践中，对wait的使用一般在循环里，并且会判断相关的数据状态是否达到预期，如果没有，继续等待，这样做主要是为了防止虚假唤醒。虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒，而此时是不应该唤醒的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sychronized(obj)&#123;</div><div class="line"></div><div class="line">       <span class="keyword">while</span>(&lt;condition does not hold&gt;)</div><div class="line">            obj.wait();</div><div class="line">           //<span class="keyword">do</span>Sometihing()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是java.util.concurrent包中的一个类。CountDownLatch提供的机是当多个（具体数量是等于初始化CountDownLatch初始化的值）线程都到达了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件触发自己后续的工作。等待的线程可以是多个，即CountDownLatch可以唤醒多个等待的线程，到达自己预期的状态会调用CountDownLatch的countDown方法，而等待的线程可以调用countDownLatch的await方法。<br>如果CountDownLatch的初始化count值为1就退化成为了单个事件，即由一个线程通知其他线程，效果等同于await和notifyAll。count值大于1是常用的方式，目的是让多个线程到达各自的预期状态，变为一个事件来通知，线程继续自己的行为。<br>例如我们使用一台多核机器对一组数据进行排序，我们可以把一组数据分到不同的线程去排序，然后在进行合并；可以将CountDownLatch作为各个线程排好序的通知。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int count=10;</div><div class="line">final CountDownLatch latch=new CountDownLatch(count);</div><div class="line">int[] datas=new int[10204];</div><div class="line">int step=datas.length/count;</div><div class="line"><span class="keyword">for</span>(int i=0;i&lt;count;i++)&#123;</div><div class="line">    int begin=i*step;</div><div class="line">    int end=(i+1)*step;</div><div class="line">    <span class="keyword">if</span>(i==count-1)&#123;</div><div class="line">      end=datas.length;</div><div class="line">    &#125;</div><div class="line">    threadPool.execute(new MyRunnable(latch,datas,begin,end));</div><div class="line">&#125;</div><div class="line">latch.await();</div><div class="line">合并数据</div><div class="line">MyRunnable的run实现</div><div class="line">public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">  //数据排序</div><div class="line">  latch.countDown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier字面意思循环屏障，CyclicBarrier可以协调多个线程，让多个线程在这个屏障等待，直到所有线程都到达了这个屏障，再一起继续执行后面的动作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static class WorkerThread implements Runnable&#123;</div><div class="line"></div><div class="line">          CyclicBarrier barrier;</div><div class="line"></div><div class="line">          public WorkerThread(CyclicBarrier b)&#123;</div><div class="line">             this.barrier = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         @Override</div><div class="line">         public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">             // TODO Auto-generated method stub</div><div class="line">             try&#123;</div><div class="line">                 System.out.println(<span class="string">"Worker's waiting"</span>);</div><div class="line">                 //线程在这里等待，直到所有线程都到达barrier。</div><div class="line">                 barrier.await();</div><div class="line">                 System.out.println(<span class="string">"ID:"</span>+Thread.currentThread().getId()+<span class="string">" Working"</span>);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch的count等于调用countDown的个数，CyclicBarrier的数量是await的数量。CyclicBarrier、CountDownLatch都是用于多线程协调，但不同是，CountDownLatch是在多线程中进行latch.countDown后才会触发事件，唤醒await的线程。而CyclicBarrier是用于同步所有调用await方法的线程。并且等到所有线程到了await后才会一起返回继续自己的工作。CountDownLatch不能循环调用,CyclicBarrier可以循环调用。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是用来管理信号量的，构造的时候传入可供管理信号量的数值。简单来说，信号量对象管理的信号就像令牌，构造时传入个数，总数就是控制并发的数量。执行前先获取信号（通过acquire），执行后归还信号（通过release），每次acquire成功后，信号量减少一，如果没有可用的信号，acquire就会阻塞，等待release调用释放信号，才能获取信号返回。<br>如果Semaphore管理的信号量只有一个，就退化成互斥锁。如果大于1的信号量，主要用于控制并发数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">semaphore.acquire();</div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">semaphore.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger用于两个线程的数据进行交换，线程会阻塞Exchanger的exchange方法，知道另外一个线程也到exchange方法，然后交换数据，往下执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">final Exchanger&lt;List&lt;String&gt;&gt; exchanger = new Exchanger&lt;List&lt;String&gt;&gt;();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"1"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread1"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"3"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread2"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div></pre></td></tr></table></figure></p>
<h3 id="Future和FuturTask"><a href="#Future和FuturTask" class="headerlink" title="Future和FuturTask"></a>Future和FuturTask</h3><p>Future 是一个接口，FutureTask是接口的实现类，我们看下这么样的场景<br>通过调用一个方法从远程获取一些计算结果，假设有HashMap getDataFromRemote();<br>假设是同步的方式，我们会一直等待这个方法的返回，然后才能继续下面的工作，如果这个方法执行的时间比较长，并且后面的代码跟这个方法没关系的话，那么阻塞在这里就没有意义。<br>第二种方式是异步的方式，调用函数后马上返回，然后继续执行，等需要用时再来取数据。具体实现方式是用Future，或者回调。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>并发容器是线程安全容器的一种，但是并发容器强调容器的并发性，也就是不仅强调安全，也强调并发。比较有代表的是CopyAndWrite和Concurrent开头的容器。如ConcurrentHashMap，ConcurrentLinkedQueue，ConcurrentLinkedDequeue、CopyOnWriteArrayList、CopyOnWriteArraySet。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	 public void <span class="keyword">do</span>Something();  </div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	  public void <span class="function"><span class="title">doSomething</span></span>()   </div><div class="line">	  &#123;   </div><div class="line">	    System.out.println( <span class="string">"call doSomething()"</span> );   </div><div class="line">	  &#125;   </div><div class="line">&#125;</div><div class="line">public class ProxyObject implements Subject &#123;</div><div class="line"></div><div class="line">	private RealSubject realSubject;</div><div class="line"></div><div class="line">	public ProxyObject(RealSubject realSubject) &#123;</div><div class="line">		super();</div><div class="line">		this.realSubject = realSubject;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		realSubject.doSomething();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理有静态代理和动态代理之分。<br>静态代理方式是为每一个被代理的对象构造对应的代理类。这种方式比较直接，实现也比较方便，不过也存在问题，即如对多个类进行代理，并且在代理类的功能实现是一致的，就必须为每一个具体类都完成一个代理类。<br>动态代理是动态地生成具体委托类的代理类实现对象。与静态代理不同，它只需要为一类代理行为写一个具体的实现类。用过Proxy.newProxyInstance来创建代理的方式可以为不同的委托类创建代理类。在具体的代理实现上，所给出的是通用实现，被代理的方法会进入invoke方法，我们可以在invoke方法中做很多事情，例如调用前和调用后可以操作。并且对于一类的增强事情，我们不用写多个ProxyHandler，就可以给多个委托类使用<br><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ProxyHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	  private Object proxied;   </div><div class="line"></div><div class="line">	  public ProxyHandler( Object proxied )   </div><div class="line">	  &#123;   </div><div class="line">	    this.proxied = proxied;   </div><div class="line">	  &#125;   </div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println(&quot;before invoke&quot;);</div><div class="line">		Object object=method.invoke(proxied, args);</div><div class="line">		System.out.println(&quot;after invoke&quot;);</div><div class="line">		return object;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">RealSubject realSubject = new RealSubject();</div><div class="line">		Subject subject = (Subject) Proxy.newProxyInstance(</div><div class="line">				Subject.class.getClassLoader(), new Class[]&#123;Subject.class&#125;,</div><div class="line">				new ProxyHandler(realSubject));</div><div class="line">		subject.doSomething();</div></pre></td></tr></table></figure></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>java反射机制是指在运行状态中，对于任意的一个类，都能知道这个类的所有方法和所有属性。对于任意一个对象，都能调用他的任意一个他的方法或者他的属性。反射主要提供的功能有：1.在运行时判断任意一个对象所属的类；2.在运行时构造任意一个对象所属的类；3.在运行时判断任意一个类的所具有的成员变量和方法；4.在运行时调用任意一个对象的方法；5.生成动态代理。用法示例</p>
<h3 id="获取对象属于哪个类"><a href="#获取对象属于哪个类" class="headerlink" title="获取对象属于哪个类"></a>获取对象属于哪个类</h3><p>Subject subject=new Subject(“lr12”, “topic”);<br>Class class=subject.getClass();</p>
<h3 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h3><p>//获取类名<br>String className=clazz.getName();<br>//获取方法<br>Method[] methods=clazz.getDeclaredMethods();<br>//获取成员变量<br>Field[] fields=clazz.getDeclaredFields();</p>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3><p>Class.forName(“reflect.Subject”).newInstance();<br>在这里的通过传入一个字符创来构造对象，体现了动态性，同时要求这个类的构造函数必须有一个无参的，否则将抛出异常。</p>
<h3 id="动态执行方法"><a href="#动态执行方法" class="headerlink" title="动态执行方法"></a>动态执行方法</h3><p>Method method=clazz.getDeclaredMethod(“doSomething”);<br>method.invoke(subject);</p>
<h3 id="动态操作属性"><a href="#动态操作属性" class="headerlink" title="动态操作属性"></a>动态操作属性</h3><p>Field field=clazz.getDeclaredField(“name”);<br>field.set(subject, “lr”)<br>这里要强调如果方法和属性是静态的，这时候可以不用传对象，可以传null。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>网络通信三个模型：BIO、NIO、AIO。在1.4的版本中增加了NIO，在1.7的版本中增加了AIO。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/17/大型软件架构及其结构演进过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/大型软件架构及其结构演进过程/" itemprop="url">大型软件架构及其结构演进过程第二章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T17:25:39+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是大型网站"><a href="#什么是大型网站" class="headerlink" title="什么是大型网站"></a>什么是大型网站</h1><p>访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是个分布式系统</p>
<h1 id="大型网站的架构演进"><a href="#大型网站的架构演进" class="headerlink" title="大型网站的架构演进"></a>大型网站的架构演进</h1><h2 id="用java技术和单机来构建网站"><a href="#用java技术和单机来构建网站" class="headerlink" title="用java技术和单机来构建网站"></a>用java技术和单机来构建网站</h2><p>选择一个开源的server作为容器，使用一些JSP/servlet技术或者开源框架构建我们的应用，选择一个数据库管理系统来管理数据，通过jdbc进行数据库的连接和操作。</p>
<h2 id="从一个单机的交易网站说起"><a href="#从一个单机的交易网站说起" class="headerlink" title="从一个单机的交易网站说起"></a>从一个单机的交易网站说起</h2><p>考虑一个交易网站，最基本功能有这么三个部分：用户模块、商品模块、交易模块，各个功能模块是通过JVM内部的方法调用来进行交互，应用和数据库之间是通过jdbc来访问的。同时应用和数据库放在同一台机子上。</p>
<h2 id="单机负载告警，数据库与应用分离"><a href="#单机负载告警，数据库与应用分离" class="headerlink" title="单机负载告警，数据库与应用分离"></a>单机负载告警，数据库与应用分离</h2><p>网站对外提供服务后，访问量不断增大，负载持续升高。我们可以把数据库和应用分开，分别放到两台机子上。</p>
<h2 id="应用服务器告警，如何让应用服务器走向集群"><a href="#应用服务器告警，如何让应用服务器走向集群" class="headerlink" title="应用服务器告警，如何让应用服务器走向集群"></a>应用服务器告警，如何让应用服务器走向集群</h2><p>服务器压力仍然变大，把应用从单机升级为集群，我们可以考虑一台应用服务器变为两台。我们要考虑如下两个问题，第一个是服务器的选择问题，可以用dns或者增加负载均衡设备来解决这个问题；第二个是session问题。</p>
<h3 id="引入负载均衡设备"><a href="#引入负载均衡设备" class="headerlink" title="引入负载均衡设备"></a>引入负载均衡设备</h3><h3 id="解决应用服务器变为集群后的session问题"><a href="#解决应用服务器变为集群后的session问题" class="headerlink" title="解决应用服务器变为集群后的session问题"></a>解决应用服务器变为集群后的session问题</h3><p>http协议本身是无状态的，需要基于http协议支持会话状态机制，具体的实现方式是：在会话开始时，分配唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后再每次请求的时候，浏览器会带上这个会话标识告诉web服务器请求属于哪个会话的。在web服务器上，各个会话有独立的存储，保存不同的会话信息。如果是禁用cookie的情况，就把会话标识放在url参数上。<br>当应用服务器扩展时就会遇到session问题。因为session是存在单机上的。</p>
<h4 id="session-sticky（保持-粘滞会话）"><a href="#session-sticky（保持-粘滞会话）" class="headerlink" title="session sticky（保持-粘滞会话）"></a>session sticky（保持-粘滞会话）</h4><p>在负载均衡器上做了操作，同样的session请求每次发送给同一个服务器端处理。但也带来以下的问题：1.如果一台服务器宕机或者重启，那么这台服务器上的会话数据会全部丢失，如果会话中有登录状态的数据的话，那就要重新登录。2.会话标识的应用层信息，那么负载均衡器需要进行应用层解析，这个开销比第四层交换大。3.负载均衡器变为有状态的节点，要将会话保存到web服务器映射。和无状态节点相比，内存消耗更大，容灾更麻烦。</p>
<h4 id="session-Replication（复制会话）"><a href="#session-Replication（复制会话）" class="headerlink" title="session Replication（复制会话）"></a>session Replication（复制会话）</h4><p>web服务器会增加会话的同步，但在一些场景存在问题：1.同步session造成网络的开销。只要session数据发生变化，就需要把数据同步到其他机器上，机器越多，同步带来的网络带宽的开销就会越大；2.每台web服务器都需要保存所有的session数据，如果整个集群的session数很多，每台机器用于保存session的内容占用会很严重。</p>
<h4 id="session数据集中存储"><a href="#session数据集中存储" class="headerlink" title="session数据集中存储"></a>session数据集中存储</h4><p>把session数据集中存储，不同的web服务器从相同的地方获取session数据。session会统一存储在另外的服务器上，这样可以保证web服务器读到的session数据都是一样的。存储session的具体方式，可以使用数据库或者其他分布式存储系统。这个方案解决了replication的内存问题和带宽问题。但也存在问题是：1.读写session引入网络操作，问题就在时延和不稳定性，但如果是内网，这个问题不大；2.如果集中存储session的机器或者集群有问题，会影响我们的应用。</p>
<h4 id="cookie-based（基于cookie1）"><a href="#cookie-based（基于cookie1）" class="headerlink" title="cookie based（基于cookie1）"></a>cookie based（基于cookie1）</h4><p>通过cookie传递session数据，我们的session数据存储在cookie里，然后web服务器从cookie中生成对应的session数据。这个方案存在着不足：1.cookie的长度限制限制了session的长度限制。2.安全性；session数据是服务器数据，而这个方案导致服务端数据到了外部网络和客户端，因而存在安全性问题。但也可以通过对session数据加密，但从安全角度来看物理上不接触才更安全。3.带宽消耗，数据中心整体的带宽消耗；4.性能影响；每次http请求和响应都带有session数据，对web服务器来说，响应结果输出越少，支持的并发请求越多</p>
<h2 id="数据读压力大，那么就读写分离吧"><a href="#数据读压力大，那么就读写分离吧" class="headerlink" title="数据读压力大，那么就读写分离吧"></a>数据读压力大，那么就读写分离吧</h2><p>接下来从数据库的角度来看。</p>
<h3 id="采用数据库作为读库"><a href="#采用数据库作为读库" class="headerlink" title="采用数据库作为读库"></a>采用数据库作为读库</h3><p>对于大型网站，有不少业务是读多写少，这个状况会直接反应到数据库上，我们考虑读写分离的方式。我们在前面结构增加一个读库，这个库不承担写工作，只提供读操作。这个结构的变化会带来两个问题：1.数据复制问题；2.应用对于数据源的问题<br>首先看下第一个问题，现在数据库系统一般都提供数据复制的功能，可以直接使用数据库系统的自身机制。除此，还需要考虑数据复制时延问题，以及复制过程中数据源和目标之间的映射关系以及过滤条件的支持问题。复制时延带来的是短期的数据不一致。<br>mysql支持master+slave模式，5.5版本以前是异步数据复制，会有延迟，提供完全镜像方式的复制；5.5以后采用semisync（半同步）<br>备注：异步复制模式：主库将已经提交的事务event 写入binlog后，即返回成功给app，该模式下并不保证任何已经提交的事务会传递到任何slave并被成功应用。全同步复制模式：当主库提交一个事务 event，主库会等待该事务被传递到所有的slave上，且所有slave applay 该事务/event 通知主库之后，才会返回会话，事务已经成功。Semisynchronous Replication模式下,在主库上提交一个事务/event，它会等待至少一个slave通知主库，slave 已经接收到传递过来的events并写入relay log，才返回给回话层 写入成功，或者直到传送日志发生超时。<br>对于一个应用来说，增加一个读库对结构变化有一个影响，我们应用需要根据不同情况选择不同的数据库源。写操作走主库，事务的读也要走主库，用时也要考虑备库相对于主库的数据延时。即使是不在事务的读，考虑备库数据延迟，不同业务选择也有差异。<br>广义读写分离的特点是增加读源，分担读写源的读压力，要考虑读源的数据复制问题。</p>
<h3 id="搜索引擎其实是一个读库"><a href="#搜索引擎其实是一个读库" class="headerlink" title="搜索引擎其实是一个读库"></a>搜索引擎其实是一个读库</h3><p>大型网站的站内搜索。在交易网站中，用户需要查找商品功能之类的，这就像数据库的like功能，但这种方式的代价很大。可以使用搜索引擎的倒排表方式，能够大大提升搜索效率。搜索集群的使用方式和读库我们希望的使用的方式是一样的。构建索引的方式有两种，一种按照全量/增量划分，另一种是实时/非实时划分。全量用于第一次建立索引。增量一般用于加入每日的全量作为补充。实时/非实时划分体现在索引更新时间上。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，也就是我们常说的cache。</p>
<h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p>缓存系统一般是用来保存和查询key-value键值对的。应用访问缓存，如果数据不存在，就从数据库中读出数据放入缓存。当缓存数量不够时，最近不被访问的数据就被清除。还有另外做法，在数据库中数据发生变化后，能主动把数据放入缓存系统中。这样的好处是能够及时地更新缓存数据，不会造成读取失效，一般用于全数据缓存，还要能够理解业务逻辑。</p>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>有些动态产生的页面特别热，我们可以对这些内容进行缓存。</p>
<h2 id="弥补关系型数据库的不足，引入分布式存储系统"><a href="#弥补关系型数据库的不足，引入分布式存储系统" class="headerlink" title="弥补关系型数据库的不足，引入分布式存储系统"></a>弥补关系型数据库的不足，引入分布式存储系统</h2><p>常见的分布式存储系统有分布式文件系统，分布式key-value系统和分布式数据库。通过分布式文件系统来解决小文件和大文件的存储问题，通过key-value系统提供高性能的半结构化的支持，通过分布式数据库提供一个支持大数据、高并发的数据库系统。</p>
<h2 id="读写分离后，数据库又遇到瓶颈"><a href="#读写分离后，数据库又遇到瓶颈" class="headerlink" title="读写分离后，数据库又遇到瓶颈"></a>读写分离后，数据库又遇到瓶颈</h2><p>通过读写分离，分布式存储来替代关系型数据库能够降低主库的压力，但是交易、商品、用户的数据还在同一个数据库中，这时候数据库的压力还在，这时候采取的方案有水平拆分和垂直拆分。</p>
<h3 id="专库专用，数据垂直拆分"><a href="#专库专用，数据垂直拆分" class="headerlink" title="专库专用，数据垂直拆分"></a>专库专用，数据垂直拆分</h3><p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合交易系统的例子，就是将交易、商品、用户的数据拆分开。所造成的的影响是需要配置多个数据源，这就增加了所需配置，所带来的的是每个数据库连接池的隔离，那就需要考虑单机跨业务的事务。一种方案是分布式事务，另一种是去掉事务或者不去追求强事务支持，则原来在单库中可以使用的表关联的查询也需要改变实现。</p>
<h3 id="垂直拆分后的单机遇到瓶颈，数据水平拆分"><a href="#垂直拆分后的单机遇到瓶颈，数据水平拆分" class="headerlink" title="垂直拆分后的单机遇到瓶颈，数据水平拆分"></a>垂直拆分后的单机遇到瓶颈，数据水平拆分</h3><p>数据水平拆分就是把同一个表的数据拆分成不同的数据库中去。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到单个数据库的瓶颈。这时就把一张表拆到两个或者多个数据库中。数据水平拆分和读写分离的区别是读写分离解决的是读压力大，对于数据量大或者更新量大的情况并不起到作用；数据水平拆分和数据垂直拆分区别是，垂直拆分是把不同表拆到不同数据中去；水平拆分是把同一张表拆分到不同数据库中去。水平拆分后的问题：1.需要解决SQL路由的问题；2.主键的处理也会变得不同。3.分页会变得困难。</p>
<h2 id="数据库问题解决后，应用面对的新挑战"><a href="#数据库问题解决后，应用面对的新挑战" class="headerlink" title="数据库问题解决后，应用面对的新挑战"></a>数据库问题解决后，应用面对的新挑战</h2><h3 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h3><p>前面都是在解决数据的问题，现在我们可以看应用的问题。随着功能越来越多，应用也越来越大，我们需要把应用拆开。在我们的例子中，主要业务功能分为：交易、商品、用户。我们可以把这个应用分为交易和商品两个应用。对于交易和商品都会有涉及用户的地方，我们让两个自己完成涉及用户的工作，类似用户工作</p>
<h3 id="走服务化的做法"><a href="#走服务化的做法" class="headerlink" title="走服务化的做法"></a>走服务化的做法</h3><p>我们把应用分为了三层，分为商品中心、用户中心、交易中心，处于最上层是web系统，用于完成不同的业务功能，处于中间是服务中心，最下层是业务数据库。服务化带来的变化：1.业务功能之间的访问不在是单机的简单方法调用，而是远程服务调用；2.共享的代码的实现放在服务中心；3.数据库的连接发生了变化，我们把数据库的交互工作放到服务中心，让前端专注与浏览器的交互上，而不必关注业务逻辑。连接数据库交给业务中心，减少数据库连接数；4.通过服务化，无论前端web应用还是服务中心，都可以由固定的小团队来维护的系统，这样更好地保持稳定和降低风险。</p>
<h2 id="初始消息中间件"><a href="#初始消息中间件" class="headerlink" title="初始消息中间件"></a>初始消息中间件</h2><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件，消息中间件的好处是异步和解耦，生产者和消费者都直接跟消息中间件打交道，两个应用之间并不直接联系。这样完成了解耦，目的是希望双方彼此都不知道对方的存在，不受对方影响，消息投递给接收者用到异步的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/16/大型网站系统与中间件实践读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/16/大型网站系统与中间件实践读书笔记/" itemprop="url">分布式系统介绍（第一章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-16T11:22:37+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><p>1.组件分布在网络计算机上；<br>2.组件之间仅仅通过消息传递来通信并协调行动</p>
<h2 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h2><p>1.升级单机处理能力的性价比越来越低<br>2.单机处理能力存在瓶颈<br>3.出于稳定性和可用性的考虑</p>
<h2 id="线程和进程的执行模式"><a href="#线程和进程的执行模式" class="headerlink" title="线程和进程的执行模式"></a>线程和进程的执行模式</h2><h3 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h3><p>s(N)=1/(1-p+p/n);n代表核数，p代表并行部分在单核占的时间</p>
<h3 id="互不通信的多线程模式"><a href="#互不通信的多线程模式" class="headerlink" title="互不通信的多线程模式"></a>互不通信的多线程模式</h3><p>线程之间不需要处理共享的数据，也不需要进行动作协调，没有交集，各自执行自己的逻辑和任务。</p>
<h3 id="基于共享容器协同的多线程模式"><a href="#基于共享容器协同的多线程模式" class="headerlink" title="基于共享容器协同的多线程模式"></a>基于共享容器协同的多线程模式</h3><p>多个线程之间对共享数据进行处理。例如经典的有生产者和消费者，我们有个队列用于生产和消费，这个队列就是共享的对象，多个线程会并发的访问这个队列。对于存储数据的容器或者对象，有线程安全和线程不安全之分。对于线程不安全的容器或者对象，一般通过加锁或者copy on write的方式来处理（CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。CopyOnWriteArrayList、CopyOnWriteArraySet。问题：内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器）</p>
<h3 id="基于事件协同的多线程模式"><a href="#基于事件协同的多线程模式" class="headerlink" title="基于事件协同的多线程模式"></a>基于事件协同的多线程模式</h3><p>除了并发访问，线程之间会存在着协调的需求。例如线程B需要等到某个状态或者事件的发生后才能继续自己的工作。能够原子性的获取多个锁或者调整锁的顺序可以避免死锁。比如T1：A.lock();B.lock(); T2:B.lock();A.lock();这时候就发生死锁了。</p>
<h3 id="多进程模式"><a href="#多进程模式" class="headerlink" title="多进程模式"></a>多进程模式</h3><p>多线程和多进程不同在于线程是属于进程，一个进程内的多个线程共享了进程的内存空间；多个进程的内存空间是独立的。多进程可以共享数据，但代价比多线程大，会涉及到序列化和反序列化的开销。分布式系统是多机系统，可以看成是多机多进程。</p>
<h2 id="网络通信基础知识"><a href="#网络通信基础知识" class="headerlink" title="网络通信基础知识"></a>网络通信基础知识</h2><h3 id="osi和tcp-ip网络模型"><a href="#osi和tcp-ip网络模型" class="headerlink" title="osi和tcp/ip网络模型"></a>osi和tcp/ip网络模型</h3><p>osi是七层 物理层 数据链路层 网络层 运输层 会话层 展示层 应用层<br>tco/ip是四层 网络接口 网络层 运输层 应用层</p>
<h3 id="网络io的实现"><a href="#网络io的实现" class="headerlink" title="网络io的实现"></a>网络io的实现</h3><h4 id="BIO的方式"><a href="#BIO的方式" class="headerlink" title="BIO的方式"></a>BIO的方式</h4><p>Blocking IO，采用阻塞的方式去实现，也就是一个套接字需要使用一个线程处理。发生建立连接、读数据、写数据时都可能会发生阻塞。</p>
<h4 id="NIO的方式"><a href="#NIO的方式" class="headerlink" title="NIO的方式"></a>NIO的方式</h4><p>NonBlocking IO，基于事件驱动思想。相比较BIO，NIO不需要为每一个套接字分配一个线程，而可以在一个线程中处理多个套接字工作。reactor模式下，Reactor会管理所有的handler，并且把出现的事件交给相应的handler去处理。在NIO中统一通过reactor对所有客户端的套接字的事件做处理，然后在派发到不同的线程。这样解决了为了支撑更多套接字而打开更多线程的问题。</p>
<h4 id="AIO的方式"><a href="#AIO的方式" class="headerlink" title="AIO的方式"></a>AIO的方式</h4><p>Asynchronous IO（异步IO），AIO采用Proactor模式，AIO在进行读/写操作时，只需要调用对应的read/write方法，并且传入completionHandler；在动作完成后，会调用completionHandler。NIO的通知是发生在动作之前，是在可读可写，selector发现这些事件调用handler来处理。</p>
<h2 id="如何把应用从单机扩展到分布式"><a href="#如何把应用从单机扩展到分布式" class="headerlink" title="如何把应用从单机扩展到分布式"></a>如何把应用从单机扩展到分布式</h2><h3 id="输入设备的变化"><a href="#输入设备的变化" class="headerlink" title="输入设备的变化"></a>输入设备的变化</h3><p>两种：一种是互相连接的多个节点，接受其他节点信息的节点；一种是人机交互的输入设备</p>
<h3 id="输出设备的变化"><a href="#输出设备的变化" class="headerlink" title="输出设备的变化"></a>输出设备的变化</h3><p>两种：向其他节点传递信息的节点；人机交互的输出设备</p>
<h3 id="控制器的变化"><a href="#控制器的变化" class="headerlink" title="控制器的变化"></a>控制器的变化</h3><p>在单机中，控制器就是cpu，在分布式中，控制器就是协调和控制节点之间的动作和行为。</p>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>请求发起方需要确定谁来处理这个请求，请求发起方和请求处理方中间有一个硬件负载均衡设备，所有的请求都要经过这个负载均衡设备来完成请求转发的控制。</p>
<h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>把硬件负载均衡器换为LVS；特点：代价低，可控性强，你可以相对自由地按照自己的需要去增加负载均衡策略。在集群中，对于发起请求的一方和处理请求的一方来说都是透明的。发送请求的一方会认为中间代理提供了服务，而处理请求的一方会认为中间代理请求服务。发起方不需要知道有几台机器提供服务，也不需要知道提供服务的地址，只需要知道中间代理的地址。有两个不足：第一个是增加网络的开销，一方面指的是流量，一方面指的是延迟。第二个是这个透明代理在请求的必经路径上，如果这个代理出现问题，那么所有请求都会出现问题。所以要考虑热备份</p>
<h4 id="名称服务"><a href="#名称服务" class="headerlink" title="名称服务"></a>名称服务</h4><p>与透明服务最大的区别是，请求发起方和请求处理方两个集群间没有代理服务器这样的设备存在，而是请求方和处理方直接相连。除此之外，有一个名称服务的角色，主要作用有两个，收集请求服务处理的服务器的地址信息，和提供这些地址信息给请求发起方。名称服务只是起到地址交换的作用，在发起请求的机器上，需要根据从名称服务得到的地址进行负载均衡的工作。这种方案的优势是名称服务不在请求的必经路径上，就是说如果这个名称服务出现问题，很多时候我们有不少办法保证请求处理的正常。其次，发起请求的一方和处理请求的一方是直连的，减少了中间路径，以及可能的额外带宽消耗。劣势是升级代码复杂。</p>
<h4 id="规则服务器"><a href="#规则服务器" class="headerlink" title="规则服务器"></a>规则服务器</h4><p>请求发起方根据规则服务器给的规则选择请求处理方，在请求发起的机器上，会有对规则进行处理从而进行请求处理服务机器的选择代码。与名称服务不同的是，规则服务器不和请求处理机器进行交互，只负责把规则提供给请求发起方。</p>
<h4 id="master-worker"><a href="#master-worker" class="headerlink" title="master+worker"></a>master+worker</h4><p>存在一个master节点管理任务，由master分配给不同的woker去进行处理。</p>
<h3 id="运算器的变化"><a href="#运算器的变化" class="headerlink" title="运算器的变化"></a>运算器的变化</h3><p>单机中，运算器就是具体的电子元件，而多机中，运算器由多个节点组成，分布式的运算器是运用多个节点的计算能力来协同完成整体的计算任务。</p>
<h4 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h4><h4 id="多台服务器"><a href="#多台服务器" class="headerlink" title="多台服务器"></a>多台服务器</h4><p>方案一：通过DNS服务器进行调度控制，在用户解析dns时候，就会给予一个服务器地址。有点像名称服务和规则服务，中间没有代理。<br>方案二：在用户和服务器之间架起了负载均衡设备（硬件或者软件LVS）。DNS返回的是负载均衡的地址，用户的访问都是通过负载均衡器到达后面的网站服务器。</p>
<h4 id="日志的处理"><a href="#日志的处理" class="headerlink" title="日志的处理"></a>日志的处理</h4><p>增加日志的处理服务器的数量来提升处理日志的能力。一种方案是利用 master+worker方式的控制器运用到这个日志处理的场景。除了master以外，还可以用规则服务器来分配问题。</p>
<h4 id="存储器的变化"><a href="#存储器的变化" class="headerlink" title="存储器的变化"></a>存储器的变化</h4><p>存储器分为内存和外存，内存在断电、重启或者OS崩溃情况下会丢失，而外存是用来长久保存数据的。在分布式系统中，我们需要把承担存储功能的多个节点组织在一起，使之看起是一个存储器。以最基础的key-value为例。</p>
<h4 id="单机的key-value"><a href="#单机的key-value" class="headerlink" title="单机的key-value"></a>单机的key-value</h4><h4 id="在应用服务器与key-value存储服务器之间加了一个代理服务器"><a href="#在应用服务器与key-value存储服务器之间加了一个代理服务器" class="headerlink" title="在应用服务器与key-value存储服务器之间加了一个代理服务器"></a>在应用服务器与key-value存储服务器之间加了一个代理服务器</h4><h4 id="名称服务的key-value服务"><a href="#名称服务的key-value服务" class="headerlink" title="名称服务的key-value服务"></a>名称服务的key-value服务</h4><h4 id="规则服务器的key-value服务"><a href="#规则服务器的key-value服务" class="headerlink" title="规则服务器的key-value服务"></a>规则服务器的key-value服务</h4><h4 id="master控制的key-value服务"><a href="#master控制的key-value服务" class="headerlink" title="master控制的key-value服务"></a>master控制的key-value服务</h4><h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><h4 id="缺乏全局时钟"><a href="#缺乏全局时钟" class="headerlink" title="缺乏全局时钟"></a>缺乏全局时钟</h4><p>单机的以单机的时钟为准控制时序。多机每个节点都有自己的时钟，如果依赖时序，将会难以处理。</p>
<h4 id="面对故障的独立性"><a href="#面对故障的独立性" class="headerlink" title="面对故障的独立性"></a>面对故障的独立性</h4><p>在单机系统的单进程程序中，不会出现一些模块不行，一些模块正常。而在分布式系统中，整个系统一部分有问题而其他模块正常的情况是经常出现。我们称故障独立性。</p>
<h4 id="处理单点故障"><a href="#处理单点故障" class="headerlink" title="处理单点故障"></a>处理单点故障</h4><p>在分布式系统中，如果某个角色或者功能只有单机在支撑，那么这个节点我们称之为单点。避免单点的关键就是把这个功能从单机实现变为集群实现。如果不能把单机实现变为集群实现，那一般还有另外两种选择：<br>1.给单点做好备份<br>2.降低单点故障的影响范围（比如，在交易网站中，交易信息放在一个数据库里，这就形成了单点，我们会给这个数据库增加一个备库以解决容灾问题。我们可以考虑拆分数据，把一份数据库拆分成多个数据库后，出现故障的影响面就更小了。从本质上说，这种方式更多是转移和交换）</p>
<h4 id="分布式事务的挑战"><a href="#分布式事务的挑战" class="headerlink" title="分布式事务的挑战"></a>分布式事务的挑战</h4><p>2pc、3pc、最终一致、BASE、CAP、paxos算法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第八周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第八周周报/" itemprop="url">云取证第八周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T19:54:42+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。<br>首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次。2.显示云测试的总体上下文；3.提供了包括Guidance EnCase和AccesData Forensic Toolkit在内的流行取证获取工具。<br>云计算使取证不同，特别是考虑到证据的远程性质，缺乏实体访问权限以及完整性和真实性所需的信任。虽然取证检查员的目标与以前相同，但非传统困难的问题包括：远程数据的取证知识获取，大量传播，分布式数据，监管链和数据所有权。检获和获取数字文物是取证进程的初步步骤。存在两种可能的情况：远程调查员可以从源头自己收集取证证据，或者提供者可以提供证据。每个场景需要对所返回数据的不同程度的信任。此外，每种情况都使用不同的技术实现来恢复数据。主要工作有亚马逊弹性计算云（EC2）在公共云中执行持续和非持久性数据收集的现有工具的三个实验结果。对于使用客户机操作系统的数据采集不够信任的情况，分析基础设施堆栈较低级别的取证方法。演示如何使用虚拟机内省来注入远程取证代理进行远程采集。用不受信任的管理程序探索取证数据采集的四个策略。<table><tr><td>Layer</td><td>Cloud layer</td><td>Acquisition method</td><td>Trust required</td></tr><br>    <tr><td>6</td><td>Guest application/data</td><td>Depends on data</td><td>Guest operating system (OS), hypervisor, host OS, hardware, network</td></tr>  <tr><td>5</td><td>Guest OS</td><td>Remote forensic software</td><td>Guest OS, hypervisor, host OS, hardware, network</td></tr><tr><td>4</td><td>Virtualization</td><td>Introspection</td><td>Hypervisor, host OS, hardware, network</td></tr><tr><td>3</td><td>Access virtual disk</td><td>Access virtual disk</td><td>Host OS, hardware, network</td></tr><tr><td>2</td><td>Physical hardware</td><td>Access physical disk</td><td>Hardware, network</td></tr><tr><td>1</td><td>Network</td><td>Packet capture </td><td>Network</td></tr></table><br>  在IaaS中，尽管没有物理访问，消费者仍保留对第5层（访客操作系统）和6（访客应用程序）的管理控制权。此外，各层次的取证行为将不同。每一层需要不同的信任，即该层是安全和信任的;堆栈越远，累积的信任就越少。在公共云中，所有层都需要提供商的一些信任，特别是对恶意内部人员的信任。防伪策略，病毒检测器应在多层次上检查证据。调查人员可以选择云层的哪一层进行取证处理。关于这一决定的考虑首先围绕在该级别进行取证的技术能力，再次对所返回数据的信任。该层还影响可用于收集的哪些类型的取证数据，例如第1层（网络）上的数据包捕获，第2层物理文件（物理硬件）或第3层（主机操作系统）上的虚拟文件。对于每种数据类型，数据必须遵守严格的监管链，并且必须包括完整性检查机制。云计算引入了一个强大的新选项：虚拟机快照。利用虚拟化的许多云实现可以拍摄正在运行的计算机的快照，然后像现在一样将该快照恢复并运行。这提供了创造历史记录的能力，以及事后做“活”取证。</p>
<p>  接下来就是实验。能够远程获取aharddrive和内存映像。分析EnCase Forensic和FTK Investigator中的这些映像分别正确显示了活动的时间表，包括安装Apache和网页创建和删除。分析显示虚拟环境的异常现象，也没有任何明显的异议，引起对数据完整性的怀疑。采集过程的速度受到我们学习如何使用远程代理和网络带宽传输数据的限制。每个EnCase和FTK大约12小时，使用我们大学的OC-12连接传输30 GB磁盘映像和2 GB内存映像。实验2成功地形成了驱动器的完整图像和正确的时间线。 VM内省是取证学的强大工具，允许人的实时调查，而不会显露调查人员的存在。然而，内省是云服务提供商必须实施的一个特殊功能。这是我们能够验证图像完整性的唯一实验，因为我们可以访问物理磁盘，并且可以比较EnCase映像和原始磁盘的散列值。实验3中的AWS导出过程也成功地返回了驱动器的完整映像。我们能够将驱动器加载到EnCase和FTK中，没有任何困难，并验证了驱动器的内容。这种方法的另外一个好处是，AWS会为导出的每个文件生成一个具有元数据的日志报告。此报告包含以下每个文件：传输的日期和时间，存储设备上的位置，MD5校验和和字节数。使用快速运输，花了五天时间收到我们的数据，费用为125美元。我们设想这个过程将会严格地模仿AWS在遵守搜索令或传票时所采取的步骤。 EnCase和FTK最容易使用。尽管使用远程功能需要安装和学习时间，但工具的功能是熟悉且易于执行的。检索磁盘映像所需的12小时时间远远少于此数据卷的AWS导出过程所需的120小时。下载数据平均每小时2.5 GB。 AWSExport花了4小时加载了我们的数据，而剩下的116小时在运输过程中花费了时间。按照这些速率，最有效的选择是导出过程，当超过240 GB的数据将被检索。</p>
<p>  A forensically robust method for acquisition of iCloud data主要讲一种方法，不仅使得下载数据到验证的计算机上然后验证数据的完整性，还可以定位到数据的来源。首先是采集云服务中存储的数据变得越来越重要数字取证调查。 苹果公司不断扩大其云端的功能服务，iCloud。 因此，确定取证获取的有效手段是至关重要的，来自该服务的数据的定义及其对原始文件数据和元数据的影响。本研究通过本机Mac OS X检查从iCloud服务获取的文件系统与服务同步。 目标是确定操作系统iCloud同步文件的位置。 一旦找到，次要目标是确定是否文件哈希值与原始文件匹配，特别是文件元数据时间戳，被改变。</p>
<p>  研究人员使用不同的技术去获取数据。有两种技术是先是通过虚拟机创建镜像，然后用FTK工具去分析这些镜像。还有一种是根据AWS去导出数据。导出的还包括包括“日期和时间传输，存储设备上的位置，MD5校验和，和字节数“。如果哈希值相同则代表数据并未改变。接下来是实验，有两台虚拟机，第一台在整个过程进行快照拍摄，并且数据与云服务同步，第二台新创建的iCloud帐户。然后进行分析以定位iCloud 。下载的文件是与原始文件进行比较以确定文件是否相符<br>  和元数据是一样的，如果不是，初始化配置。</p>
<p>  Side channels in cloud services, the case of deduplication in cloud storage云存储服务通常使用重复数据删除，通过仅存储每个文件或块的单个副本来消除冗余数据。重复数据删除减少了数据存储服务的空间和带宽需求，并且在跨多个用户应用时是最有效的，这是云存储产品的常见做法。我们研究跨用户重复数据删除的隐私含义。我们演示如何使用重复数据删除作为侧面通道，显示有关其他用户的文件内容的信息。在不同的情况下，重复数据删除可以用作隐藏通道，恶意软件可以通过该渠道与其控制中心进行通信，而不管受攻击机器上的任何防火墙设置如何。由于跨用户重复数据删除所带来的高额节省，云存储提供商不可能停止使用此技术。因此，我们提出了简单的机制，可以跨用户重复数据删除，同时大大降低数据泄露的风险。<br>  有两种主要的重复数据删除策略：（1）文件级重复数据删除，其中只存储每个文件的单个副本。如果两个或多个文件具有相同的哈希值，则它们将被标识为相同。这是一种非常受欢迎的多种产品提供的服务; （2）块级重复数据删除，将文件分割成块并仅存储每个块的单个副本。系统可以使用固定大小的块或可变大小的块。</p>
<p>  我们描述的攻击可以应用于在文件级别或块级执行的重复数据删除（具体来说，我们假设从现在开始，在文件级别执行重复数据删除）。但是，重复数据删除服务有两个对攻击至关重要的功能：•基于源的重复数据删除。也就是说，重复数据消除必须在客户端进行。如上所述，此版本的重复数据删除功能节省了带宽，因此常用。应用此方法的结果是，客户端可以观察某个文件或块是否被重复数据删除（或简称为“重复数据删除”）。这可以通过检查通过网络传输的数据量，或通过观察存储软件的日志（如果该软件提供此类报告）来完成。 •对攻击至关重要的第二个功能是跨用户重复数据删除。也就是说，将每个文件或块与其他用户的数据进行比较，如果在服务器上已经可以使用相同的副本，则将其重新排除。这种方法是受欢迎的，因为它不仅在单个用户具有相同数据的多个副本时，而且当不同的用户存储数据的副本时，可以节省存储和带宽。 （企业客户端通常存储相同或相似数据的多个副本，我们发现即使对于私人客户也是如此：几乎每个常用的软件手册或我们试图使用流行备份服务进行备份的媒体文件都已经可以使用请注意，这些是巨大的文件，因此重复数据删除为服务提供商节省了巨大的成本。）识别易受攻击的存储提供商：我们进行了以下测试，以确定执行基于源和跨平台的服务，用户重复数据删除（测试可以由任何读者重复，他选择的存储服务）：（1）我们在两台不同的计算机上安装了该服务的客户端软件，并创建了两个不同的用户帐户; （2）我们使用一个帐号上传文件（在我们的测试中，这个文件是Sun的VirtualBox软件，大小接近73M）; （3）我们使用第二个帐号再次上传同一个文件，检查是否确实上传了。当文件没有通过网络重新发送时，我们得出结论，备份服务执行基于源的跨用户重复数据删除。 （事实上​​，当检查流行的存储服务时，不需要使用两个帐号，因为如上所述，在网络上发现的任何流行的文件很可能存在于服务器上，因为它以前是由其他用户上传的，因此测试可以包括从Web下载流行的文件，将其上传到服务并检查重复数据删除是否发生。）我们确定了三个领先的备份和文件同步提供程序的服务，它们执行跨用户，基于源的重复数据删除。这些服务是（1）DropBox，一种流行的文件共享和备份服务，超过了300万用户里程碑; 2 2）Mozy是面向消费者和企业的在线备份的领先提供商，为超过一百万客户和50,000名业务用户提供备份，并存储超过25 PB; 3和（3）备份审查作为欧洲最佳在线备份服务的Memopal，每天有近1000个新用户4值得注意的是，大多数供应商并不试图隐藏重复数据删除的事实，在我们的测试中容易地以几种简单的方式检测：（1）检查历史记录或日志文件（此方法与MozyHome 5配合使用）; （2）根据上传状态消息，上传和重复数据删除的文件有所不同（此方法与Memopal 6配合使用）; （3）根据上传速度，检查文件上传是否在比客户机上传带宽所需的时间短得多的时间内完成（DropBox 7就是这样）; （4）最终，最常用的重复数据删除检测方法适用于所有服务，无论其接口如何，都是监控网络流量并测量传输数据量。我们注意到，大多数服务具有额外的客户端 - 服务器通信流量，但与上传大型文件时传输的大量数据相比，可以忽略不计。<br>  第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。此第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。假设有一个攻击者，爱丽丝，谁想要了解有关Bob，云存储服务的用户的信息。那么显然，如果爱丽丝怀疑鲍勃有一些不太可能拥有任何其他用户的特定敏感文件X，她可以使用重复数据删除来检查这个猜想是否正确。 Alice应该做的是尝试备份X的副本，并检查是否发生重复数据删除。作为一个具体的例子，假设有一个文件证明一些非法活动（例如记录暴力事件，或者是具有一些被盗的敏感信息的文件，或与儿童色情相关的材料）。执法机关一旦掌握该文件的副本，就可以将文件上传到不同的云存储提供商，并识别存储文件副本的存储服务。然后，他们可以要求法院命令，要求服务提供商披露上传文件的用户的身份。 （如果文件被认为对于识别拥有该用户的用户来说太敏感，则如上所述，当局上传该文件的过程可以在确定是否在开始之后立即终止重复数据删除应用于此文件。）2.2攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。但是，攻击者可能会将此攻击应用于同一文件的多个版本，对本文件内容的所有可能的值基本上执行强力攻击。例如，假设Alice和Bob在同一家公司工作，该公司使用云备份服务来备份所有员工的机器。每年一次，所有员工将收到一份新的标准合同副本，其中包含其更新的薪水。爱丽丝好奇地找到了鲍勃的新工资，这可能是$ 500- $ 200,000之间的$ 500的倍数。所有Alice必须做的是生成一个Bob的合同模板，Bob的名字和新合同的日期，然后为Bob的每个可能的工资（总共301个文件）生成合同的副本。然后，她运行备份到她和Bob使用的公司备份服务。发生重复数据删除的单个文件是包含Bob实际工资的单个文件。只要目标文件的可能版本数量适中，就可以应用此攻击。这对于企业环境来说似乎非常有用，通常文件是标准模板的小变体。请考虑以下三个示例：•网上银行服务向客户发送一个包含其登录名和PIN的文档，这是一个4位数字。因此，爱丽丝可以使用登录名“Bob”和PIN的所有可能值生成10,000个文档，并检查其中哪些文件已被存储。本文档对应于Bob的实际PIN码。相同的攻击可以应用于任意密码，如果它们来自中等大小的域。请注意，与在线字典攻击不同，受到攻击的银行服务不会注意到某人正在尝试某个用户的所有潜在密码。 •假设一个详细描述Bob的医学检查结果的文件存储在他的计算机上。爱丽丝可以使用这种攻击来查找测试的结果，这通常来自一个小域（例如，对于遗传性疾病的发生或怀孕测试的结果是一个是/否的答案，或来自一个范围，例如胆固醇测试的一百个可能的值）。转诊医生的姓名和转诊日期可能是爱丽丝所知，或者可能来自一个小领域。即使是测试的序列号，如果存在这样一个数字，可能会被Alice猜出，如果她有一个类似日期的测试结果的例子。 •假设爱丽丝和鲍勃都参与拍卖，要求投标人以包含其名称和出价的标准表格提交投标（这实际上是许多拍卖和采购流程中的常见做法）。如果爱丽丝可以推测出鲍勃的10,000个最有可能的出价值，她可以使用相同的攻击来查找鲍勃的实际出价，然后相应地设置出价。<br>  攻击III：隐蔽通道假设爱丽丝设法在Bob的机器上安装了一些恶意软件。然而，Bob运行防火墙，防止未经授权的程序连接到外部世界。即使这样的防火墙没有运行，Alice 3可能希望隐藏恶意软件与其命令和控制服务器之间的通信）。如果Bob正在使用使用跨用户重复数据删除的在线存储服务，则Alice可以使用重复数据删除攻击来建立从恶意软件到由其运行的远程控制中心的隐蔽通道。 （隐藏通道的存在可能是二次攻击，也可能有其他方法建立隐蔽通道，但是通过利用跨用户的重复数据删除来检查隐藏通道是如何建立起来的。我们先来描述一个位如何传输：软件生成文件的两个版本之一X 0或X 1，并将其保存在Bob的机器上。如果要传送消息“0”，则保存文件X 0;否则保存文件X 1。这些文件必须是足够随机的，因此任何其他用户不可能生成相同的文件。在某些时间点（例如每天），Bob运行备份并将文件存储在在线存储服务中。 Alice然后执行与Bob相同的服务的备份，并且学习以前存储哪些文件X 0或X 1，也就是说，她将学习软件发送的消息。隐藏通道可用于通过使软件保存多于一个文件，并为每个文件的内容使用两个以上的选项来传输任意长的消息。此方法的详细性能分析超出了本文的范围。我们在这里描述了恶意软件如何向其命令和控制中心发送消息。如果恶意软件有可能检查备份的日志文件，并在进行重复数据删除时进行观察，则可以使用相同的技术来发送相反方向的消息。</p>
<p>  重复数据删除的安全风险源于以下事实：文件的重复数据删除会发生，如果并且只有此文件已经上传到存储服务。通过削弱重复数据删除与存储服务中文件的存在之间的相关性，可以降低风险。这是通过为每个文件分配一个随机阈值，并且只有当文件的副本超过此阈值时才执行重复数据删除。在更详细地检查此解决方案之前，要检查类似的方法，这是不安全的：这里，服务器设置全局阈值t（例如，t = 10），并且只有至少在文件中执行重复数据删除t文件的副本已上传。在这种情况下，确实，Alice上传文件的单个副本并不能显示Bob先前是否已经上传过该文件。然而，Alice可以上传许多文件副本（甚至使用多个用户身份），并检查是否在t或t-1之后重复数据删除，文件副本由她上传。后一种情况表示该文件的副本以前由其他用户上传。 （我们可以放心地假设爱丽丝知道阈值t，因为她可以进行简单的实验来揭示t的价值。）解决方案：现在让我们更详细地描述随机解。对于每个文件X，存储服务器分配在[2，d]范围内随机均匀选择的阈值t X，其中d是可能是公共的参数。 （例如，假设d = 20）重要的是，除了服务器之外，没有人可以计算t X，即使X的内容是已知的。实现此属性的一种方式是服务器随机选择t X并私有存储该值。另一种方法是使用秘密密钥的服务器，并且根据文件的内容或其散列值和密钥的计算阈值。即，计算t X = F（X，s）。在这种情况下，不需要显式存储X的阈值，因为服务器可以轻松地重新计算它。现在，对于每个文件X，服务器保留先前已经上传X副本的客户端数量的计数器X.当上传文件的新副本时，如果存在以下两个条件之一，则在客户端进行重复数据删除保持：（1）c X≥t X，或（2）由以前上传过X的客户端上传副本。否则不会发生重复数据删除。请注意，重复数据删除的最小份数为2，因为在上传文件的第一个副本时，不可能执行5次重复数据删除。该解决方案在X上传的第一个t X - 1次中隐藏了用户重复数据删除的发生，因为该文件被上传，就像在服务器上没有可用的副本一样。然而，一旦将数据传输到服务器端，就可以执行重复数据删除。因此，此解决方案提供的整体磁盘空间节省与基本重复数据删除方案完全相同。唯一的赔偿是带宽利用率较小，因为与tp重复数据删除解决方案相比，（t X -1）·X个文件的多个副本被上传。图1说明了提出的解决方案及其数据流。处理删除：文件删除也必须加以修饰。当删除发生时，减少文件副本的计数器c X似乎是很自然的。但是，此设置可以进行以下攻击：Alice上传文件X的副本，并注意到t副本上传后会发生重复数据删除。然后，她再次从在线存储中删除X的两个副本，并再次上传这两个副本。如果在其中一个测试中，她注意到在上传两个副本中只有一个之后发生重复数据删除，则必须是其他用户刚刚上传了X的副本。同样，如果重复数据删除在上传三个之后发生，而不是两个，X的副本，那么另一个用户必须删除这个文件的副本。这种攻击并不实用，因为在删除后，在线存储服务通常会保留已删除文件的副本一段时间。例如，包括Mozy，DropBox和Memopal在内的大多数服务的策略是删除文件至少要保留30天。因此，攻击的每次迭代都需要至少30天才能执行。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第七周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第七周周报/" itemprop="url">云取证第七周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T19:54:30+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。</p>
<p>云计算安全研究主要讲云计算的趋势、云安全挑战、云安全现状、云计算安全框架的建议、云安全的技术研究。这里面我觉得这几点是比较重要的，例如云安全的挑战和云计算安全关键技术研究。<br>首先在于云安全的挑战，在于以下三点：1.建立以数据安全和隐私保护为主要目标的云安全技术框架，具体体现在：云计算服务计算模式所引发的安全问题、云计算的动态虚拟化管理方式引发的安全问题、 云计算中多层服务模式引发的安全问题；2.建立以安全目标验证、安全服务等级测评为核心的云计算安全标准及其测评体系；3.建立可控的云计算安全监管体系，具体体现在：实现基于云计算的安全攻击的快速识别、预警与防护；实现云计算内容监控的难度；识别并防止基于云计算的密码类犯罪活动。<br>接着是云计算安全关键技术研究，主要有以下几点：1.可信访问控制；2.密文检索与处理；3.数据存在与可使用性证明；4.数据隐私保护；5.虚拟安全技术；6.云资源访问控制；7.可信云计算；</p>
<p>云计算:系统实例与研究现状主要讲了针对云计算这样一个范畴综述了当前云计算所采用的技术,剖析其背后的技术含义以及当前云计算参与企业所采用的云计算实现方案。现有的云计算实现使用的技术体现了以下 3 个方面的特征:1) 硬件基础设施架构在大规模的廉价服务器集群之上.2) 应用程序与底层服务协作开发,最大限度地利用资源.3) 通过多个廉价服务器之间的冗余,使用软件获得高可用性.这里面讲了一下几个项目：清华大学透明计算平台、Google的云计算平台、IBM“蓝云”计算平台、Amazon的弹性计算云。.从平台技术构建来看,云计算具有3 个基本特征,即系统建立在大规模的廉价服务器集群之上,通过基础设施与上层应用程序的协同构建以达到最大效率利用硬件资源的目的,以及通过软件的方法容忍多个节点的错误.通过云计算对这 3 个方面基本特征的体现,达到了分布式系统两个方面的目标,即系统的可扩展性和可靠性。</p>
<p>Dependability in the Cloud: Challenges and Opportunitie主要讲了几个比较流行的问题，监控大量应用程序的能力可以使“人群智慧”方法提供更强大的安全性，其方式与网络提供商能够进行蠕虫和DDoS攻击相同，其中一些例子如下：几个大型云基础架构提供商的环境不仅增加了影响大量应用程序的103次共模中断的风险，而且为攻击者提供了高度可见的目标。社区驱动的网站，如主要云提供商的跟踪中断，并记录了过去两年影响数百个互联网站点的一些中断和安全漏洞。从事广泛的行为，并采用不同程度的最佳做法可以暴露云应用提高风险水平。例如，2008年4月26日，亚马逊的弹性云（EC2）在几个实例中出现了中断，原因是单个客户应用了一大批异常的防火墙规则，同时实例化了大量实例引发亚马逊分布式防火墙中的性能下降错误。</p>
<p>The Challenge of Cloud Control主要讨论了资源优化云数据中心的一些主要挑战。我们提出了一个称为云控制的新研究领域，这是一系列云管理问题的控制理论方法，旨在将当今的静态和能耗云数据中心转变为自我管理，动态和可靠的基础设施。<br>第一个挑战是性能模型，这对设计和开发至关重要稳健的控制系统。值得注意的是，云数据中心的规模大大增加，工作量动态变化比以前的电信和互联网系统多。服务器系统上的以前的结果表明，可以使用黑匣子方法和相当简单的队列模型或使用流模型。第二个挑战是服务准入控制，这在本质上是长期容量规划，控制系统根据预期的利润决定是否接受服务。此外，弹性控制器应该为正在运行的应用程序分配足够的资源，以提供可接受的QoS，同时避免昂贵的过度配置。这些解决方案分为三大类：基于机器学习算法的解决方案，基于控制理论的解决方案和基于统计工作负载分析的解决方案。此外，还有一些VM安置问题需要解决，以确定哪些部署新的VM以及要关闭的VM 。鉴于云的动态性质，随着需求和供应的变化随着时间的推移发生重大变化，VM布局决策需要频繁更新。最近关于重新布置的工作包括通过限制可以同时迁移的VM数量来实现VM迁移和性能转向的性能建模。其他动态方法包括使用随机整数规划来处理不确定性和遗传算法，以减少负载波动时的重新迁移。另一个挑战是提供云服务的大型数据中心不仅具有购买设备的成本，而且能源成本大幅提高，这意味着能源优化将至关重要。</p>
<p>首先，服务准入控制器决定是否接受弹性服务，随着时间的推移可能会有很大的变化。云提供商必须确定要承认的最佳服务数量，以最大限度地发挥其效用（收入，利用率等），而不会危及已提供服务的服务水平协议（SLA）。服务增加了云基础设施的随机负载。因此，需要接纳管制计划，以评估新服务的长期影响，具体取决于他们估计的工作量。第二，弹性控制系统的目标是分配足够的所谓的计算单位（CU），以便符合某些控制目标，以系统的性能期望为目标。我们提出定义CU术语，以便满足能力需求的要求，这与维护虚拟机的定义无关。后续的CU将被映射到合适的VM。如果假定系统状态和工作负荷可以用一定的精度来估计，则控制器设计基本上成为随机的最优控制问题。第三，VM布局控制器都执行从CU到适当的VM集的映射，以在本地或远程数据中心运行，并确定物理机器上的虚拟机的打包。在将VM分配到数据中心内的PM之前，我们考虑从CU到VM和从VM到数据中心的映射。可以制定的这些容量分配（分配）问题，例如作为限制线性问题，用于优化成本受制于容量和可能的其他约束，从而实现特定的负载平衡亲和力和抗亲和力的客观或要求（例如，在同一数据中心（或主机）中，而不是在相同的数据中心）。第四，数据中心能源优化器模型，优化机房定位决策的机房能量温度相互作用。能量优化将需要一个网络身体的看法。最后，整体管理系统监控整个系统的行为，并优化管理工具在整体数据中心管理目标方面的协同运作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/云取证第六周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/云取证第六周周报/" itemprop="url">云取证第六周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T12:44:53+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。</p>
<p>首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件系统的源文件来收集系统级别的来源。虽然这种方法是有效的，但是它具有两个显着的缺点：内核的每个新版本都需要重新整合PASS变化，其稳定性必须不断测试; 同样，使用可堆叠的文件系统使得很难在根卷上收集来源，特别是在早期引导过程中。所通过以Xen虚拟机管理程序运行的虚拟客户机收集系统级别来源的方法可以有效解决这两个缺点。</p>
<p>PASS拦截execve，fork，exit，read，readv，write，writev，mmap，open，pipe以及内核操作drop inode。这些调用足以捕获Linux文件，管道和进程之间丰富的祖先关系。这种原始的“原始来源”转向观察者，将原始来源转化为证明记录。例如，当进程P读取文件A时，观察器生成包含P取决于A的事实的记录。接着是修改Xen虚拟机管理程序的方法（Xen 是一个开放源代码虚拟机监视器）。</p>
<p>首先是前提假设。假设目标虚拟机（我们将收集来源的目标虚拟机）正在运行一个PV密钥，但是也可以针对未修改的内核（如Windows）。 Linux，Minix，GNU Hurd，OpenSolaris，NetBSD和FreeBSD都支持PV内核。本文的其余部分假定我们正在运行Linux访客内核;假设Dom0和DomU密钥以及Xen管理程序本身是不妥协的，以便我们可以信任和验证任何生成的证明。我们的方法通过在Xen的系统调用进入机制中放置适当的钩子来拦截DomU系统调用。 该挂钩为拦截器提供系统调用号及其数值参数。 拦截器又通过查找表中的系统调用来确定哪些参数是数字，哪些是用户空间中的数据结构和字符串的指针。然后继续创建一个系统调用记录。用户空间守护程序在特权域中运行，定期地：1.消耗来自环形缓冲区的记录，2.使用来源分析器处理它们，3.输出源日志，4.并将日志提供给Waldo。我们可以在多处理器/多核系统中的专用CPU /内核上运行此过程，以提高访客性能。用户空间守护程序以及其他支持软件通过专用的超级呼叫与Xen的来源子系统进行通信，只能在特权域中访问。拦截器与源极分析仪的耦合使我们能够将CPU密集型分析转移到另一个CPU或核心上，从而使客户的单线程性能受到最小的影响。更重要的是，我们将不会担心可堆叠文件系统引用的API的更改;这些变化往往会经常发生，相当可观。我们的方法的一个障碍是拦截器需要一个大的环形缓冲区来保存分析器尚未消耗的所有系统调用的记录。<strong>典型的Linux客户机每秒产生数十个读/写系统调用，涉及标准输入和输出流。我们无法轻易地将其过滤掉在拦截器上，因为这些流可能已被重新排列到文件或管道。除了消耗大量内存之外，缓冲区操作通常会增加处理器高速缓存的压力。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/云取证第五周周报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/云取证第五周周报/" itemprop="url">云取证第五周周报</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T20:50:47+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。</p>
<p>首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询SELECT taskname,datacenter FROM systemlog.today WHERE severity=’warning’，扫描的数据量有100GB级别的数据量，但是查询时间仅仅需要10秒左右。BigQuery旨在分析数十亿行近似的数据，使用类SQL语法。它并不是完全符合SQL数据库的替代，并不适用于交易处理应用。BigQuery支持分析交互风格。使用SELECT命令构建查询，对于任何SQL开发者都应该很熟悉。<strong>因为我以前在做数据交换平台的时候，对于非基于lucene的全文检索的传统数据库，例如mysql查询时候，对于上百万或者上千万条甚至在上亿条数据量的查询，即使是针对索引列的查询也会很慢，更不用说数据量达到pb级别的数据量</strong>。查了下资料，总体而言，BigQuery 在大规模数据（数十亿行）上查询有很好得速度、适合快速分析大规模数据，不支持数据修改；BigQuery是OLAP系统，通过CSV格式将数据导入BigQuery，数据以弱关系型存储与云上。BigQuery 不是一个数据库系统， 1. 不支持表索引和其他关系数据库特性 2. BigQuery支持SQL得一个子集，不支持update,delete操作 3.BigQuery得join只在一张表远比另一张表小时有效（也就是不支持两张大表得join）。BigQuery 支持REST接口。</p>
<p>其次是对于Regeneration of events using system snapshots for cloud forensic analysis。 这篇论文主要讲述了在这个一种新的云攻击分析方法通过事件再生。 VNsnaps用于定期进行虚拟网络环境（VNE）的快照通过使用模糊聚类检测的云攻击技术。 然后恢复这些快照以重新生成攻击事件。首先是对于公司来说，云安全依然是在云计算里面最关心的问题。 AAA协议大致将这些尝试分为三个阶段：认证，授权和会计。云取证专注于会计，并用于分析和调查云攻击的本质，试图恢复从他们的伤害。几个输入，如日志文件和孤立的系统快照用于提取信息关于袭击。然而，这些方法只能导致一个模糊的事件视图。另外，由于网络定时协议不适用于云计算，我们是不可避免的客户和CSP的时间戳差异这使得更难于将各种实例相关联两端因此，传统技术无法明确图片的整个操作顺序的数据和涉及的过程我们的工作，通过一系列定期的快照，旨在提供具体和顺序证明所有事件对安全构成威胁数据的隐私和委托云的计算。</p>
<p>通过使用一种检测攻击的技术来解决问题正确标注其开始和结束。我们实现这个使用模糊聚类算法的“距离”概念。 VNsnap：我们使用VNsnap，一个中建立的系统来采取系统来自虚拟机外部的整个VNE的快照（VM），从而提供所有信息关于有关组件。为全球一致快照，VNsnap使用Mattern的分布式快照算法基于消息着色。另外，VM快照操作与VM的正常操作同时进行操作因此隐藏来自用户的快照延迟应用程序和减少系统停机时间（少于一个）即使在最坏的情况下）。另一个优点VNsnap是不需要任何修改在虚拟机内运行的软件，从而与之配合使用未修改的应用程序和操作系统内置快照支持。B.正确记录攻击：在我们的工作中，我们假设有足够的文档可用关于以前采取的云攻击放在各种类似的环境中。一般来说，这些记录的攻击是使用硬聚类分类的。</p>
<p>技术如分区聚类、层次聚类，这意味着每次新的攻击都被放在现有的攻击中<br>“分区”或“细分”取决于一些固定的或预定特性。，学习后云攻击的复杂性，我们发现需要考虑新攻击与全部攻击之间的相似程度现有的集合而不是完整的任务之一固定集或攻击群集。因此，我们愿意依靠将决定程度的算法每个现有集合的新实体的归属而不是将它分配给只有一个的那些预定套。由于模糊聚类是一个软聚类将一组成员级别与之联系起来的技术每个新实体，通过这样做，我们实际上考虑到整体影响所有类似的攻击，从而确保更好的准确性结果。</p>
<p>快照可以给出：<br>A. 将攻击定义为群集 关于以前的攻击的可用文档应该是 首先被组织成小型的原始操作 每个组合都可以作为个人攻击。我们对待每一个这些攻击是单点（或单对象）集群。每个点或攻击随后以n维向量来表示，每个维度代表可量化的特征，如内存使用，处理能力要求，带宽使用，复杂度等。 因此，每个攻击Xp可以被假设为具有n维度的空间向（xp1，xp2，…，xpn）。<br>B.为尺寸分配权重： 同样重要的是我们考虑到这一点 在空间中定义的每个维度的相关性。因此， 我们将一个权重wi分配给第i个维度来量化它 确定相似性（或不相似性）的重要性 两个代码之间。这个权重应该通过实验确定。例如，如果我们找到相似性的顺序 复杂度是内存相似度的两倍,那么分配到复杂度的权重将是两倍分配给内存使用的权重。<br>C.当前代码模块距离：在每个VM中，首先确定执行中的代码模块。 这些模块中的每一个基于其自身的特性再次被分配在相同的n维空间中。 但是，请注意，在这种情况下，这些代码模块是时间的函数，它们的坐标也是这样。 例如，第q个VM中的代码模块Y q（t）将具有坐标：（y q1（t），y q2（t），…，y qn（t））。 然后我们从每个集群（攻击）中计算代码模块的距离。 攻击X p和代码模块Y q（t）之间的距离为：D pq i（t）=√（Σ（wi（x pi - y qi（t）））2）… i 1到n。注意，该距离表示第t个攻击与第t个虚拟机的代码模块在时间t的不相似性。 通过为维度分配权重，我们确保了关于测量的相似程度或不相似性的推论是正确的。<br>D.阈值：我们需要确定攻击和代码模块之间的距离的阈值，在该模块之下系统可能受到损害。为此，我们从实验中找出应该保持的最小距离<br>为了使系统安全起见。这个实验涉及：<br>1.常见攻击的模拟（文档中提供）<br>2.观察其所有特征（以其坐标的形式）的量化值，如内存使用量，带宽使用量，处理能力要求等<br>3.对VM上的无数代码模块进行仿真，并将其坐标与步骤2中获得的坐标进行比较<br>4.查找代码模块和每个维度中的攻击之间的最小差异。说，无害代码模块与维度“i”的攻击之间的最小差异是mi，那么我们为所有n个维度获得以下值：m1，m2，… mn。<br>5.计算阈值：<br>阈值=√Σ（wi*mi）2 … i从1到n不等。<br>以下是通过上述步骤获得的阈值的预期特性：<br>1.阈值足够高，以确保与攻击的意外相似性一般不予以考虑。<br>2.该值足够低以确保跟踪恶意代码模块的最大概率。<br>当前代码模块与已记录攻击的比较提出的技术的有效性在很大程度上取决于阈值的正确确定。 在获得一致的阈值时，我们的方法可以证明是足够可靠的，以便最终决定代码模块的有害性。<br>接着是再生事件的产生，我们使用连续运行的计算器来测量所有VM中的代码模块与攻击集合之间的时间依赖距离（如方程式）当使用VNsnap的任何时间点的距离开始使用VNsnap在时间循环中以编程方式定期执行快照一些攻击的代码模块降低到阈值以下，当所有距离都超过阈值时停止进程，因此记录了整个攻击。<br>可以通过将系统恢复到每个快照（以编程方式再次）按照与其创建顺序相同的顺序来重新生成攻击。但是，在该再生过程之前应该采取系统的孤立快照，以便一旦重播攻击就可以将系统恢复到原来的位置.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
