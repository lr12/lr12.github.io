<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/hbase-java-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/hbase-java-api/" itemprop="url">hbase java api</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-02T16:29:51+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.hadoop.conf.Configuration;</div><div class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</div><div class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</div><div class="line">import org.apache.hadoop.hbase.HTableDescriptor;</div><div class="line">import org.apache.hadoop.hbase.KeyValue;</div><div class="line">import org.apache.hadoop.hbase.client.Delete;</div><div class="line">import org.apache.hadoop.hbase.client.Get;</div><div class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</div><div class="line">import org.apache.hadoop.hbase.client.HTable;</div><div class="line">import org.apache.hadoop.hbase.client.HTablePool;</div><div class="line">import org.apache.hadoop.hbase.client.Put;</div><div class="line">import org.apache.hadoop.hbase.client.Result;</div><div class="line">import org.apache.hadoop.hbase.client.ResultScanner;</div><div class="line">import org.apache.hadoop.hbase.client.Scan;</div><div class="line">import org.apache.hadoop.hbase.util.Bytes;</div><div class="line"></div><div class="line">public class Hbase &#123;</div><div class="line">    // 声明静态配置</div><div class="line">    static Configuration conf = null;</div><div class="line">    static &#123;</div><div class="line">        conf = HBaseConfiguration.create();</div><div class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"localhost"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 创建表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @family 列族列表</div><div class="line">     */</div><div class="line">    public static void creatTable(String tableName, String[] family)</div><div class="line">            throws Exception &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        HTableDescriptor desc = new HTableDescriptor(tableName);</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; family.length; i++) &#123;</div><div class="line">            desc.addFamily(new HColumnDescriptor(family[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</div><div class="line">            System.out.println(<span class="string">"table Exists!"</span>);</div><div class="line">            System.exit(0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            admin.createTable(desc);</div><div class="line">            System.out.println(<span class="string">"create table Success!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 为表添加数据（适合知道有多少列族的固定表）</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @column1 第一个列族列表</div><div class="line">     *</div><div class="line">     * @value1 第一个列的值的列表</div><div class="line">     *</div><div class="line">     * @column2 第二个列族列表</div><div class="line">     *</div><div class="line">     * @value2 第二个列的值的列表</div><div class="line">     */</div><div class="line">    public static void addData(String rowKey, String tableName,</div><div class="line">            String[] column1, String[] value1, String[] column2, String[] value2)</div><div class="line">            throws IOException &#123;</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));// 设置rowkey</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// HTabel负责跟记录相关的操作如增删改查等//</div><div class="line">                                                                    // 获取表</div><div class="line">        HColumnDescriptor[] columnFamilies = table.getTableDescriptor() // 获取所有的列族</div><div class="line">                .getColumnFamilies();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; columnFamilies.length; i++) &#123;</div><div class="line">            String familyName = columnFamilies[i].getNameAsString(); // 获取列族名</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"article"</span>)) &#123; // article列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column1.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column1[j]), Bytes.toBytes(value1[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"author"</span>)) &#123; // author列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column2.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column2[j]), Bytes.toBytes(value2[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"add data Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 根据rwokey查询</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static Result getResult(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// 获取表</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName, String start_rowkey,</div><div class="line">            String stop_rowkey) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        scan.setStartRow(Bytes.toBytes(start_rowkey));</div><div class="line">        scan.setStopRow(Bytes.toBytes(stop_rowkey));</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void getResultByColumn(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName)); // 获取指定列族和列修饰符对应的列</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 更新表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     *</div><div class="line">     * @value 更新后的值</div><div class="line">     */</div><div class="line">    public static void updateTable(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName, String value)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));</div><div class="line">        put.add(Bytes.toBytes(familyName), Bytes.toBytes(columnName),</div><div class="line">                Bytes.toBytes(value));</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"update table Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询某列数据的多个版本</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void getResultByVersion(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</div><div class="line">        get.setMaxVersions(5);</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">         * List&lt;?&gt; results = table.get(get).list(); Iterator&lt;?&gt; it =</div><div class="line">         * results.iterator(); <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">         * System.out.println(it.next().toString()); &#125;</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void deleteColumn(String tableName, String rowKey,</div><div class="line">            String falilyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteColumn = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        deleteColumn.deleteColumns(Bytes.toBytes(falilyName),</div><div class="line">                Bytes.toBytes(columnName));</div><div class="line">        table.delete(deleteColumn);</div><div class="line">        System.out.println(falilyName + <span class="string">":"</span> + columnName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void deleteAllColumn(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteAll = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        table.delete(deleteAll);</div><div class="line">        System.out.println(<span class="string">"all columns are deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void deleteTable(String tableName) throws IOException &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        admin.disableTable(tableName);</div><div class="line">        admin.deleteTable(tableName);</div><div class="line">        System.out.println(tableName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">        // 创建表</div><div class="line">        String tableName = <span class="string">"blog2"</span>;</div><div class="line">        String[] family = &#123; <span class="string">"article"</span>, <span class="string">"author"</span> &#125;;</div><div class="line">        // creatTable(tableName, family);</div><div class="line"></div><div class="line">        // 为表添加数据</div><div class="line"></div><div class="line">        String[] column1 = &#123; <span class="string">"title"</span>, <span class="string">"content"</span>, <span class="string">"tag"</span> &#125;;</div><div class="line">        String[] value1 = &#123;</div><div class="line">                <span class="string">"Head First HBase"</span>,</div><div class="line">                <span class="string">"HBase is the Hadoop database. Use it when you need random, realtime read/write access to your Big Data."</span>,</div><div class="line">                <span class="string">"Hadoop,HBase,NoSQL"</span> &#125;;</div><div class="line">        String[] column2 = &#123; <span class="string">"name"</span>, <span class="string">"nickname"</span> &#125;;</div><div class="line">        String[] value2 = &#123; <span class="string">"nicholas"</span>, <span class="string">"lee"</span> &#125;;</div><div class="line">        addData(<span class="string">"rowkey1"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey2"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey3"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line"></div><div class="line">        // 遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line">        // 根据row key范围遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line"></div><div class="line">        // 查询</div><div class="line">        getResult(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 更新列</div><div class="line">        updateTable(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>, <span class="string">"bin"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 查询某列的多版本</div><div class="line">        getResultByVersion(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 删除一列</div><div class="line">        deleteColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"nickname"</span>);</div><div class="line"></div><div class="line">        // 删除所有列</div><div class="line">        deleteAllColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 删除表</div><div class="line">        deleteTable(<span class="string">"blog2"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>事实上，许多基于列表的操作，如delete(List <delete> deletes)或者get(List <get> gets)，都是基于batch()方法实现的。它们都是一些为了方便用户使用而保留的方法。如果你是新手，推荐使用batch()方法进行所有操作。<br>下面的客户端API方法提供了批量处理操作。用户可能注意到这里引入了一个新的名为Row的类，它是Put、Get和Delete的祖先，或者是父类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void batch(List&lt;Row&gt; actions,Object[] results) throws IOException,InterruptedException</div><div class="line">Object [] batch(List&lt;Row&gt; actions) throws IOException,InterruptedException</div></pre></td></tr></table></figure></get></delete></p>
<p>使用同样的父类允许在列表中实现多态，即放入以上3种不同的子类。这种调用跟之前介绍的基于列表的调用方法一样简单调用。请注意，不可以将针对同一行的Put和Delete操作放在同一个批量处理请求中，为了保证最好的性能，这些操作的处理顺序可能不同，但是这样会产生不可预料的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void batchDone(HTable hTable,String[] family,String[] column1) throws IOException&#123;</div><div class="line"></div><div class="line">      List&lt;Row&gt; batch = new ArrayList&lt;Row&gt;();</div><div class="line">        Put put = new Put(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        put.add(family[0].getBytes(), column1[1].getBytes(), Bytes.toBytes(<span class="string">"valTest"</span>));</div><div class="line">        batch.add(put);</div><div class="line">        Get get1 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get1.addColumn(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(get1);</div><div class="line">        Delete delete = new Delete(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        delete.deleteColumns(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(delete);</div><div class="line">        Get get2 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get2.addFamily(family[0].getBytes());</div><div class="line">        batch.add(get2);</div><div class="line">        Object[] results = new Object[batch.size()];</div><div class="line">        try &#123;</div><div class="line">            hTable.batch(batch,results);</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; results.length; i++) &#123;</div><div class="line">     System.out.println(results[i]);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>results返回值有<br>null    操作与远程服务器的通信失败<br>EmptyResult    Put与Delete操作成功后的返回结果<br>Result    Get操作成功的返回结果，如果没有匹配的行或列，会返回空的Result<br>Throwable    当服务器端返回一个异常时，这个异常会按原样返回给客户端。用户可以使用这个异常检查哪里出了错，也许可以在自己的代码中自动处理异常<br>void batch(List<row> actions,Object[] results)和Object [] batch(List<row> actions)<br>不同点：后面那个批量操作一旦出现异常，将不会获取到结果<br>相同点：get、delete和put都支持，如果执行时出现问题，客户端将抛出异常并报告问题。</row></row></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>像put、delete、checkAndPut这样的修改操作是独立执行的，这意味者在一个串行方式的执行中，对于每一行必须保证行级别的操作是原子性，region服务器提供了行锁的特性，这个特性保证只有一个客户获得一行数据对应的锁，同时对该行进行修改。使用如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RowLock lock=table.lockRow(row1);</div><div class="line">Put put=new Put(row1,lock);</div><div class="line">table.put(put);</div><div class="line">table.unlockRow(lock);</div></pre></td></tr></table></figure></p>
<p>获取数据也可以加显式锁，历史提供了Get(byte[] row,RowLock lock)，但服务器根本用不到这个方法，首先不说加锁的性能影响，原因在于获取数据时，应用了多版本并发控制保证行级读操作。<br>备注：MVCC算法<br>HBase采用了MVCC算法来避免读操作去获取行锁。<br>对于写操作：<br>(w1) 获取行锁后，每个写操作都立即分配一个写序号<br>(w2) 写操作在保存每个数据cell时都要带上写序号<br>(w3) 写操作需要申明以这个写序号来完成本次写操作（标注该行）<br>对于读操作:<br>(r1) 每个读操作开始都分配一个读序号，也称为读取点<br>(r2) 读取点的值是所有的写操作完成序号中的最大整数(所有的写操作完成序号&lt;=读取点）<br>(r3) 对某个(row,column)的读取操作r来说，结果是满足写序号为“写序号&lt;=读取点这个范围内”的最大整数的所有cell值的组合</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>Put、Delete与Get对象都是Row的子类，从该继承关系中我们就可以了解到Get、Delete与Pu对象本身就只能进行单行的操作，HBase客户端还提供了一套能够进行全表扫描的API，方便用户能够快速对整张表进行扫描，以获取想要的结果—scan</p>
<h3 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h3><p>全表扫描是一种不需要行键值的操作，因此初始化时不需要指定行键值，因此就产生了不同的使用方法<br>1、不进行Scan对象创建的全表扫描<br>在该过程中，Htable对象会在扫描请求发送前隐式的创建一个scan对象，然后传递给Hbase服务器集群。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void scanWithoutInit(String tableName,String family)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            //获取全表扫描  </div><div class="line">            ResultScanner resultScanner=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            //对结果进行显示  </div><div class="line">            Iterator&lt;Result&gt; results=resultScanner.iterator();  </div><div class="line">            <span class="keyword">while</span>(results.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                Result result=results.next();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:result.raw())  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>getScanner()方法时，如果不输入指定的scan对象，则需要输入相应的列簇或者列。因此在不进行scan对象创建的扫描中，需要明确指出列簇或者列，如果需要扫描多个列簇时，该方法就无法起到作用了。<br>2、进行初始化的全表扫描<br>初始化一个scan对象，然后对该对象进行相应的配置过，通过 getScanner(Scan scan) 函数进行全表扫描。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void scanWithInit(String tableName)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建扫描类  </div><div class="line">            Scan scan=new Scan();  </div><div class="line">            scan.setStartRow(Bytes.toBytes(<span class="string">"row-1"</span>));  </div><div class="line">            scan.setStopRow(Bytes.toBytes(<span class="string">"row-9"</span>));  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            ResultScanner rs=table.getScanner(scan);  </div><div class="line">            Result result;  </div><div class="line">            <span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">            &#123;  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();  </div><div class="line">            table.close();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在上段代码中，使用了setStartRow() 与 setStopRow() 两个函数进行调优。Scan有多个函数可以进行对全表扫描做出相应的规范。<br>3、数据遍历与显示ScannerResult<br>通过上述两种方法可以发送对一张表是遍历请求，当发送后，服务器会相应的启动全表扫面程序，从而准备向客户端返回相应的数据。因此根据客户端的遍历需要对数据尽心请求，然后将请求的结果进行返回，客户端拿到后进行展示<br>（1）next()的单行返回数据的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ResultScanner rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">//进项单行获取演示  </div><div class="line">Result result=null;  </div><div class="line"><span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">&#123;  </div><div class="line">    KeyValue[] kvs=result.raw();  </div><div class="line">    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">rs.close();</div></pre></td></tr></table></figure></p>
<p>next()方法会默认想客户端请求发送一行数据请求，刚服务器端的scan程序接收到请求后会将经需要返回的数据封装成一个result对象返回给客户端，因此客户端可以通过result对象去接受该行数据。接收到的数据则跟Get中的result使用方法是相同的。<br>（2）next(int n)的多行返回数据的方法<br>next(int n)：该函数会向服务器发送多个请求，以返回多条数据请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//一次获取多个结果（行数据）进行展示  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Result[] results=null;  </div><div class="line">            <span class="keyword">while</span>((results=rs.next(2))!=null)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">for</span>(Result r:results)  </div><div class="line">                &#123;  </div><div class="line">                    KeyValue[] kvs=r.raw();  </div><div class="line">                    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                    &#123;  </div><div class="line">                        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>next(int n)函数返回的是一个result数组。用户接受到数据后可以进行相应的操作。<br>（3）迭代器遍历<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进行迭代的方式进行输出  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Iterator&lt;Result&gt; resultIterator=rs.iterator();  </div><div class="line">            <span class="keyword">while</span>(resultIterator.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                result=resultIterator.next();  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            //关闭表  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>（4）注意点<br>因为当用户发送一个scan全表扫描后，region服务器会为全表扫描创建扫描资源，因此长时间启用全表扫描的话会占用region服务器的大量资源，所以在要求在使用完scanner扫描器后尽快释放掉资源。<br>rs.close() 会告知服务其扫描器租约已经结束，服务器就会释相应的全局扫描的资源。<br>三、Scan对象<br>（1）setStartRow() / setStopRow<br>设置扫描的开始行与结束行，通过这两个可以直接确scan在扫描的范围，通过缩小范围可以减少扫描到时间，从而提高扫描的效率<br>（2）addFamily() / addColumn()<br>通过这两个函数，可以在列或者列簇上的扫描位置。HBase是面向lie出书的数据库，而同一个列簇的数据全部存放在同一个位置文件中。因此如果可以确定扫描那个一列簇时，可以减少扫描的范围，从而缩短扫描的时间。而在确定到某一个列时也会因为HBase的面向列存储使得其效率提高。<br>（3）setMaxVersion() / setMaxVersion(int version)<br>设置返回的版本数量，默认为返回最新的数据。第一个函数则会返回所有的版本数据，第二个函数可以设置返回的版本数量<br>（4）setTimeStamp(long max)<br>返回该时间戳的数据<br>（5）setTimeRange(long min,long max)<br>设定返回的时间戳的范围，只有版本值在该范围之内的数据才会被返回到客户端<br>（6）setFilter(Filter f)<br>设置过滤器，有时候扫描全表返回的数量过大时，可以通过过滤器将不符合的数据进行过滤，这样可以减少从服务器到客户端的数据传送，挺高扫描效率。<br>（7）setCacheBlocks(boole open)<br>在进行全表扫描过程中，服务器端提供了一个缓存区，该缓存区可以将指定的数据量全部放入到内存中，这样可以提高读取效率。缓存区的打开也可以通过htable客户端进行打开。在开发后用户可以通过 setCache(int n)的方式设置每次缓存的数量为多少。通过调整该函数以提高读取的效率。<br>四、总结<br>scan的全表扫描区别于其他三个操作，虽然获取数据与Get获取的数据是相同的，其与Get也具有形似的属性，可以通过修改这些属性去对数据获取进行调优，从而使得提高数据获取的效率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/hbase简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/hbase简介/" itemprop="url">hbase简介(第一章)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T09:38:49+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index">
                    <span itemprop="name">hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="海量数据的黎明"><a href="#海量数据的黎明" class="headerlink" title="海量数据的黎明"></a>海量数据的黎明</h2><p>hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，可以帮助用户分析数据时决定如何解释这些数据，同时允许用户随时更改数据分类的方式；一旦用户更新了算法，只需要重新分析数据。Hadoop是现有数据库的一个补充，提供了数据存储无限的空间，并且针对大文件存储、批量访问和流式访问做了优化。<br>列式存储数据库，以列为单位聚合数据，然后将列值顺序存入磁盘，而行式数据库则是连续存储整行。<br>1.优点是：查询时只有涉及到的列会被读取；投影(projection)很高效；任何列都能作为索引。缺点：选择完成时，被选择的列要重新组装；INSERT/UPDATE比较麻烦。<br>2.更好的进行数据压缩：通过字典表压缩数据。经过字典表进行数据压缩后，表中的字符串才都变成数字了，比如我们的材料名可以用一张材料表，这样子在列存储就可以根据id来关联材料。<br>3.查询性能<br>我们能根据列查询结果通过为运算（&amp;或者|）进行结果合并，加快速度<br>关键步骤如下：<br>1.去字典表里找到字符串对应数字(只进行一次字符串比较)。<br>2.用数字去列表里匹配，匹配上的位置设为1。<br>3.把不同列的匹配结果进行位运算得到符合所有条件的记录下标。<br>4.使用这个下标组装出最终的结果集。<br>Hbase以列式存储的格式存储数据，传统的列式存储比较适合实时存储数据的场景，Hbase比较适合键值对的数据存取或者有序的数据存取。</p>
<h2 id="关系数据库系统的问题"><a href="#关系数据库系统的问题" class="headerlink" title="关系数据库系统的问题"></a>关系数据库系统的问题</h2><p>数据量大时，索引量也大到足以让数据库的性能直线下降。最后能够提供的查询也只剩下主键查询，最后的采取的方案就是数据分区，也就是分库分表。</p>
<h2 id="非关系型数据库系统"><a href="#非关系型数据库系统" class="headerlink" title="非关系型数据库系统"></a>非关系型数据库系统</h2><h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><p>包括数据模型、存储模型、一致性模型、物理模型、读写性能、辅助索引、故障处理、压缩、负载均衡、原子操作的读修改写、加锁等待死锁</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><h3 id="数据库的范式和反范式"><a href="#数据库的范式和反范式" class="headerlink" title="数据库的范式和反范式"></a>数据库的范式和反范式</h3><h2 id="Hbase结构"><a href="#Hbase结构" class="headerlink" title="Hbase结构"></a>Hbase结构</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="表、行、列和单元格"><a href="#表、行、列和单元格" class="headerlink" title="表、行、列和单元格"></a>表、行、列和单元格</h3><p>最基本的单位是列，一列或者多列构成一行，并由唯一的行健来确定存储。反过来，一个表中有若干行，其中每列可能有多个版本，在每个单元格中存储了不同值。行序是按照字典顺序进行排序的，意思是从左到右一次对比每一个键。关于排序：排列顺序如果跟预期的不一样，需要补键，比如  row-1 永远小于 row-2，无论后面是什么，将始终按照这个顺序排列。行健总是唯一的，否则你就是在更新同一行。行健可以是任意的字节数组，但它不一定是人直接可读。<br>一行由若干列组成，若干列构成一个列族，有助于构建语义边界，还有助于给他们设置某些特性（压缩），或者指示他们存储在内存中。一个列族所有列存储在HFile。<br>常用的引用列的格式为family：qualifier，qualifier是任意字节数组。一个列族没有列的数量限制，可以有数百万列。列值没有类型和长度的限制。NUll值在Hbase不占任何空间。<br>每一列的值或者单元格都有时间戳，不同时间戳区分不同的版本值，同一个单元格的不同版本值按照时间戳降序排序，访问时候优先读取最新的值。这样优化使得新值比老值更容易读到。用户可以指定每个值能保存的最大版本数，此外还支持谓词删除（LSM树）。<br>Hbase是一个稀疏的、分布式的、持久化的、多维的映射、由行健列键和时间戳索引。数据存储模式：(Table,RowKey,Family,Column,TimeStamp)-&gt;value</p>
<h3 id="自动分区"><a href="#自动分区" class="headerlink" title="自动分区"></a>自动分区</h3><p>Hbase中扩展和负载均衡的基本单元是region，region本质是以行键排序的连续存储的区间。如果region太大，系统会动态拆分，相反会合并region，减少存储文件数量。<br>一张表初始化只有一个region，用户不断插入数据，当数据量超过配置的最大值，会在中间键处将这个region拆分成两个大致相等的region。每一个region只能由一台regionServer加载，而一台RegionServer可以同时加载多个region。（每台regionServer1加载的最佳数量是10~1000，每个region最佳大小是1GB~2GB）。当某个region服务器由于负载过大等原因导致不可用时，系统会将该region转到其他服务器上。</p>
<h3 id="存储API"><a href="#存储API" class="headerlink" title="存储API"></a>存储API</h3><p>API提供了建表、删表、增加列族、删除列族、修改表、修改列族元数据（压缩，设置块大小）、行键值的增加，删除，查找<br>scan可以限定返回的列或者返回的版本数，可以设置过滤器。系统支持单行事务，进一步实现单行键下存储的数据的 读-修改-写（read-modify-write）序列。单元格的值可以当计数器用，并且支持原子更新，意味着这个计数器可以在一个操作中实现读写，客户端可以基于此实现一个全局强一致的计数器。协处理器(coprocessor): 可以在服务器的地址空间执行来自客户端的代码。用于实现轻量级的批处理作业，或者使用表达式分析或者汇总数据。通过包装器可以将表转换成MapReduce的输入输出目标</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>数据存储在存储文件中，称为HFile，HFile存储的是经过排序的键值映射结构。文件内部由连续的块组成，块的索引信息放在尾部，当打开HFile并加载在内存中，索引信息会优先加载到内存中，每个块的大小为64k。每个HFile都有一个块索引，通过一个磁盘查询就可以实现查询，存储文件写在HDFS中。每次更新数据，都会将数据记录在提交日志中，然后在将数据写入内存memstore,一旦内存超过一定的大小，就会移除内存，作为HFile写入磁盘。移除内存后，就会丢弃提交日志，只保留未持久化的提交日志。数据移出memstore，丢弃提交日志。采用滚动memstore可以实现不阻塞系统读写，即用空的新memstore获取更新数据，将旧的满的memstore转换成一个文件，由于memstore中的数据本来就排序好了，所以存储的时候不用再次排序。删除是在做个删除标记，让客户端无法读取到值。<br>HFile过多的时候有管家机制来处理，合并有两种类型：<br>minor合并：多个小文件合并成一个大文件，由于是多路归并所以速度快<br>major压缩合并：将region中一个列族的若干个HFile重写为一个新HFile。合并扫描所有键值对，顺序重写所有数据，重写数据的过程中会略过做了删除标记的数据。断言删除此时生效。<br>master 负责负载均衡，将繁忙服务器中的region移到负载轻的服务器中。还提供元数据的管理，例如创建表和创建列族。<br>region服务器负责为他们提供的Region提供读写功能<br>数十亿行<em>数百万列</em>数千个版本=TB级别或者PB级别的存储</p>
<h2 id="Hbase：Hadoop数据库"><a href="#Hbase：Hadoop数据库" class="headerlink" title="Hbase：Hadoop数据库"></a>Hbase：Hadoop数据库</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Hbase是一个分布式的、持久性的、强一致性的存储系统，具有近似最优的写性能和出色的读性能。它充分利用磁盘空间，支持特定列族切换可选压缩算法。Hbase支持行原子性</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/elasticSearch初步了解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/elasticSearch初步了解/" itemprop="url">elasticSearch入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T23:10:46+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/elasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">elasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="elasticSearch简介"><a href="#elasticSearch简介" class="headerlink" title="elasticSearch简介"></a>elasticSearch简介</h2><p>1.基于Apache Lucene构建的开源搜索引擎<br>2.基于java编写，提供简单易用的Resful API<br>3.轻松的横向扩展，可支持PB级别的结构化和非结构化的数据处理</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1.海量数据分析引擎<br>2.站内搜索引擎<br>3.数据仓库<br>备注应用：github站内搜索、维基百科、百度实时日志监控</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>版本历史 1.x-&gt;2.x-&gt;5.x</p>
<h2 id="安装head插件"><a href="#安装head插件" class="headerlink" title="安装head插件"></a>安装head插件</h2><p>安装elasticsearch-head,github地址：<a href="https://github.com/mobz/elasticsearch-head.git，然后进行npm" target="_blank" rel="external">https://github.com/mobz/elasticsearch-head.git，然后进行npm</a> install，在启动head插件（npm run start），<a href="http://localhost:9100。" target="_blank" rel="external">http://localhost:9100。</a><br>同时更改elasticsearch.yml，新增以下内容支持跨域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http.cors.enabled: <span class="literal">true</span></div><div class="line">http.cors.allow-origin: <span class="string">"*"</span></div></pre></td></tr></table></figure></p>
<h2 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h2><p>举个例子，三个节点<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: master</div><div class="line">node.master: <span class="literal">true</span></div><div class="line">network.host: 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>slave节点的配置如下，在elasticsearch.yml修改<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: slave1</div><div class="line">network.host: 127.0.0.1</div><div class="line">http.port: 8200</div><div class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"127.0.0.1"</span>]</div></pre></td></tr></table></figure></p>
<h2 id="集群和节点"><a href="#集群和节点" class="headerlink" title="集群和节点"></a>集群和节点</h2><p>集群有节点组成，每个集群有唯一的名字。 一个节点只是集群的一部分，节点通过集群名字加入集群</p>
<ul>
<li>索引(database)<br>含有相同属性的文档集合</li>
<li>类型(table)<br>索引可以定义一个或者多个类型，文档必须属于一个类型</li>
<li>文档(row)<br>文档是可以被索引的基本数据单位</li>
<li>分片<br>每个索引都有多个分片，每个分片是lucene索引</li>
<li>备份<br>拷贝一份分片就完成了分片的备份<br>备注：es默认五个分片一个备份<h2 id="es的基本用法"><a href="#es的基本用法" class="headerlink" title="es的基本用法"></a>es的基本用法</h2></li>
<li>api的基本格式：http://<ip>:<port>/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</port></ip></li>
<li>常用的动词有：GET/PUT/POST/DELETE<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3>在head插件创建索引<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:book put请求</div><div class="line">&#123;</div><div class="line">  <span class="string">"novel"</span>: &#123;</div><div class="line">    <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"title"</span>: &#123;</div><div class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用postman插件，可视化插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:people put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"settings"</span>:&#123;</div><div class="line">		<span class="string">"number_of_shards"</span>:3,</div><div class="line">		<span class="string">"number_of_replicas"</span>:1</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"mappings"</span>:&#123;</div><div class="line">		<span class="string">"man"</span>:&#123;</div><div class="line">			<span class="string">"properties"</span>:&#123;</div><div class="line">				<span class="string">"name"</span>:&#123;</div><div class="line">					<span class="string">"type"</span>:<span class="string">"text"</span></div><div class="line">				&#125;,</div><div class="line">			    <span class="string">"country"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"keyword"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"age"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"integer"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"date"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"date"</span>,</div><div class="line">			    	<span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss"</span></div><div class="line">			    &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入索引"><a href="#插入索引" class="headerlink" title="插入索引"></a>插入索引</h3><ul>
<li><p>指定文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1 Put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"lirui"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 24,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-09-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自动产生文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man POST请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"李睿"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 25,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-06-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/_update POST请求</div><div class="line">  &#123;</div><div class="line">  	<span class="string">"doc"</span>:&#123;</div><div class="line">       <span class="string">"name"</span>:<span class="string">"kobe_brant"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/ DELETE请求</div></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>使用head插件删除索引或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/ DELETE请求</div></pre></td></tr></table></figure></p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/_search POST</div><div class="line">//查询全部</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_all"</span>:&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//针对查询</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;<span class="string">"name"</span>:<span class="string">"kobe"</span>&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"sort"</span>:[</div><div class="line">    	   &#123;</div><div class="line">    	   	<span class="string">"date"</span>:&#123;</div><div class="line">    	   	  <span class="string">"order"</span>:<span class="string">"desc"</span></div><div class="line">    	   &#125;</div><div class="line">    	   &#125;</div><div class="line">    	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_name"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"country"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ul>
<li>子条件查询<br>特定字段查询所指的特定值<h4 id="query-context"><a href="#query-context" class="headerlink" title="query context"></a>query context</h4>查询过程中，除了判断文档是否满足条件外，es会计算一个_sore来标识匹配程度<br>分为全文本查询（文本类型数据）和字段级别查询（结构化数据如数字、日期）<h4 id="filter-context"><a href="#filter-context" class="headerlink" title="filter context"></a>filter context</h4>在查询时只需要判断文档是否满足条件，只有Yes或者No。</li>
<li>复合条件查询<br>以一定逻辑组合子条件查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line">      <span class="string">"should"</span>:[&#123;</div><div class="line">         <span class="string">"match"</span>:&#123;</div><div class="line">           <span class="string">"author"</span>:<span class="string">"瓦力"</span></div><div class="line">         &#125;</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">          <span class="string">"match"</span>:&#123;</div><div class="line">            <span class="string">"title"</span>:<span class="string">"瓦力"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"term"</span>:&#123;</div><div class="line">          <span class="string">"word_count"</span>:1000</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/构建大型网站的其他要素/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/构建大型网站的其他要素/" itemprop="url">构建大型网站的其他要素（第八章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T13:25:33+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="加速静态内容访问的速度的CDN"><a href="#加速静态内容访问的速度的CDN" class="headerlink" title="加速静态内容访问的速度的CDN"></a>加速静态内容访问的速度的CDN</h2><p>CDN，Content Delivery Network，内容分发网络。CDN的作用是把用户需要的内容分发到离用户近的地方，这样可以从用户能就近获取所需的内容。整个CDN系统分为CDN源站和CDN节点。CDN源站提供CDN节点使用的数据源头，CDN节点部署在离最终用户比较近的地方，加速用户对站点的访问。CDN就是网络缓存技术，一般存放静态文件（js，css，图片，视频，页面框架）。<br>浏览器访问网站的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，获取ip地址；<br>3.浏览器向所得到的ip发送请求；<br>4.浏览器根据返回的内容显示数据<br>有了CDN后的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，由于CDN对域名解析过程做了调整，所以得到该域名对应的CNAME记录。<br>3.对CNAME进行解析得到实际的ip地址。在这次解析中会使用全局负载均衡CDN解析，需要我们根据地理位置以及所在的ISP确定结果，然后获取到具体的IP地址。<br>4.得到实际的ip地址后，我们会向服务器发送请求。<br>5.CDN会根据请求的内容是否在本地缓存进行不同的处理。<br>如果存在，直接返回结果；不存在，则请求CDN源站，获取内容，返回结果。<br>CDN关键的技术：<br>1.全局调度<br>全局调度是完成用户就近访问的第一步，我们需要根据用户地域、接入运营商、以及CDN机房的负载情况去调度。<br>2.缓存技术<br>如果请求不存在CDN节点，则请求CDN源站，获取内容，返回结果。如果命中率不高，加速有限。要提升命中率，首先缓存的容量要足够大，可以使用内存+SSD+硬盘混合存储。还有新增变更数据预加载也能提升命中<br>3.内容分发<br>内容分发主要包括在CDN上不用回源的数据的管理和分发，主要包括静态页面。<br>4.带宽优化<br>只返回必要数据和使用更好的压缩算法</p>
<h2 id="大型网站的存储支持"><a href="#大型网站的存储支持" class="headerlink" title="大型网站的存储支持"></a>大型网站的存储支持</h2><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><p>对一些图片、大文本的存储使用数据库就不合适了。GFS主要由三部分构成：GFS Client、GFS Master、GFS chunkserver</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>应用使用GFS的入口，Client负责从GFS Master上获取要操作的文件在chunkserver中的具体地址，然后直接和chunkserver通信，获取数据或者进行数据写入和更新。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>可以说是整个文件系统的大脑，这里维护了所有的文件系统的元数据，包括名字空间、访问控制信息、文件与chunk的映射信息、chunk的当前位置。Master也控制整个系统范围内的活动，例如，无效的chunk的回收以及chunksever之前的chunk迁移等。Master与chunkServer之间通过周期性的心跳进行通信，检测对方是否在线。</p>
<h4 id="ChunkServer"><a href="#ChunkServer" class="headerlink" title="ChunkServer"></a>ChunkServer</h4><p>这是文件系统存储的地方。在每个chunkserver上会用chunk的方式管理数据。每个chunk是固定大小的文件，超过chunk的文件会被分为多个chunk进行存储，小于chunk的文件则会将多个文件存储在一个chunk中。<br>GFS主要解决单机的存储问题和安全问题，HDFS是java的类GFS的实现。</p>
<h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h3><p>not only sql。基本上处于分布式文件系统和SQL关系型数据库之间的系统都被归为NoSql范畴。<br>在NoSql Data Modeling Techniques文章中，一个NoSql和Sql的基础都来自key value，另外一个NoSql继续发展，就会变成Sql数据库。</p>
<h4 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h4><p>最基础的技术支撑，后续的产品都基于key-value存储发展起来。但是有个问题，没有办法进行高效的范围查询。</p>
<h4 id="ordered-key-value"><a href="#ordered-key-value" class="headerlink" title="ordered key-value"></a>ordered key-value</h4><p>key是有序的，可以解决key的范围查询的效率，但是在这个模型中，value本身的内容和结构是由应用来负责解析和存储的。</p>
<h4 id="Big-Table"><a href="#Big-Table" class="headerlink" title="Big Table"></a>Big Table</h4><p>是google发表的名为BigTable：A Distributed Storage System for Structured Data论文中提到的一个产品，是一个结构化数据的分布式存储系统。BigTable对value进行了schema的支持，value是由多个Column family组成，Column family的内部是Column，ColumnFamily不能动态扩展，但是Column能够动态扩展。（hbase可以是里面的一个实现）</p>
<h4 id="Document-full-text-Search"><a href="#Document-full-text-Search" class="headerlink" title="Document full-text Search"></a>Document full-text Search</h4><p>Document数据库有两个很大的进步，一个是可以在内部任意定义schema，而不再仅仅是map的嵌套；另一个是全文检索的支持。</p>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>图数据库可以看成从有序的key-value数据库发展而来的一个分支，主要是支持图结构的数据模型。<br>这里面讲的Full-Text Search和Graph在一些地方可能不能归为NoSql。<br>Hbase是借鉴Google BigTable的一个java版本的实现，存储到hbase的数据是通过HRegionServer来管理，每个HRegionServer管理了多个HRegion，每个Region管理了具体数据。HMaster管理所有的HRegionServer节点，是一个中心控制结构。还有比较经典的Amazon的Dynamo，它是采用了一致性哈希来进行管理。</p>
<h3 id="缓存系统"><a href="#缓存系统" class="headerlink" title="缓存系统"></a>缓存系统</h3><p>缓存是非持久化，用来加速应用对数据的读取。Redis和Memcache是两个广泛的缓存系统，Redis已经有了对于集群的支持，memcache本身还是一个单机的应用。如果想把多个节点构成一个集群，常见的有一致性哈希。有两个使用缓存的场景<br>首先是使用缓存降低底层读的压力，需要注意缓存和数据一致性的问题。在这种方式中，应用不直接操作缓存，存储由缓存控制。但是这种场景下，因为保证写入缓存后要能写入存储，所以缓存本身的逻辑比较复杂，需要很多操作日志和故障恢复。<br>另一种使用缓存的方式是，应用直接与缓存和存储系统打交道，一般的做法是在写操作时更新缓存，然后失效缓存；而在读数据时先读缓存，如果缓存没有命中，再去读数据，写入缓存。<br>这里重点考虑缓存与存储数据一致性问题，这里指最终一致性。重点考虑缓存没有命中和数据更改的情况，以及更新存储中的数据后没来得及将缓存失效<br>还有就是全数据缓存，当存储的数据变化就直接同步到缓存，这样应用取数据都从缓存中取。用于数据变更通知平台<br>大型网站使用缓存的场景还有对于web应用页面渲染的缓存。以一个页面展示为例，我们队页面进行了分块，其中有静态内容，也有动态内容，如果整个页面采用服务器渲染的方式，我们希望相对静止的内容可以进行缓存而不用每次都要重新渲染。具体的技术有ESI（edge side includes），是通过在返回的页面加上标签，然后标签的内容去用缓存填充的一个过程。处理ESI标签可以放在java应用容器中去处理，也可以放在java应用容器前置的服务器去处理。<br>两种方式对比如下：<br>1.渲染页面和ESI处理在一个进程里，处理效率会提升，当页面内容是内部对象时就可以处理ESI标签，而如果放在前置服务器，需要对内容进行一次扫描，定位到ESI标签后再处理。<br>2.ESI放在Web前置服务器去处理，对于后端来说可以不用去考虑ESI标签问题，例如当后端处理请求为java应用、php 应用时，可以统一把ESI处理放在前置服务器上，这样后端就只用处理请求，不必对每个应用做都去处理ESI工作。</p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>当网站的数据量和访问量很小时候，一些数据的查询可以用数据库的like操作来实现，当然这种操作比较效率很低也不够智能。当数据量和访问量很大时候，就需要在站内使用搜索技术来解决这问题。</p>
<h3 id="爬虫问题"><a href="#爬虫问题" class="headerlink" title="爬虫问题"></a>爬虫问题</h3><p>对于全网搜索来说，我们需要爬虫去获取被检索的网站内容。这里我们要讲更新索引的方式<br>1.定时从数据源中拉取，我们称之为增量dump。这要求数据库有个记录变更时间的字段，否则无法获取一段时间变更的数据，而这个字段需要有索引，否则效率变得很低。增量dump开始前，需要全量dump构造初始化的数据。增量的时间间隔一般在分钟级，这会引起明显延迟。<br>2.通过数据变更的通知，及时通过搜索引擎构建索引及时性会很好不过带来的系统压力会很大。因而这种方式主要用在实时性很高的场景。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引是很重要的一项搜索引擎技术。正向索引可以理解为文章和关键词的映射。相对于正向索引，倒排索引是把值的内容拆分成了索引的key，而原来用做索引的key则变成了值，也就是关键词和文档之间的映射。搜索引擎比数据库高效的原因就在于倒排索引。如何确定倒排索引的关键词，关键在于分词。</p>
<h3 id="查询预处理"><a href="#查询预处理" class="headerlink" title="查询预处理"></a>查询预处理</h3><p>查询表预处理主要负责对用户搜索内容进行分词及分词后的分析，包括同义词的替换和及词后的分析，包括一些同义词的替换和纠错等。这一部分是在使用搜索引擎前对搜索内容的梳理，这部分的工作也最终影响到搜索结果的质量。<br>备注：1、在建立索引时，拆词建索引时就把同义词考虑进去，将同义词的词条加入到索引中，然后检索时，直接根据输入拆词来检索2、在建立索引时，不对同义词进行任何处理，在检索时，先拆词，针对拆分出来的词元（呵呵，自创的称呼）也即关键字，进行同义词匹配，把匹配好的同义词拼成一个新的关键字，搜索索引时根据此关键字来进行检索。个人觉得，方案二更优于方案一，理由如下：在建立索引时，就处理同义词，一方面会增加索引库的容量，导致索引效率的降低；其次，如果后期对同义词进行了扩展，比如原来，一个单词有2个同义词，后面增加到3个，就需要对索引进行重建了，！<br>似,is,are =&gt; 是（一般适用于纠错，格式一表示如果文本中出现了is,are,那么直接替换成是。expand参数对此没有影响。）好人,好心人,热心人（格式二表示如果文本中出现了好人或者好心人或者热心人，当expand=true时，把待替换的文本用好人好心人 热心人替换；当expand=false时，把待替换文本用第一个单词即好人替换。）</p>
<h3 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h3><p>查询在搜索引擎上被执行，对于返回的结果，需要计算和搜索内容的相关度展示给用户，相关度计算是指不指定按照某个字段排序的基础上对结果的排序，排序的原则是被搜索到的内容和搜索内容之间的相关度。<br>相关度的计算方式很多，例如有空间向量模型、概率模型<br><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7981145</a></p>
<h2 id="数据计算支撑"><a href="#数据计算支撑" class="headerlink" title="数据计算支撑"></a>数据计算支撑</h2><h3 id="离线计算"><a href="#离线计算" class="headerlink" title="离线计算"></a>离线计算</h3><p>离线计算是业务产生数据离开生产环境后进行的计算。就是业务数据从在线存储中移动到离线存储中，然后进行数据处理的过程。<br>在离线计算领域里，MapReduce模型十分著名和常用，MapReduce是google在2004发表的论文：MapReduce：simplified Data Processing On Large Clusters.<br>（<a href="http://www.cnblogs.com/fuzhe1989/p/3413457.html）。" target="_blank" rel="external">http://www.cnblogs.com/fuzhe1989/p/3413457.html）。</a><br>主要分为两个阶段，Map阶段和Reduce阶段。在map阶段，我们根据设定的规则，把整体数据集映射给不同的worker来处理，并且生成各自的处理结果。而在reduce阶段，是对前面处理过的数据进行聚合，形成不同的结果，一个任务的处理可能是不止一次MapReduce过程。<br>Hadoop是MapReduce的一个开源实现，Hadoop使用HDFS进行数据存储，Spark提供了基于内存的集群计算的支持，Spark本身是为了集群计算中特定类型工作而设计的。例如机器学习，基于内存的方式使得spark的速度非常快</p>
<h3 id="在线计算"><a href="#在线计算" class="headerlink" title="在线计算"></a>在线计算</h3><p>Storm是在线计算的一个框架<br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。</p>
<h2 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h2><p>当完成应用的开发和测试后，需要使应用上线来为最终用户提供服务。<br>1.分发应用<br>我们需要提供自动高效且容易操作的机制把经过测试的程序包分发到线上的应用，我们一般会采用web的操作方式，通过专用通道把应用程序包从线下环境传送到线上的发布服务器。发布控制台-&gt;多机房-&gt;发布服务器<br>2.启动校验<br>应用重启启动后，需要进行校验从而完成这台应用服务器上的应用发布，对应用的校验通常是应用自身提供一个检测脚本或者页面，发布系统执行这个脚本或者访问页面后来判断返回的结果。<br>停止应用时,需要优雅的关闭，需要在关闭应用前把这个应用从负载均衡或者软负载中心上移除<br>3.灰度发布<br>会对新应用进行分批发布，逐步扩大新应用在整个集群中的比例直至最后全部完成。这里讲的灰度发布主要是针对新应用在用户体验方面完全感知不到的更新.<br>4.产品改版Beta<br>提供新旧应用的共存</p>
<h2 id="应用监控系统"><a href="#应用监控系统" class="headerlink" title="应用监控系统"></a>应用监控系统</h2><p>1.数据监视维度<br>系统数据和应用自身的数据.系统数据指的就是当前应用运行的系统环境的信息，如CPU使用率、内存使用情况、交换分区使用情况、当前系统负载、IO情况等;而应用自身的数据，则是不同应用有不同的数据，一般会是调用次数、成功率、响应时间、异常数量等维度的数据<br>2.数据记录方式<br>系统自身的数据已经被记录到了本地磁盘，应用的数据一般也是存放在应用自身的目录中，便于采集。也有直接把应用日志通过网络发送到采集服务器的情况，可以减轻本地写日志的压力<br>对于应用数据的记录，会考虑用定时统计的方式记录一些量很大的信息.如对于一个提供服务的应用，在没有特别需求时，并不直接记录每次调用的信息，而是会记录一段时间如5s或者一个间隔时间内的总调用次数、总响应时间这样写信息，而对于异常信息则每次都会予以记录;采用统计的方式是为了减小记录的大小以及对本地磁盘的写入压力。<br>3.数据采集方式<br>采集方式有应用服务器主动对同给监控中心以及等待监控中心来拉取两种方式。前者控制权在应用服务器上,可能出现的问题是应用服务器推送的压力超过采集的中心服务器的能力，会造成重试等额外开销并且需要应用服务器上的推送程序控制重试逻辑和当前传送位置等信息。后者把复杂性都放在中心采集服务器上处理，使得应用服务器中支持数据采集的部分变的简单<br>4.展示与警告<br>提供图表的形式可以提供Web页面的展示-&gt;通过手机应用来接收报警-&gt;短信方式好<br>5.控制<br>控制<br>应用启动后在运行期对于应用的行为改变-&gt;对于应用的运维，最低的要求是出现问题时可以通过重启应用解决，但是我们还是需要更加精细化的控制应用-降低和一些切换。降级是我们遇到大量请求且不能扩容的情况时所进行的功能限制的行为-&gt;而切换更多的是当依赖的下层系统出现故障并且需要手工进行切换时的一个管理，这些控制一般都是通过开关，参数设置来完成</p>
<h2 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h2><p>随着网站功能增多，应用的个数迅速增加，应用之间的关系也会越来越复杂，理清这些依赖关系并能够管理这些依赖会非常重要<br>-&gt;一个应用在完成某个功能时到底需要依赖哪些外部系统、这些依赖中哪些是必要依赖，强依赖(登陆验证用户名和密码)，哪些是有了更好没有也可以的依赖，弱依赖（如记录登陆时间和ip等）-&gt;<br>-&gt;动态检测（在系统运行阶段，通过功能的调用来发现应用的依赖关系）和静态检测（分析代码来确定所调用的具体外部应用）-&gt;动态检测的主要检查方式是模拟被调用系统不可用和响应慢的两种情况-&gt;<br>-&gt;Google#Dapper,A Large-Scale Distributed Systems Tracing Infrastructure-&gt;traceId,index-&gt;形成一个调用时序图</p>
<h2 id="多机房问题分析"><a href="#多机房问题分析" class="headerlink" title="多机房问题分析"></a>多机房问题分析</h2><p>同城机房和异地机房<br>同城多个机房中，对于重要的应用系统，会在不止一个机房中部署；而对于数据库系统，则会把主备放在不同机房。尽量避免不必要的跨机房的内部系统调用，为了数据安全，把产生的业务数据都同步到异地的机房。把一些对数据延迟不敏感的系统部署到异地,如只读系统….</p>
<h2 id="系统容量规划"><a href="#系统容量规划" class="headerlink" title="系统容量规划"></a>系统容量规划</h2><p>我们应该知道的信息就是整个系统的容量以及运行时所处的水位。我们把某个应用系统集群能够提供的并发能力和当前的压力比作一个水桶的容量和水位。那么准确知道各个系统的容量和当前高峰时的水位是一件很重要的事情。因为我们还是希望优先通过扩大容量来支持更多的请求而不是首选降级的方案。<br>考虑过去的增长情况并结合人为的判断<br>1.弄清楚当前系统高峰期的水位<br>2.弄清楚当前各个系统的容量<br>3.通过测试，压力测试，设置警戒值，高峰水位搞过警戒值就增加容量，保持高峰的水位是低于警戒值的</p>
<h2 id="内部私有云"><a href="#内部私有云" class="headerlink" title="内部私有云"></a>内部私有云</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/27/软负载中心与集中配置管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/软负载中心与集中配置管理/" itemprop="url">软负载中心与集中配置管理（第七章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T15:39:30+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初始软负载中心"><a href="#初始软负载中心" class="headerlink" title="初始软负载中心"></a>初始软负载中心</h2><p>在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知也是通过软负载中心。<br>软负载中心有两个最基本的职能：<br>1.聚合地址信息；无论是服务框架中需要用到的服务提供者地址还是消息中间件系统中的消息中间件地址，都需要由软负载中心去聚合地址列表，形成一个可供服务调用者及消息发送者、接收者接收的列表。<br>2.生命周期感知；软件负载中心能够对服务上下线自动感知，并且根据这个变化去更新服务地址数据，形成新的地址列表后，把数据传给需要数据的调用者或者消息的发送者和接收者。</p>
<h2 id="软负载中心的结构"><a href="#软负载中心的结构" class="headerlink" title="软负载中心的结构"></a>软负载中心的结构</h2><p>软负载中心包括：一个是软负载中心的服务端，另一个是软负载中心的客户端；服务端主要负责感知提供服务的机器是否在线，聚合提供者的机器信息，并且负责把数据传给使用数据的应用。客户端承载了两个角色，作为服务提供者，客户端主要是把服务提供者提供服务的具体信息主动传给服务端，并且随着提供服务的变化去更新数据；而作为服务使用者，客户端主要向服务端告知自己所需要的数据，并负责去更新数据，还要进行本地缓存，使得每次去请求服务来获取列表都是一个本地操作。<br>软件负载中心内部有三部分重要数据<br>1.聚合数据<br>聚合后的地址列表。对于提供的服务信息，我们使用唯一的dataId来标识，同时dataId支持分组（group），通过dataId和group可以定位到唯一的数据内容，这个内容是通过聚合完成的完整数据，而这个信息在内部就是一个key-value结构。<br>2.订阅关系<br>在软负载中心中，需要数据的应用把自己需要的数据告诉软负载中心，这就是订阅关系，订阅的粒度也是通过dataId和group来确定数据，那么会有dataId和group到数据订阅者的分组ID的一个映射关系，当聚合的数据发生变化，通过订阅关系的数据找到需要通知的数据订阅者，然后去进行数据更新操作。<br>3.连接关系<br>连接到软负载中心的节点和软负载中心已经建立的连接管理。使用软负载中心的应用，无论是发布数据还是订阅数据，都会有一个独立的分组，而连接数据就是用groupId作为key，然后对应管理这个物理连接，采用的是长连接方式。当订阅的数据发生变化，通过订阅关系找到需要通知的groupId，在连接数据这里就能够找到对应的连接，完成对应用的更新。</p>
<h2 id="内容聚合功能的设计"><a href="#内容聚合功能的设计" class="headerlink" title="内容聚合功能的设计"></a>内容聚合功能的设计</h2><p>保证数据的正确性<br>内容聚合主要需要保证的是并发场景下的数据聚合的正确性。另外需要考虑发布数据的机器短时间内上下线的问题，指发布数据刚连接上来，然后就断线了就是断线后又很快上线发布数据。内容聚合主要保证在这些异常又较为复杂的场景中保证数据的正确性<br>高效聚合数据<br>因为软负载中心是系统的中枢，虽然软负载中心不再服务调用或者消息投递的路径上，但是服务提供者以及消息中间件的服务地址列表都是由软负载中心进行管理的，高效聚合数据在软负载中心自身重启或者服务提供者大面积重启带来很大的便利。<br>在这里，我们讨论下实现（前提是java实现），我们可以用map来存储，用dataId和group作为key，value就是聚合后的数据。有几个关键点需要注意<br>1.并发下的数据正确性的保证<br>先看看场景，并发操作会是数据插入、更新、删除三个一起在一起的操作，其中删除、更新主要因同一个数据的不同数据发布者变化产生，而数据插入是由于多个新的dataId有进入到Map结构的需求。（如软件负载中心重启和大量的数据发布者重启时）<br>我们可以用ConcurrentHashMap线程安全管理所有dataId的数据，也可以用linkedlist来操作，但是要在增删或者读加锁，否则线程不安全。<br>2.数据更新、删除的顺序保证<br>所发布数据变化主要有新增、更新和删除，而处理顺序一定要跟真实世界的顺序一致，比较容易出现的问题是在网络断开后删除数据与数据新增和删除的问题。我们采用NIO的方式通信，通过selector感知连接的事件，包括数据可读、数据可写、建立连接、连接断开的事件，然后把这些交给IO线程池中的线程去处理，那么更新、新增数据和连接断开要去删除数据有可能在两个线程中去处理。如果是发布数据很快就断开，那么就有可能会出现先删除再新增。一个解决方案是新增数据时查看下是否连接还存在。<br>3.大量数据的同时插入、更新时的性能保证<br>ConcurrentHashmap在写时候采用分段锁，在读的时候不加锁，但在大量数据也遇到性能问题，改进的方案是：增加任务队列，对应的处理线程，以及对应的数据存储。这样针对同样的数据处理任务都放在同一个线程里，我们可以直接使用线程不安全容器；多线程的请求变成一个顺序的队列操作，交给任务队列处理，任务队列是需要线程安全，但是因为这里的操作主要是任务加入队列和任务从队列取出，都是简单的操作，锁冲突的情况相对之前加锁进行数据处理好多了。数据更新的线程如果需要等待更新结果，那就只要进行等待就可以了；而读取数据则一定需要等待任务执行结束后才能拿到结果。</p>
<h2 id="解决服务上下线的感知"><a href="#解决服务上下线的感知" class="headerlink" title="解决服务上下线的感知"></a>解决服务上下线的感知</h2><p>软负载的可用服务列表，当服务可用时，需要自动把服务加到服务地址列表，而服务不可用，需要自动从列表删除，这也就是上下线感知，这也是与使用硬件负载均衡需要配置服务列表的相比的一大优点<br>服务器的上下线的感知，具体有两种实现<br>1.通过客户端与服务器端的连接感知<br>无论是服务的发布者还是接收者都需要与软负载中心维持一个长连接。对于服务提供者来说，软负载中心可以通过这个长连接的心跳或者数据的发布来判断服务发布者是否在线。如果很久没有心跳或者数据的发布，则判定为不在线，那么就会取出这个发布者发布的数据。而对于新上线的发布者，通过连接建立和数据发布就实现了上线的通知。<br>这个方式有个结构的问题，即软负载中心属于旁路，也就是它不在调用链上，当软负载中心自身的负载很高时，是可能产生误判的。例如软负载中心负载压力很大，处理请求变慢，心跳数据来不及处理，会以为心跳超时而判定服务不在线，会导致原本可用的服务下线。<br>另外可能的问题是，如果服务发布者到软负载中心的网络链路有问题，而服务发布者到服务使用者本身没有问题，也会造成感知的问题，解决方案有在软负载中心的客户端增加逻辑，当收到软负载中心通知的应用下线数据时，需要服务调用者进行验证才能接收这个通知，但是这个方法带来的是对每个服务提供者的一次额外校验。<br>2.通过对于发布数据中提供的地址接口进行连接的检查<br>通过长连接的相关感知判断服务下线，不直接认定这个服务下线，而是交给另一个独立的监控应用去验证这个服务是否已经不在了，方式是通过地址、端口去进行连接验证，这种方法是有缺陷，所以还是需要服务调用者进行最终确认。</p>
<h2 id="软负载中心的数据分发的特点和设计"><a href="#软负载中心的数据分发的特点和设计" class="headerlink" title="软负载中心的数据分发的特点和设计"></a>软负载中心的数据分发的特点和设计</h2><h3 id="数据分发和消息订阅的区别"><a href="#数据分发和消息订阅的区别" class="headerlink" title="数据分发和消息订阅的区别"></a>数据分发和消息订阅的区别</h3><p>第一个差别是：消息中间件需要保证消息不丢失、每条消息都能送到消息订阅者，而软负载中心只需要保证最新的数据送到消息订阅者，不需要保证每次的数据变化都能让最终订阅者感知<br>第二个差别是：关于订阅者的集群，也就是订阅者的分组。在消息中间件中，一个集群的不同机器是分享所有消息，因为只要同一集群的一台机器去处理就好。而软负载中心不同，软负载中心维持的是大家需要的服务数据，所以需要把这个数据分发给所有机器。</p>
<h3 id="提升数据分发性能需要注意的问题"><a href="#提升数据分发性能需要注意的问题" class="headerlink" title="提升数据分发性能需要注意的问题"></a>提升数据分发性能需要注意的问题</h3><p>1.数据压缩<br>数据压缩可以降低数据量，提升网络吞吐量，使用cpu来换带宽。<br>2.全量与增量的选择<br>每次传输全量数据，逻辑简单，但是传输数据量大。使用增量，传输数据小，但实现复杂。建议刚开始数据量小时传输全量，数据量大传输增量</p>
<h2 id="针对服务化的特性支持"><a href="#针对服务化的特性支持" class="headerlink" title="针对服务化的特性支持"></a>针对服务化的特性支持</h2><h3 id="软负载特性分组"><a href="#软负载特性分组" class="headerlink" title="软负载特性分组"></a>软负载特性分组</h3><p>通过dataId和group来唯一确定数据。分组是为了隔离<br>1.根据环境区分<br>比较多的用于线下环境。在线下开发测试的环境中，需要对不同环境项目隔离和区分<br>2.分优先级的隔离<br>更多用于线上，也就是可以把提供同样的服务通过组的概念分开，也就是重要的服务使用者会有专门的组提供服务<br>关于分组，可以采用ip地址自动归组的方式</p>
<h3 id="提供自动感知以外的上下线开关"><a href="#提供自动感知以外的上下线开关" class="headerlink" title="提供自动感知以外的上下线开关"></a>提供自动感知以外的上下线开关</h3><p>1.优雅地停止应用<br>我们先从服务列表中去掉这个机器，然后等待这个机器的服务执行完成，然后再停止应用。通过指令直接从软负载中心使机器下线，是可以帮助做到这一点。<br>2.保持应用场景，用于排错<br>遇到服务的问题，可以把出问题的服务留下一台机器进行故障定位和场景分析，这时需要把这台机器从服务列表中拿下，以免有新的请求进来造成服务失败。</p>
<h3 id="维护路由规则"><a href="#维护路由规则" class="headerlink" title="维护路由规则"></a>维护路由规则</h3><p>路由规则需要统一维护，软负载中心可以管理这些数据。</p>
<h2 id="从单机到集群"><a href="#从单机到集群" class="headerlink" title="从单机到集群"></a>从单机到集群</h2><p>当系统规模不是很大时，可以使用单机加一个备用机器的方式充当软负载中心。<br>对于服务框架而言，用到的场景是服务调用，而服务本身多是无状态的，其中集群处理相对简单；对于消息中间件，如果本身存储系统不在本地，那也就是无状态的集群，如果存储在本地，还要考虑数据的迁移。而软负载中心要走向集群，需要考虑的问题有：<br>1.数据管理问题<br>软负载中心聚合了整个分布式集群中的服务地址信息，首先是信息存放的位置<br>2.连接管理问题</p>
<h3 id="数据统一管理方案"><a href="#数据统一管理方案" class="headerlink" title="数据统一管理方案"></a>数据统一管理方案</h3><p>把数据聚合信息放在同一个地方，那么也就变成了无状态；整个结构分三层：聚合数据这一层就是在管理数据；软负载中心的机器则是无状态的；最下层是数据发布者或者订阅者。此时软负载中心的机器是对等的。我们还可以对这个方案进行改进，把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；</p>
<h3 id="数据对等管理方案"><a href="#数据对等管理方案" class="headerlink" title="数据对等管理方案"></a>数据对等管理方案</h3><p>把数据分散到各个软负载中心的节点上，并且把自己管理的数据分发到其他节点上，从而保证每个节点都有整个集群的数据，并且这些节点的角色是对等的，数据发布者和数据订阅者，只需要去连软负载中心集群的任何一台机器就好，在软负载中心各个节点间会进行数据同步。同步的时候，我们没有必要每次变化都同步，我们可以批量处理更加高效，只要合并这些变化同步一次就好。一种方案是每个负载均衡节点互相同步；另一种是把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；需要同步的是数据推送数据和聚合数据机器。</p>
<h2 id="集中配置管理中心"><a href="#集中配置管理中心" class="headerlink" title="集中配置管理中心"></a>集中配置管理中心</h2><p>软负载中心保存了管理服务地址列表、路由规则、消息的订阅关系，这些数据我们可以从是否持久和是否聚合两个维度分类。<br>持久性是数据本身跟发布者的生命周期无关，典型的是持久订阅关系、路由规则、数据访问层的分库分表规则和数据库配置。非持久指的是与发布者的生命周期有关，例如服务地址列表，此外服务地址列表和订阅关系是需要聚合的，而路由关系不需要聚合</p>
<h3 id="客户端的实现和容灾策略"><a href="#客户端的实现和容灾策略" class="headerlink" title="客户端的实现和容灾策略"></a>客户端的实现和容灾策略</h3><p>客户端通过http协议与集中配置管理中心进行通信，采用长轮询的方式。建立连接并且发送请求，如果有数据，长轮询和普通轮询就会返回；如果没有数据，长轮询就会等待直到有数据或者超时。普通轮询就会直接返回。容灾的考虑，客户端有四个特性：1.数据缓存；2.数据快照；3.本地配置；4.文件格式。</p>
<h3 id="服务端的实现和容灾策略"><a href="#服务端的实现和容灾策略" class="headerlink" title="服务端的实现和容灾策略"></a>服务端的实现和容灾策略</h3><h3 id="数据库策略"><a href="#数据库策略" class="headerlink" title="数据库策略"></a>数据库策略</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/消息中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/消息中间件/" itemprop="url">消息中间件（第六章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T15:23:21+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息中间件的价值"><a href="#消息中间件的价值" class="headerlink" title="消息中间件的价值"></a>消息中间件的价值</h2><h3 id="消息中间件的定义"><a href="#消息中间件的定义" class="headerlink" title="消息中间件的定义"></a>消息中间件的定义</h3><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件</p>
<h3 id="通过示例看消息中间件对应用的解耦"><a href="#通过示例看消息中间件对应用的解耦" class="headerlink" title="通过示例看消息中间件对应用的解耦"></a>通过示例看消息中间件对应用的解耦</h3><h4 id="通过服务调用让其他系统感知事件发生的方式"><a href="#通过服务调用让其他系统感知事件发生的方式" class="headerlink" title="通过服务调用让其他系统感知事件发生的方式"></a>通过服务调用让其他系统感知事件发生的方式</h4><p>假设我们的登录系统，需要支持的一个功能是发短信给用户，如果在增加后续跟其他系统打交道的工作，会让登录系统变得十分复杂。<br>如登陆系统负责向消息中间件发送消息，而其他的系统则向消息中间件来订阅这个消息，然后完成自己的工作。</p>
<h4 id="通过消息中间件解耦服务调用"><a href="#通过消息中间件解耦服务调用" class="headerlink" title="通过消息中间件解耦服务调用"></a>通过消息中间件解耦服务调用</h4><p>从登陆系统的角度来看，这些系统都不是登录系统必须依赖的，登录系统只需要校验用户名和密码，而类似发短信系统不是登录系统必须依赖的系统。所以，我们需要解耦，服务调用会被固定格式的消息所取代。<br>通过消息中间件解耦，登录系统不需要知道有多少个系统需要知道登录成功这件事，也不用关心怎么传递给他们，只需要把登录成功这件事转化成一个消息发送到消息中间件就好。并且各个系统不受影响。</p>
<h2 id="互联网时代的消息中间件"><a href="#互联网时代的消息中间件" class="headerlink" title="互联网时代的消息中间件"></a>互联网时代的消息中间件</h2><p>JMS:Java Message Service-&gt;规范-&gt;Hornetq,ActiveMQ等产品是这个规范的实现</p>
<h3 id="如何解决消息发送的一致性"><a href="#如何解决消息发送的一致性" class="headerlink" title="如何解决消息发送的一致性"></a>如何解决消息发送的一致性</h3><h4 id="消息发送一致性的定义"><a href="#消息发送一致性的定义" class="headerlink" title="消息发送一致性的定义"></a>消息发送一致性的定义</h4><p>消息发送一致性指产生消息的业务动作与消息发送的一致。即如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了；而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去.</p>
<h4 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h4><p>JMS几个比较重要的元素：<br>Destination：消息所走的通道的目标定义，也就是消息从发送方发出后要走的通道，而不是最终接收方。<br>ConnectionFactory：用于创建连接的对象<br>Connection：连接接口，用于创建session<br>Session：会话接口，消息的发送者，消息的接收者以及消息都是由会话创建。<br>MessageConsumer：消息的消费者，用于订阅并处理消息的对象。<br>MessageProvider：消息的生产者，用于发送消息的对象<br>XXXMessage：指各种类型的对象，包括Bytemessage、MapMessage、ObjectMessage、StreamMesssage和TextMessage；<br>在jms的api接口中，有很多XA开头的类，他们是支持XA协议的接口。XA系列的接口集中在ConnectionFactory、Connection和Session上。但也会造成问题：<br>1.引入分布式事务，这会带来开销和复杂性；<br>2.对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起做分布式事务，这会造成限制（凡是参与全局事务的所有资源均应该使用其XA版。特别地，对于JDBC资源，必须使用JDBC XADataSource）。</p>
<h4 id="其他办法"><a href="#其他办法" class="headerlink" title="其他办法"></a>其他办法</h4><p>简单的方案不能保证一致性，但是出现问题的概率也不大；即便做到业务操作都支持XA，如果引入二阶段提交的分布式事务，则有点重。<br>简化流程：<br>1) 业务处理应用首先把消息发给消息中间件，标记消息的状态为待处理.<br>   (2) 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息.<br>   (3)消息中间件返回消息处理的结果，仅是入库的结果，结果是成功或者失败.<br>   (4)业务方收到消息中间件返回的结果并进行处理:<br>a) 如果收到的结果是失败，那么就放弃业务处理，结束<br>b) 如果收到的结果是成功，则进行业务自身的操作<br>   (5)业务操作完成，把业务操作的结果发送给消息中间件<br>   (6)消息中间件收到业务操作结果，根据结果进行处理<br>a) 如果业务失败，则删除消息存储中的消息，结束<br>b)如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递。<br>最终一致性方案的补偿流程:<br>(1)消息中间件询问状态为待处理的消息对应业务操作结果<br>(2)应用即消息发布者对业务操作检查操作结果<br>(3)发送业务处理结果给消息中间件<br>(4)消息中间件更新消息状态，业务成功，消息状态为待发送；业务失败则消息删除</p>
<h3 id="如何解决消息中间件与使用者的强依赖关系"><a href="#如何解决消息中间件与使用者的强依赖关系" class="headerlink" title="如何解决消息中间件与使用者的强依赖关系"></a>如何解决消息中间件与使用者的强依赖关系</h3><p>如果消息系统出现问题，就会导致业务操作无法继续操作。解决的思路如下：<br>1.提供消息中间件系统的可靠性，但是没办法办证百分百可靠；<br>2.对于消息中间件系统中影响业务的部分，其可靠性与业务系统一样；<br>3.提供弱依赖的功能；<br>对于思路一：我们无法保证百分百可靠；<br>对于思路二：把消息中间件所需要的消息表与业务数据表放到同一个业务数据库，业务操作和写入消息作为一个本地事务完成，然后再通知消息中间件有消息可以发送，解决一致性，也可以消息中间件定时去轮询业务数据库找到需要发送的消息，取出内容后进行发送。这个会有三个影响：<br>1.需要业务自己的数据库去承载消息数据；<br>2.需要消息中间件访问业务数据库；<br>3.需要业务操作的对象是数据库，或者说是支持事务的存储，必须这个存储能够支持消息中间件的需求。<br>所以我们有个折中的操作：消息中间件不再直接与业务数据库打交道，将业务操作、写入消息，轮询消息等全部放到业务应用。<br>加一个本地磁盘作为一个消息存储，如果消息中间件崩溃，我们可以把本地磁盘作为存储消息的地方。这有两种用法：1.作为一致性发送消息的解决方案的容灾手段，，平时不工作，出问题才切换。2.直接使用该方式；<br>最后我们看下业务操作与消息一致性带来的两个限制：<br>1.需要确定要发送的消息内容；2.需要实现对业务的检查</p>
<h3 id="消息模型对消息的接收的影响"><a href="#消息模型对消息的接收的影响" class="headerlink" title="消息模型对消息的接收的影响"></a>消息模型对消息的接收的影响</h3><p>在JMS中，有Queue（点对点）和Topic（发布/订阅）两种模型</p>
<h4 id="JMS-Queue模型"><a href="#JMS-Queue模型" class="headerlink" title="JMS Queue模型"></a>JMS Queue模型</h4><p>应用1和应用2发送消息到JMS服务器，这些消息根据到达的顺序形成一个队列，应用3和应用4进行消息的消费;如果Queue里面的消息被一个应用处理了，那么连接到JMS Queue上的另一个应用是收不到这个消息的。即连接到这个JMS Queue上的应用共同消费了所有的消息。消息从发送端发送出来时不能确定最终会被哪个应用消费，但是可以明确的是只有一个应用会去消费这条消息，Peer To Peer方式(PTP)</p>
<h4 id="JMS-Topic模型"><a href="#JMS-Topic模型" class="headerlink" title="JMS Topic模型"></a>JMS Topic模型</h4><p>和Queue模型的最大区别在于消息接收的部分，在该模型中，接收消息的应用3和应用4是可以独立收到所有到达Topic的消息的，Pub/Sub方式</p>
<h4 id="JMS中客户端连接的处理和带来的限制"><a href="#JMS中客户端连接的处理和带来的限制" class="headerlink" title="JMS中客户端连接的处理和带来的限制"></a>JMS中客户端连接的处理和带来的限制</h4><p>在使用JMS时，每个Connection都有一个ClientId，用于标记的唯一性。如果两个应用共建立三个连接，每个连接都会收到所有发送到topic的消息。</p>
<h4 id="我们需要什么样的消息模型"><a href="#我们需要什么样的消息模型" class="headerlink" title="我们需要什么样的消息模型"></a>我们需要什么样的消息模型</h4><p>我们要满足的需求为：<br>消息发送方和接收方都是集群；<br>同一个消息的接收方可能有多个集群进行消息的处理；<br>不同集群对于同一条消息的消息不能互相干扰；<br>现在我们需要每个集群使用topic模式，然后集群的内部使用queue模式；我们可以引入clusterId，用这个id标识不同的集群；集群内各个应用连接使用这个clusterid。当服务器端进行调度时，在不同的集群之间独立投递，而拥有相同的clusterId的共同消费这个消息。<br>还有一种思路是将JMS的topic和queue级联使用，首先最顶层是JMS topic，中间有一层消息中转层，再通过JMS queue，最下层是集群内消费使用。<br>缺点是级联方式过于繁重，处理复杂，好处是使用jms实现。</p>
<h3 id="消息订阅者订阅消息的方式"><a href="#消息订阅者订阅消息的方式" class="headerlink" title="消息订阅者订阅消息的方式"></a>消息订阅者订阅消息的方式</h3><p>分为持久订阅和非持久订阅<br>非持久化订阅指的是消息接收者和消息中间件之间的消息订阅关系的存续，与消息接收者自身运行的状态有直接的关系。<br>持久化订阅指的是消息订阅关系一旦建立，除非应用显式地取消订阅关系，否则订阅关系将一直存在，如果消息接收者应用停止，那么消息会保留，等待下次应用启用后投递给消息接收者。</p>
<h3 id="保证消息可靠性的做法"><a href="#保证消息可靠性的做法" class="headerlink" title="保证消息可靠性的做法"></a>保证消息可靠性的做法</h3><p>持久订阅能够保证消息的可靠性，消息从发送端到接收端，中间需要经历三个阶段可靠：<br>1.消息发送者把消息发送给消息中间件；<br>2.消息中间件把消息存入消息存储；<br>3.消息中间件把消息投递给消息接收端；</p>
<h4 id="消息发送端的可靠"><a href="#消息发送端的可靠" class="headerlink" title="消息发送端的可靠"></a>消息发送端的可靠</h4><p>发送者需要把消息的发送结果准确的传给应用，应用才能进行相关的业务操作。消息从发送者发送到消息中间件，只有消息中间件及时明确地返回成功，才能确认消息可靠地到达消息中间件。返回错误、异常或者超时，都可以认为这个动作失败。</p>
<h4 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h4><p>1.实现基于文件的消息存储<br>主要把消息直接存储在本地磁盘，不需要对额外独立存储。ActiveMQ（kaha db），KahaDB是基于文件的本地数据库储存形式<br>2.使用数据库作为消息存储<br>3.基于双机内存的消息存储<br>磁盘IO的关系，性能会受到影响，内存的速度远超磁盘，但断电会失去数据，正常情况下，消息持久存储不工作，一旦一个机器故障，会停止另一台的写，并把数据写入数据持久存储。</p>
<h4 id="消息系统的扩容"><a href="#消息系统的扩容" class="headerlink" title="消息系统的扩容"></a>消息系统的扩容</h4><p>1.消息中间件自身如何扩容<br>消息中间件本身没有持久态，扩容比较容易，只需要让消息发送者和消息订阅者能够感知到有新的消息中间件机器加入了集群。同一个存储区分存储的消息来自哪个消息中间件应用：增加一个server字段。<br>2.消息存储的扩容处理<br>优势：1.不用保证消息的顺序；2.提供从服务端对消息投递的方式，不支持主动获取消息。<br>首先，消息发送到消息中间件，消息中间件将消息入库，所以消息中间件一定知道消息存在哪。<br>其次，由于内存中进行调度的消息数量有限，因此我们会调度存在数据库的消息，这个调度必然会跨所有库和所有表，需要投递的消息会把相关索引消息加载到内存中，内存调度消息也自然有了存储节点的消息。</p>
<h4 id="消息投递的可靠性保证"><a href="#消息投递的可靠性保证" class="headerlink" title="消息投递的可靠性保证"></a>消息投递的可靠性保证</h4><p>1.消息投递简介<br>消息中间件需要显示地收到接收者确认消息处理完毕，才能删除消息。<br>2.投递处理的优化<br>投递处理第一个可优化的是在进行投递时一定要采用多线程方式处理，每个线程处理一条消息时，会得到需要接收该消息的订阅者集群Id列表，然后从每个订阅者集群Id里选择一个连接来处理，消息投递后会更新消息状态，然后统一更新消息表中的消息状态。如果订阅者集群有一个很慢的订阅者，负责投递的所有线程会慢慢堵死，都需要等待这个慢的订阅者返回。<br>我们还可以采用，采用异步的方式，把消息返回处理的工作放到另外的线程池中操作，保证投递的环节不会被堵死，返回的结果可以放在内存中，等待其他线程进行处理。<br>其次我们还要优化，即一个应用有多个订阅者订阅同样的消息，如果不加以优化，会发送多次同样的消息，我们的优化是：单机共享连接；消息只发送一次，然后传到单机多订阅者生成多个处理实例。</p>
<h3 id="订阅者视角的消息重复的产生和应对"><a href="#订阅者视角的消息重复的产生和应对" class="headerlink" title="订阅者视角的消息重复的产生和应对"></a>订阅者视角的消息重复的产生和应对</h3><h4 id="消息重复产生的原因"><a href="#消息重复产生的原因" class="headerlink" title="消息重复产生的原因"></a>消息重复产生的原因</h4><p>第一类原因是消息发送方重复发送消息<br>1.消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，这是消息中间件出现了问题，导致应用端没有收到消息发送成功的返回，因而进行了重复的发送。<br>2.消息中间件由于负载比较高变得比较慢，成功把消息存储到消息存储后，返回成功结果超时。<br>3.消息中间件收到消息存储后，但由于网络原因，导致应用端收不到消息，进行重试。<br>解决的办法有通过消息id来标识<br>第二类原因是消息中间件对外投递时发生了重复<br>1.消息中间件投递由于网络原因，消息中间件没能收到反馈消息；<br>2.消息接收者处理时间比较长，超时<br>3.消息中间件出现问题，没收到结果消息<br>4.消息存储出现故障，没能更新状态<br>可以采用分布式事务来解决，但是不过这种方式比较复杂，成本也比较高；另一种方式是要求消息消费者来处理这种重复的方式，也就是要求这是幂等操作。</p>
<h4 id="JMS消息确认与消息重复的关系"><a href="#JMS消息确认与消息重复的关系" class="headerlink" title="JMS消息确认与消息重复的关系"></a>JMS消息确认与消息重复的关系</h4><p>AUTO_ACKNOWLEDGE<br>自动确认，当JMS消息接收者接收到消息，JMS的客户端会自动进行确认。但是确认时消息还没来得及处理或者还未处理完成，所以这种确认方式也是不可靠<br>CLIENT-ACKNOWLEDGE<br>客户自己确认的方式，也就是客户端如果要确认消息处理成功，告诉服务器端确认消息，需要主动调用Message接口的acknowledge方法进行消息接收成功的调用；<br>DUPS_OK_ACKNOWLEDGE<br>这种方式是消息接收方的消息处理函数执行结束后确认，一方面保证消息一定是处理结束后才确认，另一方面也不需要客户端调用acknowledge接口<br>消息接收者接收的消息会出现下面两张情况：<br>1.at lease once<br>采用CLIENT-ACKNOWLEDGE或者DUPS_OK_ACKNOWLEDGE并且在消息处理前没有确认的话，就可能产生这种现象。<br>2.at most once<br>采用AUTO_ACKNOWLEDGE或者CLIENT-ACKNOWLEDGE并且在接收消息后立刻确认的情况</p>
<h3 id="消息投递的其他属性支持"><a href="#消息投递的其他属性支持" class="headerlink" title="消息投递的其他属性支持"></a>消息投递的其他属性支持</h3><p>1.消息优先级<br>一般情况下消息先到先投递，消息的优先级属性可以根据优先级确定投递顺序。<br>2.订阅者消息处理顺序和分级订阅<br>消息的多个订阅者之间是独立的，它们对消息的处理并不会相互造成影响。但对于一些场景，对于同样的消息，可能会希望有些订阅者处理结束后再让其他订阅者处理。另一种方案是分级订阅。<br>把优先接收者和一般接收者分开，优先接收者处理成功后主动把消息投递到另外的消息中间件，然后一般接收者接收新产生的消息。<br>3，自定义属性<br>消息自身的创建时间、类型、投递次数等属性属于基础属性，在消息体外，自定义属性会很方便，这种自定义属性类似http的header<br>4.局部顺序<br>局部顺序是指在众多消息中，和某件事情有关的多条消息之间有顺序，而多件事情之间的消息没有顺序。比如我们可以不必保持多个人之间的交易顺序，但是对同一个交易产生的变化需要保持其顺序。<br>比如线上的交易的消息状态依次生死：创建、付款、发货、确认（Kafka发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton和key是可选的。如果你指定了partition，那就是所有消息发往同1个partition，就是有序的。并且在消费端，Kafka保证，1个partition只能被1个consumer消费。）</p>
<h3 id="保证顺序的消息队列的设计"><a href="#保证顺序的消息队列的设计" class="headerlink" title="保证顺序的消息队列的设计"></a>保证顺序的消息队列的设计</h3><p>同一消息订阅者处理不同消息，成功与否跟消息的内容有关（比如手机充值，我们可以看到充值成功与否跟手机号码合法化有关），现在讨论依赖消息订阅者的状态有关（数据复制，只要源数据库可用，则复制一定成功）。<br>在这样场景下，一个吞吐量达且支持顺序的消息中间件是很有价值的，数据变更平台就是这样的一个场景。在这里，由原来的push模式变为pull模式，为了让消息接收者更好的控制消息的接收和处理，消息中间件逻辑也得到了简化。具体实现是消息存储写到文件中，采用顺序写入，消息必须按顺序消费，所以一个消息接收者在每一个他所接收的消息队列上有一个当前消费的位置，之前的位置代表已经消费的消息，不同消费者维护分别维护自己的指针，可以通过指针的回溯来进行消息的补发。接收端拥有比较大的自主权。</p>
<h4 id="单机多序列问题和优化"><a href="#单机多序列问题和优化" class="headerlink" title="单机多序列问题和优化"></a>单机多序列问题和优化</h4><p>单机多队列的隔离完成了对消息的有序支持。如果单的队列数量数量多，性能会下降很大，原因是队列数量大时，写就接近随机写。改进措施有按顺序写入，然后根据队列做个索引。<br>带来的好处是：<br>1.队列轻量化，单个队列数据量少<br>2.对磁盘访问串行化，避免竞争<br>缺点是：<br>1.写虽然是顺序写，但是读是随机读<br>2.读先读逻辑队列在读物理队列，增加开销<br>3.需要保证物理队列与逻辑队列的完全一致。编程复杂</p>
<h4 id="解决本地消息存储的可靠性"><a href="#解决本地消息存储的可靠性" class="headerlink" title="解决本地消息存储的可靠性"></a>解决本地消息存储的可靠性</h4><p>采用消息同步复制的方式解决可靠性的问题<br>把单个消息中间件变为主（master）备（slave）两个节点，slave订阅master所有消息，用来消息备份。不过需要注意这是一个异步操作，slave订阅收到的消息会比master略少一点，存在着丢失信息的可能，类似mysql的replication<br>同样是把单个节点扩展到Master/Slave节点，但是采用的是同步复制，而不是订阅。对于消息更为严格的场景，第二种更为安全可靠</p>
<h4 id="如何支持队列的扩容"><a href="#如何支持队列的扩容" class="headerlink" title="如何支持队列的扩容"></a>如何支持队列的扩容</h4><p>基本的策略是消息发送者能够知道应该把消息写入迁移到新的队列中，并且也让消息订阅者知道，当前队列消费完消息后要去新的队列去消费消息<br>有几个关键点：<br>1.原队列在开始扩容会有个标记，即便有新的消息进来，也不再接收<br>2.通知消息发送端发送新的队列位置<br>3.对于消息接收端，对原来队列的定位会收到新旧两个位置，当旧数据的数据接收完毕后，则只会关心新队列的位置</p>
<h3 id="push和pull方式对比"><a href="#push和pull方式对比" class="headerlink" title="push和pull方式对比"></a>push和pull方式对比</h3><p>1.从数据传输状态；push保存在服务器端，pull保存在消费端<br>2.从传输失败，重试；push要维护每次传输状态，pull不需要<br>3.数据传输的实时性；push非常实时，pull默认的短轮询方式的实时依赖性依赖于pull间隔时间，间隔越大，实时性越低，长轮询的方式实时性与pull一致。<br>4.从流控机制；push方式服务器需要根据订阅者的消费能力做流控，pull方式消费端可以根据自身消费能力决定是否去pull消息</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/数据访问层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/23/数据访问层/" itemprop="url">数据访问层（第五章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T17:24:31+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据库从单机到分布式的挑战和应对"><a href="#数据库从单机到分布式的挑战和应对" class="headerlink" title="数据库从单机到分布式的挑战和应对"></a>数据库从单机到分布式的挑战和应对</h2><h3 id="从应用使用单机数据库开始"><a href="#从应用使用单机数据库开始" class="headerlink" title="从应用使用单机数据库开始"></a>从应用使用单机数据库开始</h3><p>各种类似ODBC、JDBC的封装、以及ORM的封装都很成熟，我们这里重点考虑数据量和访问量增大的时候，系统要面临的问题和相应的解决方案。</p>
<h3 id="数据库垂直拆分和水平拆分的困难"><a href="#数据库垂直拆分和水平拆分的困难" class="headerlink" title="数据库垂直拆分和水平拆分的困难"></a>数据库垂直拆分和水平拆分的困难</h3><p>垂直拆分会带来的影响：<br>1.单机的ACID保证会被打破；要么放弃单机事务，修改实现，要么引入分布式事务。<br>2.一些join操作会变得比较困难，因为数据已经在两个数据库中，所以不是很方便利用数据库自身的join；<br>3.靠外键进行约束的场景会受限制；<br>水平拆分会带来的影响：<br>1.同样可能ACID会被打破；<br>2.同样join可能会受到影响；<br>3.靠外键进行约束的场景会受限制；<br>4.依靠单库生成递增唯一标识会受影响；<br>5.针对单个逻辑上的表的查询要跨库；</p>
<h3 id="多机事务如何处理"><a href="#多机事务如何处理" class="headerlink" title="多机事务如何处理"></a>多机事务如何处理</h3><h4 id="分布式事务知识"><a href="#分布式事务知识" class="headerlink" title="分布式事务知识"></a>分布式事务知识</h4><h5 id="分布式事务模型与规范"><a href="#分布式事务模型与规范" class="headerlink" title="分布式事务模型与规范"></a>分布式事务模型与规范</h5><p>X/Open组织（the open group）提出了分布式事务规范-XA，分布式事务处理模型-X/Open DTP（distributed transaction processing reference model）模型。定义了三个组件–application  program、Resource manager和transaction manager。<br>AP:应用程序，它定义了事务的边界，并定义了构成该事务的应用程序的特定操作。<br>RM：资源管理器，可以理解为DBMS系统，或者消息服务器管理系统。AP通过RM对资源进行控制，资源必须实现XA接口。资源管理器提供了存储共享资源的支持。<br>TM：事务管理器，负责协调和管理事务，提供给AP接口用来管理RM。事务管理器向事务指定标识，监视他们的进程，并负责处理事务的完成和失败。事务分支标识（XID）用TM指定，标识一个RM的全局事务和特定分支。他是TM日志和RM日志之间的相关标识。两阶段性提交用到XID<br>AP和TM、RM通信，TM和RM之间互相通信，通过XA接口。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交。<br>提交阶段<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)。<br>首先是会有很多日志的操作，以及网络交互的增多引入事务管理器的开销导致整体开销会大。所以在进行垂直或水平拆分时，必要时才引入二阶段式提交。</p>
<h4 id="大型网站一致性理论基础理论–CAP-BASE"><a href="#大型网站一致性理论基础理论–CAP-BASE" class="headerlink" title="大型网站一致性理论基础理论–CAP/BASE"></a>大型网站一致性理论基础理论–CAP/BASE</h4><p>CAP的含义：<br>C：Consistency:一致性，所有节点在同样的时间读到同样的数据。这就是数据上的一致性，也就是当数据写入成功后，所有的节点都能同时看到这个新的数据<br>A：Availability：保证无论是成功还是失败，每个请求都能够收到一个反馈。这就是数据的可用性，这里重点是系统要有响应。<br>P：Partition Tolerance：即便系统有部分问题或者消息丢失，但系统依然能够继续运行。这被称为分区容忍性，也就是系统的一部分出现问题，系统仍能够继续工作。<br>分布式不能同时满足这三项，也就是我们可以选择两个来提升，但另外一个将会受到损失。在系统进行设计和权衡时，也就是在选择CA、CP、AP<br>选择CA：放弃分区容忍性，加强一致性和可用性。传统单机数据库的选择；<br>选择AP：放弃一致性，很多NOSQL系统的选择；<br>选择CP：放弃可用性，这种情况下可用性会很低，网络的问题会让整个系统不可用<br>在分布式系统中，我们一般选择增强可用性和分区容错性而选择牺牲一致性。<br>BASE(Base available 基本可用 soft state 软状态 eventually  consistent 最终一致性 )<br>基本可用指的是分布式系统发生故障，允许损失部分可用性。<br>软状态指的是接受一段时间状态不同步<br>最终一致性指的是强调的是系统中的所有数据副本，在经过一段时间的同步后，最终能够达到一致的状态。</p>
<h4 id="paxos协议"><a href="#paxos协议" class="headerlink" title="paxos协议"></a>paxos协议</h4><h4 id="集群内数据一致性的算法实例"><a href="#集群内数据一致性的算法实例" class="headerlink" title="集群内数据一致性的算法实例"></a>集群内数据一致性的算法实例</h4><p>quorum，它是用来权衡分布式系统的数据一致性和可用性的。<br>N：数据复制节点数量<br>R：成功读操作的最小节点数<br>W：成功写操作的最小节点数<br>如果R+W&gt;N，是可以保证强一致性，而如果R+W&lt;=N，则保证最终一致性。<br>vector clock的思路是对同一份数据的每次修改都要加上&lt;修改者，版本号&gt;，用来记录修改者信息以及版本号。Vector Clock能解决分布式系统多版本合并的问题，但是对于确实发生冲突的版本，它无法合并，而需要用户自己去做合并。</p>
<h2 id="多机的sequence问题与处理"><a href="#多机的sequence问题与处理" class="headerlink" title="多机的sequence问题与处理"></a>多机的sequence问题与处理</h2><p>当转变为水平分库以后，原来单库的sequence以及自增的id都需要改变。我们可以从两个方向去考虑解决这个问题：唯一性和连续性。<br>如果只考虑唯一性，可以考虑用uuid（ip，机器名，mac，时间，本机计数器）生成，但是会导致分布式系统的连续性不好。<br>如果考虑连续性，我们可以把所有的ID集中放在一个地方进行管理，对每一个ID序列进行独立管理，每台机器使用Id都从这个地方去取。这里有几个问题需要解决：<br>性能问题：每次远程取Id会有资源损耗。一种办法是一次取一段Id，然后缓存到本地，这样就不用每次再去取。但也会带来问题，比如，如果机器宕机，那么取的一段Id将不可用。<br>生成器稳定问题：Id生成器是无状态集群，其可用性要靠整个集群保证<br>存储问题：底层存储的选择空间比较大，需要根据不同类型来进行对应的容灾方案。下面介绍两种方式：<br>第一种是底层有一个独立存储记录每个Id序列当前的最大值，并控制并发更新。这样一来生成逻辑就比较简单。第二种是去掉Id生成器，把相关逻辑嵌入到需要生成Id的应用中，而在每个应用中完成生成器要做的工作，即读取可用的ID或者Id段。因为没有中心控制节点，我们不希望生成器之间有通信，所以id并不是严格按照进入数据库的顺序增大。</p>
<h2 id="应对多机的数据查询"><a href="#应对多机的数据查询" class="headerlink" title="应对多机的数据查询"></a>应对多机的数据查询</h2><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><p>解决方案有：1.把原来join操作分成多次数据库操作。2.数据冗余，对一些常用的信息进行冗余，这样就可以把原来的join变为单表查询。3.借助外部系统如搜索引擎来解决。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>如果要对分库后的单库做外键约束，就要求分库后的每个单库都是数据内聚，否则只能在应用层的判断和容错。</p>
<h3 id="跨库查询的问题及解决"><a href="#跨库查询的问题及解决" class="headerlink" title="跨库查询的问题及解决"></a>跨库查询的问题及解决</h3><h4 id="数据库分库分表的演化"><a href="#数据库分库分表的演化" class="headerlink" title="数据库分库分表的演化"></a>数据库分库分表的演化</h4><p>合并查询问题的根源是我们在进行水平分库分表后，把一张表分成了多张物理上的表。我们举个例子，我们有两个库，每个库存了两张用户表。从逻辑上这些表应该一起储存，但随着访问量和数据量的增多，需要经历分库分表，此时，一张逻辑表对应多张物理表，在应用中，对这张逻辑表的查询就要做跨库的跨表的合并了。</p>
<h4 id="从具体例子看分库分表的问题"><a href="#从具体例子看分库分表的问题" class="headerlink" title="从具体例子看分库分表的问题"></a>从具体例子看分库分表的问题</h4><p>如果我们查询一个省的符合年龄的用户。在单表时，这是一个普通的查询。而分库分表后，我们可能会遇到麻烦。如果我们按地域划分，那么问题就退化成为单库单表问题。但是如果我们查询多个省份，这就产生了跨库问题，就需要再查询结果取个并集。但还有更为复杂的操作，如：</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>即多个数据源的数据查询出来，在应用层做排序，如果从数据库查出来的数据已经排好序，那么，只需要做多路归并排序就好；如果查询的数据没有排序，则需要做全排序；</p>
<h5 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a>函数处理</h5><p>使用max min sum count函数，即对多个数据源的值进行函数处理。</p>
<h5 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h5><p>从多个数据源查询时，需要把SQL改为Sum和count，然后对多个数据源求sum和count。</p>
<h5 id="非排序分页"><a href="#非排序分页" class="headerlink" title="非排序分页"></a>非排序分页</h5><p>这里面有两种策略，一种是同等步长的在多个数据源上分页处理；另一种是同等比例地分页处理。同等步长指的是分页中的每一页，来自不同数据源的记录数是一样的；同等比例值得是，来自不同数据源的数据数，占这个数据源符合条件的数据总数的比例是一样的。<br>打个比方，有两个数据源，符合条件的数据数分别有16和8，一页的数量为4，同等步长指的是每次取数据源一2个，数据源二2个。如果是同比例，假设一页数量6，那么是数据源一4个，数据源二2个。因此用相同的次数获取完。</p>
<h5 id="排序分页"><a href="#排序分页" class="headerlink" title="排序分页"></a>排序分页</h5><p>如果我们要取第n页数据，我们需要从各个数据源取前n页数据，然后归并排序。也就是越往后翻页，压力越大。在访问量很大的情况下，我们需要尽量避免这种情况，尤其是排序需要翻很多页的时候。</p>
<h2 id="数据层的设计和实现"><a href="#数据层的设计和实现" class="headerlink" title="数据层的设计和实现"></a>数据层的设计和实现</h2><h3 id="如何对外提供数据访问层功能"><a href="#如何对外提供数据访问层功能" class="headerlink" title="如何对外提供数据访问层功能"></a>如何对外提供数据访问层功能</h3><h4 id="对外提供数据访问层方式"><a href="#对外提供数据访问层方式" class="headerlink" title="对外提供数据访问层方式"></a>对外提供数据访问层方式</h4><p>第一种方式是为用户提供专有API；第二种通用的方式是一般通过jdbc访问数据库。还有是通过基于orm或者类orm接口的方式，如ibatis、hibernate、spring jdbc。</p>
<h4 id="不同提供方式之间合并查询场景下的对比"><a href="#不同提供方式之间合并查询场景下的对比" class="headerlink" title="不同提供方式之间合并查询场景下的对比"></a>不同提供方式之间合并查询场景下的对比</h4><p>比如分页排序，orm会生成很多无效的对象然后丢弃，而jdbc只需要生成响应的对象。再获取后面页内容时，直接基于jdbc的的优势比较明显</p>
<h3 id="按照数据层流程的顺序看数据层设计"><a href="#按照数据层流程的顺序看数据层设计" class="headerlink" title="按照数据层流程的顺序看数据层设计"></a>按照数据层流程的顺序看数据层设计</h3><h4 id="sql解析阶段的处理"><a href="#sql解析阶段的处理" class="headerlink" title="sql解析阶段的处理"></a>sql解析阶段的处理</h4><p>通过sql的解析可以获取表名、字段、where条件，根据参数规则确定目标数据源的连接。</p>
<h4 id="规则处理阶段"><a href="#规则处理阶段" class="headerlink" title="规则处理阶段"></a>规则处理阶段</h4><p>1.采用固定的哈希算法作为规则<br>根据某个字段（例如用户id）取模，然后将数据分散到不同的数据库或表中。除了会根据id取模，还会根据时间维度，例如（天，星期，月，年）等来存储数据，这一般用于数据产生后日期不再修改的场景，否则就要涉及数据迁移。时间取模多用于日志类和其他时间维度密切相关的场景。通常将周期性数据放在一起，这样进行数据备份，迁移或者现有的数据清空都会很方便。 固定哈希的规则和设置都比较简单，但是扩容比较复杂。<br>2.一致性哈希算法<br>一致性哈希所带来的最大变化是把节点的哈希值变为一个范围，而不在是离散的。在一致性哈希中，我们会把哈希值范围定的非常大，然后把这个范围分配给现在节点。如果有新节点加入，那么这个新节点会从原来某个节点分管一部分哈希值。如果这个节点退出，那么这个节点管理的哈希值会分配给下一个节点。但一致性哈希会导致负载不均衡，比如不管是新加一个节点还是减少一个节点，他能造成的影响的范围只有他自己和另外一个节点。<br>3.虚拟节点对一致性哈希的改进<br>4个物理节点可以变成很多个虚拟节点，每个虚拟节点支持连续的哈希环上的一段。而这时如果加入一个物理节点，就会相应加入很多虚拟节点，这些新的虚拟节点是相对均匀地插入到整个哈希环上，这样，就可以很好的分担现有物理节点的压力了；如果减少一个物理节点，对应的很多虚拟节点就会失效，这样，就会有很多剩余的虚拟节点来承担之前虚拟节点的工作，但是对于物理节点来说，增加的负载相对是均衡的。<br>4.映射表与规则自定义计算方式<br>映射表是根据分库分表字段的值的查表法来确定数据源的方法，一般对热点数据的特殊处理，或者在一些场景下对完全不符合规律的规则进行补充。<br>最后定义的计算方式是最灵活的方式，它已经不算是以配置的方式做规则，而是通过复杂的函数来解决数据访问规则，扩展性最强。<br>举例来说，我们id取模分成四个库，然后对于热点数据，单独放到一个库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( id  <span class="keyword">in</span> hotest)&#123;</div><div class="line">  <span class="built_in">return</span> 4;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> id%4;</div></pre></td></tr></table></figure></p>
<h4 id="为甚么要改写sql"><a href="#为甚么要改写sql" class="headerlink" title="为甚么要改写sql"></a>为甚么要改写sql</h4><p>如何设定规则，一般原则是分库后尽量避免跨库查询。举商品为例，我们可以根据商品id取模或者一致性哈希分库，但同个卖家多个商品可能涉及到跨库。如果以卖家id分库那么根据商品id查询就麻烦了，因为不知道商品在哪个库中。具体采用哪种分库需要综合考虑。除了根据规则确定数据源，如果是分表的话，表明还不一样，一般在逻辑表加自增后缀。还有索引名和跨库计算平均值。</p>
<h4 id="如何选择数据源"><a href="#如何选择数据源" class="headerlink" title="如何选择数据源"></a>如何选择数据源</h4><p>在User进行分库分表后，我们会给分库提供一个备库，也就是原来的一个数据库变为一个数据库矩阵，分库就是把数据分到不同的数据分组。除了决定访问哪个数据库组以外，还需决定是分组的哪个库。这些库一般是一写多读，要根据sql的特点（读或者写）以及库的权重规则，计算sql请求访问的数据库。</p>
<h4 id="执行sql和结果处理阶段"><a href="#执行sql和结果处理阶段" class="headerlink" title="执行sql和结果处理阶段"></a>执行sql和结果处理阶段</h4><h4 id="实战经验分享"><a href="#实战经验分享" class="headerlink" title="实战经验分享"></a>实战经验分享</h4><p>1.复杂的连接管理<br>2.三层数据的选择和支持</p>
<h3 id="独立部署的数据库访问层实现方式"><a href="#独立部署的数据库访问层实现方式" class="headerlink" title="独立部署的数据库访问层实现方式"></a>独立部署的数据库访问层实现方式</h3><p>从数据库的物理部署上可以分为jar包和proxy模式，如果是proxy模式的话，那么客户端和proxy之间的协议有数据库协议和私有协议。</p>
<h3 id="读写分离的挑战和应对"><a href="#读写分离的挑战和应对" class="headerlink" title="读写分离的挑战和应对"></a>读写分离的挑战和应对</h3><p>通过读写分离的方案，可以分担主库的读压力。这里面存在一个数据复制问题，也就是把主库（master）的数据复制到备库（slave）去。</p>
<h4 id="主库从库非对称场景"><a href="#主库从库非对称场景" class="headerlink" title="主库从库非对称场景"></a>主库从库非对称场景</h4><p>1.数据结构相同，多从库对应一主库的场景<br>mysql的replication可以解决这个问题，并且延迟比较小。在多从库对应一主库的情况下，业务应用只要根据自身的业务特点，把对数据不敏感的读切换到备库进行即可。首先来看slave，slave采用PC server，和Mysql的方案比较划算的。对于一个主库，需要多台采用mysql的PC Servcer对应原来master中的一部分数据，也就是进行了分库。<br>数据复制有两种方式：<br>比较优雅的方式是通过数据库的日志来进行数据复制；<br>比较不优雅的方式是应用通过数据层访问数据库，通过消息系统对数据库的更新送出消息通知，数据同步服务器获得消息通知后会进行数据的复制工作。分库规则则负责在读数据和数据同步服务器更新分库时让数据层知道分库规则。数据同步服务器和DB主库的交互方式，主要根据修改或者新增的数据主键来获取内容，采用行复制的功能。<br>2.主备分库方式不同的数据复制<br>数据读写分离一般采取的是对称复制，也就是镜像，但也有一些场景下进行非对称复制。这里指的非对称复制是指源数据和目标数据不是镜像规则。打个比方，我们订单可以按照买家进行分库，把所有订单分到四个库中，这保证了一个买家的订单都在同一个库里，但是卖家却不在同一个库中，因而要进行跨库查询。我们可以做一个备库，按照卖家id来查询。这时候需要控制数据的分发，而不是简单地进行镜像复制。<br>3.引入数据变更平台<br>引入Extractor和Applier，Extractor负责把数据源变更的信息加入到数据分发平台中，而Applier的作用是把这些变更应用到相应的目标上，中间的数据分发平台中是由多个管道组成，进入到数据分发平台的变更信息就是标准化、结构化的数据了。例如MySQL推出Applier,可实时复制数据到Hadoop</p>
<h4 id="如何做到数据平滑迁移"><a href="#如何做到数据平滑迁移" class="headerlink" title="如何做到数据平滑迁移"></a>如何做到数据平滑迁移</h4><p>最大挑战是，在迁移的过程中又会有数据的变化(因为很多应用不能接受长时间的停机)，可以考虑的方案是在开始进行数据迁移时记录增量的日志，在迁移结束后，再对增量的变化进行处理，在最后,可以要把要被迁移的数据的写暂停，保证增量日志都处理完毕后，再切换规则，放开所有的写，完成迁移工作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/服务框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/21/服务框架/" itemprop="url">服务框架（第四章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T19:56:11+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网站功能持续丰富后的困境与应对"><a href="#网站功能持续丰富后的困境与应对" class="headerlink" title="网站功能持续丰富后的困境与应对"></a>网站功能持续丰富后的困境与应对</h2><p>网站的功能主要集中在几个大应用上，而且这些应用都直接访问底层的服务，例如数据库、缓存、搜索引擎、分布式存储。随着网站规模扩大，开发人的增多，每个应用变得复杂、臃肿。</p>
<h3 id="把应用拆小"><a href="#把应用拆小" class="headerlink" title="把应用拆小"></a>把应用拆小</h3><p>把庞大的应用拆成多个。这样的好处是相对较快的完成，但是仍然存在一些问题。一方面是数据库的连接数的压力还在，其次是代码的重复问题。</p>
<h3 id="服务化方案"><a href="#服务化方案" class="headerlink" title="服务化方案"></a>服务化方案</h3><p>我们在原来的应用和底层的数据库、缓存系统、文件系统等系统之间增加了服务层。</p>
<h2 id="服务框架的设计和实现"><a href="#服务框架的设计和实现" class="headerlink" title="服务框架的设计和实现"></a>服务框架的设计和实现</h2><h3 id="应用从集中式走向分布式所遇到的问题"><a href="#应用从集中式走向分布式所遇到的问题" class="headerlink" title="应用从集中式走向分布式所遇到的问题"></a>应用从集中式走向分布式所遇到的问题</h3><p>要把单层Web应用的结构改为多层的、有服务层的结构的时，很多人不会直接做一个通用的服务框架，而是为当前要用的服务做一个RPC的功能，为服务使用者提供相关的客户端。而当提供的服务的集群多于一个小时，通用的服务框架就非常重要。服务化会使得把本地调用变为远程调用。研发人员关注的是提高易用性和降低性能损失这两方面。<br>在单机单进程中，程序只需要将寄存器地址改为相应的入口地址就好，而在多机之间，我们需要对调用的请求信息进行编码，然后传给远程的节点，解码后再进行真正的调用。寻址路由是为了让调用方确定哪个实例被调用的，实际定位是指被调用的机器找到对应的实例来进行方法调用，从而实现功能。</p>
<h3 id="通过示例看服务框架原型"><a href="#通过示例看服务框架原型" class="headerlink" title="通过示例看服务框架原型"></a>通过示例看服务框架原型</h3><p>服务框架即包含调用方的逻辑，又包含服务端的逻辑的一个实现。</p>
<h4 id="单机方式"><a href="#单机方式" class="headerlink" title="单机方式"></a>单机方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Calculator&#123;</div><div class="line">     public int add(int a,int b)&#123;</div><div class="line">       <span class="built_in">return</span> a+b;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Calculator calculator =new Calculator();</div><div class="line">calculator.add(2,3);</div></pre></td></tr></table></figure>
<h4 id="实现远程服务的调用客户端"><a href="#实现远程服务的调用客户端" class="headerlink" title="实现远程服务的调用客户端"></a>实现远程服务的调用客户端</h4><p>以单机为例，我们希望实现这个服务的方式和当前的做法一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int add(int a,int b)&#123;</div><div class="line"></div><div class="line">  //获取可用服务列表</div><div class="line">  List&lt;String&gt; l=getAvailableServiceAddresses(<span class="string">"Calculator.add"</span>);</div><div class="line">  //获取调用服务的目标机器</div><div class="line">  String address=chooseTarget();</div><div class="line">  //建立连接</div><div class="line">  Socket socket=new Socket(address);</div><div class="line">  //请求序列化</div><div class="line">  byte[] request=getRequest(a,b);</div><div class="line">  //发送请求</div><div class="line">  socket.getOuputStream().write(request);</div><div class="line">  //接受结果</div><div class="line">  byte[] response=new byte[1024];</div><div class="line">  socket.getInputStream().read(response);</div><div class="line">  int result=getResult(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们解析这段代码，首先是获取服务机器的地址列表，并且从可用的服务地址列表中选取一个要调用的目标机器。<br>如果我们采取的LVS或者硬件负载均衡方案，那么getAvailableServiceAddresses获取的就是获取LVS或者硬件负载均衡器的地址和端口，并且choosTarget会直接返回地址和端口。<br>如果我们采取名称服务，那么getAvailableServiceAddresses返回的是当前的服务的地址列表，参数值用来定位服务，这个一般用做key的服务名字一般采用接口的全名，也就是全限类名，也可以用类名加版本号。<br>如果我们采用规则解析，这种方式更多应用在有状态的场景上。像数据这种状态要求很高的场景，或者缓存这种尽量要有状态的场景，都会用到规则服务器的方式来解决寻址问题。在无状态的场景，则不太用规则服务器的方式处理。<br>构造请求数据包其实就是把对象变为二进制数据，也就是java的序列化。请求后，我们需要等待远程服务的执行和结果的返回，收到结果后，我们会对数据进行java1反序列化，等到结果。</p>
<h4 id="实现服务端"><a href="#实现服务端" class="headerlink" title="实现服务端"></a>实现服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">eventHandler</span></span>()&#123;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    byte[] requestData=receiveRequest();</div><div class="line">    Request request=getRequest(requestData);</div><div class="line">    Object service=getServiceByNameAndVersion(request.getServiceName(),request.getServiceVersion());</div><div class="line">    Object result=callService(service,request.getMethodName(),request.getArgs());</div><div class="line">    byte[] data=getResult(result);</div><div class="line">    request.socket.getOuputStream.write(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段伪代码中，我们需要持续接受请求并进行响应，收到的数据也需要反序列化。在这里，我们关注服务的名称、服务的版本号、调用的方法名称和参数以及调用的连接。当我们拿到请求对象后，我们需要本地定位具体的服务，我们会有个服务注册表，我们可以动态发布服务。得到服务实例后，我们会服务调用，一般通过反射来调用，然后序列化结果，传输给客户端。</p>
<h3 id="服务调用端的设计和实现"><a href="#服务调用端的设计和实现" class="headerlink" title="服务调用端的设计和实现"></a>服务调用端的设计和实现</h3><p>调用过程是调用发起、寻址路由、协议适配/序列化、网络传输、反序列化/协议解析、得到结果返回调用方。</p>
<h4 id="从代码的角度看如何使用服务框架"><a href="#从代码的角度看如何使用服务框架" class="headerlink" title="从代码的角度看如何使用服务框架"></a>从代码的角度看如何使用服务框架</h4><p>客户端的引入是我们首先需要解决的问题，大多数的java开发都会使用spring作为容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ConsumerBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>以上是简单的版本的服务框架，我们先看三个基础的属性</p>
<h5 id="interfaceName"><a href="#interfaceName" class="headerlink" title="interfaceName"></a>interfaceName</h5><p>接口名称，在进程远程通信时ConsumerBean必须要知道调用的接口是哪一个，然后才能生成这个接口的代理，以供本地调用。</p>
<h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>版本号，在实际场景中，接口的变化是可能的。如果直接变化，那么要求所有使用的地方一起修改，一起升级。解决问题的方式有两种，一种是需要修改方法的参数或者返回值，也就是新增一个方法，保持原来方法不变，不过在过渡阶段导致代码臃肿，并且方法名不好取名。第二种是通过版本号进行隔离。</p>
<h5 id="group"><a href="#group" class="headerlink" title="group"></a>group</h5><p>分组。分组属性的好处是如果对同一个接口的远程调用有很多机器，那么我们可以把远程机器分组，然后调用者可以选择不同分组调用，这样就可以把不同调用者对同一服务进行隔离。</p>
<h4 id="运行期服务框架与应用和容器的关系"><a href="#运行期服务框架与应用和容器的关系" class="headerlink" title="运行期服务框架与应用和容器的关系"></a>运行期服务框架与应用和容器的关系</h4><p>有两个比较重要的问题需要解决：1.服务框架本身的部署方式问题；2.实现服务框架所依赖的一些外部包和应用自身依赖的jar包冲突。<br>首先是部署方式；一种方案是把服务框架作为应用的一个依赖包并与应用进行打包。通过这个方式，服务框架就变为应用的一个库，并随应用启动。存在的问题是，如果要升级服务框架，就需要更新应用本身；并且服务框架也没办法接管classloader，也没办法做到隔离和包的实现替换工作。<br>另一种方案是把服务框架作为容器的一部分，那么服务框架就变为一个容器提供远程调用和远程服务的功能。<br>Jar包冲突问题，应用和服务框架的jar包版本冲突；将服务框架的自身用的类和应用用的类都控制在User-defined class loader级别上，这样就实现了相互间的隔离。web容器对多个web应用的处理以及OSGI对bundle处理采用了类似的方法。我们可以看下类加载器的层级关系，最上到下依次是bootstrap class loader($JAVA_HOME/jre/lib/rt.jar)、Extension class Loader($JAVA_HOME/jre/lib/ext/rt.jar)、System class loader($CLASSPATH)、user defined class loader</p>
<h3 id="服务调用者和服务提供者之间通信方式的选择"><a href="#服务调用者和服务提供者之间通信方式的选择" class="headerlink" title="服务调用者和服务提供者之间通信方式的选择"></a>服务调用者和服务提供者之间通信方式的选择</h3><p>服务框架是为了把本地对象之间的方法调用变为远程过程调用，，这就涉及到远程通信问题。</p>
<h4 id="远程通信遇到的问题"><a href="#远程通信遇到的问题" class="headerlink" title="远程通信遇到的问题"></a>远程通信遇到的问题</h4><p>最初的路由寻址过程是把远程的IP和端口号写死在代码中，但是如果是一个集群这种方式就满足不了</p>
<h4 id="采用透明代理与调用者、服务提供者直连的解决方案"><a href="#采用透明代理与调用者、服务提供者直连的解决方案" class="headerlink" title="采用透明代理与调用者、服务提供者直连的解决方案"></a>采用透明代理与调用者、服务提供者直连的解决方案</h4><p>这里面我们通过两种方式，一种是中间代理，另一种是服务注册查找中心；服务注册查找中心只是提供可用的服务提供者列表，调用者会缓存下来地址，然后当地址列表发生改变时在去向中心获取。当客户端拿到地址后，如何对当次进行调用就是路由要做的事情，我们首先要考虑的是集群的负载均衡的实现，比如轮询、随机、权重等方式，可以参考硬件负载均衡机器或者LVS或者HAProxy策略。</p>
<h4 id="引入基于接口、方法、参数的的路由"><a href="#引入基于接口、方法、参数的的路由" class="headerlink" title="引入基于接口、方法、参数的的路由"></a>引入基于接口、方法、参数的的路由</h4><p>一般用接口作为服务的粒度，一个服务也就是一个接口的远程实现。假设服务提供两个接口，分别是接口A，接口B，每个服务又提供了两个方法。一般来说一个请求对应一个线程，而总线程数量有一个限制，一旦并发请求过多，其余的就必须要等待。假设某个方法执行的时间很慢，那么很快如果很多线程请求该方法，那么在进入这个方法时，一旦达到瓶颈值，那么其他线程就在等待。我们可以有两种解决方案，增加机器数，可以减少分到单台机器的请求数。也就是增加资源保证系统的能力超出需要；第二种方案是隔离这些资源，从而使得快慢不同重量级别不同的方法互不影响。而分流策略可以让请求服务A的请求全部在右上方机器，请求服务B的请求全部在右下方机器。我们负载均衡的策略的具体实现是先获取服务框架的规则后进行路由处理，也就是根据服务定位提供服务集群的地址，然后在与接口路由规则中的地址做个交集，得到的地址在进行负载均衡算法，最后得到一个可用的地址进行调用。但是基于接口并未解决这个问题，因为A服务的方法一的瓶颈会影响A服务的方法而，这时我们路由规则可以基于接口名加方法，什么可以基于方法名加方法加参数</p>
<h3 id="多机房场景"><a href="#多机房场景" class="headerlink" title="多机房场景"></a>多机房场景</h3><h3 id="服务调用端的流控处理"><a href="#服务调用端的流控处理" class="headerlink" title="服务调用端的流控处理"></a>服务调用端的流控处理</h3><p>流量控制是为了保证系统的稳定性。我们有两种控制方式，一种是01开关，完全打开和完全不打开；另外一种设定一个固定值，表示每秒可以进行请求的次数。超过这个请求数的就拒接对远程的请求。我们可以从两个维度进行控制：1.根据服务端的接口、方法进行控制；也就是根据不同接口设置不同阈值，这是为了使服务端的不同接口、方法之间的负载不互相影响；根据来源做控制，也就是对同样的接口对不同来源设置不同的限制。</p>
<h3 id="序列化和反序列处理"><a href="#序列化和反序列处理" class="headerlink" title="序列化和反序列处理"></a>序列化和反序列处理</h3><p>对于Java的序列化，需要考虑三个问题：1.跨语言问题；2.序列化和反序列化的性能开销；3.序列化后的长度；我们可以考虑xml或者json作为序列化方式。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>通信方式有BIO、NIO和AIO，BIO是阻塞IO，是一个连接消耗一个线程，但是消耗大。如果是NIO，那么客户端和服务器端之间的连接是可以复用的，而不是一个连接消耗一个线程。我们希望通过一个连接来进行多个并发请求操作。类比公路的职能，每条公路允许多辆汽车行驶而不是只有一辆汽车行驶。NIO提供的是非阻塞方式的IO，需要对外提供的是类似阻塞的同步远程请求方式。我们增加了IO线程，数据队列，通信对象队列，和定时任务。</p>
<h3 id="支持异步服务的调用方式"><a href="#支持异步服务的调用方式" class="headerlink" title="支持异步服务的调用方式"></a>支持异步服务的调用方式</h3><h4 id="oneWay"><a href="#oneWay" class="headerlink" title="oneWay"></a>oneWay</h4><p>oneWay是只管发送不管结果，只需要把要发送的数据放入数据队列，然后继续下面的操作。oneway不关心对方是否收到数据，也不关心返回值。</p>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>这种方式下，请求方发送后会继续执行下面操作，等对方响应会进行一个回调</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>把数据写入队列，把future写入队列，通过future获取结果</p>
<h4 id="可靠的异步"><a href="#可靠的异步" class="headerlink" title="可靠的异步"></a>可靠的异步</h4><p>通过消息中间件</p>
<h3 id="使用Future对远程服务调用的优化"><a href="#使用Future对远程服务调用的优化" class="headerlink" title="使用Future对远程服务调用的优化"></a>使用Future对远程服务调用的优化</h3><p>如果我们在一个请求处理中调用多个远程服务，如果采用同步的方式，那么总时间是全部请求时间求和，如果我们仍然按照顺序把服务的请求依次发给各个服务，但是请求过去后并不等待结果，而是在最后服务发出去后在等待，这样总时间变为单个远程服务时间的最大值。但是这有个前提，所有的服务并没有依赖关系，所以他们可以一起等。</p>
<h2 id="服务端的设计和实现"><a href="#服务端的设计和实现" class="headerlink" title="服务端的设计和实现"></a>服务端的设计和实现</h2><h3 id="如何暴露远程服务"><a href="#如何暴露远程服务" class="headerlink" title="如何暴露远程服务"></a>如何暴露远程服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ProviderBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"target"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>服务端提供的是providerBean，而客户端提供的是ConsumerBean。providerBean的职能是服务需要注册到服务查找中心后才能被服务调用者发现，所以providerBean需要将自己所代表的服务注册到服务注册查找中心。也需要在本机注册服务和对应服务的实例。</p>
<h3 id="服务端对请求处理的流程"><a href="#服务端对请求处理的流程" class="headerlink" title="服务端对请求处理的流程"></a>服务端对请求处理的流程</h3><p>服务框架启动时需要监听端口号，并且等待调用的请求。当服务注册好，监听端口号也准备好，就只需等待服务调用的请求进来。请求处理流程是：网络通信层、协议解析/反序列化、定位服务、调用服务。</p>
<h3 id="执行不同服务的线程池隔离"><a href="#执行不同服务的线程池隔离" class="headerlink" title="执行不同服务的线程池隔离"></a>执行不同服务的线程池隔离</h3><h3 id="服务提供者的流控处理"><a href="#服务提供者的流控处理" class="headerlink" title="服务提供者的流控处理"></a>服务提供者的流控处理</h3><p>在服务提供者看来，不同来源的服务调用者、0-1开关、限制具体数值的QPS方式都需要实现。对不同调用者进行升级，确保优先级高的服务调用者被优先调用</p>
<h3 id="服务升级"><a href="#服务升级" class="headerlink" title="服务升级"></a>服务升级</h3><h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><h4 id="修改调用参数列表"><a href="#修改调用参数列表" class="headerlink" title="修改调用参数列表"></a>修改调用参数列表</h4><p>1.对原来的方法的代码进行修改<br>2.通过版本号来解决<br>3.在设计的方法上考虑参数的扩展。但是不可行，通过map不直观</p>
<h2 id="实战的优化"><a href="#实战的优化" class="headerlink" title="实战的优化"></a>实战的优化</h2><h3 id="服务的拆分"><a href="#服务的拆分" class="headerlink" title="服务的拆分"></a>服务的拆分</h3><h3 id="服务的粒度"><a href="#服务的粒度" class="headerlink" title="服务的粒度"></a>服务的粒度</h3><h3 id="优雅和实用的平衡"><a href="#优雅和实用的平衡" class="headerlink" title="优雅和实用的平衡"></a>优雅和实用的平衡</h3><p>最上层是服务调用者，如果服务调用者调用服务十分频繁，可以写入缓存。没有在调用服务提供者，服务提供者先访问本地缓存，没有在访问数据库</p>
<h3 id="分布式环境下的请求合并"><a href="#分布式环境下的请求合并" class="headerlink" title="分布式环境下的请求合并"></a>分布式环境下的请求合并</h3><p>对于热点数据的处理，如果可以进行一些任务的合并问题，就会明显降低整个系统的负载。首先可以通过缓存，减少数据的读取和计算的工作量。还可以解析完参数，检查是否有线程在在计算相同的数据，如果有，等待结果；没有，进行计算。分布式环境下会涉及到多节点，如果使用分布式锁，则会有额外的开销。但是我们可以使用路由策略，相同参数的服务发送到同一台服务提供者。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/构建java中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/构建java中间件/" itemprop="url">构建java中间件（第三章）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:59:08+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java中间件的定义"><a href="#java中间件的定义" class="headerlink" title="java中间件的定义"></a>java中间件的定义</h2><p>基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的服务，中间件不是操作系统的一部分，不是数据库管理的一部分，不是软件应用的一部分，而是能够让软件开发者更方便的处理通信、输入、输出，能够专注在他们自己应用的部分。总体来说，中间件不是最上层应用，也不是最底层的操作系统，是处于中间的组件，起到桥梁的作用，是应用和应用之间，应用和服务之间的桥梁。<br>主要有三个领域的中间件：</p>
<h3 id="远程对象调用和对象访问中间件"><a href="#远程对象调用和对象访问中间件" class="headerlink" title="远程对象调用和对象访问中间件"></a>远程对象调用和对象访问中间件</h3><p>解决分布式的应用互相访问的问题</p>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>解决应用之间的消息传递、解耦、异步的问题</p>
<h3 id="数据访问中间件"><a href="#数据访问中间件" class="headerlink" title="数据访问中间件"></a>数据访问中间件</h3><p>主要解决应用访问数据库的共性问题的组件</p>
<h2 id="构建java中间件的基础知识"><a href="#构建java中间件的基础知识" class="headerlink" title="构建java中间件的基础知识"></a>构建java中间件的基础知识</h2><h3 id="跨平台的运行环境–jvm"><a href="#跨平台的运行环境–jvm" class="headerlink" title="跨平台的运行环境–jvm"></a>跨平台的运行环境–jvm</h3><p>java虚拟机所识别的是统一格式的中间代码也就是java字节码。</p>
<h3 id="垃圾回收与内存堆布局"><a href="#垃圾回收与内存堆布局" class="headerlink" title="垃圾回收与内存堆布局"></a>垃圾回收与内存堆布局</h3><p>java虚拟机是通过垃圾回收方式来回收内存的，而不像C/C++语言那样通过代码显示释放。JVM内存堆布局有新生代、年老代、持久代。对象创建一般在新生代的eden区，也有可能直接分配在年老区。</p>
<h2 id="java并发编程的类、接口和方法"><a href="#java并发编程的类、接口和方法" class="headerlink" title="java并发编程的类、接口和方法"></a>java并发编程的类、接口和方法</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池可以降低创建线程的开销，这是因为线程池在线程结束后进行的是回收操作，而不是销毁线程。在java中，我们主要使用的线程池是ThreadPoolExecutor,此外，我们还有定时线程池scheduledThreadPoolExecutor。需要注意的是ThredPool.newCachedThreadPool()返回的线程池的使用，该方法返回的线程池的线程使用没有上限。因而没办法控制总体线程的数量，因为每个内存都要占用内存，这会造成过多内存的占用。建议不要用这个线程池。而使用有固定线程上限的线程池。</p>
<h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><p>sychronized可以用于声明方法，也可以用于声明代码块。看一下三个使用场景。<br>场景一：<br>在这个类的两个静态方法中，不同线程中，两个方法的调用是互斥的，不仅这样任何两个线程都是互斥的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo1&#123;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo1</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo2</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景二：<br>foo3和foo4是类的两个成员函数，在多线程中，调用同一个对象的foo3和foo4才会互斥，这是同一对象的多线程调用互斥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo2&#123;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo3</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo4</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景三：<br>sychronized用来修饰代码块，后面的参数就是同步锁的对象。sychronized(this) 与Demo3中加sychronized成员方法是互斥，sychronized(Demo3.class)与Demo3中加sychronized静态方法是互斥的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo3&#123;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo5</span></span>()&#123;</div><div class="line">           sychronized(this)&#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo6</span></span>()&#123;</div><div class="line">          sychronized(Demo3.class)&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是java.util.concurrent.locks中的一个类，他的用法类似sychronized类似，但是需要显示unlock。</p>
<h4 id="ReentrantLock提供tryLock"><a href="#ReentrantLock提供tryLock" class="headerlink" title="ReentrantLock提供tryLock"></a>ReentrantLock提供tryLock</h4><p>调用的时候，如果锁被其他线程持有，那么tryLock就会立刻返回，返回结果为false，如果锁没有被其他线程持有，当前线程会持有锁，返回true。</p>
<h4 id="ReentrantLock提供公平锁和抢占锁"><a href="#ReentrantLock提供公平锁和抢占锁" class="headerlink" title="ReentrantLock提供公平锁和抢占锁"></a>ReentrantLock提供公平锁和抢占锁</h4><p>默认是抢占锁，通过参数boolean fair；公平锁的好处是等待锁的线程不会饿死，但是整体效率会降低；非公平锁的好处是整体效率会相对高点，但是有些线程会饿死或者等待很长时间才能获取。公平锁是按照锁的排队顺序需要获取锁，而非公平锁是抢占式的。此外ReentrantLock还提供了ReentrantReadWriteLock，读写锁，主要用于读多写少并且读不需要互斥的场景，这样的锁比全部互斥锁性能会高。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlock写在finally表示一定可以释放锁，ReentrantReadWriteLock与ReentrantLock用法相似，但是通过readLock()和writeLock()两个方法来获取读锁和写锁，这两个锁按照前面的方式进行加锁和解锁。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>sychronized除了有互斥性，还有可见性。可见性是指一个线程修改了变量后，其他线程能够马上看到这个修改值。volatile能够保证变量的可见性，它更多是修饰开关的可见性，它不能保证操作的原子性。</p>
<h3 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h3><p>JDK 1.5增加了java.util.concurrent.atomic包，这些包是以Atomic开头的类，这些类提供了一些原子操作，以AtomicInteger为例，通过jni使用硬件支持的CAS指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Sample &#123;</div><div class="line"></div><div class="line">    private static AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">increment</span></span>() &#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">decrease</span></span>() &#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h3><p>wait、notify和notifyAll是java的object对象的三个方法，wait是用来等待的，notify和notifyAll是用来通知的。在多线程中，可以把某个对象做为事件对象，通过这个对象的wait、notify、notifyAll完成线程的通知。notify和notifyAll都是唤醒调用同一个对象的wait，但不同的是notify会唤醒一个等待线程，notifyAll会唤醒全部等待线程。对wait、notify、notifyAll的调用必须在对象的sychronized中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">testWait</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.wait();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">testNotify</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实践中，对wait的使用一般在循环里，并且会判断相关的数据状态是否达到预期，如果没有，继续等待，这样做主要是为了防止虚假唤醒。虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒，而此时是不应该唤醒的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sychronized(obj)&#123;</div><div class="line"></div><div class="line">       <span class="keyword">while</span>(&lt;condition does not hold&gt;)</div><div class="line">            obj.wait();</div><div class="line">           //<span class="keyword">do</span>Sometihing()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是java.util.concurrent包中的一个类。CountDownLatch提供的机是当多个（具体数量是等于初始化CountDownLatch初始化的值）线程都到达了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件触发自己后续的工作。等待的线程可以是多个，即CountDownLatch可以唤醒多个等待的线程，到达自己预期的状态会调用CountDownLatch的countDown方法，而等待的线程可以调用countDownLatch的await方法。<br>如果CountDownLatch的初始化count值为1就退化成为了单个事件，即由一个线程通知其他线程，效果等同于await和notifyAll。count值大于1是常用的方式，目的是让多个线程到达各自的预期状态，变为一个事件来通知，线程继续自己的行为。<br>例如我们使用一台多核机器对一组数据进行排序，我们可以把一组数据分到不同的线程去排序，然后在进行合并；可以将CountDownLatch作为各个线程排好序的通知。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int count=10;</div><div class="line">final CountDownLatch latch=new CountDownLatch(count);</div><div class="line">int[] datas=new int[10204];</div><div class="line">int step=datas.length/count;</div><div class="line"><span class="keyword">for</span>(int i=0;i&lt;count;i++)&#123;</div><div class="line">    int begin=i*step;</div><div class="line">    int end=(i+1)*step;</div><div class="line">    <span class="keyword">if</span>(i==count-1)&#123;</div><div class="line">      end=datas.length;</div><div class="line">    &#125;</div><div class="line">    threadPool.execute(new MyRunnable(latch,datas,begin,end));</div><div class="line">&#125;</div><div class="line">latch.await();</div><div class="line">合并数据</div><div class="line">MyRunnable的run实现</div><div class="line">public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">  //数据排序</div><div class="line">  latch.countDown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier字面意思循环屏障，CyclicBarrier可以协调多个线程，让多个线程在这个屏障等待，直到所有线程都到达了这个屏障，再一起继续执行后面的动作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static class WorkerThread implements Runnable&#123;</div><div class="line"></div><div class="line">          CyclicBarrier barrier;</div><div class="line"></div><div class="line">          public WorkerThread(CyclicBarrier b)&#123;</div><div class="line">             this.barrier = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         @Override</div><div class="line">         public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">             // TODO Auto-generated method stub</div><div class="line">             try&#123;</div><div class="line">                 System.out.println(<span class="string">"Worker's waiting"</span>);</div><div class="line">                 //线程在这里等待，直到所有线程都到达barrier。</div><div class="line">                 barrier.await();</div><div class="line">                 System.out.println(<span class="string">"ID:"</span>+Thread.currentThread().getId()+<span class="string">" Working"</span>);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch的count等于调用countDown的个数，CyclicBarrier的数量是await的数量。CyclicBarrier、CountDownLatch都是用于多线程协调，但不同是，CountDownLatch是在多线程中进行latch.countDown后才会触发事件，唤醒await的线程。而CyclicBarrier是用于同步所有调用await方法的线程。并且等到所有线程到了await后才会一起返回继续自己的工作。CountDownLatch不能循环调用,CyclicBarrier可以循环调用。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是用来管理信号量的，构造的时候传入可供管理信号量的数值。简单来说，信号量对象管理的信号就像令牌，构造时传入个数，总数就是控制并发的数量。执行前先获取信号（通过acquire），执行后归还信号（通过release），每次acquire成功后，信号量减少一，如果没有可用的信号，acquire就会阻塞，等待release调用释放信号，才能获取信号返回。<br>如果Semaphore管理的信号量只有一个，就退化成互斥锁。如果大于1的信号量，主要用于控制并发数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">semaphore.acquire();</div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">semaphore.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger用于两个线程的数据进行交换，线程会阻塞Exchanger的exchange方法，知道另外一个线程也到exchange方法，然后交换数据，往下执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">final Exchanger&lt;List&lt;String&gt;&gt; exchanger = new Exchanger&lt;List&lt;String&gt;&gt;();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"1"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread1"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"3"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread2"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div></pre></td></tr></table></figure></p>
<h3 id="Future和FuturTask"><a href="#Future和FuturTask" class="headerlink" title="Future和FuturTask"></a>Future和FuturTask</h3><p>Future 是一个接口，FutureTask是接口的实现类，我们看下这么样的场景<br>通过调用一个方法从远程获取一些计算结果，假设有HashMap getDataFromRemote();<br>假设是同步的方式，我们会一直等待这个方法的返回，然后才能继续下面的工作，如果这个方法执行的时间比较长，并且后面的代码跟这个方法没关系的话，那么阻塞在这里就没有意义。<br>第二种方式是异步的方式，调用函数后马上返回，然后继续执行，等需要用时再来取数据。具体实现方式是用Future，或者回调。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>并发容器是线程安全容器的一种，但是并发容器强调容器的并发性，也就是不仅强调安全，也强调并发。比较有代表的是CopyAndWrite和Concurrent开头的容器。如ConcurrentHashMap，ConcurrentLinkedQueue，ConcurrentLinkedDequeue、CopyOnWriteArrayList、CopyOnWriteArraySet。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	 public void <span class="keyword">do</span>Something();  </div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	  public void <span class="function"><span class="title">doSomething</span></span>()   </div><div class="line">	  &#123;   </div><div class="line">	    System.out.println( <span class="string">"call doSomething()"</span> );   </div><div class="line">	  &#125;   </div><div class="line">&#125;</div><div class="line">public class ProxyObject implements Subject &#123;</div><div class="line"></div><div class="line">	private RealSubject realSubject;</div><div class="line"></div><div class="line">	public ProxyObject(RealSubject realSubject) &#123;</div><div class="line">		super();</div><div class="line">		this.realSubject = realSubject;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		realSubject.doSomething();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理有静态代理和动态代理之分。<br>静态代理方式是为每一个被代理的对象构造对应的代理类。这种方式比较直接，实现也比较方便，不过也存在问题，即如对多个类进行代理，并且在代理类的功能实现是一致的，就必须为每一个具体类都完成一个代理类。<br>动态代理是动态地生成具体委托类的代理类实现对象。与静态代理不同，它只需要为一类代理行为写一个具体的实现类。用过Proxy.newProxyInstance来创建代理的方式可以为不同的委托类创建代理类。在具体的代理实现上，所给出的是通用实现，被代理的方法会进入invoke方法，我们可以在invoke方法中做很多事情，例如调用前和调用后可以操作。并且对于一类的增强事情，我们不用写多个ProxyHandler，就可以给多个委托类使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ProxyHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	  private Object proxied;   </div><div class="line"></div><div class="line">	  public ProxyHandler( Object proxied )   </div><div class="line">	  &#123;   </div><div class="line">	    this.proxied = proxied;   </div><div class="line">	  &#125;   </div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println(<span class="string">"before invoke"</span>);</div><div class="line">		Object object=method.invoke(proxied, args);</div><div class="line">		System.out.println(<span class="string">"after invoke"</span>);</div><div class="line">		<span class="built_in">return</span> object;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">RealSubject realSubject = new RealSubject();</div><div class="line">		Subject subject = (Subject) Proxy.newProxyInstance(</div><div class="line">				Subject.class.getClassLoader(), new Class[]&#123;Subject.class&#125;,</div><div class="line">				new ProxyHandler(realSubject));</div><div class="line">		subject.doSomething();</div></pre></td></tr></table></figure></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>java反射机制是指在运行状态中，对于任意的一个类，都能知道这个类的所有方法和所有属性。对于任意一个对象，都能调用他的任意一个他的方法或者他的属性。反射主要提供的功能有：1.在运行时判断任意一个对象所属的类；2.在运行时构造任意一个对象所属的类；3.在运行时判断任意一个类的所具有的成员变量和方法；4.在运行时调用任意一个对象的方法；5.生成动态代理。用法示例</p>
<h3 id="获取对象属于哪个类"><a href="#获取对象属于哪个类" class="headerlink" title="获取对象属于哪个类"></a>获取对象属于哪个类</h3><p>Subject subject=new Subject(“lr12”, “topic”);<br>Class class=subject.getClass();</p>
<h3 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h3><p>//获取类名<br>String className=clazz.getName();<br>//获取方法<br>Method[] methods=clazz.getDeclaredMethods();<br>//获取成员变量<br>Field[] fields=clazz.getDeclaredFields();</p>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3><p>Class.forName(“reflect.Subject”).newInstance();<br>在这里的通过传入一个字符创来构造对象，体现了动态性，同时要求这个类的构造函数必须有一个无参的，否则将抛出异常。</p>
<h3 id="动态执行方法"><a href="#动态执行方法" class="headerlink" title="动态执行方法"></a>动态执行方法</h3><p>Method method=clazz.getDeclaredMethod(“doSomething”);<br>method.invoke(subject);</p>
<h3 id="动态操作属性"><a href="#动态操作属性" class="headerlink" title="动态操作属性"></a>动态操作属性</h3><p>Field field=clazz.getDeclaredField(“name”);<br>field.set(subject, “lr”)<br>这里要强调如果方法和属性是静态的，这时候可以不用传对象，可以传null。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>网络通信三个模型：BIO、NIO、AIO。在1.4的版本中增加了NIO，在1.7的版本中增加了AIO。</p>
<h2 id="分布式系统中的中间件"><a href="#分布式系统中的中间件" class="headerlink" title="分布式系统中的中间件"></a>分布式系统中的中间件</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/17/大型软件架构及其结构演进过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/大型软件架构及其结构演进过程/" itemprop="url">大型软件架构及其结构演进过程第二章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T17:25:39+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大型网站中间件/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是大型网站"><a href="#什么是大型网站" class="headerlink" title="什么是大型网站"></a>什么是大型网站</h1><p>访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是个分布式系统</p>
<h1 id="大型网站的架构演进"><a href="#大型网站的架构演进" class="headerlink" title="大型网站的架构演进"></a>大型网站的架构演进</h1><h2 id="用java技术和单机来构建网站"><a href="#用java技术和单机来构建网站" class="headerlink" title="用java技术和单机来构建网站"></a>用java技术和单机来构建网站</h2><p>选择一个开源的server作为容器，使用一些JSP/servlet技术或者开源框架构建我们的应用，选择一个数据库管理系统来管理数据，通过jdbc进行数据库的连接和操作。</p>
<h2 id="从一个单机的交易网站说起"><a href="#从一个单机的交易网站说起" class="headerlink" title="从一个单机的交易网站说起"></a>从一个单机的交易网站说起</h2><p>考虑一个交易网站，最基本功能有这么三个部分：用户模块、商品模块、交易模块，各个功能模块是通过JVM内部的方法调用来进行交互，应用和数据库之间是通过jdbc来访问的。同时应用和数据库放在同一台机子上。</p>
<h2 id="单机负载告警，数据库与应用分离"><a href="#单机负载告警，数据库与应用分离" class="headerlink" title="单机负载告警，数据库与应用分离"></a>单机负载告警，数据库与应用分离</h2><p>网站对外提供服务后，访问量不断增大，负载持续升高。我们可以把数据库和应用分开，分别放到两台机子上。</p>
<h2 id="应用服务器告警，如何让应用服务器走向集群"><a href="#应用服务器告警，如何让应用服务器走向集群" class="headerlink" title="应用服务器告警，如何让应用服务器走向集群"></a>应用服务器告警，如何让应用服务器走向集群</h2><p>服务器压力仍然变大，把应用从单机升级为集群，我们可以考虑一台应用服务器变为两台。我们要考虑如下两个问题，第一个是服务器的选择问题，可以用dns或者增加负载均衡设备来解决这个问题；第二个是session问题。</p>
<h3 id="引入负载均衡设备"><a href="#引入负载均衡设备" class="headerlink" title="引入负载均衡设备"></a>引入负载均衡设备</h3><h3 id="解决应用服务器变为集群后的session问题"><a href="#解决应用服务器变为集群后的session问题" class="headerlink" title="解决应用服务器变为集群后的session问题"></a>解决应用服务器变为集群后的session问题</h3><p>http协议本身是无状态的，需要基于http协议支持会话状态机制，具体的实现方式是：在会话开始时，分配唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后再每次请求的时候，浏览器会带上这个会话标识告诉web服务器请求属于哪个会话的。在web服务器上，各个会话有独立的存储，保存不同的会话信息。如果是禁用cookie的情况，就把会话标识放在url参数上。<br>当应用服务器扩展时就会遇到session问题。因为session是存在单机上的。</p>
<h4 id="session-sticky（保持-粘滞会话）"><a href="#session-sticky（保持-粘滞会话）" class="headerlink" title="session sticky（保持-粘滞会话）"></a>session sticky（保持-粘滞会话）</h4><p>在负载均衡器上做了操作，同样的session请求每次发送给同一个服务器端处理。但也带来以下的问题：1.如果一台服务器宕机或者重启，那么这台服务器上的会话数据会全部丢失，如果会话中有登录状态的数据的话，那就要重新登录。2.会话标识的应用层信息，那么负载均衡器需要进行应用层解析，这个开销比第四层交换大。3.负载均衡器变为有状态的节点，要将会话保存到web服务器映射。和无状态节点相比，内存消耗更大，容灾更麻烦。</p>
<h4 id="session-Replication（复制会话）"><a href="#session-Replication（复制会话）" class="headerlink" title="session Replication（复制会话）"></a>session Replication（复制会话）</h4><p>web服务器会增加会话的同步，但在一些场景存在问题：1.同步session造成网络的开销。只要session数据发生变化，就需要把数据同步到其他机器上，机器越多，同步带来的网络带宽的开销就会越大；2.每台web服务器都需要保存所有的session数据，如果整个集群的session数很多，每台机器用于保存session的内容占用会很严重。</p>
<h4 id="session数据集中存储"><a href="#session数据集中存储" class="headerlink" title="session数据集中存储"></a>session数据集中存储</h4><p>把session数据集中存储，不同的web服务器从相同的地方获取session数据。session会统一存储在另外的服务器上，这样可以保证web服务器读到的session数据都是一样的。存储session的具体方式，可以使用数据库或者其他分布式存储系统。这个方案解决了replication的内存问题和带宽问题。但也存在问题是：1.读写session引入网络操作，问题就在时延和不稳定性，但如果是内网，这个问题不大；2.如果集中存储session的机器或者集群有问题，会影响我们的应用。</p>
<h4 id="cookie-based（基于cookie1）"><a href="#cookie-based（基于cookie1）" class="headerlink" title="cookie based（基于cookie1）"></a>cookie based（基于cookie1）</h4><p>通过cookie传递session数据，我们的session数据存储在cookie里，然后web服务器从cookie中生成对应的session数据。这个方案存在着不足：1.cookie的长度限制限制了session的长度限制。2.安全性；session数据是服务器数据，而这个方案导致服务端数据到了外部网络和客户端，因而存在安全性问题。但也可以通过对session数据加密，但从安全角度来看物理上不接触才更安全。3.带宽消耗，数据中心整体的带宽消耗；4.性能影响；每次http请求和响应都带有session数据，对web服务器来说，响应结果输出越少，支持的并发请求越多</p>
<h2 id="数据读压力大，那么就读写分离吧"><a href="#数据读压力大，那么就读写分离吧" class="headerlink" title="数据读压力大，那么就读写分离吧"></a>数据读压力大，那么就读写分离吧</h2><p>接下来从数据库的角度来看。</p>
<h3 id="采用数据库作为读库"><a href="#采用数据库作为读库" class="headerlink" title="采用数据库作为读库"></a>采用数据库作为读库</h3><p>对于大型网站，有不少业务是读多写少，这个状况会直接反应到数据库上，我们考虑读写分离的方式。我们在前面结构增加一个读库，这个库不承担写工作，只提供读操作。这个结构的变化会带来两个问题：1.数据复制问题；2.应用对于数据源的问题<br>首先看下第一个问题，现在数据库系统一般都提供数据复制的功能，可以直接使用数据库系统的自身机制。除此，还需要考虑数据复制时延问题，以及复制过程中数据源和目标之间的映射关系以及过滤条件的支持问题。复制时延带来的是短期的数据不一致。<br>mysql支持master+slave模式，5.5版本以前是异步数据复制，会有延迟，提供完全镜像方式的复制；5.5以后采用semisync（半同步）<br>备注：异步复制模式：主库将已经提交的事务event 写入binlog后，即返回成功给app，该模式下并不保证任何已经提交的事务会传递到任何slave并被成功应用。全同步复制模式：当主库提交一个事务 event，主库会等待该事务被传递到所有的slave上，且所有slave applay 该事务/event 通知主库之后，才会返回会话，事务已经成功。Semisynchronous Replication模式下,在主库上提交一个事务/event，它会等待至少一个slave通知主库，slave 已经接收到传递过来的events并写入relay log，才返回给回话层 写入成功，或者直到传送日志发生超时。<br>对于一个应用来说，增加一个读库对结构变化有一个影响，我们应用需要根据不同情况选择不同的数据库源。写操作走主库，事务的读也要走主库，用时也要考虑备库相对于主库的数据延时。即使是不在事务的读，考虑备库数据延迟，不同业务选择也有差异。<br>广义读写分离的特点是增加读源，分担读写源的读压力，要考虑读源的数据复制问题。</p>
<h3 id="搜索引擎其实是一个读库"><a href="#搜索引擎其实是一个读库" class="headerlink" title="搜索引擎其实是一个读库"></a>搜索引擎其实是一个读库</h3><p>大型网站的站内搜索。在交易网站中，用户需要查找商品功能之类的，这就像数据库的like功能，但这种方式的代价很大。可以使用搜索引擎的倒排表方式，能够大大提升搜索效率。搜索集群的使用方式和读库我们希望的使用的方式是一样的。构建索引的方式有两种，一种按照全量/增量划分，另一种是实时/非实时划分。全量用于第一次建立索引。增量一般用于加入每日的全量作为补充。实时/非实时划分体现在索引更新时间上。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，也就是我们常说的cache。</p>
<h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p>缓存系统一般是用来保存和查询key-value键值对的。应用访问缓存，如果数据不存在，就从数据库中读出数据放入缓存。当缓存数量不够时，最近不被访问的数据就被清除。还有另外做法，在数据库中数据发生变化后，能主动把数据放入缓存系统中。这样的好处是能够及时地更新缓存数据，不会造成读取失效，一般用于全数据缓存，还要能够理解业务逻辑。</p>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>有些动态产生的页面特别热，我们可以对这些内容进行缓存。</p>
<h2 id="弥补关系型数据库的不足，引入分布式存储系统"><a href="#弥补关系型数据库的不足，引入分布式存储系统" class="headerlink" title="弥补关系型数据库的不足，引入分布式存储系统"></a>弥补关系型数据库的不足，引入分布式存储系统</h2><p>常见的分布式存储系统有分布式文件系统，分布式key-value系统和分布式数据库。通过分布式文件系统来解决小文件和大文件的存储问题，通过key-value系统提供高性能的半结构化的支持，通过分布式数据库提供一个支持大数据、高并发的数据库系统。</p>
<h2 id="读写分离后，数据库又遇到瓶颈"><a href="#读写分离后，数据库又遇到瓶颈" class="headerlink" title="读写分离后，数据库又遇到瓶颈"></a>读写分离后，数据库又遇到瓶颈</h2><p>通过读写分离，分布式存储来替代关系型数据库能够降低主库的压力，但是交易、商品、用户的数据还在同一个数据库中，这时候数据库的压力还在，这时候采取的方案有水平拆分和垂直拆分。</p>
<h3 id="专库专用，数据垂直拆分"><a href="#专库专用，数据垂直拆分" class="headerlink" title="专库专用，数据垂直拆分"></a>专库专用，数据垂直拆分</h3><p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合交易系统的例子，就是将交易、商品、用户的数据拆分开。所造成的的影响是需要配置多个数据源，这就增加了所需配置，所带来的的是每个数据库连接池的隔离，那就需要考虑单机跨业务的事务。一种方案是分布式事务，另一种是去掉事务或者不去追求强事务支持，则原来在单库中可以使用的表关联的查询也需要改变实现。</p>
<h3 id="垂直拆分后的单机遇到瓶颈，数据水平拆分"><a href="#垂直拆分后的单机遇到瓶颈，数据水平拆分" class="headerlink" title="垂直拆分后的单机遇到瓶颈，数据水平拆分"></a>垂直拆分后的单机遇到瓶颈，数据水平拆分</h3><p>数据水平拆分就是把同一个表的数据拆分成不同的数据库中去。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到单个数据库的瓶颈。这时就把一张表拆到两个或者多个数据库中。数据水平拆分和读写分离的区别是读写分离解决的是读压力大，对于数据量大或者更新量大的情况并不起到作用；数据水平拆分和数据垂直拆分区别是，垂直拆分是把不同表拆到不同数据中去；水平拆分是把同一张表拆分到不同数据库中去。水平拆分后的问题：1.需要解决SQL路由的问题；2.主键的处理也会变得不同。3.分页会变得困难。</p>
<h2 id="数据库问题解决后，应用面对的新挑战"><a href="#数据库问题解决后，应用面对的新挑战" class="headerlink" title="数据库问题解决后，应用面对的新挑战"></a>数据库问题解决后，应用面对的新挑战</h2><h3 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h3><p>前面都是在解决数据的问题，现在我们可以看应用的问题。随着功能越来越多，应用也越来越大，我们需要把应用拆开。在我们的例子中，主要业务功能分为：交易、商品、用户。我们可以把这个应用分为交易和商品两个应用。对于交易和商品都会有涉及用户的地方，我们让两个自己完成涉及用户的工作，类似用户工作</p>
<h3 id="走服务化的做法"><a href="#走服务化的做法" class="headerlink" title="走服务化的做法"></a>走服务化的做法</h3><p>我们把应用分为了三层，分为商品中心、用户中心、交易中心，处于最上层是web系统，用于完成不同的业务功能，处于中间是服务中心，最下层是业务数据库。服务化带来的变化：1.业务功能之间的访问不在是单机的简单方法调用，而是远程服务调用；2.共享的代码的实现放在服务中心；3.数据库的连接发生了变化，我们把数据库的交互工作放到服务中心，让前端专注与浏览器的交互上，而不必关注业务逻辑。连接数据库交给业务中心，减少数据库连接数；4.通过服务化，无论前端web应用还是服务中心，都可以由固定的小团队来维护的系统，这样更好地保持稳定和降低风险。</p>
<h2 id="初始消息中间件"><a href="#初始消息中间件" class="headerlink" title="初始消息中间件"></a>初始消息中间件</h2><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件，消息中间件的好处是异步和解耦，生产者和消费者都直接跟消息中间件打交道，两个应用之间并不直接联系。这样完成了解耦，目的是希望双方彼此都不知道对方的存在，不受对方影响，消息投递给接收者用到异步的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
