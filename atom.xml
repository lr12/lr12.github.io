<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-28T15:52:41.688Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软负载中心与集中配置管理（第七章）</title>
    <link href="http://yoursite.com/2017/10/27/%E8%BD%AF%E8%B4%9F%E8%BD%BD%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/27/软负载中心与集中配置管理/</id>
    <published>2017-10-27T07:39:30.000Z</published>
    <updated>2017-10-28T15:52:41.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始软负载中心"><a href="#初始软负载中心" class="headerlink" title="初始软负载中心"></a>初始软负载中心</h2><p>在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知也是通过软负载中心。<br>软负载中心有两个最基本的职能：<br>1.聚合地址信息；无论是服务框架中需要用到的服务提供者地址还是消息中间件系统中的消息中间件地址，都需要由软负载中心去聚合地址列表，形成一个可供服务调用者及消息发送者、接收者接收的列表。<br>2.生命周期感知；软件负载中心能够对服务上下线自动感知，并且根据这个变化去更新服务地址数据，形成新的地址列表后，把数据传给需要数据的调用者或者消息的发送者和接收者。</p>
<h2 id="软负载中心的结构"><a href="#软负载中心的结构" class="headerlink" title="软负载中心的结构"></a>软负载中心的结构</h2><p>软负载中心包括：一个是软负载中心的服务端，另一个是软负载中心的客户端；服务端主要负责感知提供服务的机器是否在线，聚合提供者的机器信息，并且负责把数据传给使用数据的应用。客户端承载了两个角色，作为服务提供者，客户端主要是把服务提供者提供服务的具体信息主动传给服务端，并且随着提供服务的变化去更新数据；而作为服务使用者，客户端主要向服务端告知自己所需要的数据，并负责去更新数据，还要进行本地缓存，使得每次去请求服务来获取列表都是一个本地操作。<br>软件负载中心内部有三部分重要数据<br>1.聚合数据<br>聚合后的地址列表。对于提供的服务信息，我们使用唯一的dataId来标识，同时dataId支持分组（group），通过dataId和group可以定位到唯一的数据内容，这个内容是通过聚合完成的完整数据，而这个信息在内部就是一个key-value结构。<br>2.订阅关系<br>在软负载中心中，需要数据的应用把自己需要的数据告诉软负载中心，这就是订阅关系，订阅的粒度也是通过dataId和group来确定数据，那么会有dataId和group到数据订阅者的分组ID的一个映射关系，当聚合的数据发生变化，通过订阅关系的数据找到需要通知的数据订阅者，然后去进行数据更新操作。<br>3.连接关系<br>连接到软负载中心的节点和软负载中心已经建立的连接管理。使用软负载中心的应用，无论是发布数据还是订阅数据，都会有一个独立的分组，而连接数据就是用groupId作为key，然后对应管理这个物理连接，采用的是长连接方式。当订阅的数据发生变化，通过订阅关系找到需要通知的groupId，在连接数据这里就能够找到对应的连接，完成对应用的更新。</p>
<h2 id="内容聚合功能的设计"><a href="#内容聚合功能的设计" class="headerlink" title="内容聚合功能的设计"></a>内容聚合功能的设计</h2><p>保证数据的正确性<br>内容聚合主要需要保证的是并发场景下的数据聚合的正确性。另外需要考虑发布数据的机器短时间内上下线的问题，指发布数据刚连接上来，然后就断线了就是断线后又很快上线发布数据。内容聚合主要保证在这些异常又较为复杂的场景中保证数据的正确性<br>高效聚合数据<br>因为软负载中心是系统的中枢，虽然软负载中心不再服务调用或者消息投递的路径上，但是服务提供者以及消息中间件的服务地址列表都是由软负载中心进行管理的，高效聚合数据在软负载中心自身重启或者服务提供者大面积重启带来很大的便利。<br>在这里，我们讨论下实现（前提是java实现），我们可以用map来存储，用dataId和group作为key，value就是聚合后的数据。有几个关键点需要注意<br>1.并发下的数据正确性的保证<br>先看看场景，并发操作会是数据插入、更新、删除三个一起在一起的操作，其中删除、更新主要因同一个数据的不同数据发布者变化产生，而数据插入是由于多个新的dataId有进入到Map结构的需求。（如软件负载中心重启和大量的数据发布者重启时）<br>我们可以用ConcurrentHashMap线程安全管理所有dataId的数据，也可以用linkedlist来操作，但是要在增删或者读加锁，否则线程不安全。<br>2.数据更新、删除的顺序保证<br>所发布数据变化主要有新增、更新和删除，而处理顺序一定要跟真实世界的顺序一致，比较容易出现的问题是在网络断开后删除数据与数据新增和删除的问题。我们采用NIO的方式通信，通过selector感知连接的事件，包括数据可读、数据可写、建立连接、连接断开的事件，然后把这些交给IO线程池中的线程去处理，那么更新、新增数据和连接断开要去删除数据有可能在两个线程中去处理。如果是发布数据很快就断开，那么就有可能会出现先删除再新增。一个解决方案是新增数据时查看下是否连接还存在。<br>3.大量数据的同时插入、更新时的性能保证<br>ConcurrentHashmap在写时候采用分段锁，在读的时候不加锁，但在大量数据也遇到性能问题，改进的方案是：增加任务队列，对应的处理线程，以及对应的数据存储。这样针对同样的数据处理任务都放在同一个线程里，我们可以直接使用线程不安全容器；多线程的请求变成一个顺序的队列操作，交给任务队列处理，任务队列是需要线程安全，但是因为这里的操作主要是任务加入队列和任务从队列取出，都是简单的操作，锁冲突的情况相对之前加锁进行数据处理好多了。数据更新的线程如果需要等待更新结果，那就只要进行等待就可以了；而读取数据则一定需要等待任务执行结束后才能拿到结果。</p>
<h2 id="解决服务上下线的感知"><a href="#解决服务上下线的感知" class="headerlink" title="解决服务上下线的感知"></a>解决服务上下线的感知</h2><p>软负载的可用服务列表，当服务可用时，需要自动把服务加到服务地址列表，而服务不可用，需要自动从列表删除，这也就是上下线感知，这也是与使用硬件负载均衡需要配置服务列表的相比的一大优点<br>服务器的上下线的感知，具体有两种实现<br>1.通过客户端与服务器端的连接感知<br>无论是服务的发布者还是接收者都需要与软负载中心维持一个长连接。对于服务提供者来说，软负载中心可以通过这个长连接的心跳或者数据的发布来判断服务发布者是否在线。如果很久没有心跳或者数据的发布，则判定为不在线，那么就会取出这个发布者发布的数据。而对于新上线的发布者，通过连接建立和数据发布就实现了上线的通知。<br>这个方式有个结构的问题，即软负载中心属于旁路，也就是它不在调用链上，当软负载中心自身的负载很高时，是可能产生误判的。例如软负载中心负载压力很大，处理请求变慢，心跳数据来不及处理，会以为心跳超时而判定服务不在线，会导致原本可用的服务下线。<br>另外可能的问题是，如果服务发布者到软负载中心的网络链路有问题，而服务发布者到服务使用者本身没有问题，也会造成感知的问题，解决方案有在软负载中心的客户端增加逻辑，当收到软负载中心通知的应用下线数据时，需要服务调用者进行验证才能接收这个通知，但是这个方法带来的是对每个服务提供者的一次额外校验。<br>2.通过对于发布数据中提供的地址接口进行连接的检查<br>通过长连接的相关感知判断服务下线，不直接认定这个服务下线，而是交给另一个独立的监控应用去验证这个服务是否已经不在了，方式是通过地址、端口去进行连接验证，这种方法是有缺陷，所以还是需要服务调用者进行最终确认。</p>
<h2 id="软负载中心的数据分发的特点和设计"><a href="#软负载中心的数据分发的特点和设计" class="headerlink" title="软负载中心的数据分发的特点和设计"></a>软负载中心的数据分发的特点和设计</h2><h3 id="数据分发和消息订阅的区别"><a href="#数据分发和消息订阅的区别" class="headerlink" title="数据分发和消息订阅的区别"></a>数据分发和消息订阅的区别</h3><p>第一个差别是：消息中间件需要保证消息不丢失、每条消息都能送到消息订阅者，而软负载中心只需要保证最新的数据送到消息订阅者，不需要保证每次的数据变化都能让最终订阅者感知<br>第二个差别是：关于订阅者的集群，也就是订阅者的分组。在消息中间件中，一个集群的不同机器是分享所有消息，因为只要同一集群的一台机器去处理就好。而软负载中心不同，软负载中心维持的是大家需要的服务数据，所以需要把这个数据分发给所有机器。</p>
<h3 id="提升数据分发性能需要注意的问题"><a href="#提升数据分发性能需要注意的问题" class="headerlink" title="提升数据分发性能需要注意的问题"></a>提升数据分发性能需要注意的问题</h3><p>1.数据压缩<br>数据压缩可以降低数据量，提升网络吞吐量，使用cpu来换带宽。<br>2.全量与增量的选择<br>每次传输全量数据，逻辑简单，但是传输数据量大。使用增量，传输数据小，但实现复杂。建议刚开始数据量小时传输全量，数据量大传输增量</p>
<h2 id="针对服务化的特性支持"><a href="#针对服务化的特性支持" class="headerlink" title="针对服务化的特性支持"></a>针对服务化的特性支持</h2><h3 id="软负载特性分组"><a href="#软负载特性分组" class="headerlink" title="软负载特性分组"></a>软负载特性分组</h3><p>通过dataId和group来唯一确定数据。分组是为了隔离</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初始软负载中心&quot;&gt;&lt;a href=&quot;#初始软负载中心&quot; class=&quot;headerlink&quot; title=&quot;初始软负载中心&quot;&gt;&lt;/a&gt;初始软负载中心&lt;/h2&gt;&lt;p&gt;在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件（第六章）</title>
    <link href="http://yoursite.com/2017/10/25/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/10/25/消息中间件/</id>
    <published>2017-10-25T07:23:21.000Z</published>
    <updated>2017-10-27T07:31:26.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息中间件的价值"><a href="#消息中间件的价值" class="headerlink" title="消息中间件的价值"></a>消息中间件的价值</h2><h3 id="消息中间件的定义"><a href="#消息中间件的定义" class="headerlink" title="消息中间件的定义"></a>消息中间件的定义</h3><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件</p>
<h3 id="通过示例看消息中间件对应用的解耦"><a href="#通过示例看消息中间件对应用的解耦" class="headerlink" title="通过示例看消息中间件对应用的解耦"></a>通过示例看消息中间件对应用的解耦</h3><h4 id="通过服务调用让其他系统感知事件发生的方式"><a href="#通过服务调用让其他系统感知事件发生的方式" class="headerlink" title="通过服务调用让其他系统感知事件发生的方式"></a>通过服务调用让其他系统感知事件发生的方式</h4><p>假设我们的登录系统，需要支持的一个功能是发短信给用户，如果在增加后续跟其他系统打交道的工作，会让登录系统变得十分复杂。<br>如登陆系统负责向消息中间件发送消息，而其他的系统则向消息中间件来订阅这个消息，然后完成自己的工作。</p>
<h4 id="通过消息中间件解耦服务调用"><a href="#通过消息中间件解耦服务调用" class="headerlink" title="通过消息中间件解耦服务调用"></a>通过消息中间件解耦服务调用</h4><p>从登陆系统的角度来看，这些系统都不是登录系统必须依赖的，登录系统只需要校验用户名和密码，而类似发短信系统不是登录系统必须依赖的系统。所以，我们需要解耦，服务调用会被固定格式的消息所取代。<br>通过消息中间件解耦，登录系统不需要知道有多少个系统需要知道登录成功这件事，也不用关心怎么传递给他们，只需要把登录成功这件事转化成一个消息发送到消息中间件就好。并且各个系统不受影响。</p>
<h2 id="互联网时代的消息中间件"><a href="#互联网时代的消息中间件" class="headerlink" title="互联网时代的消息中间件"></a>互联网时代的消息中间件</h2><p>JMS:Java Message Service-&gt;规范-&gt;Hornetq,ActiveMQ等产品是这个规范的实现</p>
<h3 id="如何解决消息发送的一致性"><a href="#如何解决消息发送的一致性" class="headerlink" title="如何解决消息发送的一致性"></a>如何解决消息发送的一致性</h3><h4 id="消息发送一致性的定义"><a href="#消息发送一致性的定义" class="headerlink" title="消息发送一致性的定义"></a>消息发送一致性的定义</h4><p>消息发送一致性指产生消息的业务动作与消息发送的一致。即如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了；而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去.</p>
<h4 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h4><p>JMS几个比较重要的元素：<br>Destination：消息所走的通道的目标定义，也就是消息从发送方发出后要走的通道，而不是最终接收方。<br>ConnectionFactory：用于创建连接的对象<br>Connection：连接接口，用于创建session<br>Session：会话接口，消息的发送者，消息的接收者以及消息都是由会话创建。<br>MessageConsumer：消息的消费者，用于订阅并处理消息的对象。<br>MessageProvider：消息的生产者，用于发送消息的对象<br>XXXMessage：指各种类型的对象，包括Bytemessage、MapMessage、ObjectMessage、StreamMesssage和TextMessage；<br>在jms的api接口中，有很多XA开头的类，他们是支持XA协议的接口。XA系列的接口集中在ConnectionFactory、Connection和Session上。但也会造成问题：<br>1.引入分布式事务，这会带来开销和复杂性；<br>2.对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起做分布式事务，这会造成限制（凡是参与全局事务的所有资源均应该使用其XA版。特别地，对于JDBC资源，必须使用JDBC XADataSource）。</p>
<h4 id="其他办法"><a href="#其他办法" class="headerlink" title="其他办法"></a>其他办法</h4><p>简单的方案不能保证一致性，但是出现问题的概率也不大；即便做到业务操作都支持XA，如果引入二阶段提交的分布式事务，则有点重。<br>简化流程：<br>1) 业务处理应用首先把消息发给消息中间件，标记消息的状态为待处理.<br>   (2) 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息.<br>   (3)消息中间件返回消息处理的结果，仅是入库的结果，结果是成功或者失败.<br>   (4)业务方收到消息中间件返回的结果并进行处理:<br>a) 如果收到的结果是失败，那么就放弃业务处理，结束<br>b) 如果收到的结果是成功，则进行业务自身的操作<br>   (5)业务操作完成，把业务操作的结果发送给消息中间件<br>   (6)消息中间件收到业务操作结果，根据结果进行处理<br>a) 如果业务失败，则删除消息存储中的消息，结束<br>b)如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递。<br>最终一致性方案的补偿流程:<br>(1)消息中间件询问状态为待处理的消息对应业务操作结果<br>(2)应用即消息发布者对业务操作检查操作结果<br>(3)发送业务处理结果给消息中间件<br>(4)消息中间件更新消息状态，业务成功，消息状态为待发送；业务失败则消息删除</p>
<h3 id="如何解决消息中间件与使用者的强依赖关系"><a href="#如何解决消息中间件与使用者的强依赖关系" class="headerlink" title="如何解决消息中间件与使用者的强依赖关系"></a>如何解决消息中间件与使用者的强依赖关系</h3><p>如果消息系统出现问题，就会导致业务操作无法继续操作。解决的思路如下：<br>1.提供消息中间件系统的可靠性，但是没办法办证百分百可靠；<br>2.对于消息中间件系统中影响业务的部分，其可靠性与业务系统一样；<br>3.提供弱依赖的功能；<br>对于思路一：我们无法保证百分百可靠；<br>对于思路二：把消息中间件所需要的消息表与业务数据表放到同一个业务数据库，业务操作和写入消息作为一个本地事务完成，然后再通知消息中间件有消息可以发送，解决一致性，也可以消息中间件定时去轮询业务数据库找到需要发送的消息，取出内容后进行发送。这个会有三个影响：<br>1.需要业务自己的数据库去承载消息数据；<br>2.需要消息中间件访问业务数据库；<br>3.需要业务操作的对象是数据库，或者说是支持事务的存储，必须这个存储能够支持消息中间件的需求。<br>所以我们有个折中的操作：消息中间件不再直接与业务数据库打交道，将业务操作、写入消息，轮询消息等全部放到业务应用。<br>加一个本地磁盘作为一个消息存储，如果消息中间件崩溃，我们可以把本地磁盘作为存储消息的地方。这有两种用法：1.作为一致性发送消息的解决方案的容灾手段，，平时不工作，出问题才切换。2.直接使用该方式；<br>最后我们看下业务操作与消息一致性带来的两个限制：<br>1.需要确定要发送的消息内容；2.需要实现对业务的检查</p>
<h3 id="消息模型对消息的接收的影响"><a href="#消息模型对消息的接收的影响" class="headerlink" title="消息模型对消息的接收的影响"></a>消息模型对消息的接收的影响</h3><p>在JMS中，有Queue（点对点）和Topic（发布/订阅）两种模型</p>
<h4 id="JMS-Queue模型"><a href="#JMS-Queue模型" class="headerlink" title="JMS Queue模型"></a>JMS Queue模型</h4><p>应用1和应用2发送消息到JMS服务器，这些消息根据到达的顺序形成一个队列，应用3和应用4进行消息的消费;如果Queue里面的消息被一个应用处理了，那么连接到JMS Queue上的另一个应用是收不到这个消息的。即连接到这个JMS Queue上的应用共同消费了所有的消息。消息从发送端发送出来时不能确定最终会被哪个应用消费，但是可以明确的是只有一个应用会去消费这条消息，Peer To Peer方式(PTP)</p>
<h4 id="JMS-Topic模型"><a href="#JMS-Topic模型" class="headerlink" title="JMS Topic模型"></a>JMS Topic模型</h4><p>和Queue模型的最大区别在于消息接收的部分，在该模型中，接收消息的应用3和应用4是可以独立收到所有到达Topic的消息的，Pub/Sub方式</p>
<h4 id="JMS中客户端连接的处理和带来的限制"><a href="#JMS中客户端连接的处理和带来的限制" class="headerlink" title="JMS中客户端连接的处理和带来的限制"></a>JMS中客户端连接的处理和带来的限制</h4><p>在使用JMS时，每个Connection都有一个ClientId，用于标记的唯一性。如果两个应用共建立三个连接，每个连接都会收到所有发送到topic的消息。</p>
<h4 id="我们需要什么样的消息模型"><a href="#我们需要什么样的消息模型" class="headerlink" title="我们需要什么样的消息模型"></a>我们需要什么样的消息模型</h4><p>我们要满足的需求为：<br>消息发送方和接收方都是集群；<br>同一个消息的接收方可能有多个集群进行消息的处理；<br>不同集群对于同一条消息的消息不能互相干扰；<br>现在我们需要每个集群使用topic模式，然后集群的内部使用queue模式；我们可以引入clusterId，用这个id标识不同的集群；集群内各个应用连接使用这个clusterid。当服务器端进行调度时，在不同的集群之间独立投递，而拥有相同的clusterId的共同消费这个消息。<br>还有一种思路是将JMS的topic和queue级联使用，首先最顶层是JMS topic，中间有一层消息中转层，再通过JMS queue，最下层是集群内消费使用。<br>缺点是级联方式过于繁重，处理复杂，好处是使用jms实现。</p>
<h3 id="消息订阅者订阅消息的方式"><a href="#消息订阅者订阅消息的方式" class="headerlink" title="消息订阅者订阅消息的方式"></a>消息订阅者订阅消息的方式</h3><p>分为持久订阅和非持久订阅<br>非持久化订阅指的是消息接收者和消息中间件之间的消息订阅关系的存续，与消息接收者自身运行的状态有直接的关系。<br>持久化订阅指的是消息订阅关系一旦建立，除非应用显式地取消订阅关系，否则订阅关系将一直存在，如果消息接收者应用停止，那么消息会保留，等待下次应用启用后投递给消息接收者。</p>
<h3 id="保证消息可靠性的做法"><a href="#保证消息可靠性的做法" class="headerlink" title="保证消息可靠性的做法"></a>保证消息可靠性的做法</h3><p>持久订阅能够保证消息的可靠性，消息从发送端到接收端，中间需要经历三个阶段可靠：<br>1.消息发送者把消息发送给消息中间件；<br>2.消息中间件把消息存入消息存储；<br>3.消息中间件把消息投递给消息接收端；</p>
<h4 id="消息发送端的可靠"><a href="#消息发送端的可靠" class="headerlink" title="消息发送端的可靠"></a>消息发送端的可靠</h4><p>发送者需要把消息的发送结果准确的传给应用，应用才能进行相关的业务操作。消息从发送者发送到消息中间件，只有消息中间件及时明确地返回成功，才能确认消息可靠地到达消息中间件。返回错误、异常或者超时，都可以认为这个动作失败。</p>
<h4 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h4><p>1.实现基于文件的消息存储<br>主要把消息直接存储在本地磁盘，不需要对额外独立存储。ActiveMQ（kaha db），KahaDB是基于文件的本地数据库储存形式<br>2.使用数据库作为消息存储<br>3.基于双机内存的消息存储<br>磁盘IO的关系，性能会受到影响，内存的速度远超磁盘，但断电会失去数据，正常情况下，消息持久存储不工作，一旦一个机器故障，会停止另一台的写，并把数据写入数据持久存储。</p>
<h4 id="消息系统的扩容"><a href="#消息系统的扩容" class="headerlink" title="消息系统的扩容"></a>消息系统的扩容</h4><p>1.消息中间件自身如何扩容<br>消息中间件本身没有持久态，扩容比较容易，只需要让消息发送者和消息订阅者能够感知到有新的消息中间件机器加入了集群。同一个存储区分存储的消息来自哪个消息中间件应用：增加一个server字段。<br>2.消息存储的扩容处理<br>优势：1.不用保证消息的顺序；2.提供从服务端对消息投递的方式，不支持主动获取消息。<br>首先，消息发送到消息中间件，消息中间件将消息入库，所以消息中间件一定知道消息存在哪。<br>其次，由于内存中进行调度的消息数量有限，因此我们会调度存在数据库的消息，这个调度必然会跨所有库和所有表，需要投递的消息会把相关索引消息加载到内存中，内存调度消息也自然有了存储节点的消息。</p>
<h4 id="消息投递的可靠性保证"><a href="#消息投递的可靠性保证" class="headerlink" title="消息投递的可靠性保证"></a>消息投递的可靠性保证</h4><p>1.消息投递简介<br>消息中间件需要显示地收到接收者确认消息处理完毕，才能删除消息。<br>2.投递处理的优化<br>投递处理第一个可优化的是在进行投递时一定要采用多线程方式处理，每个线程处理一条消息时，会得到需要接收该消息的订阅者集群Id列表，然后从每个订阅者集群Id里选择一个连接来处理，消息投递后会更新消息状态，然后统一更新消息表中的消息状态。如果订阅者集群有一个很慢的订阅者，负责投递的所有线程会慢慢堵死，都需要等待这个慢的订阅者返回。<br>我们还可以采用，采用异步的方式，把消息返回处理的工作放到另外的线程池中操作，保证投递的环节不会被堵死，返回的结果可以放在内存中，等待其他线程进行处理。<br>其次我们还要优化，即一个应用有多个订阅者订阅同样的消息，如果不加以优化，会发送多次同样的消息，我们的优化是：单机共享连接；消息只发送一次，然后传到单机多订阅者生成多个处理实例。</p>
<h3 id="订阅者视角的消息重复的产生和应对"><a href="#订阅者视角的消息重复的产生和应对" class="headerlink" title="订阅者视角的消息重复的产生和应对"></a>订阅者视角的消息重复的产生和应对</h3><h4 id="消息重复产生的原因"><a href="#消息重复产生的原因" class="headerlink" title="消息重复产生的原因"></a>消息重复产生的原因</h4><p>第一类原因是消息发送方重复发送消息<br>1.消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，这是消息中间件出现了问题，导致应用端没有收到消息发送成功的返回，因而进行了重复的发送。<br>2.消息中间件由于负载比较高变得比较慢，成功把消息存储到消息存储后，返回成功结果超时。<br>3.消息中间件收到消息存储后，但由于网络原因，导致应用端收不到消息，进行重试。<br>解决的办法有通过消息id来标识<br>第二类原因是消息中间件对外投递时发生了重复<br>1.消息中间件投递由于网络原因，消息中间件没能收到反馈消息；<br>2.消息接收者处理时间比较长，超时<br>3.消息中间件出现问题，没收到结果消息<br>4.消息存储出现故障，没能更新状态<br>可以采用分布式事务来解决，但是不过这种方式比较复杂，成本也比较高；另一种方式是要求消息消费者来处理这种重复的方式，也就是要求这是幂等操作。</p>
<h4 id="JMS消息确认与消息重复的关系"><a href="#JMS消息确认与消息重复的关系" class="headerlink" title="JMS消息确认与消息重复的关系"></a>JMS消息确认与消息重复的关系</h4><p>AUTO_ACKNOWLEDGE<br>自动确认，当JMS消息接收者接收到消息，JMS的客户端会自动进行确认。但是确认时消息还没来得及处理或者还未处理完成，所以这种确认方式也是不可靠<br>CLIENT-ACKNOWLEDGE<br>客户自己确认的方式，也就是客户端如果要确认消息处理成功，告诉服务器端确认消息，需要主动调用Message接口的acknowledge方法进行消息接收成功的调用；<br>DUPS_OK_ACKNOWLEDGE<br>这种方式是消息接收方的消息处理函数执行结束后确认，一方面保证消息一定是处理结束后才确认，另一方面也不需要客户端调用acknowledge接口<br>消息接收者接收的消息会出现下面两张情况：<br>1.at lease once<br>采用CLIENT-ACKNOWLEDGE或者DUPS_OK_ACKNOWLEDGE并且在消息处理前没有确认的话，就可能产生这种现象。<br>2.at most once<br>采用AUTO_ACKNOWLEDGE或者CLIENT-ACKNOWLEDGE并且在接收消息后立刻确认的情况</p>
<h3 id="消息投递的其他属性支持"><a href="#消息投递的其他属性支持" class="headerlink" title="消息投递的其他属性支持"></a>消息投递的其他属性支持</h3><p>1.消息优先级<br>一般情况下消息先到先投递，消息的优先级属性可以根据优先级确定投递顺序。<br>2.订阅者消息处理顺序和分级订阅<br>消息的多个订阅者之间是独立的，它们对消息的处理并不会相互造成影响。但对于一些场景，对于同样的消息，可能会希望有些订阅者处理结束后再让其他订阅者处理。另一种方案是分级订阅。<br>把优先接收者和一般接收者分开，优先接收者处理成功后主动把消息投递到另外的消息中间件，然后一般接收者接收新产生的消息。<br>3，自定义属性<br>消息自身的创建时间、类型、投递次数等属性属于基础属性，在消息体外，自定义属性会很方便，这种自定义属性类似http的header<br>4.局部顺序<br>局部顺序是指在众多消息中，和某件事情有关的多条消息之间有顺序，而多件事情之间的消息没有顺序。比如我们可以不必保持多个人之间的交易顺序，但是对同一个交易产生的变化需要保持其顺序。<br>比如线上的交易的消息状态依次生死：创建、付款、发货、确认（Kafka发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton和key是可选的。如果你指定了partition，那就是所有消息发往同1个partition，就是有序的。并且在消费端，Kafka保证，1个partition只能被1个consumer消费。）</p>
<h3 id="保证顺序的消息队列的设计"><a href="#保证顺序的消息队列的设计" class="headerlink" title="保证顺序的消息队列的设计"></a>保证顺序的消息队列的设计</h3><p>同一消息订阅者处理不同消息，成功与否跟消息的内容有关（比如手机充值，我们可以看到充值成功与否跟手机号码合法化有关），现在讨论依赖消息订阅者的状态有关（数据复制，只要源数据库可用，则复制一定成功）。<br>在这样场景下，一个吞吐量达且支持顺序的消息中间件是很有价值的，数据变更平台就是这样的一个场景。在这里，由原来的push模式变为pull模式，为了让消息接收者更好的控制消息的接收和处理，消息中间件逻辑也得到了简化。具体实现是消息存储写到文件中，采用顺序写入，消息必须按顺序消费，所以一个消息接收者在每一个他所接收的消息队列上有一个当前消费的位置，之前的位置代表已经消费的消息，不同消费者维护分别维护自己的指针，可以通过指针的回溯来进行消息的补发。接收端拥有比较大的自主权。</p>
<h4 id="单机多序列问题和优化"><a href="#单机多序列问题和优化" class="headerlink" title="单机多序列问题和优化"></a>单机多序列问题和优化</h4><p>单机多队列的隔离完成了对消息的有序支持。如果单的队列数量数量多，性能会下降很大，原因是队列数量大时，写就接近随机写。改进措施有按顺序写入，然后根据队列做个索引。<br>带来的好处是：<br>1.队列轻量化，单个队列数据量少<br>2.对磁盘访问串行化，避免竞争<br>缺点是：<br>1.写虽然是顺序写，但是读是随机读<br>2.读先读逻辑队列在读物理队列，增加开销<br>3.需要保证物理队列与逻辑队列的完全一致。编程复杂</p>
<h4 id="解决本地消息存储的可靠性"><a href="#解决本地消息存储的可靠性" class="headerlink" title="解决本地消息存储的可靠性"></a>解决本地消息存储的可靠性</h4><p>采用消息同步复制的方式解决可靠性的问题<br>把单个消息中间件变为主（master）备（slave）两个节点，slave订阅master所有消息，用来消息备份。不过需要注意这是一个异步操作，slave订阅收到的消息会比master略少一点，存在着丢失信息的可能，类似mysql的replication<br>同样是把单个节点扩展到Master/Slave节点，但是采用的是同步复制，而不是订阅。对于消息更为严格的场景，第二种更为安全可靠</p>
<h4 id="如何支持队列的扩容"><a href="#如何支持队列的扩容" class="headerlink" title="如何支持队列的扩容"></a>如何支持队列的扩容</h4><p>基本的策略是消息发送者能够知道应该把消息写入迁移到新的队列中，并且也让消息订阅者知道，当前队列消费完消息后要去新的队列去消费消息<br>有几个关键点：<br>1.原队列在开始扩容会有个标记，即便有新的消息进来，也不再接收<br>2.通知消息发送端发送新的队列位置<br>3.对于消息接收端，对原来队列的定位会收到新旧两个位置，当旧数据的数据接收完毕后，则只会关心新队列的位置</p>
<h3 id="push和pull方式对比"><a href="#push和pull方式对比" class="headerlink" title="push和pull方式对比"></a>push和pull方式对比</h3><p>1.从数据传输状态；push保存在服务器端，pull保存在消费端<br>2.从传输失败，重试；push要维护每次传输状态，pull不需要<br>3.数据传输的实时性；push非常实时，pull默认的短轮询方式的实时依赖性依赖于pull间隔时间，间隔越大，实时性越低，长轮询的方式实时性与pull一致。<br>4.从流控机制；push方式服务器需要根据订阅者的消费能力做流控，pull方式消费端可以根据自身消费能力决定是否去pull消息</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消息中间件的价值&quot;&gt;&lt;a href=&quot;#消息中间件的价值&quot; class=&quot;headerlink&quot; title=&quot;消息中间件的价值&quot;&gt;&lt;/a&gt;消息中间件的价值&lt;/h2&gt;&lt;h3 id=&quot;消息中间件的定义&quot;&gt;&lt;a href=&quot;#消息中间件的定义&quot; class=&quot;head
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据访问层（第五章）</title>
    <link href="http://yoursite.com/2017/10/23/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82/"/>
    <id>http://yoursite.com/2017/10/23/数据访问层/</id>
    <published>2017-10-23T09:24:31.000Z</published>
    <updated>2017-10-25T07:14:17.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库从单机到分布式的挑战和应对"><a href="#数据库从单机到分布式的挑战和应对" class="headerlink" title="数据库从单机到分布式的挑战和应对"></a>数据库从单机到分布式的挑战和应对</h2><h3 id="从应用使用单机数据库开始"><a href="#从应用使用单机数据库开始" class="headerlink" title="从应用使用单机数据库开始"></a>从应用使用单机数据库开始</h3><p>各种类似ODBC、JDBC的封装、以及ORM的封装都很成熟，我们这里重点考虑数据量和访问量增大的时候，系统要面临的问题和相应的解决方案。</p>
<h3 id="数据库垂直拆分和水平拆分的困难"><a href="#数据库垂直拆分和水平拆分的困难" class="headerlink" title="数据库垂直拆分和水平拆分的困难"></a>数据库垂直拆分和水平拆分的困难</h3><p>垂直拆分会带来的影响：<br>1.单机的ACID保证会被打破；要么放弃单机事务，修改实现，要么引入分布式事务。<br>2.一些join操作会变得比较困难，因为数据已经在两个数据库中，所以不是很方便利用数据库自身的join；<br>3.靠外键进行约束的场景会受限制；<br>水平拆分会带来的影响：<br>1.同样可能ACID会被打破；<br>2.同样join可能会受到影响；<br>3.靠外键进行约束的场景会受限制；<br>4.依靠单库生成递增唯一标识会受影响；<br>5.针对单个逻辑上的表的查询要跨库；</p>
<h3 id="多机事务如何处理"><a href="#多机事务如何处理" class="headerlink" title="多机事务如何处理"></a>多机事务如何处理</h3><h4 id="分布式事务知识"><a href="#分布式事务知识" class="headerlink" title="分布式事务知识"></a>分布式事务知识</h4><h5 id="分布式事务模型与规范"><a href="#分布式事务模型与规范" class="headerlink" title="分布式事务模型与规范"></a>分布式事务模型与规范</h5><p>X/Open组织（the open group）提出了分布式事务规范-XA，分布式事务处理模型-X/Open DTP（distributed transaction processing reference model）模型。定义了三个组件–application  program、Resource manager和transaction manager。<br>AP:应用程序，它定义了事务的边界，并定义了构成该事务的应用程序的特定操作。<br>RM：资源管理器，可以理解为DBMS系统，或者消息服务器管理系统。AP通过RM对资源进行控制，资源必须实现XA接口。资源管理器提供了存储共享资源的支持。<br>TM：事务管理器，负责协调和管理事务，提供给AP接口用来管理RM。事务管理器向事务指定标识，监视他们的进程，并负责处理事务的完成和失败。事务分支标识（XID）用TM指定，标识一个RM的全局事务和特定分支。他是TM日志和RM日志之间的相关标识。两阶段性提交用到XID<br>AP和TM、RM通信，TM和RM之间互相通信，通过XA接口。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交。<br>提交阶段<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)。<br>首先是会有很多日志的操作，以及网络交互的增多引入事务管理器的开销导致整体开销会大。所以在进行垂直或水平拆分时，必要时才引入二阶段式提交。</p>
<h4 id="大型网站一致性理论基础理论–CAP-BASE"><a href="#大型网站一致性理论基础理论–CAP-BASE" class="headerlink" title="大型网站一致性理论基础理论–CAP/BASE"></a>大型网站一致性理论基础理论–CAP/BASE</h4><p>CAP的含义：<br>C：Consistency:一致性，所有节点在同样的时间读到同样的数据。这就是数据上的一致性，也就是当数据写入成功后，所有的节点都能同时看到这个新的数据<br>A：Availability：保证无论是成功还是失败，每个请求都能够收到一个反馈。这就是数据的可用性，这里重点是系统要有响应。<br>P：Partition Tolerance：即便系统有部分问题或者消息丢失，但系统依然能够继续运行。这被称为分区容忍性，也就是系统的一部分出现问题，系统仍能够继续工作。<br>分布式不能同时满足这三项，也就是我们可以选择两个来提升，但另外一个将会受到损失。在系统进行设计和权衡时，也就是在选择CA、CP、AP<br>选择CA：放弃分区容忍性，加强一致性和可用性。传统单机数据库的选择；<br>选择AP：放弃一致性，很多NOSQL系统的选择；<br>选择CP：放弃可用性，这种情况下可用性会很低，网络的问题会让整个系统不可用<br>在分布式系统中，我们一般选择增强可用性和分区容错性而选择牺牲一致性。<br>BASE(Base available 基本可用 soft state 软状态 eventually  consistent 最终一致性 )<br>基本可用指的是分布式系统发生故障，允许损失部分可用性。<br>软状态指的是接受一段时间状态不同步<br>最终一致性指的是强调的是系统中的所有数据副本，在经过一段时间的同步后，最终能够达到一致的状态。</p>
<h4 id="paxos协议"><a href="#paxos协议" class="headerlink" title="paxos协议"></a>paxos协议</h4><h4 id="集群内数据一致性的算法实例"><a href="#集群内数据一致性的算法实例" class="headerlink" title="集群内数据一致性的算法实例"></a>集群内数据一致性的算法实例</h4><p>quorum，它是用来权衡分布式系统的数据一致性和可用性的。<br>N：数据复制节点数量<br>R：成功读操作的最小节点数<br>W：成功写操作的最小节点数<br>如果R+W&gt;N，是可以保证强一致性，而如果R+W&lt;=N，则保证最终一致性。<br>vector clock的思路是对同一份数据的每次修改都要加上&lt;修改者，版本号&gt;，用来记录修改者信息以及版本号。Vector Clock能解决分布式系统多版本合并的问题，但是对于确实发生冲突的版本，它无法合并，而需要用户自己去做合并。</p>
<h2 id="多机的sequence问题与处理"><a href="#多机的sequence问题与处理" class="headerlink" title="多机的sequence问题与处理"></a>多机的sequence问题与处理</h2><p>当转变为水平分库以后，原来单库的sequence以及自增的id都需要改变。我们可以从两个方向去考虑解决这个问题：唯一性和连续性。<br>如果只考虑唯一性，可以考虑用uuid（ip，机器名，mac，时间，本机计数器）生成，但是会导致分布式系统的连续性不好。<br>如果考虑连续性，我们可以把所有的ID集中放在一个地方进行管理，对每一个ID序列进行独立管理，每台机器使用Id都从这个地方去取。这里有几个问题需要解决：<br>性能问题：每次远程取Id会有资源损耗。一种办法是一次取一段Id，然后缓存到本地，这样就不用每次再去取。但也会带来问题，比如，如果机器宕机，那么取的一段Id将不可用。<br>生成器稳定问题：Id生成器是无状态集群，其可用性要靠整个集群保证<br>存储问题：底层存储的选择空间比较大，需要根据不同类型来进行对应的容灾方案。下面介绍两种方式：<br>第一种是底层有一个独立存储记录每个Id序列当前的最大值，并控制并发更新。这样一来生成逻辑就比较简单。第二种是去掉Id生成器，把相关逻辑嵌入到需要生成Id的应用中，而在每个应用中完成生成器要做的工作，即读取可用的ID或者Id段。因为没有中心控制节点，我们不希望生成器之间有通信，所以id并不是严格按照进入数据库的顺序增大。</p>
<h2 id="应对多机的数据查询"><a href="#应对多机的数据查询" class="headerlink" title="应对多机的数据查询"></a>应对多机的数据查询</h2><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><p>解决方案有：1.把原来join操作分成多次数据库操作。2.数据冗余，对一些常用的信息进行冗余，这样就可以把原来的join变为单表查询。3.借助外部系统如搜索引擎来解决。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>如果要对分库后的单库做外键约束，就要求分库后的每个单库都是数据内聚，否则只能在应用层的判断和容错。</p>
<h3 id="跨库查询的问题及解决"><a href="#跨库查询的问题及解决" class="headerlink" title="跨库查询的问题及解决"></a>跨库查询的问题及解决</h3><h4 id="数据库分库分表的演化"><a href="#数据库分库分表的演化" class="headerlink" title="数据库分库分表的演化"></a>数据库分库分表的演化</h4><p>合并查询问题的根源是我们在进行水平分库分表后，把一张表分成了多张物理上的表。我们举个例子，我们有两个库，每个库存了两张用户表。从逻辑上这些表应该一起储存，但随着访问量和数据量的增多，需要经历分库分表，此时，一张逻辑表对应多张物理表，在应用中，对这张逻辑表的查询就要做跨库的跨表的合并了。</p>
<h4 id="从具体例子看分库分表的问题"><a href="#从具体例子看分库分表的问题" class="headerlink" title="从具体例子看分库分表的问题"></a>从具体例子看分库分表的问题</h4><p>如果我们查询一个省的符合年龄的用户。在单表时，这是一个普通的查询。而分库分表后，我们可能会遇到麻烦。如果我们按地域划分，那么问题就退化成为单库单表问题。但是如果我们查询多个省份，这就产生了跨库问题，就需要再查询结果取个并集。但还有更为复杂的操作，如：</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>即多个数据源的数据查询出来，在应用层做排序，如果从数据库查出来的数据已经排好序，那么，只需要做多路归并排序就好；如果查询的数据没有排序，则需要做全排序；</p>
<h5 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a>函数处理</h5><p>使用max min sum count函数，即对多个数据源的值进行函数处理。</p>
<h5 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h5><p>从多个数据源查询时，需要把SQL改为Sum和count，然后对多个数据源求sum和count。</p>
<h5 id="非排序分页"><a href="#非排序分页" class="headerlink" title="非排序分页"></a>非排序分页</h5><p>这里面有两种策略，一种是同等步长的在多个数据源上分页处理；另一种是同等比例地分页处理。同等步长指的是分页中的每一页，来自不同数据源的记录数是一样的；同等比例值得是，来自不同数据源的数据数，占这个数据源符合条件的数据总数的比例是一样的。<br>打个比方，有两个数据源，符合条件的数据数分别有16和8，一页的数量为4，同等步长指的是每次取数据源一2个，数据源二2个。如果是同比例，假设一页数量6，那么是数据源一4个，数据源二2个。因此用相同的次数获取完。</p>
<h5 id="排序分页"><a href="#排序分页" class="headerlink" title="排序分页"></a>排序分页</h5><p>如果我们要取第n页数据，我们需要从各个数据源取前n页数据，然后归并排序。也就是越往后翻页，压力越大。在访问量很大的情况下，我们需要尽量避免这种情况，尤其是排序需要翻很多页的时候。</p>
<h2 id="数据层的设计和实现"><a href="#数据层的设计和实现" class="headerlink" title="数据层的设计和实现"></a>数据层的设计和实现</h2><h3 id="如何对外提供数据访问层功能"><a href="#如何对外提供数据访问层功能" class="headerlink" title="如何对外提供数据访问层功能"></a>如何对外提供数据访问层功能</h3><h4 id="对外提供数据访问层方式"><a href="#对外提供数据访问层方式" class="headerlink" title="对外提供数据访问层方式"></a>对外提供数据访问层方式</h4><p>第一种方式是为用户提供专有API；第二种通用的方式是一般通过jdbc访问数据库。还有是通过基于orm或者类orm接口的方式，如ibatis、hibernate、spring jdbc。</p>
<h4 id="不同提供方式之间合并查询场景下的对比"><a href="#不同提供方式之间合并查询场景下的对比" class="headerlink" title="不同提供方式之间合并查询场景下的对比"></a>不同提供方式之间合并查询场景下的对比</h4><p>比如分页排序，orm会生成很多无效的对象然后丢弃，而jdbc只需要生成响应的对象。再获取后面页内容时，直接基于jdbc的的优势比较明显</p>
<h3 id="按照数据层流程的顺序看数据层设计"><a href="#按照数据层流程的顺序看数据层设计" class="headerlink" title="按照数据层流程的顺序看数据层设计"></a>按照数据层流程的顺序看数据层设计</h3><h4 id="sql解析阶段的处理"><a href="#sql解析阶段的处理" class="headerlink" title="sql解析阶段的处理"></a>sql解析阶段的处理</h4><p>通过sql的解析可以获取表名、字段、where条件，根据参数规则确定目标数据源的连接。</p>
<h4 id="规则处理阶段"><a href="#规则处理阶段" class="headerlink" title="规则处理阶段"></a>规则处理阶段</h4><p>1.采用固定的哈希算法作为规则<br>根据某个字段（例如用户id）取模，然后将数据分散到不同的数据库或表中。除了会根据id取模，还会根据时间维度，例如（天，星期，月，年）等来存储数据，这一般用于数据产生后日期不再修改的场景，否则就要涉及数据迁移。时间取模多用于日志类和其他时间维度密切相关的场景。通常将周期性数据放在一起，这样进行数据备份，迁移或者现有的数据清空都会很方便。 固定哈希的规则和设置都比较简单，但是扩容比较复杂。<br>2.一致性哈希算法<br>一致性哈希所带来的最大变化是把节点的哈希值变为一个范围，而不在是离散的。在一致性哈希中，我们会把哈希值范围定的非常大，然后把这个范围分配给现在节点。如果有新节点加入，那么这个新节点会从原来某个节点分管一部分哈希值。如果这个节点退出，那么这个节点管理的哈希值会分配给下一个节点。但一致性哈希会导致负载不均衡，比如不管是新加一个节点还是减少一个节点，他能造成的影响的范围只有他自己和另外一个节点。<br>3.虚拟节点对一致性哈希的改进<br>4个物理节点可以变成很多个虚拟节点，每个虚拟节点支持连续的哈希环上的一段。而这时如果加入一个物理节点，就会相应加入很多虚拟节点，这些新的虚拟节点是相对均匀地插入到整个哈希环上，这样，就可以很好的分担现有物理节点的压力了；如果减少一个物理节点，对应的很多虚拟节点就会失效，这样，就会有很多剩余的虚拟节点来承担之前虚拟节点的工作，但是对于物理节点来说，增加的负载相对是均衡的。<br>4.映射表与规则自定义计算方式<br>映射表是根据分库分表字段的值的查表法来确定数据源的方法，一般对热点数据的特殊处理，或者在一些场景下对完全不符合规律的规则进行补充。<br>最后定义的计算方式是最灵活的方式，它已经不算是以配置的方式做规则，而是通过复杂的函数来解决数据访问规则，扩展性最强。<br>举例来说，我们id取模分成四个库，然后对于热点数据，单独放到一个库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( id  <span class="keyword">in</span> hotest)&#123;</div><div class="line">  <span class="built_in">return</span> 4;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> id%4;</div></pre></td></tr></table></figure></p>
<h4 id="为甚么要改写sql"><a href="#为甚么要改写sql" class="headerlink" title="为甚么要改写sql"></a>为甚么要改写sql</h4><p>如何设定规则，一般原则是分库后尽量避免跨库查询。举商品为例，我们可以根据商品id取模或者一致性哈希分库，但同个卖家多个商品可能涉及到跨库。如果以卖家id分库那么根据商品id查询就麻烦了，因为不知道商品在哪个库中。具体采用哪种分库需要综合考虑。除了根据规则确定数据源，如果是分表的话，表明还不一样，一般在逻辑表加自增后缀。还有索引名和跨库计算平均值。</p>
<h4 id="如何选择数据源"><a href="#如何选择数据源" class="headerlink" title="如何选择数据源"></a>如何选择数据源</h4><p>在User进行分库分表后，我们会给分库提供一个备库，也就是原来的一个数据库变为一个数据库矩阵，分库就是把数据分到不同的数据分组。除了决定访问哪个数据库组以外，还需决定是分组的哪个库。这些库一般是一写多读，要根据sql的特点（读或者写）以及库的权重规则，计算sql请求访问的数据库。</p>
<h4 id="执行sql和结果处理阶段"><a href="#执行sql和结果处理阶段" class="headerlink" title="执行sql和结果处理阶段"></a>执行sql和结果处理阶段</h4><h4 id="实战经验分享"><a href="#实战经验分享" class="headerlink" title="实战经验分享"></a>实战经验分享</h4><p>1.复杂的连接管理<br>2.三层数据的选择和支持</p>
<h3 id="独立部署的数据库访问层实现方式"><a href="#独立部署的数据库访问层实现方式" class="headerlink" title="独立部署的数据库访问层实现方式"></a>独立部署的数据库访问层实现方式</h3><p>从数据库的物理部署上可以分为jar包和proxy模式，如果是proxy模式的话，那么客户端和proxy之间的协议有数据库协议和私有协议。</p>
<h3 id="读写分离的挑战和应对"><a href="#读写分离的挑战和应对" class="headerlink" title="读写分离的挑战和应对"></a>读写分离的挑战和应对</h3><p>通过读写分离的方案，可以分担主库的读压力。这里面存在一个数据复制问题，也就是把主库（master）的数据复制到备库（slave）去。</p>
<h4 id="主库从库非对称场景"><a href="#主库从库非对称场景" class="headerlink" title="主库从库非对称场景"></a>主库从库非对称场景</h4><p>1.数据结构相同，多从库对应一主库的场景<br>mysql的replication可以解决这个问题，并且延迟比较小。在多从库对应一主库的情况下，业务应用只要根据自身的业务特点，把对数据不敏感的读切换到备库进行即可。首先来看slave，slave采用PC server，和Mysql的方案比较划算的。对于一个主库，需要多台采用mysql的PC Servcer对应原来master中的一部分数据，也就是进行了分库。<br>数据复制有两种方式：<br>比较优雅的方式是通过数据库的日志来进行数据复制；<br>比较不优雅的方式是应用通过数据层访问数据库，通过消息系统对数据库的更新送出消息通知，数据同步服务器获得消息通知后会进行数据的复制工作。分库规则则负责在读数据和数据同步服务器更新分库时让数据层知道分库规则。数据同步服务器和DB主库的交互方式，主要根据修改或者新增的数据主键来获取内容，采用行复制的功能。<br>2.主备分库方式不同的数据复制<br>数据读写分离一般采取的是对称复制，也就是镜像，但也有一些场景下进行非对称复制。这里指的非对称复制是指源数据和目标数据不是镜像规则。打个比方，我们订单可以按照买家进行分库，把所有订单分到四个库中，这保证了一个买家的订单都在同一个库里，但是卖家却不在同一个库中，因而要进行跨库查询。我们可以做一个备库，按照卖家id来查询。这时候需要控制数据的分发，而不是简单地进行镜像复制。<br>3.引入数据变更平台<br>引入Extractor和Applier，Extractor负责把数据源变更的信息加入到数据分发平台中，而Applier的作用是把这些变更应用到相应的目标上，中间的数据分发平台中是由多个管道组成，进入到数据分发平台的变更信息就是标准化、结构化的数据了。例如MySQL推出Applier,可实时复制数据到Hadoop</p>
<h4 id="如何做到数据平滑迁移"><a href="#如何做到数据平滑迁移" class="headerlink" title="如何做到数据平滑迁移"></a>如何做到数据平滑迁移</h4><p>最大挑战是，在迁移的过程中又会有数据的变化(因为很多应用不能接受长时间的停机)，可以考虑的方案是在开始进行数据迁移时记录增量的日志，在迁移结束后，再对增量的变化进行处理，在最后,可以要把要被迁移的数据的写暂停，保证增量日志都处理完毕后，再切换规则，放开所有的写，完成迁移工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库从单机到分布式的挑战和应对&quot;&gt;&lt;a href=&quot;#数据库从单机到分布式的挑战和应对&quot; class=&quot;headerlink&quot; title=&quot;数据库从单机到分布式的挑战和应对&quot;&gt;&lt;/a&gt;数据库从单机到分布式的挑战和应对&lt;/h2&gt;&lt;h3 id=&quot;从应用使用单机数据
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>服务框架（第四章）</title>
    <link href="http://yoursite.com/2017/10/21/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/10/21/服务框架/</id>
    <published>2017-10-21T11:56:11.000Z</published>
    <updated>2017-10-23T14:03:13.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站功能持续丰富后的困境与应对"><a href="#网站功能持续丰富后的困境与应对" class="headerlink" title="网站功能持续丰富后的困境与应对"></a>网站功能持续丰富后的困境与应对</h2><p>网站的功能主要集中在几个大应用上，而且这些应用都直接访问底层的服务，例如数据库、缓存、搜索引擎、分布式存储。随着网站规模扩大，开发人的增多，每个应用变得复杂、臃肿。</p>
<h3 id="把应用拆小"><a href="#把应用拆小" class="headerlink" title="把应用拆小"></a>把应用拆小</h3><p>把庞大的应用拆成多个。这样的好处是相对较快的完成，但是仍然存在一些问题。一方面是数据库的连接数的压力还在，其次是代码的重复问题。</p>
<h3 id="服务化方案"><a href="#服务化方案" class="headerlink" title="服务化方案"></a>服务化方案</h3><p>我们在原来的应用和底层的数据库、缓存系统、文件系统等系统之间增加了服务层。</p>
<h2 id="服务框架的设计和实现"><a href="#服务框架的设计和实现" class="headerlink" title="服务框架的设计和实现"></a>服务框架的设计和实现</h2><h3 id="应用从集中式走向分布式所遇到的问题"><a href="#应用从集中式走向分布式所遇到的问题" class="headerlink" title="应用从集中式走向分布式所遇到的问题"></a>应用从集中式走向分布式所遇到的问题</h3><p>要把单层Web应用的结构改为多层的、有服务层的结构的时，很多人不会直接做一个通用的服务框架，而是为当前要用的服务做一个RPC的功能，为服务使用者提供相关的客户端。而当提供的服务的集群多于一个小时，通用的服务框架就非常重要。服务化会使得把本地调用变为远程调用。研发人员关注的是提高易用性和降低性能损失这两方面。<br>在单机单进程中，程序只需要将寄存器地址改为相应的入口地址就好，而在多机之间，我们需要对调用的请求信息进行编码，然后传给远程的节点，解码后再进行真正的调用。寻址路由是为了让调用方确定哪个实例被调用的，实际定位是指被调用的机器找到对应的实例来进行方法调用，从而实现功能。</p>
<h3 id="通过示例看服务框架原型"><a href="#通过示例看服务框架原型" class="headerlink" title="通过示例看服务框架原型"></a>通过示例看服务框架原型</h3><p>服务框架即包含调用方的逻辑，又包含服务端的逻辑的一个实现。</p>
<h4 id="单机方式"><a href="#单机方式" class="headerlink" title="单机方式"></a>单机方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Calculator&#123;</div><div class="line">     public int add(int a,int b)&#123;</div><div class="line">       <span class="built_in">return</span> a+b;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Calculator calculator =new Calculator();</div><div class="line">calculator.add(2,3);</div></pre></td></tr></table></figure>
<h4 id="实现远程服务的调用客户端"><a href="#实现远程服务的调用客户端" class="headerlink" title="实现远程服务的调用客户端"></a>实现远程服务的调用客户端</h4><p>以单机为例，我们希望实现这个服务的方式和当前的做法一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int add(int a,int b)&#123;</div><div class="line"></div><div class="line">  //获取可用服务列表</div><div class="line">  List&lt;String&gt; l=getAvailableServiceAddresses(<span class="string">"Calculator.add"</span>);</div><div class="line">  //获取调用服务的目标机器</div><div class="line">  String address=chooseTarget();</div><div class="line">  //建立连接</div><div class="line">  Socket socket=new Socket(address);</div><div class="line">  //请求序列化</div><div class="line">  byte[] request=getRequest(a,b);</div><div class="line">  //发送请求</div><div class="line">  socket.getOuputStream().write(request);</div><div class="line">  //接受结果</div><div class="line">  byte[] response=new byte[1024];</div><div class="line">  socket.getInputStream().read(response);</div><div class="line">  int result=getResult(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们解析这段代码，首先是获取服务机器的地址列表，并且从可用的服务地址列表中选取一个要调用的目标机器。<br>如果我们采取的LVS或者硬件负载均衡方案，那么getAvailableServiceAddresses获取的就是获取LVS或者硬件负载均衡器的地址和端口，并且choosTarget会直接返回地址和端口。<br>如果我们采取名称服务，那么getAvailableServiceAddresses返回的是当前的服务的地址列表，参数值用来定位服务，这个一般用做key的服务名字一般采用接口的全名，也就是全限类名，也可以用类名加版本号。<br>如果我们采用规则解析，这种方式更多应用在有状态的场景上。像数据这种状态要求很高的场景，或者缓存这种尽量要有状态的场景，都会用到规则服务器的方式来解决寻址问题。在无状态的场景，则不太用规则服务器的方式处理。<br>构造请求数据包其实就是把对象变为二进制数据，也就是java的序列化。请求后，我们需要等待远程服务的执行和结果的返回，收到结果后，我们会对数据进行java1反序列化，等到结果。</p>
<h4 id="实现服务端"><a href="#实现服务端" class="headerlink" title="实现服务端"></a>实现服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">eventHandler</span></span>()&#123;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    byte[] requestData=receiveRequest();</div><div class="line">    Request request=getRequest(requestData);</div><div class="line">    Object service=getServiceByNameAndVersion(request.getServiceName(),request.getServiceVersion());</div><div class="line">    Object result=callService(service,request.getMethodName(),request.getArgs());</div><div class="line">    byte[] data=getResult(result);</div><div class="line">    request.socket.getOuputStream.write(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段伪代码中，我们需要持续接受请求并进行响应，收到的数据也需要反序列化。在这里，我们关注服务的名称、服务的版本号、调用的方法名称和参数以及调用的连接。当我们拿到请求对象后，我们需要本地定位具体的服务，我们会有个服务注册表，我们可以动态发布服务。得到服务实例后，我们会服务调用，一般通过反射来调用，然后序列化结果，传输给客户端。</p>
<h3 id="服务调用端的设计和实现"><a href="#服务调用端的设计和实现" class="headerlink" title="服务调用端的设计和实现"></a>服务调用端的设计和实现</h3><p>调用过程是调用发起、寻址路由、协议适配/序列化、网络传输、反序列化/协议解析、得到结果返回调用方。</p>
<h4 id="从代码的角度看如何使用服务框架"><a href="#从代码的角度看如何使用服务框架" class="headerlink" title="从代码的角度看如何使用服务框架"></a>从代码的角度看如何使用服务框架</h4><p>客户端的引入是我们首先需要解决的问题，大多数的java开发都会使用spring作为容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ConsumerBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>以上是简单的版本的服务框架，我们先看三个基础的属性</p>
<h5 id="interfaceName"><a href="#interfaceName" class="headerlink" title="interfaceName"></a>interfaceName</h5><p>接口名称，在进程远程通信时ConsumerBean必须要知道调用的接口是哪一个，然后才能生成这个接口的代理，以供本地调用。</p>
<h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>版本号，在实际场景中，接口的变化是可能的。如果直接变化，那么要求所有使用的地方一起修改，一起升级。解决问题的方式有两种，一种是需要修改方法的参数或者返回值，也就是新增一个方法，保持原来方法不变，不过在过渡阶段导致代码臃肿，并且方法名不好取名。第二种是通过版本号进行隔离。</p>
<h5 id="group"><a href="#group" class="headerlink" title="group"></a>group</h5><p>分组。分组属性的好处是如果对同一个接口的远程调用有很多机器，那么我们可以把远程机器分组，然后调用者可以选择不同分组调用，这样就可以把不同调用者对同一服务进行隔离。</p>
<h4 id="运行期服务框架与应用和容器的关系"><a href="#运行期服务框架与应用和容器的关系" class="headerlink" title="运行期服务框架与应用和容器的关系"></a>运行期服务框架与应用和容器的关系</h4><p>有两个比较重要的问题需要解决：1.服务框架本身的部署方式问题；2.实现服务框架所依赖的一些外部包和应用自身依赖的jar包冲突。<br>首先是部署方式；一种方案是把服务框架作为应用的一个依赖包并与应用进行打包。通过这个方式，服务框架就变为应用的一个库，并随应用启动。存在的问题是，如果要升级服务框架，就需要更新应用本身；并且服务框架也没办法接管classloader，也没办法做到隔离和包的实现替换工作。<br>另一种方案是把服务框架作为容器的一部分，那么服务框架就变为一个容器提供远程调用和远程服务的功能。<br>Jar包冲突问题，应用和服务框架的jar包版本冲突；将服务框架的自身用的类和应用用的类都控制在User-defined class loader级别上，这样就实现了相互间的隔离。web容器对多个web应用的处理以及OSGI对bundle处理采用了类似的方法。我们可以看下类加载器的层级关系，最上到下依次是bootstrap class loader($JAVA_HOME/jre/lib/rt.jar)、Extension class Loader($JAVA_HOME/jre/lib/ext/rt.jar)、System class loader($CLASSPATH)、user defined class loader</p>
<h3 id="服务调用者和服务提供者之间通信方式的选择"><a href="#服务调用者和服务提供者之间通信方式的选择" class="headerlink" title="服务调用者和服务提供者之间通信方式的选择"></a>服务调用者和服务提供者之间通信方式的选择</h3><p>服务框架是为了把本地对象之间的方法调用变为远程过程调用，，这就涉及到远程通信问题。</p>
<h4 id="远程通信遇到的问题"><a href="#远程通信遇到的问题" class="headerlink" title="远程通信遇到的问题"></a>远程通信遇到的问题</h4><p>最初的路由寻址过程是把远程的IP和端口号写死在代码中，但是如果是一个集群这种方式就满足不了</p>
<h4 id="采用透明代理与调用者、服务提供者直连的解决方案"><a href="#采用透明代理与调用者、服务提供者直连的解决方案" class="headerlink" title="采用透明代理与调用者、服务提供者直连的解决方案"></a>采用透明代理与调用者、服务提供者直连的解决方案</h4><p>这里面我们通过两种方式，一种是中间代理，另一种是服务注册查找中心；服务注册查找中心只是提供可用的服务提供者列表，调用者会缓存下来地址，然后当地址列表发生改变时在去向中心获取。当客户端拿到地址后，如何对当次进行调用就是路由要做的事情，我们首先要考虑的是集群的负载均衡的实现，比如轮询、随机、权重等方式，可以参考硬件负载均衡机器或者LVS或者HAProxy策略。</p>
<h4 id="引入基于接口、方法、参数的的路由"><a href="#引入基于接口、方法、参数的的路由" class="headerlink" title="引入基于接口、方法、参数的的路由"></a>引入基于接口、方法、参数的的路由</h4><p>一般用接口作为服务的粒度，一个服务也就是一个接口的远程实现。假设服务提供两个接口，分别是接口A，接口B，每个服务又提供了两个方法。一般来说一个请求对应一个线程，而总线程数量有一个限制，一旦并发请求过多，其余的就必须要等待。假设某个方法执行的时间很慢，那么很快如果很多线程请求该方法，那么在进入这个方法时，一旦达到瓶颈值，那么其他线程就在等待。我们可以有两种解决方案，增加机器数，可以减少分到单台机器的请求数。也就是增加资源保证系统的能力超出需要；第二种方案是隔离这些资源，从而使得快慢不同重量级别不同的方法互不影响。而分流策略可以让请求服务A的请求全部在右上方机器，请求服务B的请求全部在右下方机器。我们负载均衡的策略的具体实现是先获取服务框架的规则后进行路由处理，也就是根据服务定位提供服务集群的地址，然后在与接口路由规则中的地址做个交集，得到的地址在进行负载均衡算法，最后得到一个可用的地址进行调用。但是基于接口并未解决这个问题，因为A服务的方法一的瓶颈会影响A服务的方法而，这时我们路由规则可以基于接口名加方法，什么可以基于方法名加方法加参数</p>
<h3 id="多机房场景"><a href="#多机房场景" class="headerlink" title="多机房场景"></a>多机房场景</h3><h3 id="服务调用端的流控处理"><a href="#服务调用端的流控处理" class="headerlink" title="服务调用端的流控处理"></a>服务调用端的流控处理</h3><p>流量控制是为了保证系统的稳定性。我们有两种控制方式，一种是01开关，完全打开和完全不打开；另外一种设定一个固定值，表示每秒可以进行请求的次数。超过这个请求数的就拒接对远程的请求。我们可以从两个维度进行控制：1.根据服务端的接口、方法进行控制；也就是根据不同接口设置不同阈值，这是为了使服务端的不同接口、方法之间的负载不互相影响；根据来源做控制，也就是对同样的接口对不同来源设置不同的限制。</p>
<h3 id="序列化和反序列处理"><a href="#序列化和反序列处理" class="headerlink" title="序列化和反序列处理"></a>序列化和反序列处理</h3><p>对于Java的序列化，需要考虑三个问题：1.跨语言问题；2.序列化和反序列化的性能开销；3.序列化后的长度；我们可以考虑xml或者json作为序列化方式。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>通信方式有BIO、NIO和AIO，BIO是阻塞IO，是一个连接消耗一个线程，但是消耗大。如果是NIO，那么客户端和服务器端之间的连接是可以复用的，而不是一个连接消耗一个线程。我们希望通过一个连接来进行多个并发请求操作。类比公路的职能，每条公路允许多辆汽车行驶而不是只有一辆汽车行驶。NIO提供的是非阻塞方式的IO，需要对外提供的是类似阻塞的同步远程请求方式。我们增加了IO线程，数据队列，通信对象队列，和定时任务。</p>
<h3 id="支持异步服务的调用方式"><a href="#支持异步服务的调用方式" class="headerlink" title="支持异步服务的调用方式"></a>支持异步服务的调用方式</h3><h4 id="oneWay"><a href="#oneWay" class="headerlink" title="oneWay"></a>oneWay</h4><p>oneWay是只管发送不管结果，只需要把要发送的数据放入数据队列，然后继续下面的操作。oneway不关心对方是否收到数据，也不关心返回值。</p>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>这种方式下，请求方发送后会继续执行下面操作，等对方响应会进行一个回调</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>把数据写入队列，把future写入队列，通过future获取结果</p>
<h4 id="可靠的异步"><a href="#可靠的异步" class="headerlink" title="可靠的异步"></a>可靠的异步</h4><p>通过消息中间件</p>
<h3 id="使用Future对远程服务调用的优化"><a href="#使用Future对远程服务调用的优化" class="headerlink" title="使用Future对远程服务调用的优化"></a>使用Future对远程服务调用的优化</h3><p>如果我们在一个请求处理中调用多个远程服务，如果采用同步的方式，那么总时间是全部请求时间求和，如果我们仍然按照顺序把服务的请求依次发给各个服务，但是请求过去后并不等待结果，而是在最后服务发出去后在等待，这样总时间变为单个远程服务时间的最大值。但是这有个前提，所有的服务并没有依赖关系，所以他们可以一起等。</p>
<h2 id="服务端的设计和实现"><a href="#服务端的设计和实现" class="headerlink" title="服务端的设计和实现"></a>服务端的设计和实现</h2><h3 id="如何暴露远程服务"><a href="#如何暴露远程服务" class="headerlink" title="如何暴露远程服务"></a>如何暴露远程服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calculator"</span> class=<span class="string">"ProviderBean"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"interfaceName"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"target"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"version"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"group"</span>&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>服务端提供的是providerBean，而客户端提供的是ConsumerBean。providerBean的职能是服务需要注册到服务查找中心后才能被服务调用者发现，所以providerBean需要将自己所代表的服务注册到服务注册查找中心。也需要在本机注册服务和对应服务的实例。</p>
<h3 id="服务端对请求处理的流程"><a href="#服务端对请求处理的流程" class="headerlink" title="服务端对请求处理的流程"></a>服务端对请求处理的流程</h3><p>服务框架启动时需要监听端口号，并且等待调用的请求。当服务注册好，监听端口号也准备好，就只需等待服务调用的请求进来。请求处理流程是：网络通信层、协议解析/反序列化、定位服务、调用服务。</p>
<h3 id="执行不同服务的线程池隔离"><a href="#执行不同服务的线程池隔离" class="headerlink" title="执行不同服务的线程池隔离"></a>执行不同服务的线程池隔离</h3><h3 id="服务提供者的流控处理"><a href="#服务提供者的流控处理" class="headerlink" title="服务提供者的流控处理"></a>服务提供者的流控处理</h3><p>在服务提供者看来，不同来源的服务调用者、0-1开关、限制具体数值的QPS方式都需要实现。对不同调用者进行升级，确保优先级高的服务调用者被优先调用</p>
<h3 id="服务升级"><a href="#服务升级" class="headerlink" title="服务升级"></a>服务升级</h3><h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><h4 id="修改调用参数列表"><a href="#修改调用参数列表" class="headerlink" title="修改调用参数列表"></a>修改调用参数列表</h4><p>1.对原来的方法的代码进行修改<br>2.通过版本号来解决<br>3.在设计的方法上考虑参数的扩展。但是不可行，通过map不直观</p>
<h2 id="实战的优化"><a href="#实战的优化" class="headerlink" title="实战的优化"></a>实战的优化</h2><h3 id="服务的拆分"><a href="#服务的拆分" class="headerlink" title="服务的拆分"></a>服务的拆分</h3><h3 id="服务的粒度"><a href="#服务的粒度" class="headerlink" title="服务的粒度"></a>服务的粒度</h3><h3 id="优雅和实用的平衡"><a href="#优雅和实用的平衡" class="headerlink" title="优雅和实用的平衡"></a>优雅和实用的平衡</h3><p>最上层是服务调用者，如果服务调用者调用服务十分频繁，可以写入缓存。没有在调用服务提供者，服务提供者先访问本地缓存，没有在访问数据库</p>
<h3 id="分布式环境下的请求合并"><a href="#分布式环境下的请求合并" class="headerlink" title="分布式环境下的请求合并"></a>分布式环境下的请求合并</h3><p>对于热点数据的处理，如果可以进行一些任务的合并问题，就会明显降低整个系统的负载。首先可以通过缓存，减少数据的读取和计算的工作量。还可以解析完参数，检查是否有线程在在计算相同的数据，如果有，等待结果；没有，进行计算。分布式环境下会涉及到多节点，如果使用分布式锁，则会有额外的开销。但是我们可以使用路由策略，相同参数的服务发送到同一台服务提供者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网站功能持续丰富后的困境与应对&quot;&gt;&lt;a href=&quot;#网站功能持续丰富后的困境与应对&quot; class=&quot;headerlink&quot; title=&quot;网站功能持续丰富后的困境与应对&quot;&gt;&lt;/a&gt;网站功能持续丰富后的困境与应对&lt;/h2&gt;&lt;p&gt;网站的功能主要集中在几个大应用上，而
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>构建java中间件（第三章）</title>
    <link href="http://yoursite.com/2017/10/19/%E6%9E%84%E5%BB%BAjava%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/10/19/构建java中间件/</id>
    <published>2017-10-19T02:59:08.000Z</published>
    <updated>2017-10-21T09:02:22.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中间件的定义"><a href="#java中间件的定义" class="headerlink" title="java中间件的定义"></a>java中间件的定义</h2><p>基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的服务，中间件不是操作系统的一部分，不是数据库管理的一部分，不是软件应用的一部分，而是能够让软件开发者更方便的处理通信、输入、输出，能够专注在他们自己应用的部分。总体来说，中间件不是最上层应用，也不是最底层的操作系统，是处于中间的组件，起到桥梁的作用，是应用和应用之间，应用和服务之间的桥梁。<br>主要有三个领域的中间件：</p>
<h3 id="远程对象调用和对象访问中间件"><a href="#远程对象调用和对象访问中间件" class="headerlink" title="远程对象调用和对象访问中间件"></a>远程对象调用和对象访问中间件</h3><p>解决分布式的应用互相访问的问题</p>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>解决应用之间的消息传递、解耦、异步的问题</p>
<h3 id="数据访问中间件"><a href="#数据访问中间件" class="headerlink" title="数据访问中间件"></a>数据访问中间件</h3><p>主要解决应用访问数据库的共性问题的组件</p>
<h2 id="构建java中间件的基础知识"><a href="#构建java中间件的基础知识" class="headerlink" title="构建java中间件的基础知识"></a>构建java中间件的基础知识</h2><h3 id="跨平台的运行环境–jvm"><a href="#跨平台的运行环境–jvm" class="headerlink" title="跨平台的运行环境–jvm"></a>跨平台的运行环境–jvm</h3><p>java虚拟机所识别的是统一格式的中间代码也就是java字节码。</p>
<h3 id="垃圾回收与内存堆布局"><a href="#垃圾回收与内存堆布局" class="headerlink" title="垃圾回收与内存堆布局"></a>垃圾回收与内存堆布局</h3><p>java虚拟机是通过垃圾回收方式来回收内存的，而不像C/C++语言那样通过代码显示释放。JVM内存堆布局有新生代、年老代、持久代。对象创建一般在新生代的eden区，也有可能直接分配在年老区。</p>
<h2 id="java并发编程的类、接口和方法"><a href="#java并发编程的类、接口和方法" class="headerlink" title="java并发编程的类、接口和方法"></a>java并发编程的类、接口和方法</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池可以降低创建线程的开销，这是因为线程池在线程结束后进行的是回收操作，而不是销毁线程。在java中，我们主要使用的线程池是ThreadPoolExecutor,此外，我们还有定时线程池scheduledThreadPoolExecutor。需要注意的是ThredPool.newCachedThreadPool()返回的线程池的使用，该方法返回的线程池的线程使用没有上限。因而没办法控制总体线程的数量，因为每个内存都要占用内存，这会造成过多内存的占用。建议不要用这个线程池。而使用有固定线程上限的线程池。</p>
<h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><p>sychronized可以用于声明方法，也可以用于声明代码块。看一下三个使用场景。<br>场景一：<br>在这个类的两个静态方法中，不同线程中，两个方法的调用是互斥的，不仅这样任何两个线程都是互斥的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo1&#123;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo1</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo2</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景二：<br>foo3和foo4是类的两个成员函数，在多线程中，调用同一个对象的foo3和foo4才会互斥，这是同一对象的多线程调用互斥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo2&#123;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo3</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo4</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景三：<br>sychronized用来修饰代码块，后面的参数就是同步锁的对象。sychronized(this) 与Demo3中加sychronized成员方法是互斥，sychronized(Demo3.class)与Demo3中加sychronized静态方法是互斥的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo3&#123;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo5</span></span>()&#123;</div><div class="line">           sychronized(this)&#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo6</span></span>()&#123;</div><div class="line">          sychronized(Demo3.class)&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是java.util.concurrent.locks中的一个类，他的用法类似sychronized类似，但是需要显示unlock。</p>
<h4 id="ReentrantLock提供tryLock"><a href="#ReentrantLock提供tryLock" class="headerlink" title="ReentrantLock提供tryLock"></a>ReentrantLock提供tryLock</h4><p>调用的时候，如果锁被其他线程持有，那么tryLock就会立刻返回，返回结果为false，如果锁没有被其他线程持有，当前线程会持有锁，返回true。</p>
<h4 id="ReentrantLock提供公平锁和抢占锁"><a href="#ReentrantLock提供公平锁和抢占锁" class="headerlink" title="ReentrantLock提供公平锁和抢占锁"></a>ReentrantLock提供公平锁和抢占锁</h4><p>默认是抢占锁，通过参数boolean fair；公平锁的好处是等待锁的线程不会饿死，但是整体效率会降低；非公平锁的好处是整体效率会相对高点，但是有些线程会饿死或者等待很长时间才能获取。公平锁是按照锁的排队顺序需要获取锁，而非公平锁是抢占式的。此外ReentrantLock还提供了ReentrantReadWriteLock，读写锁，主要用于读多写少并且读不需要互斥的场景，这样的锁比全部互斥锁性能会高。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlock写在finally表示一定可以释放锁，ReentrantReadWriteLock与ReentrantLock用法相似，但是通过readLock()和writeLock()两个方法来获取读锁和写锁，这两个锁按照前面的方式进行加锁和解锁。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>sychronized除了有互斥性，还有可见性。可见性是指一个线程修改了变量后，其他线程能够马上看到这个修改值。volatile能够保证变量的可见性，它更多是修饰开关的可见性，它不能保证操作的原子性。</p>
<h3 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h3><p>JDK 1.5增加了java.util.concurrent.atomic包，这些包是以Atomic开头的类，这些类提供了一些原子操作，以AtomicInteger为例，通过jni使用硬件支持的CAS指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Sample &#123;</div><div class="line"></div><div class="line">    private static AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">increment</span></span>() &#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">decrease</span></span>() &#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h3><p>wait、notify和notifyAll是java的object对象的三个方法，wait是用来等待的，notify和notifyAll是用来通知的。在多线程中，可以把某个对象做为事件对象，通过这个对象的wait、notify、notifyAll完成线程的通知。notify和notifyAll都是唤醒调用同一个对象的wait，但不同的是notify会唤醒一个等待线程，notifyAll会唤醒全部等待线程。对wait、notify、notifyAll的调用必须在对象的sychronized中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">testWait</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.wait();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">testNotify</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实践中，对wait的使用一般在循环里，并且会判断相关的数据状态是否达到预期，如果没有，继续等待，这样做主要是为了防止虚假唤醒。虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒，而此时是不应该唤醒的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sychronized(obj)&#123;</div><div class="line"></div><div class="line">       <span class="keyword">while</span>(&lt;condition does not hold&gt;)</div><div class="line">            obj.wait();</div><div class="line">           //<span class="keyword">do</span>Sometihing()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是java.util.concurrent包中的一个类。CountDownLatch提供的机是当多个（具体数量是等于初始化CountDownLatch初始化的值）线程都到达了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件触发自己后续的工作。等待的线程可以是多个，即CountDownLatch可以唤醒多个等待的线程，到达自己预期的状态会调用CountDownLatch的countDown方法，而等待的线程可以调用countDownLatch的await方法。<br>如果CountDownLatch的初始化count值为1就退化成为了单个事件，即由一个线程通知其他线程，效果等同于await和notifyAll。count值大于1是常用的方式，目的是让多个线程到达各自的预期状态，变为一个事件来通知，线程继续自己的行为。<br>例如我们使用一台多核机器对一组数据进行排序，我们可以把一组数据分到不同的线程去排序，然后在进行合并；可以将CountDownLatch作为各个线程排好序的通知。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int count=10;</div><div class="line">final CountDownLatch latch=new CountDownLatch(count);</div><div class="line">int[] datas=new int[10204];</div><div class="line">int step=datas.length/count;</div><div class="line"><span class="keyword">for</span>(int i=0;i&lt;count;i++)&#123;</div><div class="line">    int begin=i*step;</div><div class="line">    int end=(i+1)*step;</div><div class="line">    <span class="keyword">if</span>(i==count-1)&#123;</div><div class="line">      end=datas.length;</div><div class="line">    &#125;</div><div class="line">    threadPool.execute(new MyRunnable(latch,datas,begin,end));</div><div class="line">&#125;</div><div class="line">latch.await();</div><div class="line">合并数据</div><div class="line">MyRunnable的run实现</div><div class="line">public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">  //数据排序</div><div class="line">  latch.countDown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier字面意思循环屏障，CyclicBarrier可以协调多个线程，让多个线程在这个屏障等待，直到所有线程都到达了这个屏障，再一起继续执行后面的动作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static class WorkerThread implements Runnable&#123;</div><div class="line"></div><div class="line">          CyclicBarrier barrier;</div><div class="line"></div><div class="line">          public WorkerThread(CyclicBarrier b)&#123;</div><div class="line">             this.barrier = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         @Override</div><div class="line">         public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">             // TODO Auto-generated method stub</div><div class="line">             try&#123;</div><div class="line">                 System.out.println(<span class="string">"Worker's waiting"</span>);</div><div class="line">                 //线程在这里等待，直到所有线程都到达barrier。</div><div class="line">                 barrier.await();</div><div class="line">                 System.out.println(<span class="string">"ID:"</span>+Thread.currentThread().getId()+<span class="string">" Working"</span>);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch的count等于调用countDown的个数，CyclicBarrier的数量是await的数量。CyclicBarrier、CountDownLatch都是用于多线程协调，但不同是，CountDownLatch是在多线程中进行latch.countDown后才会触发事件，唤醒await的线程。而CyclicBarrier是用于同步所有调用await方法的线程。并且等到所有线程到了await后才会一起返回继续自己的工作。CountDownLatch不能循环调用,CyclicBarrier可以循环调用。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是用来管理信号量的，构造的时候传入可供管理信号量的数值。简单来说，信号量对象管理的信号就像令牌，构造时传入个数，总数就是控制并发的数量。执行前先获取信号（通过acquire），执行后归还信号（通过release），每次acquire成功后，信号量减少一，如果没有可用的信号，acquire就会阻塞，等待release调用释放信号，才能获取信号返回。<br>如果Semaphore管理的信号量只有一个，就退化成互斥锁。如果大于1的信号量，主要用于控制并发数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">semaphore.acquire();</div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">semaphore.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger用于两个线程的数据进行交换，线程会阻塞Exchanger的exchange方法，知道另外一个线程也到exchange方法，然后交换数据，往下执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">final Exchanger&lt;List&lt;String&gt;&gt; exchanger = new Exchanger&lt;List&lt;String&gt;&gt;();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"1"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread1"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">				list.add(<span class="string">"3"</span>);</div><div class="line">				try &#123;</div><div class="line">					list=exchanger.exchange(list);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(list+<span class="string">":thread2"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div></pre></td></tr></table></figure></p>
<h3 id="Future和FuturTask"><a href="#Future和FuturTask" class="headerlink" title="Future和FuturTask"></a>Future和FuturTask</h3><p>Future 是一个接口，FutureTask是接口的实现类，我们看下这么样的场景<br>通过调用一个方法从远程获取一些计算结果，假设有HashMap getDataFromRemote();<br>假设是同步的方式，我们会一直等待这个方法的返回，然后才能继续下面的工作，如果这个方法执行的时间比较长，并且后面的代码跟这个方法没关系的话，那么阻塞在这里就没有意义。<br>第二种方式是异步的方式，调用函数后马上返回，然后继续执行，等需要用时再来取数据。具体实现方式是用Future，或者回调。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>并发容器是线程安全容器的一种，但是并发容器强调容器的并发性，也就是不仅强调安全，也强调并发。比较有代表的是CopyAndWrite和Concurrent开头的容器。如ConcurrentHashMap，ConcurrentLinkedQueue，ConcurrentLinkedDequeue、CopyOnWriteArrayList、CopyOnWriteArraySet。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	 public void <span class="keyword">do</span>Something();  </div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	  public void <span class="function"><span class="title">doSomething</span></span>()   </div><div class="line">	  &#123;   </div><div class="line">	    System.out.println( <span class="string">"call doSomething()"</span> );   </div><div class="line">	  &#125;   </div><div class="line">&#125;</div><div class="line">public class ProxyObject implements Subject &#123;</div><div class="line"></div><div class="line">	private RealSubject realSubject;</div><div class="line"></div><div class="line">	public ProxyObject(RealSubject realSubject) &#123;</div><div class="line">		super();</div><div class="line">		this.realSubject = realSubject;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		realSubject.doSomething();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理有静态代理和动态代理之分。<br>静态代理方式是为每一个被代理的对象构造对应的代理类。这种方式比较直接，实现也比较方便，不过也存在问题，即如对多个类进行代理，并且在代理类的功能实现是一致的，就必须为每一个具体类都完成一个代理类。<br>动态代理是动态地生成具体委托类的代理类实现对象。与静态代理不同，它只需要为一类代理行为写一个具体的实现类。用过Proxy.newProxyInstance来创建代理的方式可以为不同的委托类创建代理类。在具体的代理实现上，所给出的是通用实现，被代理的方法会进入invoke方法，我们可以在invoke方法中做很多事情，例如调用前和调用后可以操作。并且对于一类的增强事情，我们不用写多个ProxyHandler，就可以给多个委托类使用<br><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ProxyHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	  private Object proxied;   </div><div class="line"></div><div class="line">	  public ProxyHandler( Object proxied )   </div><div class="line">	  &#123;   </div><div class="line">	    this.proxied = proxied;   </div><div class="line">	  &#125;   </div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println(&quot;before invoke&quot;);</div><div class="line">		Object object=method.invoke(proxied, args);</div><div class="line">		System.out.println(&quot;after invoke&quot;);</div><div class="line">		return object;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">RealSubject realSubject = new RealSubject();</div><div class="line">		Subject subject = (Subject) Proxy.newProxyInstance(</div><div class="line">				Subject.class.getClassLoader(), new Class[]&#123;Subject.class&#125;,</div><div class="line">				new ProxyHandler(realSubject));</div><div class="line">		subject.doSomething();</div></pre></td></tr></table></figure></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>java反射机制是指在运行状态中，对于任意的一个类，都能知道这个类的所有方法和所有属性。对于任意一个对象，都能调用他的任意一个他的方法或者他的属性。反射主要提供的功能有：1.在运行时判断任意一个对象所属的类；2.在运行时构造任意一个对象所属的类；3.在运行时判断任意一个类的所具有的成员变量和方法；4.在运行时调用任意一个对象的方法；5.生成动态代理。用法示例</p>
<h3 id="获取对象属于哪个类"><a href="#获取对象属于哪个类" class="headerlink" title="获取对象属于哪个类"></a>获取对象属于哪个类</h3><p>Subject subject=new Subject(“lr12”, “topic”);<br>Class class=subject.getClass();</p>
<h3 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h3><p>//获取类名<br>String className=clazz.getName();<br>//获取方法<br>Method[] methods=clazz.getDeclaredMethods();<br>//获取成员变量<br>Field[] fields=clazz.getDeclaredFields();</p>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3><p>Class.forName(“reflect.Subject”).newInstance();<br>在这里的通过传入一个字符创来构造对象，体现了动态性，同时要求这个类的构造函数必须有一个无参的，否则将抛出异常。</p>
<h3 id="动态执行方法"><a href="#动态执行方法" class="headerlink" title="动态执行方法"></a>动态执行方法</h3><p>Method method=clazz.getDeclaredMethod(“doSomething”);<br>method.invoke(subject);</p>
<h3 id="动态操作属性"><a href="#动态操作属性" class="headerlink" title="动态操作属性"></a>动态操作属性</h3><p>Field field=clazz.getDeclaredField(“name”);<br>field.set(subject, “lr”)<br>这里要强调如果方法和属性是静态的，这时候可以不用传对象，可以传null。</p>
<h3 id="网络通信实现选择"><a href="#网络通信实现选择" class="headerlink" title="网络通信实现选择"></a>网络通信实现选择</h3><p>网络通信三个模型：BIO、NIO、AIO。在1.4的版本中增加了NIO，在1.7的版本中增加了AIO。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java中间件的定义&quot;&gt;&lt;a href=&quot;#java中间件的定义&quot; class=&quot;headerlink&quot; title=&quot;java中间件的定义&quot;&gt;&lt;/a&gt;java中间件的定义&lt;/h2&gt;&lt;p&gt;基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大型软件架构及其结构演进过程第二章</title>
    <link href="http://yoursite.com/2017/10/17/%E5%A4%A7%E5%9E%8B%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/17/大型软件架构及其结构演进过程/</id>
    <published>2017-10-17T09:25:39.000Z</published>
    <updated>2017-10-19T03:29:47.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是大型网站"><a href="#什么是大型网站" class="headerlink" title="什么是大型网站"></a>什么是大型网站</h1><p>访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是个分布式系统</p>
<h1 id="大型网站的架构演进"><a href="#大型网站的架构演进" class="headerlink" title="大型网站的架构演进"></a>大型网站的架构演进</h1><h2 id="用java技术和单机来构建网站"><a href="#用java技术和单机来构建网站" class="headerlink" title="用java技术和单机来构建网站"></a>用java技术和单机来构建网站</h2><p>选择一个开源的server作为容器，使用一些JSP/servlet技术或者开源框架构建我们的应用，选择一个数据库管理系统来管理数据，通过jdbc进行数据库的连接和操作。</p>
<h2 id="从一个单机的交易网站说起"><a href="#从一个单机的交易网站说起" class="headerlink" title="从一个单机的交易网站说起"></a>从一个单机的交易网站说起</h2><p>考虑一个交易网站，最基本功能有这么三个部分：用户模块、商品模块、交易模块，各个功能模块是通过JVM内部的方法调用来进行交互，应用和数据库之间是通过jdbc来访问的。同时应用和数据库放在同一台机子上。</p>
<h2 id="单机负载告警，数据库与应用分离"><a href="#单机负载告警，数据库与应用分离" class="headerlink" title="单机负载告警，数据库与应用分离"></a>单机负载告警，数据库与应用分离</h2><p>网站对外提供服务后，访问量不断增大，负载持续升高。我们可以把数据库和应用分开，分别放到两台机子上。</p>
<h2 id="应用服务器告警，如何让应用服务器走向集群"><a href="#应用服务器告警，如何让应用服务器走向集群" class="headerlink" title="应用服务器告警，如何让应用服务器走向集群"></a>应用服务器告警，如何让应用服务器走向集群</h2><p>服务器压力仍然变大，把应用从单机升级为集群，我们可以考虑一台应用服务器变为两台。我们要考虑如下两个问题，第一个是服务器的选择问题，可以用dns或者增加负载均衡设备来解决这个问题；第二个是session问题。</p>
<h3 id="引入负载均衡设备"><a href="#引入负载均衡设备" class="headerlink" title="引入负载均衡设备"></a>引入负载均衡设备</h3><h3 id="解决应用服务器变为集群后的session问题"><a href="#解决应用服务器变为集群后的session问题" class="headerlink" title="解决应用服务器变为集群后的session问题"></a>解决应用服务器变为集群后的session问题</h3><p>http协议本身是无状态的，需要基于http协议支持会话状态机制，具体的实现方式是：在会话开始时，分配唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后再每次请求的时候，浏览器会带上这个会话标识告诉web服务器请求属于哪个会话的。在web服务器上，各个会话有独立的存储，保存不同的会话信息。如果是禁用cookie的情况，就把会话标识放在url参数上。<br>当应用服务器扩展时就会遇到session问题。因为session是存在单机上的。</p>
<h4 id="session-sticky（保持-粘滞会话）"><a href="#session-sticky（保持-粘滞会话）" class="headerlink" title="session sticky（保持-粘滞会话）"></a>session sticky（保持-粘滞会话）</h4><p>在负载均衡器上做了操作，同样的session请求每次发送给同一个服务器端处理。但也带来以下的问题：1.如果一台服务器宕机或者重启，那么这台服务器上的会话数据会全部丢失，如果会话中有登录状态的数据的话，那就要重新登录。2.会话标识的应用层信息，那么负载均衡器需要进行应用层解析，这个开销比第四层交换大。3.负载均衡器变为有状态的节点，要将会话保存到web服务器映射。和无状态节点相比，内存消耗更大，容灾更麻烦。</p>
<h4 id="session-Replication（复制会话）"><a href="#session-Replication（复制会话）" class="headerlink" title="session Replication（复制会话）"></a>session Replication（复制会话）</h4><p>web服务器会增加会话的同步，但在一些场景存在问题：1.同步session造成网络的开销。只要session数据发生变化，就需要把数据同步到其他机器上，机器越多，同步带来的网络带宽的开销就会越大；2.每台web服务器都需要保存所有的session数据，如果整个集群的session数很多，每台机器用于保存session的内容占用会很严重。</p>
<h4 id="session数据集中存储"><a href="#session数据集中存储" class="headerlink" title="session数据集中存储"></a>session数据集中存储</h4><p>把session数据集中存储，不同的web服务器从相同的地方获取session数据。session会统一存储在另外的服务器上，这样可以保证web服务器读到的session数据都是一样的。存储session的具体方式，可以使用数据库或者其他分布式存储系统。这个方案解决了replication的内存问题和带宽问题。但也存在问题是：1.读写session引入网络操作，问题就在时延和不稳定性，但如果是内网，这个问题不大；2.如果集中存储session的机器或者集群有问题，会影响我们的应用。</p>
<h4 id="cookie-based（基于cookie1）"><a href="#cookie-based（基于cookie1）" class="headerlink" title="cookie based（基于cookie1）"></a>cookie based（基于cookie1）</h4><p>通过cookie传递session数据，我们的session数据存储在cookie里，然后web服务器从cookie中生成对应的session数据。这个方案存在着不足：1.cookie的长度限制限制了session的长度限制。2.安全性；session数据是服务器数据，而这个方案导致服务端数据到了外部网络和客户端，因而存在安全性问题。但也可以通过对session数据加密，但从安全角度来看物理上不接触才更安全。3.带宽消耗，数据中心整体的带宽消耗；4.性能影响；每次http请求和响应都带有session数据，对web服务器来说，响应结果输出越少，支持的并发请求越多</p>
<h2 id="数据读压力大，那么就读写分离吧"><a href="#数据读压力大，那么就读写分离吧" class="headerlink" title="数据读压力大，那么就读写分离吧"></a>数据读压力大，那么就读写分离吧</h2><p>接下来从数据库的角度来看。</p>
<h3 id="采用数据库作为读库"><a href="#采用数据库作为读库" class="headerlink" title="采用数据库作为读库"></a>采用数据库作为读库</h3><p>对于大型网站，有不少业务是读多写少，这个状况会直接反应到数据库上，我们考虑读写分离的方式。我们在前面结构增加一个读库，这个库不承担写工作，只提供读操作。这个结构的变化会带来两个问题：1.数据复制问题；2.应用对于数据源的问题<br>首先看下第一个问题，现在数据库系统一般都提供数据复制的功能，可以直接使用数据库系统的自身机制。除此，还需要考虑数据复制时延问题，以及复制过程中数据源和目标之间的映射关系以及过滤条件的支持问题。复制时延带来的是短期的数据不一致。<br>mysql支持master+slave模式，5.5版本以前是异步数据复制，会有延迟，提供完全镜像方式的复制；5.5以后采用semisync（半同步）<br>备注：异步复制模式：主库将已经提交的事务event 写入binlog后，即返回成功给app，该模式下并不保证任何已经提交的事务会传递到任何slave并被成功应用。全同步复制模式：当主库提交一个事务 event，主库会等待该事务被传递到所有的slave上，且所有slave applay 该事务/event 通知主库之后，才会返回会话，事务已经成功。Semisynchronous Replication模式下,在主库上提交一个事务/event，它会等待至少一个slave通知主库，slave 已经接收到传递过来的events并写入relay log，才返回给回话层 写入成功，或者直到传送日志发生超时。<br>对于一个应用来说，增加一个读库对结构变化有一个影响，我们应用需要根据不同情况选择不同的数据库源。写操作走主库，事务的读也要走主库，用时也要考虑备库相对于主库的数据延时。即使是不在事务的读，考虑备库数据延迟，不同业务选择也有差异。<br>广义读写分离的特点是增加读源，分担读写源的读压力，要考虑读源的数据复制问题。</p>
<h3 id="搜索引擎其实是一个读库"><a href="#搜索引擎其实是一个读库" class="headerlink" title="搜索引擎其实是一个读库"></a>搜索引擎其实是一个读库</h3><p>大型网站的站内搜索。在交易网站中，用户需要查找商品功能之类的，这就像数据库的like功能，但这种方式的代价很大。可以使用搜索引擎的倒排表方式，能够大大提升搜索效率。搜索集群的使用方式和读库我们希望的使用的方式是一样的。构建索引的方式有两种，一种按照全量/增量划分，另一种是实时/非实时划分。全量用于第一次建立索引。增量一般用于加入每日的全量作为补充。实时/非实时划分体现在索引更新时间上。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，也就是我们常说的cache。</p>
<h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p>缓存系统一般是用来保存和查询key-value键值对的。应用访问缓存，如果数据不存在，就从数据库中读出数据放入缓存。当缓存数量不够时，最近不被访问的数据就被清除。还有另外做法，在数据库中数据发生变化后，能主动把数据放入缓存系统中。这样的好处是能够及时地更新缓存数据，不会造成读取失效，一般用于全数据缓存，还要能够理解业务逻辑。</p>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>有些动态产生的页面特别热，我们可以对这些内容进行缓存。</p>
<h2 id="弥补关系型数据库的不足，引入分布式存储系统"><a href="#弥补关系型数据库的不足，引入分布式存储系统" class="headerlink" title="弥补关系型数据库的不足，引入分布式存储系统"></a>弥补关系型数据库的不足，引入分布式存储系统</h2><p>常见的分布式存储系统有分布式文件系统，分布式key-value系统和分布式数据库。通过分布式文件系统来解决小文件和大文件的存储问题，通过key-value系统提供高性能的半结构化的支持，通过分布式数据库提供一个支持大数据、高并发的数据库系统。</p>
<h2 id="读写分离后，数据库又遇到瓶颈"><a href="#读写分离后，数据库又遇到瓶颈" class="headerlink" title="读写分离后，数据库又遇到瓶颈"></a>读写分离后，数据库又遇到瓶颈</h2><p>通过读写分离，分布式存储来替代关系型数据库能够降低主库的压力，但是交易、商品、用户的数据还在同一个数据库中，这时候数据库的压力还在，这时候采取的方案有水平拆分和垂直拆分。</p>
<h3 id="专库专用，数据垂直拆分"><a href="#专库专用，数据垂直拆分" class="headerlink" title="专库专用，数据垂直拆分"></a>专库专用，数据垂直拆分</h3><p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合交易系统的例子，就是将交易、商品、用户的数据拆分开。所造成的的影响是需要配置多个数据源，这就增加了所需配置，所带来的的是每个数据库连接池的隔离，那就需要考虑单机跨业务的事务。一种方案是分布式事务，另一种是去掉事务或者不去追求强事务支持，则原来在单库中可以使用的表关联的查询也需要改变实现。</p>
<h3 id="垂直拆分后的单机遇到瓶颈，数据水平拆分"><a href="#垂直拆分后的单机遇到瓶颈，数据水平拆分" class="headerlink" title="垂直拆分后的单机遇到瓶颈，数据水平拆分"></a>垂直拆分后的单机遇到瓶颈，数据水平拆分</h3><p>数据水平拆分就是把同一个表的数据拆分成不同的数据库中去。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到单个数据库的瓶颈。这时就把一张表拆到两个或者多个数据库中。数据水平拆分和读写分离的区别是读写分离解决的是读压力大，对于数据量大或者更新量大的情况并不起到作用；数据水平拆分和数据垂直拆分区别是，垂直拆分是把不同表拆到不同数据中去；水平拆分是把同一张表拆分到不同数据库中去。水平拆分后的问题：1.需要解决SQL路由的问题；2.主键的处理也会变得不同。3.分页会变得困难。</p>
<h2 id="数据库问题解决后，应用面对的新挑战"><a href="#数据库问题解决后，应用面对的新挑战" class="headerlink" title="数据库问题解决后，应用面对的新挑战"></a>数据库问题解决后，应用面对的新挑战</h2><h3 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h3><p>前面都是在解决数据的问题，现在我们可以看应用的问题。随着功能越来越多，应用也越来越大，我们需要把应用拆开。在我们的例子中，主要业务功能分为：交易、商品、用户。我们可以把这个应用分为交易和商品两个应用。对于交易和商品都会有涉及用户的地方，我们让两个自己完成涉及用户的工作，类似用户工作</p>
<h3 id="走服务化的做法"><a href="#走服务化的做法" class="headerlink" title="走服务化的做法"></a>走服务化的做法</h3><p>我们把应用分为了三层，分为商品中心、用户中心、交易中心，处于最上层是web系统，用于完成不同的业务功能，处于中间是服务中心，最下层是业务数据库。服务化带来的变化：1.业务功能之间的访问不在是单机的简单方法调用，而是远程服务调用；2.共享的代码的实现放在服务中心；3.数据库的连接发生了变化，我们把数据库的交互工作放到服务中心，让前端专注与浏览器的交互上，而不必关注业务逻辑。连接数据库交给业务中心，减少数据库连接数；4.通过服务化，无论前端web应用还是服务中心，都可以由固定的小团队来维护的系统，这样更好地保持稳定和降低风险。</p>
<h2 id="初始消息中间件"><a href="#初始消息中间件" class="headerlink" title="初始消息中间件"></a>初始消息中间件</h2><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件，消息中间件的好处是异步和解耦，生产者和消费者都直接跟消息中间件打交道，两个应用之间并不直接联系。这样完成了解耦，目的是希望双方彼此都不知道对方的存在，不受对方影响，消息投递给接收者用到异步的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是大型网站&quot;&gt;&lt;a href=&quot;#什么是大型网站&quot; class=&quot;headerlink&quot; title=&quot;什么是大型网站&quot;&gt;&lt;/a&gt;什么是大型网站&lt;/h1&gt;&lt;p&gt;访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统介绍（第一章）</title>
    <link href="http://yoursite.com/2017/10/16/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/16/大型网站系统与中间件实践读书笔记/</id>
    <published>2017-10-16T03:22:37.000Z</published>
    <updated>2017-10-19T03:04:46.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><p>1.组件分布在网络计算机上；<br>2.组件之间仅仅通过消息传递来通信并协调行动</p>
<h2 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h2><p>1.升级单机处理能力的性价比越来越低<br>2.单机处理能力存在瓶颈<br>3.出于稳定性和可用性的考虑</p>
<h2 id="线程和进程的执行模式"><a href="#线程和进程的执行模式" class="headerlink" title="线程和进程的执行模式"></a>线程和进程的执行模式</h2><h3 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h3><p>s(N)=1/(1-p+p/n);n代表核数，p代表并行部分在单核占的时间</p>
<h3 id="互不通信的多线程模式"><a href="#互不通信的多线程模式" class="headerlink" title="互不通信的多线程模式"></a>互不通信的多线程模式</h3><p>线程之间不需要处理共享的数据，也不需要进行动作协调，没有交集，各自执行自己的逻辑和任务。</p>
<h3 id="基于共享容器协同的多线程模式"><a href="#基于共享容器协同的多线程模式" class="headerlink" title="基于共享容器协同的多线程模式"></a>基于共享容器协同的多线程模式</h3><p>多个线程之间对共享数据进行处理。例如经典的有生产者和消费者，我们有个队列用于生产和消费，这个队列就是共享的对象，多个线程会并发的访问这个队列。对于存储数据的容器或者对象，有线程安全和线程不安全之分。对于线程不安全的容器或者对象，一般通过加锁或者copy on write的方式来处理（CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。CopyOnWriteArrayList、CopyOnWriteArraySet。问题：内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器）</p>
<h3 id="基于事件协同的多线程模式"><a href="#基于事件协同的多线程模式" class="headerlink" title="基于事件协同的多线程模式"></a>基于事件协同的多线程模式</h3><p>除了并发访问，线程之间会存在着协调的需求。例如线程B需要等到某个状态或者事件的发生后才能继续自己的工作。能够原子性的获取多个锁或者调整锁的顺序可以避免死锁。比如T1：A.lock();B.lock(); T2:B.lock();A.lock();这时候就发生死锁了。</p>
<h3 id="多进程模式"><a href="#多进程模式" class="headerlink" title="多进程模式"></a>多进程模式</h3><p>多线程和多进程不同在于线程是属于进程，一个进程内的多个线程共享了进程的内存空间；多个进程的内存空间是独立的。多进程可以共享数据，但代价比多线程大，会涉及到序列化和反序列化的开销。分布式系统是多机系统，可以看成是多机多进程。</p>
<h2 id="网络通信基础知识"><a href="#网络通信基础知识" class="headerlink" title="网络通信基础知识"></a>网络通信基础知识</h2><h3 id="osi和tcp-ip网络模型"><a href="#osi和tcp-ip网络模型" class="headerlink" title="osi和tcp/ip网络模型"></a>osi和tcp/ip网络模型</h3><p>osi是七层 物理层 数据链路层 网络层 运输层 会话层 展示层 应用层<br>tco/ip是四层 网络接口 网络层 运输层 应用层</p>
<h3 id="网络io的实现"><a href="#网络io的实现" class="headerlink" title="网络io的实现"></a>网络io的实现</h3><h4 id="BIO的方式"><a href="#BIO的方式" class="headerlink" title="BIO的方式"></a>BIO的方式</h4><p>Blocking IO，采用阻塞的方式去实现，也就是一个套接字需要使用一个线程处理。发生建立连接、读数据、写数据时都可能会发生阻塞。</p>
<h4 id="NIO的方式"><a href="#NIO的方式" class="headerlink" title="NIO的方式"></a>NIO的方式</h4><p>NonBlocking IO，基于事件驱动思想。相比较BIO，NIO不需要为每一个套接字分配一个线程，而可以在一个线程中处理多个套接字工作。reactor模式下，Reactor会管理所有的handler，并且把出现的事件交给相应的handler去处理。在NIO中统一通过reactor对所有客户端的套接字的事件做处理，然后在派发到不同的线程。这样解决了为了支撑更多套接字而打开更多线程的问题。</p>
<h4 id="AIO的方式"><a href="#AIO的方式" class="headerlink" title="AIO的方式"></a>AIO的方式</h4><p>Asynchronous IO（异步IO），AIO采用Proactor模式，AIO在进行读/写操作时，只需要调用对应的read/write方法，并且传入completionHandler；在动作完成后，会调用completionHandler。NIO的通知是发生在动作之前，是在可读可写，selector发现这些事件调用handler来处理。</p>
<h2 id="如何把应用从单机扩展到分布式"><a href="#如何把应用从单机扩展到分布式" class="headerlink" title="如何把应用从单机扩展到分布式"></a>如何把应用从单机扩展到分布式</h2><h3 id="输入设备的变化"><a href="#输入设备的变化" class="headerlink" title="输入设备的变化"></a>输入设备的变化</h3><p>两种：一种是互相连接的多个节点，接受其他节点信息的节点；一种是人机交互的输入设备</p>
<h3 id="输出设备的变化"><a href="#输出设备的变化" class="headerlink" title="输出设备的变化"></a>输出设备的变化</h3><p>两种：向其他节点传递信息的节点；人机交互的输出设备</p>
<h3 id="控制器的变化"><a href="#控制器的变化" class="headerlink" title="控制器的变化"></a>控制器的变化</h3><p>在单机中，控制器就是cpu，在分布式中，控制器就是协调和控制节点之间的动作和行为。</p>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>请求发起方需要确定谁来处理这个请求，请求发起方和请求处理方中间有一个硬件负载均衡设备，所有的请求都要经过这个负载均衡设备来完成请求转发的控制。</p>
<h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>把硬件负载均衡器换为LVS；特点：代价低，可控性强，你可以相对自由地按照自己的需要去增加负载均衡策略。在集群中，对于发起请求的一方和处理请求的一方来说都是透明的。发送请求的一方会认为中间代理提供了服务，而处理请求的一方会认为中间代理请求服务。发起方不需要知道有几台机器提供服务，也不需要知道提供服务的地址，只需要知道中间代理的地址。有两个不足：第一个是增加网络的开销，一方面指的是流量，一方面指的是延迟。第二个是这个透明代理在请求的必经路径上，如果这个代理出现问题，那么所有请求都会出现问题。所以要考虑热备份</p>
<h4 id="名称服务"><a href="#名称服务" class="headerlink" title="名称服务"></a>名称服务</h4><p>与透明服务最大的区别是，请求发起方和请求处理方两个集群间没有代理服务器这样的设备存在，而是请求方和处理方直接相连。除此之外，有一个名称服务的角色，主要作用有两个，收集请求服务处理的服务器的地址信息，和提供这些地址信息给请求发起方。名称服务只是起到地址交换的作用，在发起请求的机器上，需要根据从名称服务得到的地址进行负载均衡的工作。这种方案的优势是名称服务不在请求的必经路径上，就是说如果这个名称服务出现问题，很多时候我们有不少办法保证请求处理的正常。其次，发起请求的一方和处理请求的一方是直连的，减少了中间路径，以及可能的额外带宽消耗。劣势是升级代码复杂。</p>
<h4 id="规则服务器"><a href="#规则服务器" class="headerlink" title="规则服务器"></a>规则服务器</h4><p>请求发起方根据规则服务器给的规则选择请求处理方，在请求发起的机器上，会有对规则进行处理从而进行请求处理服务机器的选择代码。与名称服务不同的是，规则服务器不和请求处理机器进行交互，只负责把规则提供给请求发起方。</p>
<h4 id="master-worker"><a href="#master-worker" class="headerlink" title="master+worker"></a>master+worker</h4><p>存在一个master节点管理任务，由master分配给不同的woker去进行处理。</p>
<h3 id="运算器的变化"><a href="#运算器的变化" class="headerlink" title="运算器的变化"></a>运算器的变化</h3><p>单机中，运算器就是具体的电子元件，而多机中，运算器由多个节点组成，分布式的运算器是运用多个节点的计算能力来协同完成整体的计算任务。</p>
<h4 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h4><h4 id="多台服务器"><a href="#多台服务器" class="headerlink" title="多台服务器"></a>多台服务器</h4><p>方案一：通过DNS服务器进行调度控制，在用户解析dns时候，就会给予一个服务器地址。有点像名称服务和规则服务，中间没有代理。<br>方案二：在用户和服务器之间架起了负载均衡设备（硬件或者软件LVS）。DNS返回的是负载均衡的地址，用户的访问都是通过负载均衡器到达后面的网站服务器。</p>
<h4 id="日志的处理"><a href="#日志的处理" class="headerlink" title="日志的处理"></a>日志的处理</h4><p>增加日志的处理服务器的数量来提升处理日志的能力。一种方案是利用 master+worker方式的控制器运用到这个日志处理的场景。除了master以外，还可以用规则服务器来分配问题。</p>
<h4 id="存储器的变化"><a href="#存储器的变化" class="headerlink" title="存储器的变化"></a>存储器的变化</h4><p>存储器分为内存和外存，内存在断电、重启或者OS崩溃情况下会丢失，而外存是用来长久保存数据的。在分布式系统中，我们需要把承担存储功能的多个节点组织在一起，使之看起是一个存储器。以最基础的key-value为例。</p>
<h4 id="单机的key-value"><a href="#单机的key-value" class="headerlink" title="单机的key-value"></a>单机的key-value</h4><h4 id="在应用服务器与key-value存储服务器之间加了一个代理服务器"><a href="#在应用服务器与key-value存储服务器之间加了一个代理服务器" class="headerlink" title="在应用服务器与key-value存储服务器之间加了一个代理服务器"></a>在应用服务器与key-value存储服务器之间加了一个代理服务器</h4><h4 id="名称服务的key-value服务"><a href="#名称服务的key-value服务" class="headerlink" title="名称服务的key-value服务"></a>名称服务的key-value服务</h4><h4 id="规则服务器的key-value服务"><a href="#规则服务器的key-value服务" class="headerlink" title="规则服务器的key-value服务"></a>规则服务器的key-value服务</h4><h4 id="master控制的key-value服务"><a href="#master控制的key-value服务" class="headerlink" title="master控制的key-value服务"></a>master控制的key-value服务</h4><h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><h4 id="缺乏全局时钟"><a href="#缺乏全局时钟" class="headerlink" title="缺乏全局时钟"></a>缺乏全局时钟</h4><p>单机的以单机的时钟为准控制时序。多机每个节点都有自己的时钟，如果依赖时序，将会难以处理。</p>
<h4 id="面对故障的独立性"><a href="#面对故障的独立性" class="headerlink" title="面对故障的独立性"></a>面对故障的独立性</h4><p>在单机系统的单进程程序中，不会出现一些模块不行，一些模块正常。而在分布式系统中，整个系统一部分有问题而其他模块正常的情况是经常出现。我们称故障独立性。</p>
<h4 id="处理单点故障"><a href="#处理单点故障" class="headerlink" title="处理单点故障"></a>处理单点故障</h4><p>在分布式系统中，如果某个角色或者功能只有单机在支撑，那么这个节点我们称之为单点。避免单点的关键就是把这个功能从单机实现变为集群实现。如果不能把单机实现变为集群实现，那一般还有另外两种选择：<br>1.给单点做好备份<br>2.降低单点故障的影响范围（比如，在交易网站中，交易信息放在一个数据库里，这就形成了单点，我们会给这个数据库增加一个备库以解决容灾问题。我们可以考虑拆分数据，把一份数据库拆分成多个数据库后，出现故障的影响面就更小了。从本质上说，这种方式更多是转移和交换）</p>
<h4 id="分布式事务的挑战"><a href="#分布式事务的挑战" class="headerlink" title="分布式事务的挑战"></a>分布式事务的挑战</h4><p>2pc、3pc、最终一致、BASE、CAP、paxos算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式系统的定义&quot;&gt;&lt;a href=&quot;#分布式系统的定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的定义&quot;&gt;&lt;/a&gt;分布式系统的定义&lt;/h2&gt;&lt;p&gt;1.组件分布在网络计算机上；&lt;br&gt;2.组件之间仅仅通过消息传递来通信并协调行动&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云取证第八周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%85%AB%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第八周周报/</id>
    <published>2017-06-29T11:54:42.000Z</published>
    <updated>2017-07-05T14:57:11.842Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。<br>首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次。2.显示云测试的总体上下文；3.提供了包括Guidance EnCase和AccesData Forensic Toolkit在内的流行取证获取工具。<br>云计算使取证不同，特别是考虑到证据的远程性质，缺乏实体访问权限以及完整性和真实性所需的信任。虽然取证检查员的目标与以前相同，但非传统困难的问题包括：远程数据的取证知识获取，大量传播，分布式数据，监管链和数据所有权。检获和获取数字文物是取证进程的初步步骤。存在两种可能的情况：远程调查员可以从源头自己收集取证证据，或者提供者可以提供证据。每个场景需要对所返回数据的不同程度的信任。此外，每种情况都使用不同的技术实现来恢复数据。主要工作有亚马逊弹性计算云（EC2）在公共云中执行持续和非持久性数据收集的现有工具的三个实验结果。对于使用客户机操作系统的数据采集不够信任的情况，分析基础设施堆栈较低级别的取证方法。演示如何使用虚拟机内省来注入远程取证代理进行远程采集。用不受信任的管理程序探索取证数据采集的四个策略。<table><tr><td>Layer</td><td>Cloud layer</td><td>Acquisition method</td><td>Trust required</td></tr><br>    <tr><td>6</td><td>Guest application/data</td><td>Depends on data</td><td>Guest operating system (OS), hypervisor, host OS, hardware, network</td></tr>  <tr><td>5</td><td>Guest OS</td><td>Remote forensic software</td><td>Guest OS, hypervisor, host OS, hardware, network</td></tr><tr><td>4</td><td>Virtualization</td><td>Introspection</td><td>Hypervisor, host OS, hardware, network</td></tr><tr><td>3</td><td>Access virtual disk</td><td>Access virtual disk</td><td>Host OS, hardware, network</td></tr><tr><td>2</td><td>Physical hardware</td><td>Access physical disk</td><td>Hardware, network</td></tr><tr><td>1</td><td>Network</td><td>Packet capture </td><td>Network</td></tr></table><br>  在IaaS中，尽管没有物理访问，消费者仍保留对第5层（访客操作系统）和6（访客应用程序）的管理控制权。此外，各层次的取证行为将不同。每一层需要不同的信任，即该层是安全和信任的;堆栈越远，累积的信任就越少。在公共云中，所有层都需要提供商的一些信任，特别是对恶意内部人员的信任。防伪策略，病毒检测器应在多层次上检查证据。调查人员可以选择云层的哪一层进行取证处理。关于这一决定的考虑首先围绕在该级别进行取证的技术能力，再次对所返回数据的信任。该层还影响可用于收集的哪些类型的取证数据，例如第1层（网络）上的数据包捕获，第2层物理文件（物理硬件）或第3层（主机操作系统）上的虚拟文件。对于每种数据类型，数据必须遵守严格的监管链，并且必须包括完整性检查机制。云计算引入了一个强大的新选项：虚拟机快照。利用虚拟化的许多云实现可以拍摄正在运行的计算机的快照，然后像现在一样将该快照恢复并运行。这提供了创造历史记录的能力，以及事后做“活”取证。</p>
<p>  接下来就是实验。能够远程获取aharddrive和内存映像。分析EnCase Forensic和FTK Investigator中的这些映像分别正确显示了活动的时间表，包括安装Apache和网页创建和删除。分析显示虚拟环境的异常现象，也没有任何明显的异议，引起对数据完整性的怀疑。采集过程的速度受到我们学习如何使用远程代理和网络带宽传输数据的限制。每个EnCase和FTK大约12小时，使用我们大学的OC-12连接传输30 GB磁盘映像和2 GB内存映像。实验2成功地形成了驱动器的完整图像和正确的时间线。 VM内省是取证学的强大工具，允许人的实时调查，而不会显露调查人员的存在。然而，内省是云服务提供商必须实施的一个特殊功能。这是我们能够验证图像完整性的唯一实验，因为我们可以访问物理磁盘，并且可以比较EnCase映像和原始磁盘的散列值。实验3中的AWS导出过程也成功地返回了驱动器的完整映像。我们能够将驱动器加载到EnCase和FTK中，没有任何困难，并验证了驱动器的内容。这种方法的另外一个好处是，AWS会为导出的每个文件生成一个具有元数据的日志报告。此报告包含以下每个文件：传输的日期和时间，存储设备上的位置，MD5校验和和字节数。使用快速运输，花了五天时间收到我们的数据，费用为125美元。我们设想这个过程将会严格地模仿AWS在遵守搜索令或传票时所采取的步骤。 EnCase和FTK最容易使用。尽管使用远程功能需要安装和学习时间，但工具的功能是熟悉且易于执行的。检索磁盘映像所需的12小时时间远远少于此数据卷的AWS导出过程所需的120小时。下载数据平均每小时2.5 GB。 AWSExport花了4小时加载了我们的数据，而剩下的116小时在运输过程中花费了时间。按照这些速率，最有效的选择是导出过程，当超过240 GB的数据将被检索。</p>
<p>  A forensically robust method for acquisition of iCloud data主要讲一种方法，不仅使得下载数据到验证的计算机上然后验证数据的完整性，还可以定位到数据的来源。首先是采集云服务中存储的数据变得越来越重要数字取证调查。 苹果公司不断扩大其云端的功能服务，iCloud。 因此，确定取证获取的有效手段是至关重要的，来自该服务的数据的定义及其对原始文件数据和元数据的影响。本研究通过本机Mac OS X检查从iCloud服务获取的文件系统与服务同步。 目标是确定操作系统iCloud同步文件的位置。 一旦找到，次要目标是确定是否文件哈希值与原始文件匹配，特别是文件元数据时间戳，被改变。</p>
<p>  研究人员使用不同的技术去获取数据。有两种技术是先是通过虚拟机创建镜像，然后用FTK工具去分析这些镜像。还有一种是根据AWS去导出数据。导出的还包括包括“日期和时间传输，存储设备上的位置，MD5校验和，和字节数“。如果哈希值相同则代表数据并未改变。接下来是实验，有两台虚拟机，第一台在整个过程进行快照拍摄，并且数据与云服务同步，第二台新创建的iCloud帐户。然后进行分析以定位iCloud 。下载的文件是与原始文件进行比较以确定文件是否相符<br>  和元数据是一样的，如果不是，初始化配置。</p>
<p>  Side channels in cloud services, the case of deduplication in cloud storage云存储服务通常使用重复数据删除，通过仅存储每个文件或块的单个副本来消除冗余数据。重复数据删除减少了数据存储服务的空间和带宽需求，并且在跨多个用户应用时是最有效的，这是云存储产品的常见做法。我们研究跨用户重复数据删除的隐私含义。我们演示如何使用重复数据删除作为侧面通道，显示有关其他用户的文件内容的信息。在不同的情况下，重复数据删除可以用作隐藏通道，恶意软件可以通过该渠道与其控制中心进行通信，而不管受攻击机器上的任何防火墙设置如何。由于跨用户重复数据删除所带来的高额节省，云存储提供商不可能停止使用此技术。因此，我们提出了简单的机制，可以跨用户重复数据删除，同时大大降低数据泄露的风险。<br>  有两种主要的重复数据删除策略：（1）文件级重复数据删除，其中只存储每个文件的单个副本。如果两个或多个文件具有相同的哈希值，则它们将被标识为相同。这是一种非常受欢迎的多种产品提供的服务; （2）块级重复数据删除，将文件分割成块并仅存储每个块的单个副本。系统可以使用固定大小的块或可变大小的块。</p>
<p>  我们描述的攻击可以应用于在文件级别或块级执行的重复数据删除（具体来说，我们假设从现在开始，在文件级别执行重复数据删除）。但是，重复数据删除服务有两个对攻击至关重要的功能：•基于源的重复数据删除。也就是说，重复数据消除必须在客户端进行。如上所述，此版本的重复数据删除功能节省了带宽，因此常用。应用此方法的结果是，客户端可以观察某个文件或块是否被重复数据删除（或简称为“重复数据删除”）。这可以通过检查通过网络传输的数据量，或通过观察存储软件的日志（如果该软件提供此类报告）来完成。 •对攻击至关重要的第二个功能是跨用户重复数据删除。也就是说，将每个文件或块与其他用户的数据进行比较，如果在服务器上已经可以使用相同的副本，则将其重新排除。这种方法是受欢迎的，因为它不仅在单个用户具有相同数据的多个副本时，而且当不同的用户存储数据的副本时，可以节省存储和带宽。 （企业客户端通常存储相同或相似数据的多个副本，我们发现即使对于私人客户也是如此：几乎每个常用的软件手册或我们试图使用流行备份服务进行备份的媒体文件都已经可以使用请注意，这些是巨大的文件，因此重复数据删除为服务提供商节省了巨大的成本。）识别易受攻击的存储提供商：我们进行了以下测试，以确定执行基于源和跨平台的服务，用户重复数据删除（测试可以由任何读者重复，他选择的存储服务）：（1）我们在两台不同的计算机上安装了该服务的客户端软件，并创建了两个不同的用户帐户; （2）我们使用一个帐号上传文件（在我们的测试中，这个文件是Sun的VirtualBox软件，大小接近73M）; （3）我们使用第二个帐号再次上传同一个文件，检查是否确实上传了。当文件没有通过网络重新发送时，我们得出结论，备份服务执行基于源的跨用户重复数据删除。 （事实上​​，当检查流行的存储服务时，不需要使用两个帐号，因为如上所述，在网络上发现的任何流行的文件很可能存在于服务器上，因为它以前是由其他用户上传的，因此测试可以包括从Web下载流行的文件，将其上传到服务并检查重复数据删除是否发生。）我们确定了三个领先的备份和文件同步提供程序的服务，它们执行跨用户，基于源的重复数据删除。这些服务是（1）DropBox，一种流行的文件共享和备份服务，超过了300万用户里程碑; 2 2）Mozy是面向消费者和企业的在线备份的领先提供商，为超过一百万客户和50,000名业务用户提供备份，并存储超过25 PB; 3和（3）备份审查作为欧洲最佳在线备份服务的Memopal，每天有近1000个新用户4值得注意的是，大多数供应商并不试图隐藏重复数据删除的事实，在我们的测试中容易地以几种简单的方式检测：（1）检查历史记录或日志文件（此方法与MozyHome 5配合使用）; （2）根据上传状态消息，上传和重复数据删除的文件有所不同（此方法与Memopal 6配合使用）; （3）根据上传速度，检查文件上传是否在比客户机上传带宽所需的时间短得多的时间内完成（DropBox 7就是这样）; （4）最终，最常用的重复数据删除检测方法适用于所有服务，无论其接口如何，都是监控网络流量并测量传输数据量。我们注意到，大多数服务具有额外的客户端 - 服务器通信流量，但与上传大型文件时传输的大量数据相比，可以忽略不计。<br>  第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。此第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。假设有一个攻击者，爱丽丝，谁想要了解有关Bob，云存储服务的用户的信息。那么显然，如果爱丽丝怀疑鲍勃有一些不太可能拥有任何其他用户的特定敏感文件X，她可以使用重复数据删除来检查这个猜想是否正确。 Alice应该做的是尝试备份X的副本，并检查是否发生重复数据删除。作为一个具体的例子，假设有一个文件证明一些非法活动（例如记录暴力事件，或者是具有一些被盗的敏感信息的文件，或与儿童色情相关的材料）。执法机关一旦掌握该文件的副本，就可以将文件上传到不同的云存储提供商，并识别存储文件副本的存储服务。然后，他们可以要求法院命令，要求服务提供商披露上传文件的用户的身份。 （如果文件被认为对于识别拥有该用户的用户来说太敏感，则如上所述，当局上传该文件的过程可以在确定是否在开始之后立即终止重复数据删除应用于此文件。）2.2攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。但是，攻击者可能会将此攻击应用于同一文件的多个版本，对本文件内容的所有可能的值基本上执行强力攻击。例如，假设Alice和Bob在同一家公司工作，该公司使用云备份服务来备份所有员工的机器。每年一次，所有员工将收到一份新的标准合同副本，其中包含其更新的薪水。爱丽丝好奇地找到了鲍勃的新工资，这可能是$ 500- $ 200,000之间的$ 500的倍数。所有Alice必须做的是生成一个Bob的合同模板，Bob的名字和新合同的日期，然后为Bob的每个可能的工资（总共301个文件）生成合同的副本。然后，她运行备份到她和Bob使用的公司备份服务。发生重复数据删除的单个文件是包含Bob实际工资的单个文件。只要目标文件的可能版本数量适中，就可以应用此攻击。这对于企业环境来说似乎非常有用，通常文件是标准模板的小变体。请考虑以下三个示例：•网上银行服务向客户发送一个包含其登录名和PIN的文档，这是一个4位数字。因此，爱丽丝可以使用登录名“Bob”和PIN的所有可能值生成10,000个文档，并检查其中哪些文件已被存储。本文档对应于Bob的实际PIN码。相同的攻击可以应用于任意密码，如果它们来自中等大小的域。请注意，与在线字典攻击不同，受到攻击的银行服务不会注意到某人正在尝试某个用户的所有潜在密码。 •假设一个详细描述Bob的医学检查结果的文件存储在他的计算机上。爱丽丝可以使用这种攻击来查找测试的结果，这通常来自一个小域（例如，对于遗传性疾病的发生或怀孕测试的结果是一个是/否的答案，或来自一个范围，例如胆固醇测试的一百个可能的值）。转诊医生的姓名和转诊日期可能是爱丽丝所知，或者可能来自一个小领域。即使是测试的序列号，如果存在这样一个数字，可能会被Alice猜出，如果她有一个类似日期的测试结果的例子。 •假设爱丽丝和鲍勃都参与拍卖，要求投标人以包含其名称和出价的标准表格提交投标（这实际上是许多拍卖和采购流程中的常见做法）。如果爱丽丝可以推测出鲍勃的10,000个最有可能的出价值，她可以使用相同的攻击来查找鲍勃的实际出价，然后相应地设置出价。<br>  攻击III：隐蔽通道假设爱丽丝设法在Bob的机器上安装了一些恶意软件。然而，Bob运行防火墙，防止未经授权的程序连接到外部世界。即使这样的防火墙没有运行，Alice 3可能希望隐藏恶意软件与其命令和控制服务器之间的通信）。如果Bob正在使用使用跨用户重复数据删除的在线存储服务，则Alice可以使用重复数据删除攻击来建立从恶意软件到由其运行的远程控制中心的隐蔽通道。 （隐藏通道的存在可能是二次攻击，也可能有其他方法建立隐蔽通道，但是通过利用跨用户的重复数据删除来检查隐藏通道是如何建立起来的。我们先来描述一个位如何传输：软件生成文件的两个版本之一X 0或X 1，并将其保存在Bob的机器上。如果要传送消息“0”，则保存文件X 0;否则保存文件X 1。这些文件必须是足够随机的，因此任何其他用户不可能生成相同的文件。在某些时间点（例如每天），Bob运行备份并将文件存储在在线存储服务中。 Alice然后执行与Bob相同的服务的备份，并且学习以前存储哪些文件X 0或X 1，也就是说，她将学习软件发送的消息。隐藏通道可用于通过使软件保存多于一个文件，并为每个文件的内容使用两个以上的选项来传输任意长的消息。此方法的详细性能分析超出了本文的范围。我们在这里描述了恶意软件如何向其命令和控制中心发送消息。如果恶意软件有可能检查备份的日志文件，并在进行重复数据删除时进行观察，则可以使用相同的技术来发送相反方向的消息。</p>
<p>  重复数据删除的安全风险源于以下事实：文件的重复数据删除会发生，如果并且只有此文件已经上传到存储服务。通过削弱重复数据删除与存储服务中文件的存在之间的相关性，可以降低风险。这是通过为每个文件分配一个随机阈值，并且只有当文件的副本超过此阈值时才执行重复数据删除。在更详细地检查此解决方案之前，要检查类似的方法，这是不安全的：这里，服务器设置全局阈值t（例如，t = 10），并且只有至少在文件中执行重复数据删除t文件的副本已上传。在这种情况下，确实，Alice上传文件的单个副本并不能显示Bob先前是否已经上传过该文件。然而，Alice可以上传许多文件副本（甚至使用多个用户身份），并检查是否在t或t-1之后重复数据删除，文件副本由她上传。后一种情况表示该文件的副本以前由其他用户上传。 （我们可以放心地假设爱丽丝知道阈值t，因为她可以进行简单的实验来揭示t的价值。）解决方案：现在让我们更详细地描述随机解。对于每个文件X，存储服务器分配在[2，d]范围内随机均匀选择的阈值t X，其中d是可能是公共的参数。 （例如，假设d = 20）重要的是，除了服务器之外，没有人可以计算t X，即使X的内容是已知的。实现此属性的一种方式是服务器随机选择t X并私有存储该值。另一种方法是使用秘密密钥的服务器，并且根据文件的内容或其散列值和密钥的计算阈值。即，计算t X = F（X，s）。在这种情况下，不需要显式存储X的阈值，因为服务器可以轻松地重新计算它。现在，对于每个文件X，服务器保留先前已经上传X副本的客户端数量的计数器X.当上传文件的新副本时，如果存在以下两个条件之一，则在客户端进行重复数据删除保持：（1）c X≥t X，或（2）由以前上传过X的客户端上传副本。否则不会发生重复数据删除。请注意，重复数据删除的最小份数为2，因为在上传文件的第一个副本时，不可能执行5次重复数据删除。该解决方案在X上传的第一个t X - 1次中隐藏了用户重复数据删除的发生，因为该文件被上传，就像在服务器上没有可用的副本一样。然而，一旦将数据传输到服务器端，就可以执行重复数据删除。因此，此解决方案提供的整体磁盘空间节省与基本重复数据删除方案完全相同。唯一的赔偿是带宽利用率较小，因为与tp重复数据删除解决方案相比，（t X -1）·X个文件的多个副本被上传。图1说明了提出的解决方案及其数据流。处理删除：文件删除也必须加以修饰。当删除发生时，减少文件副本的计数器c X似乎是很自然的。但是，此设置可以进行以下攻击：Alice上传文件X的副本，并注意到t副本上传后会发生重复数据删除。然后，她再次从在线存储中删除X的两个副本，并再次上传这两个副本。如果在其中一个测试中，她注意到在上传两个副本中只有一个之后发生重复数据删除，则必须是其他用户刚刚上传了X的副本。同样，如果重复数据删除在上传三个之后发生，而不是两个，X的副本，那么另一个用户必须删除这个文件的副本。这种攻击并不实用，因为在删除后，在线存储服务通常会保留已删除文件的副本一段时间。例如，包括Mozy，DropBox和Memopal在内的大多数服务的策略是删除文件至少要保留30天。因此，攻击的每次迭代都需要至少30天才能执行。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。&lt;br&gt;首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第七周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%83%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第七周周报/</id>
    <published>2017-06-29T11:54:30.000Z</published>
    <updated>2017-07-01T14:29:21.914Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。</p>
<p>云计算安全研究主要讲云计算的趋势、云安全挑战、云安全现状、云计算安全框架的建议、云安全的技术研究。这里面我觉得这几点是比较重要的，例如云安全的挑战和云计算安全关键技术研究。<br>首先在于云安全的挑战，在于以下三点：1.建立以数据安全和隐私保护为主要目标的云安全技术框架，具体体现在：云计算服务计算模式所引发的安全问题、云计算的动态虚拟化管理方式引发的安全问题、 云计算中多层服务模式引发的安全问题；2.建立以安全目标验证、安全服务等级测评为核心的云计算安全标准及其测评体系；3.建立可控的云计算安全监管体系，具体体现在：实现基于云计算的安全攻击的快速识别、预警与防护；实现云计算内容监控的难度；识别并防止基于云计算的密码类犯罪活动。<br>接着是云计算安全关键技术研究，主要有以下几点：1.可信访问控制；2.密文检索与处理；3.数据存在与可使用性证明；4.数据隐私保护；5.虚拟安全技术；6.云资源访问控制；7.可信云计算；</p>
<p>云计算:系统实例与研究现状主要讲了针对云计算这样一个范畴综述了当前云计算所采用的技术,剖析其背后的技术含义以及当前云计算参与企业所采用的云计算实现方案。现有的云计算实现使用的技术体现了以下 3 个方面的特征:1) 硬件基础设施架构在大规模的廉价服务器集群之上.2) 应用程序与底层服务协作开发,最大限度地利用资源.3) 通过多个廉价服务器之间的冗余,使用软件获得高可用性.这里面讲了一下几个项目：清华大学透明计算平台、Google的云计算平台、IBM“蓝云”计算平台、Amazon的弹性计算云。.从平台技术构建来看,云计算具有3 个基本特征,即系统建立在大规模的廉价服务器集群之上,通过基础设施与上层应用程序的协同构建以达到最大效率利用硬件资源的目的,以及通过软件的方法容忍多个节点的错误.通过云计算对这 3 个方面基本特征的体现,达到了分布式系统两个方面的目标,即系统的可扩展性和可靠性。</p>
<p>Dependability in the Cloud: Challenges and Opportunitie主要讲了几个比较流行的问题，监控大量应用程序的能力可以使“人群智慧”方法提供更强大的安全性，其方式与网络提供商能够进行蠕虫和DDoS攻击相同，其中一些例子如下：几个大型云基础架构提供商的环境不仅增加了影响大量应用程序的103次共模中断的风险，而且为攻击者提供了高度可见的目标。社区驱动的网站，如主要云提供商的跟踪中断，并记录了过去两年影响数百个互联网站点的一些中断和安全漏洞。从事广泛的行为，并采用不同程度的最佳做法可以暴露云应用提高风险水平。例如，2008年4月26日，亚马逊的弹性云（EC2）在几个实例中出现了中断，原因是单个客户应用了一大批异常的防火墙规则，同时实例化了大量实例引发亚马逊分布式防火墙中的性能下降错误。</p>
<p>The Challenge of Cloud Control主要讨论了资源优化云数据中心的一些主要挑战。我们提出了一个称为云控制的新研究领域，这是一系列云管理问题的控制理论方法，旨在将当今的静态和能耗云数据中心转变为自我管理，动态和可靠的基础设施。<br>第一个挑战是性能模型，这对设计和开发至关重要稳健的控制系统。值得注意的是，云数据中心的规模大大增加，工作量动态变化比以前的电信和互联网系统多。服务器系统上的以前的结果表明，可以使用黑匣子方法和相当简单的队列模型或使用流模型。第二个挑战是服务准入控制，这在本质上是长期容量规划，控制系统根据预期的利润决定是否接受服务。此外，弹性控制器应该为正在运行的应用程序分配足够的资源，以提供可接受的QoS，同时避免昂贵的过度配置。这些解决方案分为三大类：基于机器学习算法的解决方案，基于控制理论的解决方案和基于统计工作负载分析的解决方案。此外，还有一些VM安置问题需要解决，以确定哪些部署新的VM以及要关闭的VM 。鉴于云的动态性质，随着需求和供应的变化随着时间的推移发生重大变化，VM布局决策需要频繁更新。最近关于重新布置的工作包括通过限制可以同时迁移的VM数量来实现VM迁移和性能转向的性能建模。其他动态方法包括使用随机整数规划来处理不确定性和遗传算法，以减少负载波动时的重新迁移。另一个挑战是提供云服务的大型数据中心不仅具有购买设备的成本，而且能源成本大幅提高，这意味着能源优化将至关重要。</p>
<p>首先，服务准入控制器决定是否接受弹性服务，随着时间的推移可能会有很大的变化。云提供商必须确定要承认的最佳服务数量，以最大限度地发挥其效用（收入，利用率等），而不会危及已提供服务的服务水平协议（SLA）。服务增加了云基础设施的随机负载。因此，需要接纳管制计划，以评估新服务的长期影响，具体取决于他们估计的工作量。第二，弹性控制系统的目标是分配足够的所谓的计算单位（CU），以便符合某些控制目标，以系统的性能期望为目标。我们提出定义CU术语，以便满足能力需求的要求，这与维护虚拟机的定义无关。后续的CU将被映射到合适的VM。如果假定系统状态和工作负荷可以用一定的精度来估计，则控制器设计基本上成为随机的最优控制问题。第三，VM布局控制器都执行从CU到适当的VM集的映射，以在本地或远程数据中心运行，并确定物理机器上的虚拟机的打包。在将VM分配到数据中心内的PM之前，我们考虑从CU到VM和从VM到数据中心的映射。可以制定的这些容量分配（分配）问题，例如作为限制线性问题，用于优化成本受制于容量和可能的其他约束，从而实现特定的负载平衡亲和力和抗亲和力的客观或要求（例如，在同一数据中心（或主机）中，而不是在相同的数据中心）。第四，数据中心能源优化器模型，优化机房定位决策的机房能量温度相互作用。能量优化将需要一个网络身体的看法。最后，整体管理系统监控整个系统的行为，并优化管理工具在整体数据中心管理目标方面的协同运作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。&lt;/p&gt;
&lt;p&gt;云计算
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第六周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%85%AD%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第六周周报/</id>
    <published>2017-06-29T04:44:53.000Z</published>
    <updated>2017-06-29T09:03:59.109Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。</p>
<p>首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件系统的源文件来收集系统级别的来源。虽然这种方法是有效的，但是它具有两个显着的缺点：内核的每个新版本都需要重新整合PASS变化，其稳定性必须不断测试; 同样，使用可堆叠的文件系统使得很难在根卷上收集来源，特别是在早期引导过程中。所通过以Xen虚拟机管理程序运行的虚拟客户机收集系统级别来源的方法可以有效解决这两个缺点。</p>
<p>PASS拦截execve，fork，exit，read，readv，write，writev，mmap，open，pipe以及内核操作drop inode。这些调用足以捕获Linux文件，管道和进程之间丰富的祖先关系。这种原始的“原始来源”转向观察者，将原始来源转化为证明记录。例如，当进程P读取文件A时，观察器生成包含P取决于A的事实的记录。接着是修改Xen虚拟机管理程序的方法（Xen 是一个开放源代码虚拟机监视器）。</p>
<p>首先是前提假设。假设目标虚拟机（我们将收集来源的目标虚拟机）正在运行一个PV密钥，但是也可以针对未修改的内核（如Windows）。 Linux，Minix，GNU Hurd，OpenSolaris，NetBSD和FreeBSD都支持PV内核。本文的其余部分假定我们正在运行Linux访客内核;假设Dom0和DomU密钥以及Xen管理程序本身是不妥协的，以便我们可以信任和验证任何生成的证明。我们的方法通过在Xen的系统调用进入机制中放置适当的钩子来拦截DomU系统调用。 该挂钩为拦截器提供系统调用号及其数值参数。 拦截器又通过查找表中的系统调用来确定哪些参数是数字，哪些是用户空间中的数据结构和字符串的指针。然后继续创建一个系统调用记录。用户空间守护程序在特权域中运行，定期地：1.消耗来自环形缓冲区的记录，2.使用来源分析器处理它们，3.输出源日志，4.并将日志提供给Waldo。我们可以在多处理器/多核系统中的专用CPU /内核上运行此过程，以提高访客性能。用户空间守护程序以及其他支持软件通过专用的超级呼叫与Xen的来源子系统进行通信，只能在特权域中访问。拦截器与源极分析仪的耦合使我们能够将CPU密集型分析转移到另一个CPU或核心上，从而使客户的单线程性能受到最小的影响。更重要的是，我们将不会担心可堆叠文件系统引用的API的更改;这些变化往往会经常发生，相当可观。我们的方法的一个障碍是拦截器需要一个大的环形缓冲区来保存分析器尚未消耗的所有系统调用的记录。<strong>典型的Linux客户机每秒产生数十个读/写系统调用，涉及标准输入和输出流。我们无法轻易地将其过滤掉在拦截器上，因为这些流可能已被重新排列到文件或管道。除了消耗大量内存之外，缓冲区操作通常会增加处理器高速缓存的压力。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。&lt;/p&gt;
&lt;p&gt;首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第五周周报</title>
    <link href="http://yoursite.com/2017/06/25/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%BA%94%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/25/云取证第五周周报/</id>
    <published>2017-06-25T12:50:47.000Z</published>
    <updated>2017-06-26T13:21:05.375Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。</p>
<p>首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询SELECT taskname,datacenter FROM systemlog.today WHERE severity=’warning’，扫描的数据量有100GB级别的数据量，但是查询时间仅仅需要10秒左右。BigQuery旨在分析数十亿行近似的数据，使用类SQL语法。它并不是完全符合SQL数据库的替代，并不适用于交易处理应用。BigQuery支持分析交互风格。使用SELECT命令构建查询，对于任何SQL开发者都应该很熟悉。<strong>因为我以前在做数据交换平台的时候，对于非基于lucene的全文检索的传统数据库，例如mysql查询时候，对于上百万或者上千万条甚至在上亿条数据量的查询，即使是针对索引列的查询也会很慢，更不用说数据量达到pb级别的数据量</strong>。查了下资料，总体而言，BigQuery 在大规模数据（数十亿行）上查询有很好得速度、适合快速分析大规模数据，不支持数据修改；BigQuery是OLAP系统，通过CSV格式将数据导入BigQuery，数据以弱关系型存储与云上。BigQuery 不是一个数据库系统， 1. 不支持表索引和其他关系数据库特性 2. BigQuery支持SQL得一个子集，不支持update,delete操作 3.BigQuery得join只在一张表远比另一张表小时有效（也就是不支持两张大表得join）。BigQuery 支持REST接口。</p>
<p>其次是对于Regeneration of events using system snapshots for cloud forensic analysis。 这篇论文主要讲述了在这个一种新的云攻击分析方法通过事件再生。 VNsnaps用于定期进行虚拟网络环境（VNE）的快照通过使用模糊聚类检测的云攻击技术。 然后恢复这些快照以重新生成攻击事件。首先是对于公司来说，云安全依然是在云计算里面最关心的问题。 AAA协议大致将这些尝试分为三个阶段：认证，授权和会计。云取证专注于会计，并用于分析和调查云攻击的本质，试图恢复从他们的伤害。几个输入，如日志文件和孤立的系统快照用于提取信息关于袭击。然而，这些方法只能导致一个模糊的事件视图。另外，由于网络定时协议不适用于云计算，我们是不可避免的客户和CSP的时间戳差异这使得更难于将各种实例相关联两端因此，传统技术无法明确图片的整个操作顺序的数据和涉及的过程我们的工作，通过一系列定期的快照，旨在提供具体和顺序证明所有事件对安全构成威胁数据的隐私和委托云的计算。</p>
<p>通过使用一种检测攻击的技术来解决问题正确标注其开始和结束。我们实现这个使用模糊聚类算法的“距离”概念。 VNsnap：我们使用VNsnap，一个中建立的系统来采取系统来自虚拟机外部的整个VNE的快照（VM），从而提供所有信息关于有关组件。为全球一致快照，VNsnap使用Mattern的分布式快照算法基于消息着色。另外，VM快照操作与VM的正常操作同时进行操作因此隐藏来自用户的快照延迟应用程序和减少系统停机时间（少于一个）即使在最坏的情况下）。另一个优点VNsnap是不需要任何修改在虚拟机内运行的软件，从而与之配合使用未修改的应用程序和操作系统内置快照支持。B.正确记录攻击：在我们的工作中，我们假设有足够的文档可用关于以前采取的云攻击放在各种类似的环境中。一般来说，这些记录的攻击是使用硬聚类分类的。</p>
<p>技术如分区聚类、层次聚类，这意味着每次新的攻击都被放在现有的攻击中<br>“分区”或“细分”取决于一些固定的或预定特性。，学习后云攻击的复杂性，我们发现需要考虑新攻击与全部攻击之间的相似程度现有的集合而不是完整的任务之一固定集或攻击群集。因此，我们愿意依靠将决定程度的算法每个现有集合的新实体的归属而不是将它分配给只有一个的那些预定套。由于模糊聚类是一个软聚类将一组成员级别与之联系起来的技术每个新实体，通过这样做，我们实际上考虑到整体影响所有类似的攻击，从而确保更好的准确性结果。</p>
<p>快照可以给出：<br>A. 将攻击定义为群集 关于以前的攻击的可用文档应该是 首先被组织成小型的原始操作 每个组合都可以作为个人攻击。我们对待每一个这些攻击是单点（或单对象）集群。每个点或攻击随后以n维向量来表示，每个维度代表可量化的特征，如内存使用，处理能力要求，带宽使用，复杂度等。 因此，每个攻击Xp可以被假设为具有n维度的空间向（xp1，xp2，…，xpn）。<br>B.为尺寸分配权重： 同样重要的是我们考虑到这一点 在空间中定义的每个维度的相关性。因此， 我们将一个权重wi分配给第i个维度来量化它 确定相似性（或不相似性）的重要性 两个代码之间。这个权重应该通过实验确定。例如，如果我们找到相似性的顺序 复杂度是内存相似度的两倍,那么分配到复杂度的权重将是两倍分配给内存使用的权重。<br>C.当前代码模块距离：在每个VM中，首先确定执行中的代码模块。 这些模块中的每一个基于其自身的特性再次被分配在相同的n维空间中。 但是，请注意，在这种情况下，这些代码模块是时间的函数，它们的坐标也是这样。 例如，第q个VM中的代码模块Y q（t）将具有坐标：（y q1（t），y q2（t），…，y qn（t））。 然后我们从每个集群（攻击）中计算代码模块的距离。 攻击X p和代码模块Y q（t）之间的距离为：D pq i（t）=√（Σ（wi（x pi - y qi（t）））2）… i 1到n。注意，该距离表示第t个攻击与第t个虚拟机的代码模块在时间t的不相似性。 通过为维度分配权重，我们确保了关于测量的相似程度或不相似性的推论是正确的。<br>D.阈值：我们需要确定攻击和代码模块之间的距离的阈值，在该模块之下系统可能受到损害。为此，我们从实验中找出应该保持的最小距离<br>为了使系统安全起见。这个实验涉及：<br>1.常见攻击的模拟（文档中提供）<br>2.观察其所有特征（以其坐标的形式）的量化值，如内存使用量，带宽使用量，处理能力要求等<br>3.对VM上的无数代码模块进行仿真，并将其坐标与步骤2中获得的坐标进行比较<br>4.查找代码模块和每个维度中的攻击之间的最小差异。说，无害代码模块与维度“i”的攻击之间的最小差异是mi，那么我们为所有n个维度获得以下值：m1，m2，… mn。<br>5.计算阈值：<br>阈值=√Σ（wi*mi）2 … i从1到n不等。<br>以下是通过上述步骤获得的阈值的预期特性：<br>1.阈值足够高，以确保与攻击的意外相似性一般不予以考虑。<br>2.该值足够低以确保跟踪恶意代码模块的最大概率。<br>当前代码模块与已记录攻击的比较提出的技术的有效性在很大程度上取决于阈值的正确确定。 在获得一致的阈值时，我们的方法可以证明是足够可靠的，以便最终决定代码模块的有害性。<br>接着是再生事件的产生，我们使用连续运行的计算器来测量所有VM中的代码模块与攻击集合之间的时间依赖距离（如方程式）当使用VNsnap的任何时间点的距离开始使用VNsnap在时间循环中以编程方式定期执行快照一些攻击的代码模块降低到阈值以下，当所有距离都超过阈值时停止进程，因此记录了整个攻击。<br>可以通过将系统恢复到每个快照（以编程方式再次）按照与其创建顺序相同的顺序来重新生成攻击。但是，在该再生过程之前应该采取系统的孤立快照，以便一旦重播攻击就可以将系统恢复到原来的位置.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。&lt;/p&gt;
&lt;p&gt;首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第四周周报</title>
    <link href="http://yoursite.com/2017/06/11/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/11/云取证第四周周报/</id>
    <published>2017-06-11T12:10:43.000Z</published>
    <updated>2017-06-11T12:47:26.878Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，将云取证收集文章看了一些，印象深刻的是Cloud application logging for forensics，即用于取证的云应用程序日志记录。这篇文章重点从日志的重要性、云的日志分析和取证相关的挑战、日志重点的记录方向以及日志的一些标准等这些方面论述。</p>
<p>首先是关于日志在云取证的重要性。日志是基于云的服务基础设施中最重要的分析数据之一。在任何时候，服务所有者和运营商都需要了解每个基础架构组件的状态，以进行故障监控，评估功能使用情况和监控业务流程。软件开发生命周期，用例按以下顺序：调试和取证、故障监控、故障排除、功能使用、绩效监测、安全/事件检测。监管和标准合规性这些用例都可以利用日志分析来完全解决或至少帮助大大加快和简化用例的解决方案。</p>
<p>基于云的日志分析和取证相关的挑战有：<strong>原木分散化、日志波动、多层和层、存档和保留、日志的可访问性、不存在日志、在日志中缺少关键信息等</strong>。不兼容/随机日志格式基于云的应用程序将日志存储在多个服务器和多个日志文件中。这些资源的易变性使日志文件只能在一段时间内可用。云应用程序堆栈中的每个层都生成日志，网络，操作系统，应用程序，数据库，网络服务等。一旦日志收集，他们需要在规定的时间内保持一段特定的时间，支持调查。我们需要向多个选区提供日志;应用程序开发人员，系统管理员，安全分析人员等。他们都需要访问，但只能访问一个子集而不是所有日志。平台即服务（PaaS）提供商通常不会将日志提供给他们的平台用户。尝试分析应用程序问题时，这可能是一个重大问题。例如，Amazon 不会使负载平衡器日志对他们的用户可用。最后，关键组件不能或不能正确地检测到生成必要的日志来回答具体问题。即使有日志可用，它们也有各种不同的格式，通常难以处理和分析。前五个挑战可以通过日志管理来解决。剩下的三个是更内在的问题，必须通过定义记录指南和标准来解决.</p>
<p>日志框架的功能列表：<strong>集中所有日志、可扩展日志存储、快速数据访问和检索、支持任何日志格式、运行数据分析作业（例如，map reduce）、保留日志记录、归档旧日志并按要求恢复、通过访问控制隔离数据访问、保存日志完整性</strong>。然而，它们并没有解决失踪和非标准化日志记录的挑战。 1例如，如果机器处于非常高的负载下，则可以启动新机器，如果不预先警告，则不再需要机器。 2请注意，在某些情况下，无法更改关于日志记录行为的任何内容，因为我们无法控制第三方应用程序的代码。 2.2日志记录如果没有为日志记录定义常见的准则或标准，会发生什么在很多情况下，应用程序开发者不会记录太多。有时候，日志记录是不完整的，如下例所示：3月16日08:09:58内核：[0.000000]普通1048576 - &gt; 1048576此日志中没有太多信息来确定实际发生了什么是正常。因此我们需要对一些操作进行日志处理以及标准化日志。</p>
<p>首先是重点记录方向：业务相关日志记录、基于操作的日志记录以及安全（取证）相关日志。云应用应该集中在以下用例：<strong>登录/注销（本地和远程）、密码更改/授权更改、资源访问失败（拒绝授权）</strong>。特权帐户执行的所有活动特权帐户，管理员或根用户都是对系统或应用程序的控制权。他们有权改变应用程序中的大部分参数。因此，对于安全目的来说，密切关注这些帐户正在做什么至关重要。</p>
<p>最后是日志的标准化.至少在日志记录中必须存在以下字段：<strong>时间戳记，应用程序，用户，会话ID，严重性，原因，分类</strong>。这些领域有助于回答问题：何时，什么，谁以及为什么。此外，它们负责提供我们的用例所规定的所有信息。需要一个时间戳来识别日志记录器记录的事件何时发生。时间戳记以标准格式记录[18]。应用程序字段标识日志条目的生成器。需要用户字段来确定哪个用户已经触发了一个活动。使用唯一的用户名或ID来区分用户彼此。 sessionID有助于跟踪跨不同应用程序和层次的单个请求。挑战是在整个组件中共享相同的ID。记录严重性以根据其重要性过滤日志。需要建立严重性系统。例如：debug，info，warn，error和crit。 sameschema应该在所有应用程序和层次中使用。通常情况下，需要找出原因来确定为什么会出现某些事情。例如，由于密码不足或密码错误，访问被拒绝。原因确定为什么。作为最后一组必填字段，类别或分类字段应该被记录。分类是通常用于在日志记录中增加信息以允许以常见方式处理类似事件的方法。这在例如报告中非常有用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，将云取证收集文章看了一些，印象深刻的是Cloud application logging for forensics，即用于取证的云应用程序日志记录。这篇文章重点从日志的重要性、云的日志分析和取证相关的挑战、日志重点的记录方向以及日志的一些标准等这些方
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第三周周报</title>
    <link href="http://yoursite.com/2017/06/04/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%89%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/04/云取证第三周周报/</id>
    <published>2017-06-04T12:44:36.000Z</published>
    <updated>2017-06-13T08:07:42.693Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，对云取证综述文章以及一些分析文章看了一些。接下来谈谈阅读Impact of Cloud Computing on Traditional Digital Forensic Investigations 的理解。</p>
<p>文章首先提出云取证的困难在于因为多个客户的日志记录和数据可能位于同一位置，也可能分布在不断变化的主机和数据中心集合中。如果有没有合同承诺支持具体形式的调查，那么调查和发现请求可能是不可能的。数字证据本身就非常脆弱。不正确的处理或检查可能会更改，损坏或毁坏。为此，必须采取预防措施来记录，收集，保存和检查此类证据。<strong>而在这点上我的一个想法是，能不能比如根据取得的证据例如云环境日志来复现操作顺序来达到重现犯罪现场进行案情重组的过程。比如说在初始环境1，经过若干步操作，变成环境2，环境2通过逆向操作，恢复成还原环境1，在还原过程中，其实也是对云攻击过程的一个模拟复原。当然这一切的假设都是建立在该云服务的的操作是可逆的。而在还原过程中，有利于对云攻击进行分析。</strong></p>
<p>紧接着，描述一系列有关取证的一些分析手段。例如传统的取证方法允许调查人员从实验室环境的相对安全性中抓取设备并进行调查。这在数字取证领域被称为“死亡分析”。还有一些比较高端的是，调查人员可能使用的最常见的工具包括：Guidance Software [11]的EnCase，Access Data [12]的取证工具包和Helix3 [13]，这是一个开源工具包。还有很多其他的，尽管三个突出显示的是最常用的和行业接受的工具[8]。这些工具非常强大，可以查找证据价值的文物，即使嫌疑人已经删除了被认为是妥协的数据。电子发现和现场取证是数字取证学的两个不断发展的领域，调查人员可以增加他们的武器组合来打击电子犯罪。<strong>这里，我在想是不是可以通过对这几个工具进行了解一下他们的分析方法。</strong></p>
<p>接着，描述了一系列攻击，如黑客攻击，分布式拒绝服务（DDOS）攻击，网络钓鱼，制药，恶意软件，病毒，特洛伊木马，间谍软件和蠕虫的分发。分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。基于现在攻击手段如此多和复杂，云计算问题服务级别协议（SLA）必须是强大的。<strong>然而在网上搜了下，现有应对DDOS已经有比较成熟的技术和方案。</strong></p>
<p>同时看了些关于云取证的一些分析方法，印象比较深刻的是。<strong>有一个使用Hadoop进行日志分析，使用K均值算法针对大数据量进行聚类，找出离群值，IP地址统计方法。汇总日志（存储到HDFS）,先是预处理（转成固定格式），使用MR进行处理分析（分析方法通过K-Means类似的数据挖掘手段），形成可视化结果。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，对云取证综述文章以及一些分析文章看了一些。接下来谈谈阅读Impact of Cloud Computing on Traditional Digital Forensic Investigations 的理解。&lt;/p&gt;
&lt;p&gt;文章首先提出云取证的困难在
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第二周周报</title>
    <link href="http://yoursite.com/2017/05/01/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/05/01/云取证第二周周报/</id>
    <published>2017-05-01T10:56:11.000Z</published>
    <updated>2017-06-11T12:48:32.497Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，看了几篇论文，主要还是了解现在云取证的一些情况和了解了一下docker这个新兴的技术在云计算中的应用和使用问题，印象比较深的有几篇云取证综述的论文。Cloud forensics State-of-the-art and future directions、cloud computing and digital forensics这两篇。</p>
<p>首先是Cloud forensics State-of-the-art and future directions。本论文主要讲的是在现有阶段下云取证的研究进展所面临的的挑战以及移动云取证的一些研究。首先文章开篇讲了在，美国国家标准与技术研究在“NIST云计算取证科学挑战”草案中，这致力于报告这一新兴调查领域的最新进展和最新进展。而在这里，接受率仅为15.4%。这侧面反应了这个评审的难度，也说明现在的挑战还是很大。其次是在新工具的使用上，文章只是提到了促进多节点Hadoop集群中的取证调查，但并没有进行展开讨论。以此为例引出了如果没有开发根本的新工具和能力，取证专家将面临越来越多的困难和成本。因此，今天的数字侦探不仅与罪犯进行军备竞赛，而且还与未来计算机系统的开发者进行了斗争。文章最后提到移动（云）取证是一个未被研究的主题，特别是从提供高级安全性的设备中获取数据，不仅可以用于静态数据（现在已经在所有智能移动设备中变得司空见惯），而且还通过高级加密的数据。NIST IR 8006将挑战分为九组，涉及架构，数据收集，分析，反取证，事件首次响应者，角色管理，法律话题，标准和培训等问题。我的体会是，首先这篇论文也算是我的看的入门第一篇论文，首先在现在云取证面临的挑战是非常大的，不仅在于理论研究还在于新技术的取证工具。文章最后提到的移动云取证现在还是一个比较新的主题，可以算是一个小小备选方案（但我上周和学长们简单交流了下，他们说现在移动云取证几乎该挖的坑都挖完了，所以在这边还是有分歧，有可能跟时间有问题或者跟看的问题角度有关）。</p>
<p>其次是cloud computing and digital forensics（云取证和数字取证）。这篇论文令我印象深的有这么几点：1.日志这一取证的手段。在网络入侵的情况下，受害者组织普遍存在于准备阶段，为了保护数字犯罪现场，关闭整个网络极少可行。因此，有用的证据可能不再可用，可能难以收集，也许完全不可接触，或者可能没有以法定的方式保存。例如，各种类型的日志在网络入侵调查中可能是非常有价值的，但是许多组织不会收集这些日志或不保留日志超过几天，或者不以确保其完整性的方式存储日志。这给我的体会是可以结合一个场景，将日志这个功能进行完善分析。2. 取证方法的分析，涉及哦取证技术；网络取证工具，内存取证方法和数据库取证方法。里面提到了计算机和智能手机云存储服务留下的痕迹的取证分析，是智能手机中碎片闪存页面的取证分析技术。Fasan和Olivier提出了一种重建存储在数据库中的数字证据的可靠方法（参见“数据库重建算法的正确性证明”）。这是一个重要的话题，因为更多的证据存储在数据库中，包括在云环境中，使得可以将很多证据得以保存，便于以后排查原因入侵者等因素。</p>
<p>关于Docker的研究。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。docker的出现极大了加快了PAAS的发展，企业私有PAAS构建蓬勃发展起来。可以看到PAAS核心是解决软件代码完成后部署运行运维到监控的所有事情。基于Docker的PaaS平台现在逐渐成为主流。关于docker的安全问题有：</p>
<h5 id="1-权限及资源限制。"><a href="#1-权限及资源限制。" class="headerlink" title="1.    权限及资源限制。"></a>1.    权限及资源限制。</h5><p>限制用户运行特权及访问资源。对于多租户应用，不同的容器共享同一主机的资源和环境，普通用户权限的恶意提升将会使宿主主机完全处于被非法操控的险境，而对于用户的合法操作，大量的资源申请也会将主机推向崩溃的编译。因此，有必要对用户权限进行限定，避免根权限的赋予，进而减少主机暴露的攻击面和潜力。同时，在CPU、内存及进程数等资源方面，限定用户在单一容器中的可用配额，来防止恶意的无限资源申请给整体系统带来的破坏。<br>镜像及制作管理</p>
<h5 id="2-对容器的镜像来源进行审核。"><a href="#2-对容器的镜像来源进行审核。" class="headerlink" title="2.对容器的镜像来源进行审核。"></a>2.对容器的镜像来源进行审核。</h5><p>容器镜像制作的简化让用户可以轻而易举的创建自定义的应用镜像，但制作的应用程序千差万别，功能完整性和测试完整性参差不齐。这让用户镜像的产生面临存在众多漏洞的风险，因此需要对镜像的制作过程尽量规范化，对放置的应用程序尽量做到测试完备并符合安全标准，从源头上减少漏洞镜像的生成。而在创建容器过程中，避免使用不受信任的镜像及应用程序，采用标准及合格厂商如时速云的镜像服务mirror，从而保证容器运行时的正规及安全。</p>
<h5 id="3-日志安全审计及升级补丁"><a href="#3-日志安全审计及升级补丁" class="headerlink" title="3.日志安全审计及升级补丁"></a>3.日志安全审计及升级补丁</h5><p>对容器及系统中宿主机进行定期安全检查及漏洞补丁升级。定期针对容器及所在宿主机的网络环境进行渗透安全测试，及时发现可疑容器或危险服务端口。对主机内核及原始镜像进行定时更新，及时修补公开漏洞。在应用层次，收集及检测容器的安全日志，统计监督应用的运行过程，及时发现服务异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，看了几篇论文，主要还是了解现在云取证的一些情况和了解了一下docker这个新兴的技术在云计算中的应用和使用问题，印象比较深的有几篇云取证综述的论文。Cloud forensics State-of-the-art and future directio
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第一周周报</title>
    <link href="http://yoursite.com/2017/04/25/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%80%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/04/25/云取证第一周周报/</id>
    <published>2017-04-25T02:33:03.000Z</published>
    <updated>2017-05-31T11:59:00.747Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，上网查询有关于云计算方面的知识点、云安全的相关知识点以及云取证的一些概念。</p>
<p>首先是对于云计算的一些见解，定义就是，云计算是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。特点是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将与互联网更相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。从我个人角度出发，我认为云这个概念其实就是任何可以通过互联网访问的服务。而这个服务往往通过分布式计算机来协助完成。</p>
<p>然后是云计算的分类，具体是分为IaaS、PaaS、SaaS。IaaS(Infrastructure as a Service，基础架构即服务)通过互联网提供了数据中心、基础架构硬件和软件资源。IaaS可以提供服务器、操作系统、磁盘存储、数据库和/或信息资源。IaaS通常会按照”弹性云”的模式引入其他的使用和计价模式，也就是在任何一个特定的时间，都只使用你需要的服务，并且只为之付费。PaaS(Platform as a Service，平台即服务)提供了基础架构，软件开发者可以在这个基础架构之上建设新的应用，或者扩展已有的应用，同时却不必购买开发、质量控制或生产服务器。这些平台允许公司创建个性化的应用，也允许独立软件厂商或者其他的第三方机构针对垂直细分行业创造新的解决方案。SaaS(Software as a Service，软件即服务)是最为成熟、最出名，也是得到最广泛应用的一种云计算。大家可以将它理解为一种软件分布模式，在这种模式下，应用软件安装在厂商或者服务供应商那里，用户可以通过某个网络来使用这些软件，通常使用的网络是互联网。这种模式通常也被称为”随需应变”软件，这是最成熟的云计算模式，因为这种模式具有高度的灵活性、已经证明可靠的支持服务、强大的可扩展性，因此能够降低客户的维护成本和投入，而且由于这种模式的多宗旨式的基础架构，运营成本也得以降低。</p>
<p>“云安全（Cloud Security）”计划是网络时代信息安全的最新体现，它融合了并行处理、网格计算、未知病毒行为判断等新兴技术和概念，通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。常见的云安全问题有：用户身份安全问题、共享业务安全问题、用户数据安全问题。</p>
<p>术语“云取证”是指从云基础设施采集数字取证数据。例如，本地取证证据包括从日志文件、存储在磁盘上的数据、网络流量和入侵标志物等收集到的信息。本地分析与云服务分析之间的基本区别是，使用本地计算机，通过简单地进入系统，从而可以收集并分析信息。然而，当涉及到云时，机器无法进行物理访问，只有计算机的某些部分，可以通过云应用程序接口进行访问。</p>
<p>我的个人见解是，对于云取证来说，可以从两个方面进行考虑。第一个是怎么取证，也就是取证的手段，换句话说就是在取证的技术或者方式上有所改善或者突破；第二个就是对于获取到的证据如何去分析，也就是在分析证据的手段上有所改善或者突破，我觉得这块可以跟比如数据挖掘或者人工智能联系起来，例如有个论文提到的，用数据挖掘来形成聚类，找出ip的之间的关系，具体是通过kmeans的算法针对原始数据进行聚类，将所有数据划分成不同的数据集；接着在各个聚类后的数据集内部，使用 IP 地址统计方法来捕捉各个数据集特征，从而找出离群值，即可能的入侵者。又比如可以对文件简历索引，通过搜索引擎大大提高海量数据查询的效率，具体做法是集中为每个文件创建唯一标志签名， 该签名会一直跟随文件直到文件被删除， 然后借助分布式任务检测海量数据中符合签名的匹配文件 ， 从而大大提高了文件搜索的效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，上网查询有关于云计算方面的知识点、云安全的相关知识点以及云取证的一些概念。&lt;/p&gt;
&lt;p&gt;首先是对于云计算的一些见解，定义就是，云计算是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。特点是通过使计算
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫问题</title>
    <link href="http://yoursite.com/2017/04/05/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/04/05/约瑟夫问题/</id>
    <published>2017-04-05T04:46:56.000Z</published>
    <updated>2017-05-31T11:51:31.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。"><a href="#问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。" class="headerlink" title="问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。"></a>问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。</h3><h4 id="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"><a href="#解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新" class="headerlink" title="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"></a>解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining(int n, int m) &#123;</div><div class="line">    <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">        <span class="built_in">return</span> -1;</div><div class="line">    &#125;</div><div class="line">    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        list.add(i);</div><div class="line">    &#125;</div><div class="line">    // 要删除元素的位置</div><div class="line">    int idx = 0;</div><div class="line">    // 开始计数的位置</div><div class="line">    int start = 0;</div><div class="line">    <span class="keyword">while</span> (list.size() &gt; 1) &#123;</div><div class="line">        // 只要移动m-1次就可以移动到下一个要删除的元素上</div><div class="line">        <span class="keyword">for</span> (int i = 1; i &lt; m; i++) &#123;</div><div class="line">            idx = (idx + 1) % list.size(); // 【A】</div><div class="line">        &#125;</div><div class="line">        list.remove(idx);</div><div class="line">        // 确保idx指向每一轮的第一个位置</div><div class="line">        // 下面的可以不用，【A】已经可以保证其正确性了，可以分析n=6，m=6的第一次删除情况</div><div class="line">    //  <span class="keyword">if</span> (idx == list.size()) &#123;</div><div class="line">    //      idx = 0;</div><div class="line">    //  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> list.get(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"><a href="#解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。" class="headerlink" title="解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"></a>解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。</h4><p>首先我们定义一个关于 n 和 m 的方程时，表示每次在 n 个数字 0，1， … ，n-1中每次删除第 m 个数字最后剩下的数字。</p>
<p>在这 n个数字中， 第一个被删除的数字是(m-1)%n。为了简单起见，我们把(m- 1)%n 记为 k，那么删除k之后剩下的 n-1 个数字为 0，1，… ，k-1，k+1，… ，n-1，并且下一次删除从数字 k+1 开始计数。相当于在剩下的序列中， k+1 排在最前面，从而形成 k+1，… ，n- 1，0，I，… ，k-1 。该序列最后剩下的数字也应该是关于 n 和 m 的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从 0 开始的连续序列），因此该函数不同于前面的函数，记为 f’(n-1,m)。最初序列最后剩下的数字 f(n, m）一定是删除一个数字之后的序列最后剩下的数字，即 f(n, m)=f’(n-1, m）。</p>
<p>接下来我们把剩下的这 n-1 个数字的序列 k-1， …，n-1，0，1，… ，k-1 做一个映射，映射的结果是形成一个从 0 到 n-2 的序列：<br><img src="http://wiki.jikexueyuan.com/project/for-offer/images/63.png" alt=""> 　　<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining2(int n, int m) &#123;</div><div class="line">     <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">         <span class="built_in">return</span> -1;</div><div class="line">     &#125;</div><div class="line">     int last = 0;</div><div class="line">     <span class="keyword">for</span> (int i = 2; i &lt;=n ; i++) &#123;</div><div class="line">         last = (last + m)%i;</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">return</span> last;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。&quot;&gt;&lt;a href=&quot;#问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/25/hello-world/"/>
    <id>http://yoursite.com/2017/03/25/hello-world/</id>
    <published>2017-03-25T02:30:03.000Z</published>
    <updated>2017-05-31T11:52:20.379Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
