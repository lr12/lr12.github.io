<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-21T08:02:14.255Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务治理Eureka</title>
    <link href="http://yoursite.com/2018/01/17/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86Eureka/"/>
    <id>http://yoursite.com/2018/01/17/服务治理Eureka/</id>
    <published>2018-01-17T03:02:50.000Z</published>
    <updated>2018-01-21T08:02:14.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>通常会构建一个注册中心，每个服务单元向注册中心注册自己的服务，将主机与端口号、版本号、通信协议等一些信息按服务名分类组织服务清单。另外，服务注册中心还需要以心跳的方式监测清单中的服务是否可用，若不可用需要将服务清单剔除，达到排除故障的效果。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务间的调用不再指定具体实例地址来实现，而是通过服务名发起请求调用。</p>
<h1 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h1><p>Eureka用来实现服务注册和发现，既包含了服务端组件，也包含了客户端组件。Eureka服务端的服务治理机制提供了完备的Restful Api，所以也支持非java语言构建的微服务。<br>Eureka服务端，也称服务注册中心，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种故障场景。如果Eureka以集群模式部署，当集群分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障继续提供服务的发现和注册，当故障分片恢复时，集群中其他分片会把他们的状态再次同步回来。以AWS为例，每个可用区域运行一个Eureka服务端，通过他形成集群，不同区域的服务注册中心通过异步模式互相复制各自的状态<br>Eureka客户端主要处理服务的注册和发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka向注册中心注册自身提供的服务并周期性地发送心跳来更新他的服务租约。同时，它能从服务端查询当前的注册服务信息并把他缓存到本地并周期性的刷新服务状态。</p>
<h1 id="搭建服务注册中心"><a href="#搭建服务注册中心" class="headerlink" title="搭建服务注册中心"></a>搭建服务注册中心</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//pom 文件</div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.example&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;cloudserver&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;cloudserver&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div><div class="line">//application.properties配置</div><div class="line">server.port=11111</div><div class="line">eureka.instance.hostname=localhost</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div><div class="line">//java代码启动</div><div class="line">@EnableEurekaServer</div><div class="line">@SpringBootApplication</div><div class="line">public class CloudserverApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new SpringApplicationBuilder(CloudserverApplication.class).web(<span class="literal">true</span>).run(args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/eureka.png" alt=""></p>
<h1 id="注册服务提供者"><a href="#注册服务提供者" class="headerlink" title="注册服务提供者"></a>注册服务提供者</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">          &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line"></div><div class="line">	&lt;/dependencies&gt;</div><div class="line">&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8081</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka</div><div class="line">spring.application.name=provider-service</div><div class="line">//java代码</div><div class="line">@SpringBootApplication</div><div class="line">public class DemoApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(DemoApplication.class, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//新建个web包，提供服务</div><div class="line">@RestController</div><div class="line">@EnableEurekaClient</div><div class="line">public class HelloController &#123;</div><div class="line">	@Value(<span class="string">"<span class="variable">$&#123;server.port&#125;</span>"</span>)</div><div class="line">	String port;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hi"</span>)</div><div class="line">	public String home(@RequestParam String name) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"hi "</span> + name + <span class="string">",i am from port:"</span> + port;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/服务.png" alt=""></p>
<h1 id="高可用注册中心"><a href="#高可用注册中心" class="headerlink" title="高可用注册中心"></a>高可用注册中心</h1><p>在微服务架构中，我们需要充分考虑发生故障的情况，所以在生产环境中必须对各个组件进行高可用部署。Eureka的设计一开始就考虑了搞可用问题，在Eureka的设计中一开始就考虑了高可用问题，在Eureka的服务治理设计中，所有节点既是服务提供方，也是服务消费方，服务注册中心也不例外。例如我们需要让设置两个参数，让服务注册中心不注册自己。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>Eureka的高可用就是将自己作为服务向其他服务中心注册自己，这样形成一组互相注册的服务注册中心，达到高可用。现在构建一个双节点的服务注册集群<br>创建application-peer1-properties作为peer1的服务中心配置。并将serviceUrl指向peer2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11111</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer1</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer2:11112/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>创建application-peer2-properties作为peer2的服务中心配置。并将serviceUrl指向peer1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11112</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer2</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer1:11111/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>接着修改etc/hosts<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1	master-peer1</div><div class="line">127.0.0.1	master-peer2</div></pre></td></tr></table></figure></p>
<p>通过–spring.profiles.active=peer1、–spring.profiles.active=peer2分别启动peer1和peer2然后修改服务提供者客户端的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.port=8888</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=provider-service</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/17/服务治理Eureka/高可用2.png" alt=""><br><img src="/2018/01/17/服务治理Eureka/高可用.png" alt=""></p>
<h1 id="服务发现和消费"><a href="#服务发现和消费" class="headerlink" title="服务发现和消费"></a>服务发现和消费</h1><p>程序是注册在Eureka注册中心上，现在有服务注册中心和服务提供者，还需要服务消费者，它主要完成发现服务和以及消费服务的功能。服务发现的任务由Eureka的客户端完成，而服务消费由Ribbon完成。Ribbon是一个基于http和tcp的客户端均衡器，它可以在通过客户端配置的ribbonServerList服务器列表去轮询访问以达到负载均衡的作用。当Ribbon与Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成Eureka注册中心中获取服务列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8082</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=consumer-invoke</div><div class="line">//java启动类</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	RestTemplate <span class="function"><span class="title">restTemplate</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//访问服务</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	RestTemplate restTemplate;</div><div class="line"></div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		String serviceString=<span class="string">"http://PROVIDER-SERVICE/hello"</span>;</div><div class="line">		<span class="built_in">return</span> restTemplate.getForEntity(serviceString, String.class).getBody();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Eureka详解"><a href="#Eureka详解" class="headerlink" title="Eureka详解"></a>Eureka详解</h1><p>构建Eureka服务治理体系中的三个核心角色：服务注册中心、服务提供者、服务消费者。</p>
<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><ul>
<li>服务注册中心：Eureka提供的服务端，提供服务注册与发现的功能，也就是eureka-server</li>
<li>服务提供者：提供服务的应用，可以是springboot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现。</li>
<li>服务消费者：消费者需要从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。</li>
</ul>
<h1 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h1><p><img src="/2018/01/17/服务治理Eureka/eureka服务治理.png" alt=""></p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><h3 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务提供者在启动时候会通过发送REST请求的方式将自己注册到Eureka Server，同时带上了自身服务的一些元数据信息。Eureka server接收到这个REST请求后，将元数据信息存储在一个双层结构map中，第一层key是服务名，第二层key是具体服务的实例名，在ribbon负载均衡中，Eureka一个服务有多个实例，所以采用了双层map。<br>在服务注册时，需要确认一下eureka.client.register-with-eureka=true,是否正确，该值默认为true，若设置为false将不会注册。</p>
<h3 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h3><p>服务提供者分别注册到两个不同的服务注册中心上，他们的信息分别被两个服务注册中心所维护。由于服务注册中心之间相互注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群相连的其他注册中心。</p>
<h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><p>在注册完服务之后，服务提供者会维护一个心跳来持续告诉Eureka server：我还活着，以防止Eureka Server的剔除任务将该实例从服务列表中排除出去。我们称这个为服务续约。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//服务续约任务调用间隔时间</div><div class="line">eureka.instance.lease-renewal-interval-in-seconds=30</div><div class="line">//服务时效时间</div><div class="line">eureka.instance.lease-expiration-duration-in-seconds=90</div></pre></td></tr></table></figure></p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>当我们启动服务消费者，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。eureka server会维护一份只读的服务清单来返回客户端，同时该缓存清单会每隔30s更新一次。</p>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在ribbon会默认采用轮询的方式调用，从而实现客户端的负载均衡。<br>对于访问实例的选择，Eureka中有region和zone的概念，一个region中可以包含多个zone，每个服务客户端需要被注册一个Zone，所以每个客户端对应一个region和一个zone。</p>
<h3 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h3><p>在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。在客户端程序中，在服务实例进行正常的关闭操作，它会触发一个服务下线的REST请求给Eureka Server，告诉服务中心：我要下线了，服务端在接收请求之后，将该服务状态置为下线，并把该下线时间传播出去。</p>
<h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h3><p>服务器可能由于内存溢出、网络故障等原因使得服务不能正常工作。为了从服务列表中将这些无法提供服务的实例剔除，Eureka在启动时会创建一个定时任务，默认每隔一段时间（60s）将当前清单中超时（默认是90s）没有续约的服务剔除出去。</p>
<h3 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h3><p>当在服务注册中心出现红色警告信息，实际上，该警告就是触发了Eureka的自我保护机制。Eureka server会统计心跳失败比例在十五分钟内是否低于百分之八十五，如果出现这些情况，会把当前实例注册信息保护起来，让这些实例不会过期，尽可能保护这些信息。但在本地开发，会使得注册中心维护的服务实例不那么准确，下面关闭保护机制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.server.enable-self-preservation=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>[<a href="https://www.jianshu.com/p/ef2591899597" target="_blank" rel="external">https://www.jianshu.com/p/ef2591899597</a>]</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在Eureka的服务治理体系中，主要分为客户端和服务器端两个不同的角色，服务端为服务注册中心，客户端为各个提供接口的微服务应用。Eureka客户端的配置如下：1.服务注册相关的配置信息。包括服务注册中心的地址、服务获取的间隔时间、可用区域。2.服务实例相关的配置信息。包括服务实例的名称、IP地址、端口号、健康检查路径。</p>
<h1 id="服务注册类配置"><a href="#服务注册类配置" class="headerlink" title="服务注册类配置"></a>服务注册类配置</h1><p>这些配置信息主要以eureka.client为前缀，以指定注册中心为例，主要通过eureka.client.serviceUrl参数实现，默认的值为defaultZone，value为<a href="http://127.0.0.1:8761/eureka/。当然也可以更改" target="_blank" rel="external">http://127.0.0.1:8761/eureka/。当然也可以更改</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div></pre></td></tr></table></figure></p>
<p>也可以是高可用注册中心集群，不同的值用逗号隔开<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/,</div></pre></td></tr></table></figure></p>
<p>为了服务注册中心的安全，可以加入安全认证，在配置serviceUrl时，需要在value值的url加入相应的安全验证信息。比如http://<uusername>:<password>@localhost:1111/eureka</password></uusername></p>
<h1 id="服务实例类配置"><a href="#服务实例类配置" class="headerlink" title="服务实例类配置"></a>服务实例类配置</h1><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据是Eureka客户端在向服务注册中心发送请求时，用来描述自身服务信息的对象，其中包含一些标准化的元数据，比如服务名称、实例名称、实例ip、实例端口等用于服务服务治理的相关信息。以及一些负载均衡策略，或是其他特殊用途的自定义元数据的信息。<br>在使用Eureka的时候，所有的配置信息都通过org.springframework.cloud.Netflix.eureka.EurekaInstanceConfigBean进行加载，但在真正进行注册，还是会包装成instanceInfo发送给服务端，其中使用ConcurrentHashMap来存储。可以通过eureka.instance.<properties>=<value>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.instance.metadataMap.zone=shanghai</div></pre></td></tr></table></figure></value></properties></p>
<h2 id="实例名配置"><a href="#实例名配置" class="headerlink" title="实例名配置"></a>实例名配置</h2><p>实例名即InstanceInfo中的instanceId参数，它是区分同一服务不同实例的唯一标识。在Netflix原生实现中，采用主机名作为默认值，导致同一主机无法启动多个相同的服务实例。现在的cloud Eureka配置，采用的规则是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$&#123;spring.cloud.client.hostname&#125;</span>:<span class="variable">$&#123;spring.application.name&#125;</span>:<span class="variable">$&#123;spring.application.instance_id&#125;</span>:<span class="variable">$&#123;server.port&#125;</span></div><div class="line">eureka.instance.instanceId=<span class="variable">$&#123;spring.application.name&#125;</span>+<span class="variable">$&#123;random.int&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="端点的配置"><a href="#端点的配置" class="headerlink" title="端点的配置"></a>端点的配置</h2><p>在instanceInfo中，我们可以看到URL的配置信息，比如homePageURL、StatusPageUrl、HealthCheckUrl，分别代表着主页、状态检查、健康检查，其中状态和健康由actuator模块提供的info和health端点。</p>
<h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>各个服务实例的健康检测并不是通过health端点来实现，而是依靠客户端的心跳，来保持服务实例的存活。默认的心跳实现方式可以有效检查客户端进程是否正常运作，却无法保证客户端能正常提供服务。spring cloud 配置 health端点</p>
<ul>
<li>在pom包引入spring-boot-starter-actuator依赖</li>
<li>在application.properties加入eureka.client.healthcheck.enabled=true<h1 id="跨平台的支持"><a href="#跨平台的支持" class="headerlink" title="跨平台的支持"></a>跨平台的支持</h1>Eureka的通信机制是通过http的rest接口实现，由于http的平台无关性，虽然server可以通过java实现，但微服务应用并不限于使用java开发。比如python、js也能支持。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务治理&quot;&gt;&lt;a href=&quot;#服务治理&quot; class=&quot;headerlink&quot; title=&quot;服务治理&quot;&gt;&lt;/a&gt;服务治理&lt;/h1&gt;&lt;h2 id=&quot;服务注册&quot;&gt;&lt;a href=&quot;#服务注册&quot; class=&quot;headerlink&quot; title=&quot;服务注册&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="spring cloud 微服务实战" scheme="http://yoursite.com/categories/spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="spring cloud" scheme="http://yoursite.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="http://yoursite.com/2018/01/16/springboot/"/>
    <id>http://yoursite.com/2018/01/16/springboot/</id>
    <published>2018-01-16T07:25:25.000Z</published>
    <updated>2018-01-16T16:06:03.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p>springboot的宗旨并非是重写spring或是替代spring，而是希望通过设计大量的自动化配置等方式来简化spring原有样版化的配置，使得开发者可以快速构建应用。<br>除了解决配置问题外，springboot还可以通过一系列starter poms的定义，让我们整合各项功能时，不需要在maven的pom.xml维护那些错综复杂的依赖关系，而是通过类似模块化的starter模块定义来引用，使得依赖管理变得更为简单。<br>springboot除了可以很好的融入docker之外，其自身支持嵌入式的tomcat、jetty等容器。通过springboot构建的应用不需要安装tomcat，只需将springboot应用打成jar包，通过java-jar命令直接运行并启动一个标准化的web应用，这使得应用变得很轻量。<br>整个springboot生态系统都用到了groovy，完全可以通过gradle和groovy来开发springboot应用。</p>
<h1 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.software&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;demo&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;demo&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">    		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>打包的为jar包，parent配置指定spring-boot-starter-parent为1.5.9，该父项定义了springboot版本的基础依赖和一些默认配置内容，比如application.properties的位置等</p>
<ul>
<li>spring-boot-starter-web:全栈web开发模块，包含嵌入式tomcat、spring MVC</li>
<li>spring-boot-starter-test:通用测试模块，包含Junit、Hamcrest、Mockito</li>
<li>spring-boot-starterjdbc或者spring-boot-starter-data-jpa：访问数据库的能力</li>
</ul>
<p>在使用springboot构建应用时，各项功能模块的整合不再像传统spring应用开发一样，需要在pom文件里做大量依赖配置，而是通过starter POMs定义的依赖包，使得功能模块整合变得非常轻巧。</p>
<h1 id="实现Restful接口"><a href="#实现Restful接口" class="headerlink" title="实现Restful接口"></a>实现Restful接口</h1><p>在springboot中创建一个restful api的实现代码同spring mvc应用一样，只是不用做很多配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class HelloController &#123;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"say hello"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>springboot默认的配置文件位置是src/main/resources/application.properties,根据我们引入的不同starter模块，可以在这里定义容器端口号，数据库连接信息，日志级别等各种配置信息。比如添加server.port=8888，指定端口号是8888.springboot除了用传统的properties文件外，还支持现在广泛使用的yaml。<br>yaml配置格式不像properties配置那样以单纯的键值对形式来表示，而是以类似缩进形式表现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">environments:</div><div class="line">   dev:</div><div class="line">      url: http://dev.bar.com</div><div class="line">      name: Developer Setup</div><div class="line">   prod:</div><div class="line">      url: http://foo.bar.com</div><div class="line">      name: My cool app</div><div class="line">等价于properties</div><div class="line">environments.dev.url=http://dev.bar.com</div><div class="line">environments.dev.name=Developer Setup</div><div class="line">environments.prod.url=http://foo.bar.com</div><div class="line">environments.prod.name=My cool app</div></pre></td></tr></table></figure></p>
<h1 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h1><p>除了可以预定义各个starter模块预定义的配置属性，也可以在配置文件中定义一些我们需要定义的属性。比如在application.properties添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">book.name=java并发</div><div class="line">book.author=lr</div><div class="line">//通过@value加载自定义参数</div><div class="line">@Component</div><div class="line">public class Book&#123;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.name&#125;</span>"</span>)</div><div class="line">  private String name;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.author&#125;</span>"</span>)</div><div class="line">  private String author;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h1><p>我们希望有些参数被加载时不是一个固定的值，比如密钥，服务端口。可以使用${random}产生随机的int、long或者String字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//随机字符串</div><div class="line">blog.value=<span class="variable">$&#123;random.value1&#125;</span></div><div class="line">//随机int</div><div class="line">blog.number=<span class="variable">$&#123;random.int&#125;</span></div><div class="line">//随机long</div><div class="line">blog.bignumber=<span class="variable">$&#123;random.long&#125;</span></div><div class="line">//10以内的随机数</div><div class="line">blog.test1=<span class="variable">$&#123;random.int(10)&#125;</span></div><div class="line">//10~20的随机数</div><div class="line">blog.test2=<span class="variable">$&#123;random.int[10,20]&#125;</span></div></pre></td></tr></table></figure></p>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>可以在命令行指定应用的参数，比如设置应用端口java -jar xxx.jar –server.port=8888</p>
<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>通常同一套程序会被应用和安装在不同环境中，比如开发、测试、生产，其中每个环境的数据库地址、服务端口等配置都不同，如果在不同环境打包时都要频繁修改配置文件，那必然十分繁琐。<br>在springboot中，多环境配置的文件名需要满足application-{profile}.properties的格式，其中profile是你的环境标识，例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">application-dev.properties 开发环境</div><div class="line">application-test.properties 测试环境</div><div class="line">application-prod.properties 生产环境</div><div class="line">在application设置spring-profiles-active=dev，默认选择开发</div><div class="line">执行时 java -jar xx.jar --spring-profiles-active=<span class="built_in">test</span> 修改</div></pre></td></tr></table></figure></p>
<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p><img src="/2018/01/16/springboot/加载顺序.png" alt=""></p>
<h1 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h1><p>spring-boot-starter-actuator模块能够为springboot提供监控，spring cloud在实现各个微服务组件时，进一步为该模块做了不少扩展，比如为原生端增加了不少指标和度量信息。</p>
<h1 id="初识actuator"><a href="#初识actuator" class="headerlink" title="初识actuator"></a>初识actuator</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">/health</div><div class="line">&#123;<span class="string">"status"</span>:<span class="string">"UP"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="原生端"><a href="#原生端" class="headerlink" title="原生端"></a>原生端</h1><ul>
<li>应用配置类：获取应用程序的应用配置、环境变量、自动化配置报告</li>
<li>度量指标类：获取运行过程监控的度量指标，比如内存信息、线程池信息、http请求统计。</li>
<li>操作控制类：提供对应用关闭等操作类功能</li>
</ul>
<h2 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h2><ul>
<li>/autoconfig 获取应用自动化配置报告</li>
<li>/beans 获取应用上下文创建的所有bean</li>
<li>/configprops 获取配置的属性信息</li>
<li>/env 环境属性报告，包括环境变量、jvm命令行、应用配置</li>
<li>/mappings 所有spring mvc控制器映射关系</li>
<li>/info 自定义信息</li>
</ul>
<h2 id="指标度量类"><a href="#指标度量类" class="headerlink" title="指标度量类"></a>指标度量类</h2><ul>
<li>metrics 内存信息、线程、垃圾回收</li>
<li>health 各类健康指标</li>
<li>dump 暴露运行中的线程信息</li>
<li>trace 返回基本http跟踪信息</li>
</ul>
<h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/shutdown</div><div class="line">endpoints.shutdown.enabled=<span class="literal">true</span> //修改配置文件</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;框架简介&quot;&gt;&lt;a href=&quot;#框架简介&quot; class=&quot;headerlink&quot; title=&quot;框架简介&quot;&gt;&lt;/a&gt;框架简介&lt;/h1&gt;&lt;p&gt;springboot的宗旨并非是重写spring或是替代spring，而是希望通过设计大量的自动化配置等方式来简化sprin
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>线程池和Executor</title>
    <link href="http://yoursite.com/2018/01/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CExecutor/"/>
    <id>http://yoursite.com/2018/01/10/线程池和Executor/</id>
    <published>2018-01-10T01:53:55.000Z</published>
    <updated>2018-01-14T09:12:54.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h1><p>线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:</p>
<ul>
<li>降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>1）线程池判断核心线程池是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已满。如果工作队列没有满，则新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<br><img src="/2018/01/10/线程池和Executor/线程池流程.png" alt=""></p>
<p><img src="/2018/01/10/线程池和Executor/线程池执行.png" alt=""><br>ThreadPoolExecutor执行execute分下面四种情况：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则新建新的线程来执行任务，执行这一步需要全局锁。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务。执行这一步骤需要获取全局锁</li>
<li>如果创建新的线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>采用上述步骤的总体思路是，是为了在执行execute方法时，尽量避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前的运行线程数大于等于corePoolSize），几乎所有的execute方法都是执行步骤2，而步骤2不需要获取全局锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable <span class="built_in">command</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">command</span> == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    // 如果线程数小于基本线程数，则创建线程并执行当前任务</div><div class="line">    <span class="keyword">if</span>(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(<span class="built_in">command</span>)) &#123;</div><div class="line">        // 如线程数大于等于核心线程数或线程创建失败，则将当前任务放到工作队列中。</div><div class="line">        <span class="keyword">if</span>(runState == RUNNING &amp;&amp; workQueue.offer(<span class="built_in">command</span>)) &#123;</div><div class="line">            <span class="keyword">if</span>(runState != RUNNING || poolSize == 0)</div><div class="line">                ensureQueuedTaskHandled(<span class="built_in">command</span>);</div><div class="line">        &#125;</div><div class="line">        // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!addIfUnderMaximumPoolSize(<span class="built_in">command</span>))</div><div class="line">            // 抛出RejectedExecutionException异常</div><div class="line">            reject(<span class="built_in">command</span>); // is shutdown or saturated</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程worker，woker在执行完任务后，还会循环获取工作队列里的任务来执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            try &#123;</div><div class="line">                Runnable task = firstTask;</div><div class="line">                firstTask = null;</div><div class="line">                <span class="keyword">while</span>(task != null || (task =getTask()) != null) &#123;</div><div class="line">                    runTask(task);</div><div class="line">                    task = null;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                workerDone(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/执行任务.png" alt=""><br>线程池执行任务分两种情况：1.在execute方法中创建一个线程时，会让这个线程执行当前任务。2.这个线程执行完任务后，会反复从BlockingQueue获取任务来执行。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>
<ol>
<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，及时其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用prestartAllCoreThreads方法，线程池会提前创建并启动所有线程。</li>
<li>runnableTaskQueue（任务队列）:用于保存等待执行任务的阻塞队列。可选择以下几个阻塞队列：<br>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另外一个线程调用移除操作，否则操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，Executors.newCachedThreadPool使用了这个队列<br>PriorityBlockingQueue：一个具有优先队列的无限阻塞队列</li>
<li>maximumPoolSize（线程池最大数量）：线程允许创建的最大线程数，如果队列满了并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用无界的任务队列这个参数就没意义。</li>
<li><p>ThreadFactory：用来创建线程的工厂，可以通过线程工厂给每个创建的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速地给线程池里的线程设置有意义的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</div></pre></td></tr></table></figure>
</li>
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池满时，说明线程池处于饱和状态，那么必须采用一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理任务时抛异常。<br>AbortPolicy：直接抛出异常<br>CallerRunsPolicy：只用调用者所在线程来运行任务<br>DiscardOldestPolicy：丢弃队列里最后一个任务，来执行当前任务<br>DiscardPolicy：不处理，丢弃掉</p>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行时间都比较短，，可以调大时间，提高cpu的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的时间有Days、HOUSRS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS</li>
</ol>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute和submit方法。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>()&#123;</div><div class="line">  public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>submit方法用于提交需要返回值的任务，线程池会返回一个Future对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成。而使用get(long timeout,TimeUnit unit)则会阻塞当前线程一段时间后立即返回，这时候有可能任务还未执行完。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future=executor.submit(harReturnValuetask);</div><div class="line">try&#123;</div><div class="line">  Object s=future.get();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;finally&#123;</div><div class="line">  executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他的原理是遍历线程池中的工作线程，然后逐个调用线程的interupt方法来中断线程，所以无法中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow是先把线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。而shoutdown只是将线程池的状态设置为shutdown状态，然后中断所有没有正在执行任务的线程。<br>只要调用这两个关闭方法中的其中一个，isshutdown方法就会返回true，当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。<br>任务的性质：CPU密集任务、IO密集任务、混合型任务<br>任务的优先级：高、中、低<br>任务执行的时间：长、中、短<br>任务的依赖性：是否依赖其他系统资源，如数据库连接<br>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应该配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。对于混合型任务，如果可以拆分，将其拆分成CPU密集型任务和IO密集型任务，只要这两个任务执行时间相差不是很大，那么拆分后的吞吐量将高于串行的执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRunTime().availableProcessors()方法获取当前设备的cpu数量。<br>优先级不同可以使用PriorityBlockingQueue来处理，它可以让优先级高的任务先执行。<br>执行时间不同交给不同规模的线程池来处理或者可以使用优先级队列，让执行时间段的任务先执行。<br>依赖数据库连接池任务，因为线程提交SQl后需要等待数据库返回结果，等待的时间越长，cpu的空余时间越长，那么线程数应该设置越大，才能更好地利用cpu。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便出现问题时定位。监控线程池可使用如下属性<br>taskCount：线程需要执行的任务数量<br>completedTaskCount：线程池在运行过程时已完成的任务数量，小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量<br>getPoolSize：线程池的线程数量<br>getActiveCount：获取活动线程数<br>通过扩展线程池进行监控，可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间。这几个方法在线程池里是空方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void beforeExecute(Thread t, Runnable r)&#123; &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>java线程被一对一映射为本地操作系统线程。java线程启动时会创建一个本地操作系统线程；当该线程终止时，这个操作系统线程会被回收。操作系统会调度所有线程并将它们分配给可用的cpu。<br>在上层，java多线程程序通常把应用分解为若干个任务，然后使用用户级调度器(Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。简单的说，应用程序通过Executor框架控制上层的调度，下层的调度通过操作系统内核控制，下层的调度不受应用程序的控制。<br><img src="/2018/01/10/线程池和Executor/二级调度.png" alt=""></p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><h4 id="Executor框架的架构"><a href="#Executor框架的架构" class="headerlink" title="Executor框架的架构"></a>Executor框架的架构</h4><p>Executor框架主要由3大部分组成。</p>
<ul>
<li>任务，包括被执行任务需要实现的接口Runnable或Callable接口。</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口，包括ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>
<p>Executor是一个接口，它是Executor框架的基础，它将任务的提交和任务的执行分离开来。<br>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。比Timer更灵活，功能更强大。<br>Future接口和实现Future接口的实现类FutureTask，代表异步计算的结果。<br>Runnable和Callable的实现类，都可以被ThreadPoolExecutor和ScheduledThreadPoolExecutor执行<br><img src="/2018/01/10/线程池和Executor/class.png" alt=""><br><img src="/2018/01/10/线程池和Executor/#x.png" alt=""><br>主线程首先要创建实现Runnable或者Callable接口的任务对象，工具类Executors可以把一个Runnable对象封装成Callable对象(Executors.callable(Runnble task)或Executors.callable(Runnable task,Object result))。<br>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runable command)),或者可以把Ruunable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit(Callable task))。<br>如果执行ExecutorService.submit(…)，ExecutorService将返回一个Future对象，（目前jdk返回的是FutureTask对象），由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService运行。<br>最后，主线程可以调用FutureTask.get()方法等待任务执行完成，主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)取消任务的运行。</p>
<h4 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h4><p>主要成员有：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建三种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</p>
<h6 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h6><p>创建固定线程数的FixedThreadPool。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h6><p>创建单个线程的SingleThreadExecutor的API<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h6><p>创建一个会根据需要创建新线程的CachedThreadPool<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>通常使用Executors创建，可以创建两种类型的ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor.包含若干线程的ScheduledThreadPoolExecutor<br>SingleThreadScheduledExecutor.包含一个线程的ScheduledThreadPoolExecutor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果，当我们把Callable接口或Runnable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会返回一个FutureTask对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</div><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</div><div class="line">Future&lt;&gt; submit(Runnable task)</div></pre></td></tr></table></figure></p>
<p>目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。在将来的JDK实现中，返回的可能不一定是FutureTask。</p>
<h5 id="Runnable和Callable接口"><a href="#Runnable和Callable接口" class="headerlink" title="Runnable和Callable接口"></a>Runnable和Callable接口</h5><p>Runnable和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。区别是Runnable不会返回结果，而Callable可以返回结果。除了可以创建实现Callable接口的对象外，还可以使用工厂类Executors把一个Runnable接口包装成Callable接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Callable&lt;Object&gt; callable(Runnable task) // 假设返回对象Callable1</div><div class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) // 假设返回对象Callable2</div></pre></td></tr></table></figure></p>
<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。例如，如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p>可重用固定线程数的线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<br>当线程池的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多于的线程将被终止。这里设置为0，意味着多余的线程会被立即终止。<br><img src="/2018/01/10/线程池和Executor/execute.png" alt=""><br>说明：<br>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。<br>2）在线程池预热后，将任务加入LinkedBlockingQueue<br>3）线程执行完1任务后，会在循环中反复从LinkedBlockingQueue获取任务执行<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE)，使用无界队列作为工作队列将会对线程池带来如下影响<br>1）当线程池中的线程数达到corePoolSize，新任务将在无界队列中等待，因此线程池的线程数不会超过corePoolSize，<br>2）由于1，使用无界队列时maximumPoolSize将是无效参数。<br>3）由于1和2，keepAlive将是无效参数<br>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown或shutdownNow）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</p>
<h3 id="SingleThreadExecutor-1"><a href="#SingleThreadExecutor-1" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newSingleThreadExecutor</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">));&#125;</div></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize都设为1，其他参数与fixedThreadPool一样。SingleThreadExecutor使用无界队列LinkedBlickedQueue。<br><img src="/2018/01/10/线程池和Executor/single.png" alt=""></p>
<h3 id="CachedThreadPool-1"><a href="#CachedThreadPool-1" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newCachedThreadPool</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()</div><div class="line">);&#125;</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界，这里把keepalive的时间设置为60L，意味着CachedThreadPool的空余线程等待新任务的最长时间为60s，空余线程超过60s会被终止。<br>CachedThreadPool采用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPoolSize是无界的，这意味者如果主线程提交的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新线程，极端情况下，CachedThreadPool会因为创建过多线程而耗尽cpu和内存资源。<br><img src="/2018/01/10/线程池和Executor/cached_execute.png" alt=""><br>1）首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有空余的时间正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行的offer操作与poll操作配对成功，主线程把任务交给空余的线程执行，execute方法执行完成；否则执行步骤2<br>2）当初始maximumPool为空时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），这种情况下步骤1）将会失败，将会创建一个新线程来执行任务。<br>3）在步骤2新建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空余线程最多在SynchronousQueue中等待60秒，如果60秒内主线程提交了一个任务，这个空余线程将执行主线程提交的任务，否则这个空余线程将会终止。<br>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。</p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承来自ThreadPoolExecutor，它主要用来给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor与Timer类似，但功能更强大且更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义。<br><img src="/2018/01/10/线程池和Executor/scheduled任务传递.png" alt=""><br>ScheduledThreadPoolExecutor的执行分为两个部分：<br>1）当调用scheduleAtFixRate方法或者scheduleWithFixedDelay时，会向DelayQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask<br>2）线程池中的线程从DelayQueue获取ScheduleFutureTask，然后执行任务。<br><img src="/2018/01/10/线程池和Executor/schedule.png" alt=""><br>ScheduleThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了修改：使用DelayQueue作为任务队列；获取任务的方式不同；执行周期任务后，增加了额外处理。</p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduleThreadPoolExecutor会把待调度的任务（ScheduledFutureTask）放到一个DelayQueue里。<br>ScheduledFutureTask有三个参数：<br>long型成员变量time，标识这个任务被执行的时间；<br>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor的序号；<br>long型成员变量period，表示任务执行的周期；<br>DelayQueue封装了一个PriorityQueue，它会对ScheduledFutureTask按照time的大小进行排序，如果time一样，就比较SequenceNumber。<br><img src="/2018/01/10/线程池和Executor/schedule任务执行.png" alt=""><br>1）线程1从DelayQueue中获取已到期的ScheduledFutureTask(delayQueue.take())，到期任务指的是time小于等于当前时间。<br>2）线程1执行这个ScheduledFutureTask<br>3）线程1修改time为下次将要被执行时间<br>4）修改time后将ScheduledFutureTask放回到DelayQueue中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lockInterruptibly(); //1</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            E first = q.peek();</div><div class="line">            <span class="keyword">if</span>(first == null) &#123;</div><div class="line">                available.await();//2.1</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                long delay =  first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                <span class="keyword">if</span>(delay &gt; 0) &#123;</div><div class="line">                    long tl = available.awaitNanos(delay);//2.2</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    E x = q.poll();  //2.3.1</div><div class="line">                    assert x != null;</div><div class="line">                    <span class="keyword">if</span>(q.size() != 0)</div><div class="line">                        available.signalAll(); //2.3.2 wake up other takers</div><div class="line">                    <span class="built_in">return</span> x;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/scheduled_condition.png" alt=""><br>1)获取Lock<br>2）获取周期任务；<br>如果PriorityQueue为空，当前线程到Condition等待，否则执行下面2.2<br>如果如果Priority的头元素的时间比当前时间大，到condition等待time时间，否则执行2.3<br>3）释放锁<br>ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。<br>最后，让我们看看ScheduledThreadPoolExecutor中的线程执行任务的步骤4，把ScheduledFutureTask放入DelayQueue中的过程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();//1</div><div class="line">    try &#123;</div><div class="line">        E first = q.peek();</div><div class="line">        q.offer(e);//2.1</div><div class="line">        <span class="keyword">if</span>(first == null || e.compareTo(first) &lt; 0)</div><div class="line">            available.signalAll();//2.2</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/schedule-delay.png" alt=""><br>1)获取锁<br>2）添加任务；向PriorityQueue添加任务，如果添加的是头元素，则唤醒其他线程<br>3）释放锁</p>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现类FutureTask，代表异步计算的结果</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口还实现了Runnable接口。FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行时机，FutureTask可以处于下面三种状态。<br>1）未启动。FutureTask.run还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，在没有执行run方法之前，处于未启动状态。<br>2）已启动。run方法被执行过程，处于已启动状态<br>3）已完成。执行完正常结束，或被取消(FutureTask.cancel())，或执行run方法过程中抛出异常而异常结束。<br><img src="/2018/01/10/线程池和Executor/FutureTask状态.png" alt=""><br>但FutureTask处于未启动或已启动状态时，执行FutureTask.get()会导致线程阻塞，当FutureTask处于已完成状态，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<br>当FutureTask处于未启动状态时，FutureTask.cancel()将导致任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成)；当FutureTask处于已完成状态时，执行FutureTask.cancel()方法将返回false。<br><img src="/2018/01/10/线程池和Executor/cancel.png" alt=""></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<br>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final  ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = new ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</div><div class="line">	private static String executionTask(final String taskName)</div><div class="line">			throws ExecutionException, InterruptedException &#123;</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">			Future&lt;String&gt; future = taskCache.get(taskName);// 1.1,2.1</div><div class="line">			<span class="keyword">if</span>(future == null) &#123;</div><div class="line">				Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;</div><div class="line">					public String call() throws InterruptedException &#123;</div><div class="line">						<span class="built_in">return</span> taskName;</div><div class="line">					&#125;</div><div class="line">				&#125;; // 1.2创建任务</div><div class="line">				FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(task);</div><div class="line">				future = taskCache.putIfAbsent(taskName, futureTask);// 1.3</div><div class="line">				<span class="keyword">if</span>(future == null) &#123;</div><div class="line">					future = futureTask;</div><div class="line">					futureTask.run();// 1.4执行任务</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				<span class="built_in">return</span> future.get();// 1.5,2.2线程在此等待任务执行完成</div><div class="line">			&#125; catch (CancellationException e) &#123;</div><div class="line">				taskCache.remove(taskName, future);</div><div class="line">			&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/future.png" alt=""><br>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread 2将在2.2等待，直到Thread 1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现是基于AQS，concurrent包中很多阻塞类(ReentrantLock)都是基于阻塞类实现的.AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程。基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、FutureTask<br>每一个基于AQS实现的同步器都会包含两种类型的操作，如下。<br>至少一个acquire操作。这个操作阻塞调用线程，除非直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get/get（long timeout，TimeUnit unit）方法调用。<br>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run方法和cancel（…）方法。<br>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。<br>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br><img src="/2018/01/10/线程池和Executor/FutureTask设计.png" alt=""><br>Sync是一个内部私有类，它继承自AQS，创建FutureTask时会创建Sync，FutureTask的所有共有方法都委托给Sync。<br>FutureTask.get()会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法执行过程如下<br>1）首先会回调在子类Sync的tryAcquireShared方法来判断是否可以成功，acquire成功的条件为：state为执行成功状态或已取消状态，且runner不为null。<br>2）如果成功则在get方法中立即返回，失败了就在等待队列中去等待其他线程执行release操作。<br>3）当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel()）唤醒当前线程。当前线程再次执行tryAcquireShared将返回正值1，当前线程将离开等待队列并且唤醒他的后继线程。<br>4）最后返回计算结果或返回抛出异常。<br>FutureTask.run()执行过程如下：<br>FutureTask.run()的执行过程如下。<br>1）执行在构造函数中指定的任务（Callable.call()）。<br>2）以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。<br>3）AQS.releaseShared（int arg）首先会回调在子类Sync中实的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。<br>4）调用FutureTask.done()。<br>当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程<br><img src="/2018/01/10/线程池和Executor/级联唤醒.png" alt=""><br>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从<br>队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java中的线程池&quot;&gt;&lt;a href=&quot;#java中的线程池&quot; class=&quot;headerlink&quot; title=&quot;java中的线程池&quot;&gt;&lt;/a&gt;java中的线程池&lt;/h1&gt;&lt;p&gt;线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程6~8</title>
    <link href="http://yoursite.com/2018/01/05/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-8/"/>
    <id>http://yoursite.com/2018/01/05/java并发编程6-8/</id>
    <published>2018-01-05T13:51:00.000Z</published>
    <updated>2018-01-11T09:28:02.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java并发容器和框架"><a href="#java并发容器和框架" class="headerlink" title="java并发容器和框架"></a>java并发容器和框架</h1><h2 id="ConcurrentHashMap实现原理与使用"><a href="#ConcurrentHashMap实现原理与使用" class="headerlink" title="ConcurrentHashMap实现原理与使用"></a>ConcurrentHashMap实现原理与使用</h2><h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p>
<h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">concurrencyLevel = MAX_SEGMENTS;</div><div class="line">int sshift = 0;</div><div class="line">int ssize = 1;</div><div class="line"><span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123;</div><div class="line">++sshift;</div><div class="line">ssize = ssize&lt;&lt;1;</div><div class="line">&#125;</div><div class="line">segmentShift = 32 - sshift;</div><div class="line">segmentMask = ssize - 1;</div><div class="line">this.segments = Segment.newArray(ssize);</div></pre></td></tr></table></figure>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16</p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。SegmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个Segment"><a href="#初始化每个Segment" class="headerlink" title="初始化每个Segment"></a>初始化每个Segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadFactor是每个Segment的负载因子。在构造方法里需要通过这两个参数来初始化数组中的每个Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">int c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">++c;</div><div class="line">int <span class="built_in">cap</span> = 1;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cap</span> &lt; c)</div><div class="line"><span class="built_in">cap</span> &lt;&lt;= 1;</div><div class="line"><span class="keyword">for</span> (int i = 0; i &lt; this.segments.length; ++i)</div><div class="line">this.segments[i] = new Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</div></pre></td></tr></table></figure></p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取数据的时候，必须先通过散列算法定位到Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static int <span class="built_in">hash</span>(int h) &#123;</div><div class="line">h += (h &lt;&lt; 15) ^ 0xffffcd7d;</div><div class="line">h ^= (h &gt;&gt;&gt; 10);</div><div class="line">h += (h &lt;&lt; 3);</div><div class="line">h ^= (h &gt;&gt;&gt; 6);</div><div class="line">h += (h &lt;&lt; 2) + (h &lt;&lt; 14);</div><div class="line"><span class="built_in">return</span> h ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以进行再散列，目的是减少哈希冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存储效率。通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Segment&lt;K,V&gt; segmentFor(int <span class="built_in">hash</span>) &#123;</div><div class="line"><span class="built_in">return</span> segments[(<span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int <span class="built_in">hash</span> = <span class="built_in">hash</span>(key.hashCode());</div><div class="line"><span class="built_in">return</span> segmentFor(<span class="built_in">hash</span>).get(key, <span class="built_in">hash</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get的高效就在于整个get过程中不用加锁，除非读到的值是空的才会加锁重读，ConcurrentHashMap在它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值。但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">transient volatile int count;</div><div class="line">volatile V value;</div></pre></td></tr></table></figure></p>
<p>定位HashEntry和定位Segment的算法虽然一样，都与数组长度减1，定位Segment使用的是元素Hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是hashcode的值，其目的是避免两次散列的值一样。虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的<span class="built_in">hash</span>算法</div><div class="line">int index = <span class="built_in">hash</span> &amp; (tab.length - 1);　　// 定位HashEntry所使用的<span class="built_in">hash</span>算法</div></pre></td></tr></table></figure></p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法需要对共享变量进行写操作，为了线程安全，操作共享变量时必须加锁。put首先定位到Segment，然后在Segment里进行插入操作，插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二部定位添加元素的位置，然后将其放入HashEntry数组中。<br>（1）是否扩容<br>在插入元素前会先判断Segment的HashEntry数组是否超过容量（threadhold），如果超过阈值，则对数组进行扩容。Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量的，如果到达就进行扩容，但是很可能扩容之后没有新元素插入，这时HashMap进行了一次无效的扩容。<br>（2）如何扩容<br>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组中，为了高效，ConcurrentHashMap不会对整个容器扩容，而只对某个Segment进行扩容。</p>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>在并发过程中有时候需要线程安全的队列，如果要实现一个线程安全队列有两种方式：一种是阻塞算法，另一种是非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队使用同一把锁）或者两个锁等方式实现。非阻塞算法可以使用循环CAS方式来实现。<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到尾部，当我们获取一个元素时，它会返回队列头部的元素，。它采用CAS算法实现。<br><img src="/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png" alt=""><br>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient volatile Node&lt;E&gt; tail = head;</div></pre></td></tr></table></figure></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><ol>
<li>入队列的过程</li>
</ol>
<p>入队列就是将入队节点添加到队列尾部。<br><img src="/2018/01/05/java并发编程6-8/添加元素.png" alt=""><br>入队主要做两件事：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null) throw new NullPointerException();</div><div class="line">// 入队前，创建一个入队节点</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line">retry:</div><div class="line">// 死循环，入队不成功反复入队。</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">// 创建一个指向tail节点的引用</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line">// p用来表示队列的尾节点，默认情况下等于tail节点。</div><div class="line">Node&lt;E&gt; p = t;</div><div class="line"><span class="keyword">for</span> (int hops = 0; ; hops++) &#123;</div><div class="line">// 获得p节点的下一个节点。</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</div><div class="line"><span class="keyword">if</span> (next != null) &#123;</div><div class="line">// 循环了两次及其以上，并且当前节点还是不等于尾节点</div><div class="line"><span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</div><div class="line"><span class="built_in">continue</span> retry;</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line">// 如果p是尾节点，则设置p节点的next节点为入队节点。</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(null, n)) &#123;</div><div class="line">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</div><div class="line">更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</div><div class="line">casTail(t, n); // 更新tail节点，允许失败</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">p = succ(p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<ol>
<li>定位尾节点</li>
</ol>
<p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123;</div><div class="line">Node&lt;E&gt; next = p.getNext();</div><div class="line"><span class="built_in">return</span> (p == next) head : next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>设置入队节点为尾节点</li>
</ol>
<p>p.casNext(null,n)方法用于将入队节点设置为当前队列尾节点的next节点，如果当前尾节点的next节点是null时，则代表当前节点为尾节点，如果不为null时，则需要重新获取当前队列的尾节点</p>
<ol>
<li>Hops的设计意图</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null)</div><div class="line">throw new NullPointerException();</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line"><span class="keyword">if</span> (t.casNext(null, n) &amp;&amp; casTail(t, n)) &#123;</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让tail节点永远作为尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列是从队列返回一个节点元素，并清空该节点对该元素的引用。并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。<br><img src="/2018/01/05/java并发编程6-8/出队.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public E <span class="function"><span class="title">poll</span></span>() &#123;</div><div class="line">Node&lt;E&gt; h = head;</div><div class="line">// p表示头节点，需要出队的节点</div><div class="line">Node&lt;E&gt; p = h;</div><div class="line"><span class="keyword">for</span> (int hops = 0;; hops++) &#123;</div><div class="line">// 获取p节点的元素</div><div class="line">E item = p.getItem();</div><div class="line">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</div><div class="line">// 如果成功则返回p节点的元素。</div><div class="line"><span class="keyword">if</span> (item != null &amp;&amp; p.casItem(item, null)) &#123;</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS) &#123;</div><div class="line">// 将p节点下一个节点设置成head节点</div><div class="line">Node&lt;E&gt; q = p.getNext();</div><div class="line">updateHead(h, (q != null) q : p);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> item;</div><div class="line">&#125;</div><div class="line">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</div><div class="line">// 一个线程修改了。那么获取p节点的下一个节点</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// 如果p的下一个节点也为空，说明这个队列已经空了</div><div class="line"><span class="keyword">if</span> (next == null) &#123;</div><div class="line">// 更新头节点。</div><div class="line">updateHead(h, p);</div><div class="line"><span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先获取头节点元素，然后判断头结点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点元素取走，如果不为空，则使用CAS方式将头结点引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列是支持两个附加操作的队列。附加操作指的是支持阻塞的插入和移除。<br>1）支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者消费者场景。生产者是向队列里添加的线程，消费者是从队列里取元素的线程。阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常:当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
<h3 id="java的阻塞队列"><a href="#java的阻塞队列" class="headerlink" title="java的阻塞队列"></a>java的阻塞队列</h3><p>jdk7提供了7个阻塞队列<br>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列<br>DelayBlockingQueue：一个使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：一个不存储元素的阻塞队列<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是用一个数组实现有界的阻塞队列，此队列按照先进先出原则对元素进行排序。默认情况下不保证线程公平访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue fairQueue=new ArrayBlockingQueue(100,<span class="literal">true</span>);</div><div class="line">//公平性是使用可重入锁</div><div class="line">public ArrayBlockingQueue(int capacity,boolean fair)&#123;</div><div class="line">  <span class="keyword">if</span>(capacity&lt;0)&#123;</div><div class="line">    throw  new IllegalArgumentException();</div><div class="line">  &#125;</div><div class="line">  this.items=new Object[capacity];</div><div class="line">  lock=new ReentrantLock(fair);</div><div class="line">  notEmpty=lock.newCondition();</div><div class="line">  notFull=lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，此队列默认最大长度为Integer.MAX_VALUE，此队列按照先进先出的原则。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue来实现。队列中的元素必须实现Delay接口，在创建元素时，可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列提取元素。<br>DelayQueue使用场景：1.缓存系统的设计；可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素，说明缓存有效期到了；2.定时任务调度，使用DelayQueue保存当天会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的<br>如何实现DelayQueue,参考ScheduledThreadPoolExecutor里ScheduledFutureTask：<br>1）在对象创建时候，初始化基本数据，使用time记录当前记录延迟到什么时候可以使用，使用SequenceNumber来标识元素在队列中的先后顺序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static final AtomicLong sequencer = new AtomicLong(0);</div><div class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</div><div class="line">super(r, result);</div><div class="line">this.time = ns;</div><div class="line">this.period = period;</div><div class="line">this.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）实现delay方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public long getDelay(TimeUnit unit) &#123;</div><div class="line">    <span class="built_in">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>3)实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int compareTo(Delayed other) &#123;</div><div class="line">     <span class="keyword">if</span> (other == this) // compare zero ONLY <span class="keyword">if</span> same object</div><div class="line">         <span class="built_in">return</span> 0;</div><div class="line">     <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</div><div class="line">         ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</div><div class="line">         long diff = time - x.time;</div><div class="line">         <span class="keyword">if</span> (diff &lt; 0)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; 0)</div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">     &#125;</div><div class="line">     long d = (getDelay(TimeUnit.NANOSECONDS) -</div><div class="line">               other.getDelay(TimeUnit.NANOSECONDS));</div><div class="line">     <span class="built_in">return</span> (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如何实现延时阻塞队列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                   <span class="keyword">if</span> (delay &lt;= 0)</div><div class="line">                       <span class="built_in">return</span> q.poll();</div><div class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != null)</div><div class="line">                       available.await();</div><div class="line">                   <span class="keyword">else</span> &#123;</div><div class="line">                       Thread thisThread = Thread.currentThread();</div><div class="line">                       leader = thisThread;</div><div class="line">                       try &#123;</div><div class="line">                           available.awaitNanos(delay);</div><div class="line">                       &#125; finally &#123;</div><div class="line">                           <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                               leader = null;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div></pre></td></tr></table></figure></p>
<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能添加。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。<br>SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
<h4 id="LinkedTransformQueue"><a href="#LinkedTransformQueue" class="headerlink" title="LinkedTransformQueue"></a>LinkedTransformQueue</h4><p>LinkedTransformQueue是一个由链表结构组成的无界阻塞TransformQueue队列。，相比较其他阻塞队列，增加了tryTransform和transform方法如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node pred = tryAppend(s, haveData);</div><div class="line"><span class="built_in">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</div></pre></td></tr></table></figure></p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用通知模式实现，所谓的通知模式，就是生产者往满的队列添加元素时会阻塞住生产者，当消费者消费一个队列后，会通知生产者当前队列可用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private final Condition notFull;</div><div class="line">private final Condition notEmpty;</div><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">// 省略其他代码</div><div class="line">notEmpty = lock.newCondition();</div><div class="line">notFull = lock.newCondition();</div><div class="line">&#125;</div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">checkNotNull(e);</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == items.length)</div><div class="line">notFull.await();</div><div class="line">insert(e);</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == 0)</div><div class="line">notEmpty.await();</div><div class="line"><span class="built_in">return</span> extract();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">private void insert(E x) &#123;</div><div class="line">items[putIndex] = x;</div><div class="line">putIndex = inc(putIndex);</div><div class="line">++count;</div><div class="line">notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当队列插入一个元素，如果队列不可用，那么阻塞生产者主要通过Locksupport.park实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(this);</div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="built_in">set</span>Blocker(t, blocker);</div><div class="line">    unsafe.park(<span class="literal">false</span>, 0L);</div><div class="line">    <span class="built_in">set</span>Blocker(t, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.park是个native方法</p>
<h2 id="fork-join任务"><a href="#fork-join任务" class="headerlink" title="fork/join任务"></a>fork/join任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class CountNumber extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private static final int THRESHOLD = 2;</div><div class="line">	private int start;</div><div class="line">	private int end;</div><div class="line"></div><div class="line">	public CountNumber(int start, int end) &#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer <span class="function"><span class="title">compute</span></span>() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		// 如果任务足够小就计算任务</div><div class="line">		boolean canCompute = (end - start) &lt;= THRESHOLD;</div><div class="line">		<span class="keyword">if</span> (canCompute) &#123;</div><div class="line">			<span class="keyword">for</span> (int i = start; i &lt;= end; i++) &#123;</div><div class="line">				sum += i;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 如果任务大于阈值，就分裂成两个子任务计算</div><div class="line">			int middle = (start + end) / 2;</div><div class="line">			CountNumber leftTask = new CountNumber(start, middle);</div><div class="line">			CountNumber rightTask = new CountNumber(middle + 1, end);</div><div class="line">			// 执行子任务</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			// 等待子任务执行完，并得到其结果</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			// 合并子任务</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> sum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		// 生成一个计算任务，负责计算1+2+3+4</div><div class="line">		CountNumber task = new CountNumber(1, 4);</div><div class="line">		// 执行一个任务</div><div class="line">		Future&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ForkJoinTask与一般任务的区别是它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常<br>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>1）当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。<br>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final ForkJoinTask&lt;V&gt; <span class="function"><span class="title">fork</span></span>() &#123;</div><div class="line">((ForkJoinWorkerThread) Thread.currentThread())</div><div class="line">.pushTask(this);</div><div class="line"><span class="built_in">return</span> this;</div><div class="line">&#125;</div><div class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;</div><div class="line">ForkJoinTask&lt;&gt;[] q; int s, m;</div><div class="line"><span class="keyword">if</span> ((q = queue) != null) &#123;　　　　// ignore <span class="keyword">if</span> queue removed</div><div class="line">long u = (((s = queueTop) &amp; (m = q.length - 1)) &lt;&lt; ASHIFT) + ABASE;</div><div class="line">UNSAFE.putOrderedObject(q, u, t);</div><div class="line">queueTop = s + 1;　　　　　　// or use putOrderedInt</div><div class="line"><span class="keyword">if</span> ((s -= queueBase) &lt;= 2)</div><div class="line">pool.signalWork();</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == m)</div><div class="line">growQueue();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)ForkJoinTask的join实现原理<br>join方法主要是阻塞当前线程并等待获取结果,它调用了doJoin()方法，通过doJoin()方法到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public final V <span class="function"><span class="title">join</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">do</span>Join() != NORMAL)</div><div class="line"><span class="built_in">return</span> reportResult();</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private V <span class="function"><span class="title">reportResult</span></span>() &#123;</div><div class="line">int s; Throwable ex;</div><div class="line"><span class="keyword">if</span> ((s = status) == CANCELLED)</div><div class="line">throw new CancellationException();</div><div class="line"><span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)</div><div class="line">UNSAFE.throwException(ex);</div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private int <span class="function"><span class="title">doJoin</span></span>() &#123;</div><div class="line">Thread t; ForkJoinWorkerThread w; int s; boolean completed;</div><div class="line"><span class="keyword">if</span> ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &#123;</div><div class="line"><span class="keyword">if</span> ((s = status) &lt; 0)</div><div class="line"><span class="built_in">return</span> s;</div><div class="line"><span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(this)) &#123;</div><div class="line">try &#123;</div><div class="line">completed = <span class="built_in">exec</span>();</div><div class="line">&#125; catch (Throwable rex) &#123;</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>ExceptionalCompletion(rex);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (completed)</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>Completion(NORMAL);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> w.joinTask(this);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> externalA<span class="built_in">wait</span>Done();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h1 id="java中的13个原子操作类"><a href="#java中的13个原子操作类" class="headerlink" title="java中的13个原子操作类"></a>java中的13个原子操作类</h1><p>java.util.concurrent.atomic提供了一种用法简单、性能高效、线程安全地更新一个变量的方式，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>AtomicBoolean:原子更新布尔类型<br>AtomicInteger：原子更新整数类型<br>AtomicLong：原子更新长整型<br>这三个类提供的方法几乎一模一样，以AtomicInteger为例<br>int addAndGet(int delta)：以原子方式将输入的数值与实例的值相加，并返回结果。<br>boolean compareAndSet(int expect,intupdate):如果输入的值等于预期，则以原子的方式将该值设为输入的值。<br>int getAndIncrement():以原子的方式将当前值加1，这里返回的值是自增前的值。<br>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。<br>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final int <span class="function"><span class="title">getAndIncrement</span></span>() &#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line"><span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line"><span class="built_in">return</span> current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。<br>Atomic包提供了3种基本类型的原子更新，但是java基本类型还有char、float、double，Atomic包是使用unsafe实现的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapObject(Object o,</div><div class="line">long offset,</div><div class="line">Object expected,</div><div class="line">Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">int expected,</div><div class="line">int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,</div><div class="line">long expected,</div><div class="line">long x);</div></pre></td></tr></table></figure></p>
<p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。</p>
<h2 id="原子数组更新"><a href="#原子数组更新" class="headerlink" title="原子数组更新"></a>原子数组更新</h2><p>AtomicIntegerArray：原子更新整型数组里的元素<br>AtomicLongArray：原子更新长整型数组里的元素<br>AtomicReferenceArray：原子更新引用数组里的元素<br>·int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。<br>·boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerArratTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		int[] value=new int[]&#123;1,2,3&#125;;</div><div class="line">		AtomicIntegerArray atomicIntegerArray=new AtomicIntegerArray(value);</div><div class="line">		atomicIntegerArray.set(0, 3);</div><div class="line">		System.out.println(atomicIntegerArray.get(0));</div><div class="line">		System.out.println(value[0]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//3</div><div class="line">//1</div></pre></td></tr></table></figure></p>
<p>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，需要使用这个原子更新引用类型提供的类，Atomic包括以下几个类：<br>AtomicReference：原子更新引用类型<br>AtomicReferenceFieldUpdater：原子更新引用类型的字段<br>AtomicMarkableReference：原子更新带有标记位的引用类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AtomicRefernceTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicReference&lt;User&gt; atomicReference=new AtomicReference&lt;&gt;();</div><div class="line">		User user=new User(<span class="string">"student"</span>, 15);</div><div class="line">		atomicReference.set(user);</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">		atomicReference.compareAndSet(user, new User(<span class="string">"teacher"</span>, 30));</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		private int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>AtomicIntegerFieldUpdater：原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicStampedReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可用于原子更新数据和数据的版本号，可以解决使用CAS进行原子更新时出现的ABA问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerFieldUpdaterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</div><div class="line">        User user=new User(<span class="string">"lr"</span>, 10);</div><div class="line">        atomicIntegerFieldUpdater.getAndIncrement(user);</div><div class="line">        System.out.println(atomicIntegerFieldUpdater.get(user));</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		public volatile int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="java中并发工具类"><a href="#java中并发工具类" class="headerlink" title="java中并发工具类"></a>java中并发工具类</h1><h2 id="等待多线程完成countDownLatch"><a href="#等待多线程完成countDownLatch" class="headerlink" title="等待多线程完成countDownLatch"></a>等待多线程完成countDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。要实现主线程等待所有线程完成任务，最简单的做法是使用join<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class JoinCountDownLatchTest &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * @throws S</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread task1=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        Thread task2=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        task1.start();</div><div class="line">        task2.start();</div><div class="line">        task1.join();</div><div class="line">        task2.join();</div><div class="line">        System.out.println(<span class="string">"total task finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>join用于执行线程等待join执行结束，原理是不同地检查线程是否存活，如果join线程存活则让当前线程永远等待，其中wait（0）是永远等待<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(isAlive())&#123;</div><div class="line">  <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>知道join线程终止后，线程的this.notifyAll()方法会被调用，调用notifyAll方法是在JVM实现的，在JDK看不到<br>并发包CountDownLatch可以实现join功能，并且比join功能更多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		final CountDownLatch countDownLatch = new CountDownLatch(2);</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		countDownLatch.await();</div><div class="line">		System.out.println(<span class="string">"all finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch构造函数接收一个int类型的参数作为计数器，如果你想等N个点完成，就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变为0。我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier字面意思是可循环使用的屏障，它要做的事情是让一组线程到达屏障时被阻塞，直到最后一个线程到达屏障时，屏障才开门，所有被屏障拦截的线程才会继续运行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障要拦截的线程数，每个线程调用await方法告诉CyclicBarrier我已经到达屏障，然后当前线程阻塞<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException, BrokenBarrierException&#123;</div><div class="line">	final CyclicBarrier cyclicBarrier=new CyclicBarrier(2);</div><div class="line">	new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			try &#123;</div><div class="line">				cyclicBarrier.await();</div><div class="line">			&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"1"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">	cyclicBarrier.await();</div><div class="line">	System.out.println(<span class="string">"2"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CyclicBarrier还提供了一个更高级的构造函数，CyclicBarrier(int parties,Runnable action)，用于在线程到达屏障时，优先执行action，方便处理更复杂的业务场景。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2, new A());</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class A implements Runnable &#123;</div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			System.out.println(3);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier应用场景"><a href="#CyclicBarrier应用场景" class="headerlink" title="CyclicBarrier应用场景"></a>CyclicBarrier应用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BankWaterService implements Runnable&#123;</div><div class="line">	/**</div><div class="line">	* 创建4个屏障，处理完之后执行当前类的run方法</div><div class="line">	*/</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	/**</div><div class="line">	* 假设只有4个sheet，所以只启动4个线程</div><div class="line">	*/</div><div class="line">	private ExecutorService executor = Executors.newFixedThreadPool(4);</div><div class="line">	/**</div><div class="line">	* 保存每个sheet计算出的银流结果</div><div class="line">	*/</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt;sheetBankWaterCount = new</div><div class="line">	ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	public void <span class="function"><span class="title">count</span></span>()&#123;</div><div class="line">		<span class="keyword">for</span>(int i=0;i&lt;4;i++)&#123;</div><div class="line">		executor.submit(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		&#125;</div><div class="line">		executor.shutdown();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		int result = 0;</div><div class="line">		<span class="keyword">for</span>(Entry&lt;String,Integer&gt; entry:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result=result+entry.getValue();</div><div class="line">		&#125;</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		new BankWaterService().count();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody>
</table>
<p>CyclicBarrier计数器可以使用reset方法重置，而CountDownLatch的计数器只能使用一次，所以CyclicBarrier可以用在更复杂的业务场景。例如计算错误了，可以重置计数器，让线程重算。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting可以获得阻塞的线程数量，isbroken可以用来了解阻塞的线程是否中断。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">importjava.util.concurrent.BrokenBarrierException;</div><div class="line">importjava.util.concurrent.CyclicBarrier;</div><div class="line">public class CyclicBarrierTest3 &#123;</div><div class="line">staticCyclicBarrier c = new CyclicBarrier(2);</div><div class="line">public static void main(String[] args) throws InterruptedException，</div><div class="line">BrokenBarrierException &#123;</div><div class="line">Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">thread.interrupt();</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">System.out.println(c.isBroken());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class SemophoreTest &#123;</div><div class="line"></div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	private static ExecutorService threadPool = Executors</div><div class="line">			.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</div><div class="line">			final int num=i;</div><div class="line">			threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">				@Override</div><div class="line">				public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						System.out.println(<span class="string">"save data"</span>+num);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Semaphore还提供一些其他方法，具体如下。<br>·int availablePermits()：返回此信号量中当前可用的许可证数。<br>·int getQueueLength()：返回正在等待获取许可证的线程数。<br>·boolean hasQueuedThreads()：是否有线程正在等待获取许可证。<br>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。<br>·Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</p>
<h2 id="线程之间的交换"><a href="#线程之间的交换" class="headerlink" title="线程之间的交换"></a>线程之间的交换</h2><p>Exchanger是一个线程间协作工具类，Exchanger可用来线程间的数据交换。它提供一个同步点，在这个同步点，线程间可以交换彼此的数据，两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程执行exchange方法，当两个线程都到达同步点，这两个线程就可以交换数据，将本线程生产的数据传递给对方。<br>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = <span class="string">"银行流水A"</span>;// A录入银行流水数据</div><div class="line">					exgr.exchange(A);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = <span class="string">"银行流水B"</span>;// B录入银行流水数据</div><div class="line">					String A = exgr.exchange(<span class="string">"B"</span>);</div><div class="line">					System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></div><div class="line">							+ A + <span class="string">"，B录入是："</span> + B);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java并发容器和框架&quot;&gt;&lt;a href=&quot;#java并发容器和框架&quot; class=&quot;headerlink&quot; title=&quot;java并发容器和框架&quot;&gt;&lt;/a&gt;java并发容器和框架&lt;/h1&gt;&lt;h2 id=&quot;ConcurrentHashMap实现原理与使用&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能管理及架构设计</title>
    <link href="http://yoursite.com/2018/01/01/MySQL%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%8F%8A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/01/01/MySQL性能管理及架构设计/</id>
    <published>2018-01-01T14:21:08.000Z</published>
    <updated>2018-01-01T14:53:02.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么影响了mysql的性能"><a href="#什么影响了mysql的性能" class="headerlink" title="什么影响了mysql的性能"></a>什么影响了mysql的性能</h1><h2 id="影响性能的几个方面"><a href="#影响性能的几个方面" class="headerlink" title="影响性能的几个方面"></a>影响性能的几个方面</h2><ol>
<li>服务器的硬件</li>
<li>操作系统或参数配置</li>
<li>数据库的存储引擎选择<br>MyIsam：不支持事务，表级锁；Innodb：事务存储引擎，完美支持行级锁，支持事务ACID特性</li>
<li>数据库参数配置</li>
<li>数据库结构设计和sql语句</li>
</ol>
<h2 id="CPU资源和内存大小"><a href="#CPU资源和内存大小" class="headerlink" title="CPU资源和内存大小"></a>CPU资源和内存大小</h2><p>CPU资源和内存大小<br>网络，memcache失效时会产生大量网络传输</p>
<h3 id="考虑cpu"><a href="#考虑cpu" class="headerlink" title="考虑cpu"></a>考虑cpu</h3><p>cpu密集型选择更好的Cpu，mysql暂不支持多cpu对同一sql并发处理</p>
<h3 id="系统的并发量"><a href="#系统的并发量" class="headerlink" title="系统的并发量"></a>系统的并发量</h3><p>QPS：同时处理sql的数量</p>
<h3 id="Mysql的版本"><a href="#Mysql的版本" class="headerlink" title="Mysql的版本"></a>Mysql的版本</h3><p>最新的版本对多核支持，尤其是5.5以后的版本</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存比SSD和Fusion-IO比也要快很多<br>myisam将索引缓存到内存，数据放在通过操作系统缓存<br>innodb同时缓存数据和索引到内存<br>选择内存的主频，频率越高速度越快</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么影响了mysql的性能&quot;&gt;&lt;a href=&quot;#什么影响了mysql的性能&quot; class=&quot;headerlink&quot; title=&quot;什么影响了mysql的性能&quot;&gt;&lt;/a&gt;什么影响了mysql的性能&lt;/h1&gt;&lt;h2 id=&quot;影响性能的几个方面&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程4~5</title>
    <link href="http://yoursite.com/2017/12/31/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-6/"/>
    <id>http://yoursite.com/2017/12/31/java并发编程4-6/</id>
    <published>2017-12-31T07:25:57.000Z</published>
    <updated>2018-01-05T13:34:18.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java并发编程基础"><a href="#java并发编程基础" class="headerlink" title="java并发编程基础"></a>java并发编程基础</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程时间片用完了就会发生线程调度，等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。<br>Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。<br>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>java线程在运行的生命周期可能处于6中不同的状态，在给定的一个时刻线程只能处于其中一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用start方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，java线程将操作系统中的就绪和运行两种状态笼统地称作运行中</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITTING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（如通知或者中断）</td>
</tr>
<tr>
<td>TIME_WAITTING</td>
<td>超时等待状态，该状态不同于WAITTING，它是可以在指定的时间返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jps <span class="_">-l</span></div><div class="line">jstack pid//查看线程情况</div></pre></td></tr></table></figure>
<p><img src="/2017/12/31/java并发编程4-6/java线程状态变迁.png" alt=""><br>注意　Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个java虚拟机不存在非Daemon线程时，java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个标记位，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了招呼，其他线程调用了该线程的interrupt方法对其进行了中断。<br>线程通过检查自身是否被中断进行响应，通过调用isInterrupted来判断是否被中断，也可以调用静态方法Thread.interrupted对当前线程进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。<br>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<h3 id="过期的suspend、resume、stop"><a href="#过期的suspend、resume、stop" class="headerlink" title="过期的suspend、resume、stop"></a>过期的suspend、resume、stop</h3><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。<br>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="volatile和synchronize关键字"><a href="#volatile和synchronize关键字" class="headerlink" title="volatile和synchronize关键字"></a>volatile和synchronize关键字</h3><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。<br>简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(value != desire) &#123;</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125;</div><div class="line"><span class="keyword">do</span>Something();</div></pre></td></tr></table></figure></p>
<p>1）难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时<br>发现条件已经变化，也就是及时性难以保证。<br>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现<br>条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。<br>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br><img src="/2017/12/31/java并发编程4-6/通知机制.png" alt=""><br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>wait、notify和notifyAll注意细节：</p>
<ul>
<li>使用wait、notify、notifyAll时需要先对对象加锁</li>
<li>调用wait后，线程状态由RUNNING变为WAITING，并将当前线程放到等待队列中</li>
<li>notify和notifyAll调用后，等待线程不会从wait返回，需要等待notify和notifyAll释放锁后，等待线程才有机会从wait中返回。</li>
<li>notify方法将等待队列中的一个线程从等待队列中移出到同步队列，notifyAll是将等待队列中的所有线程移到同步队列中，被移动的线程从waiting变为blocked。</li>
<li>从wait方法中返回前提是获得调用对象锁</li>
</ul>
<p><img src="/2017/12/31/java并发编程4-6/wait_notify.png" alt=""></p>
<h3 id="等待通知的经典范式"><a href="#等待通知的经典范式" class="headerlink" title="等待通知的经典范式"></a>等待通知的经典范式</h3><p>该范式分为两个部分：分别针对等待方和通知方</p>
<h4 id="等待方"><a href="#等待方" class="headerlink" title="等待方"></a>等待方</h4><p>等待方遵守如下规则：</p>
<ol>
<li>获取对象的锁</li>
<li>如果不满足条件，那么调用对象的wait方法，被通知后仍然检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  <span class="keyword">while</span>(条件不满足)&#123;</div><div class="line">    对象.wait();</div><div class="line">  &#125;</div><div class="line">  对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通知方"><a href="#通知方" class="headerlink" title="通知方"></a>通知方</h4><ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  改变条件</div><div class="line">  对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。<br>管道输入输出流包括了如下四种具体实现：PipedOutputStream、PipedInputStream、PipedReader、PipedWriter，前两种面向字节，后两种面向字符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Piped &#123;</div><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">PipedWriter out = new PipedWriter();</div><div class="line">PipedReader <span class="keyword">in</span> = new PipedReader();</div><div class="line">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</div><div class="line">out.connect(<span class="keyword">in</span>);</div><div class="line">Thread <span class="built_in">print</span>Thread = new Thread(new Print(<span class="keyword">in</span>), <span class="string">"PrintThread"</span>);</div><div class="line"><span class="built_in">print</span>Thread.start();</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = System.in.read()) != -1) &#123;</div><div class="line">out.write(receive);</div><div class="line">&#125;</div><div class="line">&#125; finally &#123;</div><div class="line">out.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">static class Print implements Runnable &#123;</div><div class="line">private PipedReader <span class="keyword">in</span>;</div><div class="line">public Print(PipedReader <span class="keyword">in</span>) &#123;</div><div class="line">this.in =<span class="keyword">in</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = in.read()) != -1) &#123;</div><div class="line">System.out.print((char) receive);</div><div class="line">&#125;</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><p>如果一个线程执行了thread.join语句，其含义是当前线程A等待thread线程终止后才从thread.join返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 加锁当前线程对象</div><div class="line">public final synchronized void join() throws InterruptedException &#123;</div><div class="line">// 条件不满足，继续等待</div><div class="line"><span class="keyword">while</span>(isAlive()) &#123;</div><div class="line"> <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div><div class="line">// 条件符合，方法返回</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal是线程变量，是一个以ThreadLocal为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程的值。<br>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p>开发人员经常遇到：调用一个方法等待一段时间后，如果该方法能够在给定时间段内得到结果，那么将结果返回，反之超时返回默认结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 对当前对象加锁</div><div class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line">// 当超时大于0并且result返回值不满足要求</div><div class="line"><span class="keyword">while</span>((result == null) &amp;&amp; remaining &gt; 0) &#123;</div><div class="line"><span class="built_in">wait</span>(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ConnectionPool &#123;</div><div class="line">private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</div><div class="line">public ConnectionPool(int initialSize) &#123;</div><div class="line"><span class="keyword">if</span>(initialSize &gt; 0) &#123;</div><div class="line"><span class="keyword">for</span>(int i = 0; i &lt; initialSize; i++) &#123;</div><div class="line">pool.addLast(ConnectionDriver.createConnection());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void releaseConnection(Connection connection) &#123;</div><div class="line"><span class="keyword">if</span>(connection != null) &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</div><div class="line">pool.addLast(connection);</div><div class="line">pool.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 在mills内无法获取到连接，将会返回null</div><div class="line">public Connection fetchConnection(long mills) throws InterruptedException &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 完全超时</div><div class="line"><span class="keyword">if</span>(mills &lt;= 0) &#123;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty()) &#123;</div><div class="line">pool.wait();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> pool.removeFirst();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</div><div class="line">pool.wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">Connection result = null;</div><div class="line"><span class="keyword">if</span>(!pool.isEmpty()) &#123;</div><div class="line">result = pool.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h1><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock=new ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。<br><img src="/2017/12/31/java并发编程4-6/lock特性.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/lock-api.png" alt=""></p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer是用来构建锁或者其他组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程排队工作。<br>同步器的主要使用方式是继承，子类通过继承父类同步器并实现他的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这就需要对同步器提供的三个方法（getState、setState、compareAndSetState）来进行操作，因为它能保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。<br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方<br>法，而这些模板方法将会调用使用者重写的方法。<br>·getState()：获取当前同步状态。<br>·setState(int newState)：设置当前同步状态。<br>·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。<br><img src="/2017/12/31/java并发编程4-6/同步器重写.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/模板方法.png" alt=""><br>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><p>同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，同步器将当前线程以及等待状态等信息构造称为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。<br><img src="/2017/12/31/java并发编程4-6/节点属性.png" alt=""><br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部<br><img src="/2017/12/31/java并发编程4-6/同步队列结构.png" alt=""><br>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="/2017/12/31/java并发编程4-6/cas设置尾节点.png" alt=""><br>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点<br><img src="/2017/12/31/java并发编程4-6/首节点设置.png" alt=""><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line"><span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">    selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">  Node node = new Node(Thread.currentThread(), mode);</div><div class="line">  // 快速尝试在尾部添加</div><div class="line">  Node pred = tail;</div><div class="line">  <span class="keyword">if</span>(pred != null) &#123;</div><div class="line">    node.prev = pred;</div><div class="line">    <span class="keyword">if</span>(compareAndSetTail(pred, node)) &#123;</div><div class="line">      pred.next = node;</div><div class="line">      <span class="built_in">return</span> node;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  enq(node);</div><div class="line">  <span class="built_in">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">  <span class="keyword">for</span>(;;)&#123;</div><div class="line">    Node t = tail;</div><div class="line">    <span class="keyword">if</span>(t==null)&#123;</div><div class="line">      Node temp=new Node();</div><div class="line">      <span class="keyword">if</span>(compareAndSetHead(temp))</div><div class="line">        tail = head;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      node.prev = t;</div><div class="line">      <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</div><div class="line">        t.next = node;</div><div class="line">        <span class="built_in">return</span> t;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码通过使用compareAndSetTail(Node expect,Node update)方法来确保节点能够被线程安全添加。试想一下：如果使用一个普通的LinkedList来维护节点之间的关系，那么当一个线程获取了同步状态，而其他多个线程由于调用tryAcquire(int arg)方法获取同步状态失败而并发地被添加到LinkedList时，LinkedList将难以保证Node的正确添加，最终的结果可能是节点的数量有偏差，而且顺序也是混乱的。<br>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变得“串行化”了。<br>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">    boolean failed=<span class="literal">true</span>;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(;;)&#123;</div><div class="line">          final Node p = node.predecessor();</div><div class="line">          <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">              <span class="built_in">set</span>Head(node);</div><div class="line">              p.next = null;</div><div class="line">              failed=<span class="literal">false</span>;</div><div class="line">              <span class="built_in">return</span> interrupted;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt)</div><div class="line">              interrupted = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        <span class="keyword">if</span>(failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。<br>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为<br>适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</div><div class="line">      Node h = head;</div><div class="line">      <span class="keyword">if</span>(h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">       unparkSuccessor(h);</div><div class="line">       <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">     <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="共享同步状态获取与释放"><a href="#共享同步状态获取与释放" class="headerlink" title="共享同步状态获取与释放"></a>共享同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况<br><img src="/2017/12/31/java并发编程4-6/共享与独占.png" alt=""><br>左半部分，共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞，右半部分是独占式访问资源时，同一时刻其他访问均被阻塞。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; 0)</div><div class="line">           <span class="keyword">do</span>AcquireShared(arg);</div><div class="line">   &#125;</div><div class="line">private void <span class="keyword">do</span>AcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                final Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= 0) &#123;</div><div class="line">                        <span class="built_in">set</span>HeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        <span class="built_in">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            <span class="keyword">if</span>(failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。<br>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line"><span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">      <span class="keyword">do</span>ReleaseShared();</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。在分析该方法的实现前，先介绍一下响应中断的同步状态获取过程。在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private boolean <span class="keyword">do</span>AcquireNanos(int arg, long nanosTimeout)</div><div class="line">     throws InterruptedException &#123;</div><div class="line">     long lastTime = System.nanoTime();</div><div class="line">     final Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">     boolean failed = <span class="literal">true</span>;</div><div class="line">     try &#123;</div><div class="line">         <span class="keyword">for</span> (;;) &#123;</div><div class="line">             final Node p = node.predecessor();</div><div class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                 <span class="built_in">set</span>Head(node);</div><div class="line">                 p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                 failed = <span class="literal">false</span>;</div><div class="line">                 <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= 0)</div><div class="line">                 <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                 nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                 LockSupport.parkNanos(this, nanosTimeout);</div><div class="line">             long now = System.nanoTime();</div><div class="line">             nanosTimeout -= now - lastTime;</div><div class="line">             lastTime = now;</div><div class="line">             <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                 throw new InterruptedException();</div><div class="line">         &#125;</div><div class="line">     &#125; finally &#123;</div><div class="line">         <span class="keyword">if</span> (failed)</div><div class="line">             cancelAcquire(node);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object blocker,long nanos)方法返回）。如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，同步器会进入无条件的快速自旋。<br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑。acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态，而doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。<br><img src="/2017/12/31/java并发编程4-6/独占超时.png" alt=""></p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，支持重新进入的锁，表示该锁能够支持一个线程对一个资源的重复加锁。该锁还支持获取锁的公平性和非公平性的选择。<br>当一个线程调用Mutex的lock方法获取锁之后，如果再次调用lock方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。简单地说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。<br>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。<br>如果在决定时间下，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之则是不公平的。公平锁也就是等待时间最长的线程最优先获取到锁.ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。公平锁往往没有不公平锁效率高，但是并非任何场景下都是以TPS作为唯一指标，公平锁能够减少饥饿发生的概率，等待越久的线程越是能够得到优先满足。<br>1.实现重进入<br>重进入是是指任意线程获取到锁后再次获取到该锁不会被该锁所阻塞，该特性需要解决两个问题：<br>1）线程再次获取到锁，锁需要去识别获取锁的线程是否是当前占据锁的线程，如果是，再次成功获取<br>2）锁的最终释放，线程重复n次获取到锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。<br>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">int c = getState() - releases;</div><div class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">boolean free = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line">free = <span class="literal">true</span>;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">&#125;</div><div class="line"><span class="built_in">set</span>State(c);</div><div class="line"><span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。<br>2.公平锁与非公平锁的区别<br>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>回顾nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>为什么会出现线程连续获取锁的情况呢？回顾nonfairTryAcquire(int acquires)方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待.<br>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>之前提到的锁基本都是排他锁，这些锁同一时刻只能由一个线程进行访问，而读写锁在同一时刻只允许一个线程进行访问，而读写锁同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了提升。<br>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务、（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。<br>一般情况下，读写锁的性能都会比排它锁性能好，因为大多数场景读是多于写。读写锁比排它锁有更好的并发量和吞吐量。java并发包提供读写锁ReentrantReadWriteLock</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平和公平，吞吐量非公平优于公平</td>
</tr>
<tr>
<td>重进入</td>
<td>该锁支持重进入，以读写线程为例，读线程获取读锁后，能够再次获取读锁，写线程获取写锁后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级称为读锁</td>
</tr>
</tbody>
</table>
<h3 id="读写锁接口与示例"><a href="#读写锁接口与示例" class="headerlink" title="读写锁接口与示例"></a>读写锁接口与示例</h3><p>仅定义了获取读锁和写锁两个方法，即readLock和writeLock<br><img src="/2017/12/31/java并发编程4-6/读写锁监控.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">	static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">	static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">	static Lock r = rwl.readLock();</div><div class="line">	static Lock w = rwl.writeLock();</div><div class="line"></div><div class="line">	// 获取一个key对应的value</div><div class="line">	public static final Object get(String key) &#123;</div><div class="line">		r.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.get(key);</div><div class="line">		&#125; finally &#123;</div><div class="line">			r.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置key对应的value，并返回旧的value</div><div class="line">	public static final Object put(String key, Object value) &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.put(key, value);</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清空所有的内容</div><div class="line">	public static final void <span class="function"><span class="title">clear</span></span>() &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			map.clear();</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性</p>
<h3 id="读写锁实现设计"><a href="#读写锁实现设计" class="headerlink" title="读写锁实现设计"></a>读写锁实现设计</h3><p>主要包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级</p>
<h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果一个整形变量维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量分为两个部分，前十六位表示读，低十六位表示写。<br>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。<br>当S等于零时说明没有锁，当S不等于零时，当写状态(S&amp;0x0000FFFF)等于0时，则读状态不等于0，即读锁已被获取。</p>
<h4 id="写状态的获取与释放"><a href="#写状态的获取与释放" class="headerlink" title="写状态的获取与释放"></a>写状态的获取与释放</h4><p>写锁是一个支持可重入的排它锁，如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">           Thread current = Thread.currentThread();</div><div class="line">           int c = getState();</div><div class="line">           int w = exclusiveCount(c);</div><div class="line">           <span class="keyword">if</span> (c != 0) &#123;</div><div class="line">               // (Note: <span class="keyword">if</span> c != 0 and w == 0 <span class="keyword">then</span> shared count != 0)</div><div class="line">               <span class="keyword">if</span> (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                   <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                   throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">               // Reentrant acquire</div><div class="line">               <span class="built_in">set</span>State(c + acquires);</div><div class="line">               <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">               !compareAndSetState(c, c + acquires))</div><div class="line">               <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">           <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。<br>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount()方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">int c = getState();</div><div class="line">int nextc = c + (1 &lt;&lt; 16);</div><div class="line"><span class="keyword">if</span> (nextc &lt; c)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</div><div class="line"><span class="built_in">return</span> -1;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line"><span class="built_in">return</span> 1;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。<br>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。<br>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">processData</span></span>() &#123;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 必须先释放读锁</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">// 锁降级从写锁获取到开始</div><div class="line">writeLock.lock();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 准备数据的流程（略）</div><div class="line">update = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line">&#125; finally &#123;</div><div class="line">writeLock.unlock();</div><div class="line">&#125;</div><div class="line">// 锁降级完成，写锁降级为读锁</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">// 使用数据的流程（略）</div><div class="line">&#125; finally &#123;</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。<br>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类完成相应工作。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程<br><img src="/2017/12/31/java并发编程4-6/locksupport.png" alt=""><br>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<h2 id="condition接口"><a href="#condition接口" class="headerlink" title="condition接口"></a>condition接口</h2><p>任意一个java对象，都拥有一组监视器方法，主要包括wait、notify、notifyAll方法，这些方法与synchronize同步关键字配合，可以实现等待、通知模式。Condition接口也提供了类似Object监视器方法，与lock配合实现等待通知模式。<br><img src="/2017/12/31/java并发编程4-6/对比.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Lock lock=new ReentrantLock();</div><div class="line">	static Condition condition=lock.newCondition();</div><div class="line">	public static void <span class="function"><span class="title">wait_1</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.await();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void <span class="function"><span class="title">singal</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/31/java并发编程4-6/condition.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BoundedQueue&lt;T&gt; &#123;</div><div class="line">    T[] itemsObjects;</div><div class="line">	int addindex,removeIndex,count;</div><div class="line">	Lock lock=new ReentrantLock();</div><div class="line">	Condition notFull=lock.newCondition();</div><div class="line">	Condition notEmpty=lock.newCondition();</div><div class="line">	public void add(T t)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==itemsObjects.length)&#123;</div><div class="line">				notFull.await();</div><div class="line">			&#125;</div><div class="line">			itemsObjects[addindex]=t;</div><div class="line">			addindex++;</div><div class="line">			<span class="keyword">if</span>(addindex==itemsObjects.length)&#123;</div><div class="line">				addindex=0;</div><div class="line">			&#125;</div><div class="line">			count++;</div><div class="line">			notEmpty.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public T <span class="function"><span class="title">remove</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==0)&#123;</div><div class="line">				notEmpty.await();</div><div class="line">			&#125;</div><div class="line">			T t=itemsObjects[removeIndex];</div><div class="line">			<span class="keyword">if</span>(++removeIndex==itemsObjects.length)</div><div class="line">				removeIndex=0;</div><div class="line">			count--;</div><div class="line">			notFull.signal();</div><div class="line">			<span class="built_in">return</span> t;</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="condition的实现分析"><a href="#condition的实现分析" class="headerlink" title="condition的实现分析"></a>condition的实现分析</h3><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是FIFO的操作，在队列中的每个节点都包含一个线程的引用，该线程就是在Condition对象等待的线程，如果一个对象调用Condition.await，那么线程会释放锁，构造成节点加入等待队列并进入等待状态。点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node<br>一个Condition包含一个等待队列，Condition拥有首节点和尾节点，当前线程调用Condition.await，将会以当前线程构造节点，并将节点从尾部加入等待队列。<br><img src="/2017/12/31/java并发编程4-6/等待队列基本结构.png" alt=""><br>Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向他，并且更新尾节点。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br>在Object的监视器模型上，一个对象拥有一个同步队列和同步队列，而并发包中的Lock拥有一个同步队列和多个等待队列。<br><img src="/2017/12/31/java并发编程4-6/同步与等待.png" alt=""></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await方法中返回时，当前线程一定获取了Condition的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        throw new InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    long savedState = fullyRelease(node);</div><div class="line">    int interruptMode = 0;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步状态中的后继节点，然后当前线程会进入等待</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal方法，将会唤醒等待队列中等待最长的节点，在唤醒节点前，会将节点移到同步队列中。<br><img src="/2017/12/31/java并发编程4-6/唤醒.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void <span class="function"><span class="title">signal</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">Node first = firstWaiter;</div><div class="line"><span class="keyword">if</span> (first != null)</div><div class="line"><span class="keyword">do</span>Signal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。<br>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。<br>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java并发编程基础&quot;&gt;&lt;a href=&quot;#java并发编程基础&quot; class=&quot;headerlink&quot; title=&quot;java并发编程基础&quot;&gt;&lt;/a&gt;java并发编程基础&lt;/h1&gt;&lt;h2 id=&quot;线程简介&quot;&gt;&lt;a href=&quot;#线程简介&quot; class=&quot;head
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程前三章</title>
    <link href="http://yoursite.com/2017/12/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%89%8D%E4%B8%89%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/12/26/java并发编程前三章/</id>
    <published>2017-12-26T09:08:19.000Z</published>
    <updated>2017-12-31T07:08:16.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>即使是单核也支持多线程执行代码，cpu通过给每个线程分配cpu时间片来实现这个机制。时间片是cpu分配给每个线程的时间，因为时间片非常短，所以cpu通过不停地切换线程执行，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。<br>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="多线程一定快吗"><a href="#多线程一定快吗" class="headerlink" title="多线程一定快吗"></a>多线程一定快吗</h3><p>当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<h3 id="测试上下文切换的次数"><a href="#测试上下文切换的次数" class="headerlink" title="测试上下文切换的次数"></a>测试上下文切换的次数</h3><p>使用Lmbench3可以测量上下文切换的时长，使用vmstat可以测量上下文切换的次数。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。<br>·无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。<br>·CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<br>·使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。<br>·协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h3 id="减少上下文切换实战"><a href="#减少上下文切换实战" class="headerlink" title="减少上下文切换实战"></a>减少上下文切换实战</h3><p>第一步用jstack命令dump线程信息<br>第二步统计所有线程分别处于什么状态<br>第三步打开dump文件查看处于waiting的线程在做什么<br>第四步根据查看发现很多线程都在waiting，调整线程池配置<br>第五步重启服务器再统计</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>避免死锁的方法：<br>避免一个线程同时获得多个锁；<br>避免一个锁内同时占用多个资源，尽量保证一个锁只占用一个资源<br>尝试使用定时锁来代替内部锁机制,lock.tryLock(timeout)<br>对于数据库操作，加锁和解锁必须在一个数据库的连接里，否则会出现解锁失败的现象</p>
<h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><h3 id="什么是资源限制"><a href="#什么是资源限制" class="headerlink" title="什么是资源限制"></a>什么是资源限制</h3><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。例如带宽的上传下载速度、硬盘读写速度和cpu的处理速度。软件资源限制有数据库连接数和socket的连接数</p>
<h3 id="资源限制带来的问题"><a href="#资源限制带来的问题" class="headerlink" title="资源限制带来的问题"></a>资源限制带来的问题</h3><p>资源限制引发的问题导致并发可能不会加快，反而变慢，原因在于增加了上下文的切换和资源调度的时间</p>
<h3 id="如何解决资源限制问题"><a href="#如何解决资源限制问题" class="headerlink" title="如何解决资源限制问题"></a>如何解决资源限制问题</h3><p>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制可以使用线程池将socket和数据库连接复用，或者在调用对方webservice接口获取数据时</p>
<h3 id="在资源限制情况下进行并发编程"><a href="#在资源限制情况下进行并发编程" class="headerlink" title="在资源限制情况下进行并发编程"></a>在资源限制情况下进行并发编程</h3><p>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接</p>
<h1 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h1><h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="定义及其实现原理"><a href="#定义及其实现原理" class="headerlink" title="定义及其实现原理"></a>定义及其实现原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">instance = new Singleton();//instance是volatile变量</div><div class="line">//汇编</div><div class="line">0x01a3de1d: movb \<span class="variable">$0</span>×0,0×1104800(%esi);0x01a3de24: lock addl \<span class="variable">$0</span>×0,(%esp);</div></pre></td></tr></table></figure>
<p>lock指令会在多核处理器引发两件事情：</p>
<ol>
<li>将当前的缓存处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使其他cpu缓存该地内存址的数据无效</li>
</ol>
<p><em>缓存一致性协议：在多处理器中，为了保证各个处理器的缓存是一致的，就会实现缓存一致性，每个处理器会通过嗅探在总线传播过来的数据来检查自己缓存的数据是否过期，当处理器发现自己缓存行对应的内存地址被修改时，就会将自己的缓存状态设为失效状态，当处理器对这个数据进行访问时，就会重新从系统内存中把数据读到处理器缓存中。</em></p>
<h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>Linked-TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能<br>一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。<br>为什么追加64字节能够提高并发编程的效率呢？因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。那么是不是在使用volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。<br>·缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。<br>·共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>java中每一个对象都可以成为锁，具体表现形式如下：<br>对于普通的同步方法，锁是当前实例对象<br>对于静态的同步方法，锁是当前类的class对象<br>对于同步方法快，锁是Sychronized括号里配置的对象。<br>JVM基于进入和退出monitor对象实现方法同步和代码块同步，但两个实现细节不一样，代码块同步是通过monitorenter和monitorexit指令实现，方法同步使用另一种方式。<br>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>synchronized用的锁是存在java对象头里。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果非数组，用2字宽存储对象头。<br><img src="/2017/12/26/java并发编程前三章/java对象头.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/锁状态.png" alt=""></p>
<h3 id="锁升级与对比"><a href="#锁升级与对比" class="headerlink" title="锁升级与对比"></a>锁升级与对比</h3><p>java SE1.6中锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量锁状态、重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h5 id="关闭锁"><a href="#关闭锁" class="headerlink" title="关闭锁"></a>关闭锁</h5><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果进程间存在着锁竞争会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋消耗cpu</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程使用不使用自旋，不用消耗cpu</td>
<td>线程阻塞，响应速度非常慢</td>
<td>追求吞吐量。同步块执行时间较长</td>
</tr>
</tbody>
</table>
<h2 id="原子操作实现原理"><a href="#原子操作实现原理" class="headerlink" title="原子操作实现原理"></a>原子操作实现原理</h2><p>原子操作意为不可被中断的一个或一系列操作</p>
<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><p>缓存行、比较并交换、cpu流水线、内存顺序冲突</p>
<h3 id="处理器实现原子操作"><a href="#处理器实现原子操作" class="headerlink" title="处理器实现原子操作"></a>处理器实现原子操作</h3><p>处理器通过总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性</p>
<h4 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h4><p>总线锁就是使用处理器提供的一个lock信号，当一个总线输出此信号时，其他处理器的请求将会被阻塞住，那么该处理器就可以独占共享内存。</p>
<h4 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h4><p>缓存锁定是内存区域如果被缓存在处理器的缓存行中，并且在lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言lock信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性会阻止同时修改由两个以上的处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。<br>但是有两种情况下处理器不会使用缓存锁定。<br>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。<br>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<h4 id="java如何实现原子操作"><a href="#java如何实现原子操作" class="headerlink" title="java如何实现原子操作"></a>java如何实现原子操作</h4><p>java中可以通过使用锁和cas实现原子操作<br>1.使用循环cas操作<br>2.cas实现原子操作的三大问题</p>
<ul>
<li>A-&gt;B-&gt;A问题<br>解决思路是使用版本号，在变量前面追加版本号，每次变量改变版本号加一。这个<br>类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
</ul>
<p>3.使用锁机制实现原子操作<br>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><h2 id="java内存查询的基础"><a href="#java内存查询的基础" class="headerlink" title="java内存查询的基础"></a>java内存查询的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><p>两个关键问题：线程之间如何通信以及线程之间如何同步。线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐性通信。在消息传递的并发模型中，线程没有公共状态，线程必须通过发送信息来显性通信。<br>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h3 id="java内存模型的抽象结构"><a href="#java内存模型的抽象结构" class="headerlink" title="java内存模型的抽象结构"></a>java内存模型的抽象结构</h3><p>在java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程间共享。局部变量、方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题。也不受内存模型的影响。<br>java线程的通信由java内存模型(JMM)控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写的共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br><img src="/2017/12/26/java并发编程前三章/java内存模型.png" alt=""><br>如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。<br>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>2）线程B到主内存中去读取线程A之前已更新过的共享变量。<br><img src="/2017/12/26/java并发编程前三章/线程通信.png" alt=""><br>本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p>重排序分为三类：<br>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="/2017/12/26/java并发编程前三章/重排序.png" alt=""><br>1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>现代处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>在JMM中，如果一个操作执行结果需要对另一个操作可见，那么这两个操作必须存在happens-before关系。这里提到的两个操作可以是一个线程内，也可以是不同线程间。<br>·程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问一个变量，且这两个操作有一个是写操作，那么这两个操作就存在数据依赖性。<br>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<br>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as if serial语义"></a>as if serial语义</h3><p>不管怎么重排序，程序的执行结果不能被改变。</p>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.这时B不一定能观察到线程A的写入。因为两个线程之间没有数据依赖性。</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>数据竞争：在一个线程中写一个变量、在另一个线程中读一个变量、而且写和读之间没有通过同步来排序。<br>如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>两大特性：1.一个线程内的所有操作必须按照程序的顺序来执行。2.所有线程只能看到单一的操作执行顺序。在顺序一致性模型中，每个操作都必须原子执行且立刻对所有线程可见。<br>顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摇摆的开关可以连接到任意一个线程，同时每个线程都按照程序的顺序执行内存的读写操作。<br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性模型"><a href="#同步程序的顺序一致性模型" class="headerlink" title="同步程序的顺序一致性模型"></a>同步程序的顺序一致性模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。<br>JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。为了实现最小安全性，JVM在堆上分配对象，域会默认初始化。<br>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。<br>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。<br>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的<br>操作会按程序的顺序执行<br>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程<br>能看到一致的操作执行顺序。<br>3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><p>理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。<br>锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>volatile变量自身具有下列特性：<br>可见性。对一个volatile变量的读，总能看到任意线程对这个volatile变量的写入。<br>原子性。对任意单个volatile变量的读/写具有原子性。但类似volatile++这种复合操作不具有原子性。</p>
<h3 id="volatile写-读建立的happens-before"><a href="#volatile写-读建立的happens-before" class="headerlink" title="volatile写-读建立的happens-before"></a>volatile写-读建立的happens-before</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class VolatileExample &#123;</div><div class="line"> int a = 0;</div><div class="line"> volatile boolean flag = <span class="literal">false</span>;</div><div class="line"> public void <span class="function"><span class="title">writer</span></span>() &#123;</div><div class="line">    a = 1;　　　　　// 1</div><div class="line">    flag = <span class="literal">true</span>;　　　// 2</div><div class="line"> &#125;</div><div class="line"> public void <span class="function"><span class="title">reader</span></span>() &#123;</div><div class="line">    <span class="keyword">if</span>(flag)&#123;  //3</div><div class="line">      int i=a; //4</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据程序次序规则，1 happens-before 2;3 happens-before 4<br>根据volatile规则，2 happens-before 3<br>根据happens-before的传递性规则，1 happens-before 4</p>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。<br>volatile的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置<br>为无效，线程接下来从主内存中读取共享变量。</p>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p><img src="/2017/12/26/java并发编程前三章/重排序规则.png" alt=""><br>·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。<br>·在每个volatile写操作的前面插入一个StoreStore屏障。<br>·在每个volatile写操作的后面插入一个StoreLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadStore屏障。<br><img src="/2017/12/26/java并发编程前三章/volatile写指令.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/volatile读指令.png" alt=""></p>
<h3 id="jsr-133为什么要增强volatile语句"><a href="#jsr-133为什么要增强volatile语句" class="headerlink" title="jsr-133为什么要增强volatile语句"></a>jsr-133为什么要增强volatile语句</h3><p>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><h3 id="锁的释放获取"><a href="#锁的释放获取" class="headerlink" title="锁的释放获取"></a>锁的释放获取</h3><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MonitorExample &#123;</div><div class="line">int a = 0;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>() &#123;　　　　// 1</div><div class="line">a++;　　　　　　　　　　// 2</div><div class="line">&#125;　　　　　　　　　　　　// 3</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>() &#123;　　　// 4</div><div class="line">int i = a;　　　　　　　　// 5</div><div class="line">……</div><div class="line">&#125;　　　　　　　　　　　　// 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。<br>1）根据程序次序规则，1 happens-before 2,2 happens-before 3;4 happens-before 5,5 happens-before 6。<br>2）根据监视器锁规则，3 happens-before 4。<br>3）根据happens-before的传递性，2 happens-before 5。</p>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取到锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>总结：线程A释放一个锁，实质是线程A向接下来将要获取这个锁的某个线程发出了对共享变量所做修改的消息。线程B获取一个锁，实质是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。<br>线程A释放锁，随后线程B获取这个锁，这个过程实质是线程A通过主内存向线程B发送消息。</p>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">ReentrantLock lock=new ReentrantLock();</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">    lock.lock();</div><div class="line">    try&#123;</div><div class="line">       a++;</div><div class="line">    &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">    &#125;finally&#123;</div><div class="line">      lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  lock.lock();</div><div class="line">  try&#123;</div><div class="line">    int i=a;</div><div class="line">  &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">  &#125;finally&#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer(AQS)，AQS使用一个整形的volatile(state)变量来维护同步状态。<br><img src="/2017/12/26/java并发编程前三章/ReentrantLock类图.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，使用公平锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ReentrantLock:lock();</div><div class="line">FairSync:lock();</div><div class="line">AbstractQueuedSynchronizer:acquire(int arg);</div><div class="line">ReentrantLock:tryAcquire(int acquire);</div><div class="line">FairSync:</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    final Thread current = Thread.currentThread();</div><div class="line">    int c = getState();</div><div class="line">    <span class="keyword">if</span>(c == 0)&#123;</div><div class="line">        <span class="keyword">if</span>(!hasQueuedPredecessors() &amp;&amp;compareAndSetState(0, acquires))&#123;</div><div class="line">            <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</div><div class="line">      int nextc = c + acquires;</div><div class="line">      <span class="keyword">if</span>(nextc &lt; 0)</div><div class="line">          throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">      <span class="built_in">set</span>State(nextc);</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加锁方法首先读volatile变量state<br>在使用公平锁时，解锁方法unlock()调用轨迹如下。<br>1）ReentrantLock:unlock()。<br>2）AbstractQueuedSynchronizer:release(int arg)。<br>3）Sync:tryRelease(int releases)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    int c =getState()- releases;</div><div class="line">    <span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line">    boolean free = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(c == 0) &#123;</div><div class="line">        free = <span class="literal">true</span>;</div><div class="line">        <span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span>State(c);</div><div class="line">    <span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在释放锁的最后写volatile变量state。<br>公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。<br>这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。<br>1）ReentrantLock:lock()。<br>2）NonfairSync:lock()。<br>3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。<br>现在对公平锁和非公平锁的内存语义做个总结。<br>·公平锁和非公平锁释放时，最后都要写一个volatile变量state。<br>·公平锁获取时，首先会去读volatile变量。<br>·非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</p>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>java的CAS同时具有volatile读和volatile写的内存语义，因此java线程之间的通信有了下面四种方式：<br>1）A线程写volatile变量，随后B线程读这个volatile变量。<br>2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。<br>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。<br>首先，声明共享变量为volatile。<br>然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
<h2 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h2><p>对final域的读和写更像是普通的变量访问。</p>
<h3 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h3><p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用<br>变量，这两个操作之间不能重排序。<br>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能<br>重排序。</p>
<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><p>1）JMM禁止编译器把final域的写重排序到构造函数之外；<br>2）编译器会在final域写之后，构造函数return之前，插入一个storestore。这个屏障会禁止处理器把final域的写重排序到构造函数之外。<br>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><p>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。<br>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h3 id="final为引用类型"><a href="#final为引用类型" class="headerlink" title="final为引用类型"></a>final为引用类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FinalReferenceExample &#123;</div><div class="line">final int[] intArray; // final是引用类型</div><div class="line">static FinalReferenceExample obj;</div><div class="line">public <span class="function"><span class="title">FinalReferenceExample</span></span> () &#123; // 构造函数</div><div class="line">intArray = new int[1]; // 1</div><div class="line">intArray[0] = 1; // 2</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerOne</span></span> () &#123; // 写线程A执行</div><div class="line">obj = new FinalReferenceExample (); // 3</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerTwo</span></span> () &#123; // 写线程B执行</div><div class="line">obj.intArray[0] = 2; // 4</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">reader</span></span> () &#123; // 读线程C执行</div><div class="line"><span class="keyword">if</span>(obj != null) &#123; // 5</div><div class="line">int temp1 = obj.intArray[0]; // 6</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader()方法.JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<h3 id="为什么final引用不能从构造函数内“溢出”"><a href="#为什么final引用不能从构造函数内“溢出”" class="headerlink" title="为什么final引用不能从构造函数内“溢出”"></a>为什么final引用不能从构造函数内“溢出”</h3><p>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程#都能看到这个final域在构造函数中被初始化之后的值。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><p>JMM目标：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。<br>JMM保证两点：</p>
<ol>
<li>JMM向程序员提供的happens-before能够保证程序员的需求。JMM的happens-before规则不但简单且易懂，而且向程序员提供了足够强的内存可见性保证。</li>
<li>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实在遵循一个基本原则：只要不改变程序的执行结果，编译器和处理器怎么优化都可以。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ol>
<h3 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h3><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作执行顺序排在第二个操作之前。<br>2）两个操作之间存在着happens-before关系，并不意味着java平台具体实现按照happens-before关系指定的顺序来执行。如果重排序的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法。<br>上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。<br>上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。<br>·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。<br>·as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><ol>
<li>程序顺序规则：一个程序的每个操作，happens-before与该线程的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before与后续对这个volatile的读</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执行操作ThreadB.start,那么A线程的start操作happens-before线程B的任何操作。</li>
<li>join规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ol>
<h2 id="双重检查锁和延迟初始化"><a href="#双重检查锁和延迟初始化" class="headerlink" title="双重检查锁和延迟初始化"></a>双重检查锁和延迟初始化</h2><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<h3 id="双重锁检查锁定的由来"><a href="#双重锁检查锁定的由来" class="headerlink" title="双重锁检查锁定的由来"></a>双重锁检查锁定的由来</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public synchronized static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;</div><div class="line">        single=new Singleton();</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美。<br>·多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。<br>·在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h3 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h3><p>single=new Singleton();创建了一个对象。这一行代码可以分解为如下的3行伪代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div><div class="line">single = memory;　　// 3：设置instance指向刚分配的内存地址</div></pre></td></tr></table></figure></p>
<p>上面3行伪代码中的2和3之间，可能会被重排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">instance = memory;　　// 3：设置instance指向刚分配的内存地址</div><div class="line">// 注意，此时对象还没有被初始化！</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/26/java并发编程前三章/多线程执行时序.png" alt=""></p>
<h3 id="基于volatile解决"><a href="#基于volatile解决" class="headerlink" title="基于volatile解决"></a>基于volatile解决</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当声明对象的引用为volatile后,伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><p>VM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class InstanceFactory&#123;</div><div class="line"></div><div class="line">  private static class InstanceHolder&#123;</div><div class="line">    public static Instance instance=new Instance();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> public static Instance <span class="function"><span class="title">getInstance</span></span>()&#123;</div><div class="line">         <span class="built_in">return</span> InstanceHoleder.instance;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了<br>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。<br>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。<br>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。<br>第4阶段：线程B结束类的初始化处理。<br>第5阶段：线程C执行类的初始化的处理。<br>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。</p>
<h2 id="java内存模型综述"><a href="#java内存模型综述" class="headerlink" title="java内存模型综述"></a>java内存模型综述</h2><h3 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h3><p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。<br>·放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。<br>·在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>·在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了RelaxedMemory Order内存模型（简称为RMO）和PowerPC内存模型。<br>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的<br>JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h3 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h3><p>JMM是一种语言参考模型，处理器内存模型是硬件级的内存模型，顺序一致性模型是一个理论参考模型。<br>常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按照程序类型，java程序的内存可见性保证可以分为3类：</p>
<ul>
<li>单线程程序<br>单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果跟该程序在顺序一致性模型中执行的结果一样。</li>
<li>正确同步的多线程程序<br>正确同步的多线程程序的执行将具有顺序一致性。这是JMM关注的重点。JMM通过限制编译器和处理器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>对于未同步或未正确同步的多线程程序<br>JMM提供了最小安全保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，false，null）</li>
</ul>
<p>最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们“发生”的时间点也不同。最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会无中生<br>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h3 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h3><ul>
<li>增强volatile变量的内存语义。旧内存模型允许volatile变量和普通变量进行重排序。JSR-133严格限制volatile变量与普通变量的重排序，使得volatile的写和读和和锁的释放-获取有相同的语义</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量可能有所不同。为此jsr-133增加两个重排规则，在保证final引用不会从构造函数内溢出的情况，final具有了初始化的安全。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统基础设施</title>
    <link href="http://yoursite.com/2017/12/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://yoursite.com/2017/12/21/分布式系统基础设施/</id>
    <published>2017-12-21T15:01:53.000Z</published>
    <updated>2017-12-25T08:23:39.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>在高并发环境下，大量的读、写请求涌向数据库，磁盘的读写速度与内存显然不在一个量级，从减轻数据库的压力和提高系统响应两个角度来考虑，一般都会在数据库层加一层缓存。由于单台机器的内存资源和承载有限，并且如果大量使用本地缓存，也会使相同数据被不同的节点存储多份，对内存资源造成较大的浪费，因此催生出分布式缓存。分布式缓存的经典代表是memcache，最经典的场景是分布式session。</p>
<h3 id="memchache简介及安装"><a href="#memchache简介及安装" class="headerlink" title="memchache简介及安装"></a>memchache简介及安装</h3><p>memcache使用key-value的形式存储和访问数据，在内存中维护一张巨大的hashtable，使得数据查询的时间复杂度降低到O(1),保证高性能的访问。内存的空间是有限的，当内存没有足够空间存储新的数据，memcache就会使用LRU算法，将最近步长访问的数据淘汰掉，以腾出新的空间存放。memcache支持的数据格式多样化，通过对象序列化转成二进制数据，又可以通过反序列化还原原有对象。<br>windows安装：[<a href="http://kimi.it/258.html" target="_blank" rel="external">http://kimi.it/258.html</a>]<br>linux安装：[<a href="http://kimi.it/257.html" target="_blank" rel="external">http://kimi.it/257.html</a>]<br>备注：windows安装要在管理员命令行安装</p>
<h3 id="memcache-java-api与分布式"><a href="#memcache-java-api与分布式" class="headerlink" title="memcache java api与分布式"></a>memcache java api与分布式</h3><p>java api：<br>[<a href="http://blog.csdn.net/seelye/article/details/8511073" target="_blank" rel="external">http://blog.csdn.net/seelye/article/details/8511073</a>], [<a href="http://acooly.iteye.com/blog/1120347" target="_blank" rel="external">http://acooly.iteye.com/blog/1120347</a>]<br>memcache本身不是分布式缓存系统，它的分布式是由访问的客户端来实现，一种比较简单的方式是通过缓存的key来进行哈希，当后端有N台缓存服务器时，访问的服务器为hash(key)%N,这样请求就均衡地映射到后端缓存服务器，但是需要新增时服务器时，大部分的key将会重新分布，会导致请求访问不到缓存进而访问数据库，导致雪崩。<br>一致性哈希算法可以改善这个问题：将哈希函数的值域空间组织成一个圆环，整个空间按照瞬时间方向组织，然后对应的服务器节点进行哈希，将他们映射在哈希环上。<br><img src="/2017/12/21/分布式系统基础设施/一致性哈希.png" alt=""><br>这样子当新增一个节点后，只影响局部的节点，避免大量key重新映射。当节点数量很少时，可能导致分布不均匀，引入虚拟节点机制，key的映射不变，只是多了虚拟节点映射到真实节点的过程。<br>java中一致性哈希的实现：<br>[<a href="http://blog.csdn.net/kinger0/article/details/49760751" target="_blank" rel="external">http://blog.csdn.net/kinger0/article/details/49760751</a>]</p>
<h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>传统的应用服务器，如tomcat、jboss，其自身实现的session管理大部分是基于单机的。对于大型分布式网站来说，支撑其业务的远远不止一台服务器，而是分布式集群，请求在不同服务器之间跳转。传统的做法是通过cookie进行session同步，但是cooie有安全性问题，还有存储的数据大小是有限制的，加上需要兼容移动端的session。<br>对于系统可靠性要求较高的用户，可以将session持久化到DB中，这样可以保证宕机时不易丢失，但是系统整体吞吐量会受到影响。另一种方式是session统一存储到缓存集群里，如memcache，这样可以保证有较高的读、写性能，从安全性角度看，session是有有效期的，使用缓存存储便于利用缓存失效机制。<br><img src="/2017/12/21/分布式系统基础设施/分布式session.png" alt=""><br>tomcat的web server举例，通过memcached-session-manager实现分布式session。<br>[<a href="http://chenzhou123520.iteye.com/blog/1650212" target="_blank" rel="external">http://chenzhou123520.iteye.com/blog/1650212</a>]</p>
<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="mysql扩展"><a href="#mysql扩展" class="headerlink" title="mysql扩展"></a>mysql扩展</h3><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><p><img src="/2017/12/21/分布式系统基础设施/业务拆分.png" alt=""></p>
<h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>通过数据库的复制策略，可以将一台mysql数据库服务器中的数据复制到其他mysql数据库服务器，通过读写分离。前端服务器通过master执行数据写入，数据的更新通过binary log同步到slave集群，对于数据读取请求，交由slave处理。master-slave架构能减轻单库读的压力。<br><img src="/2017/12/21/分布式系统基础设施/master-slave.png" alt=""><br>master-slaves架构存在着单点故障的问题。最佳的方式是采用dual-master架构。<br>这种架构下，两台服务器互相将对方视为自己的master，这样就可以互相同步消息，并且通过server-id，就不会出现循环复制。通常情况下，我们仅开启一台master的写入，另一台master作为standby或者读库开放，这样可以避免数据写入冲突，防止数据不一致。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>对于访问频繁且数据量巨大的单表来说，首先要做的是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐量。<br><img src="/2017/12/21/分布式系统基础设施/分表.png" alt=""><br>分表能解决单表数据量过大带来的查询效率下降的问题。却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库Master服务器无法承载写操作压力时，不管怎么扩展slave服务器，此时都没有意义。所以我们可以采用分库。<br><img src="/2017/12/21/分布式系统基础设施/分库.png" alt=""></p>
<h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><p><img src="/2017/12/21/分布式系统基础设施/hbase.png" alt=""></p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h4><p>[<a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="external">http://www.runoob.com/redis/redis-install.html</a>]</p>
<h4 id="redis-java-api"><a href="#redis-java-api" class="headerlink" title="redis java api"></a>redis java api</h4><p>[<a href="https://www.cnblogs.com/libaoting/p/4418007.html" target="_blank" rel="external">https://www.cnblogs.com/libaoting/p/4418007.html</a>]</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="/2017/12/21/分布式系统基础设施/jms和amqp.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/mq对比2.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/mq对比.png" alt=""></p>
<h2 id="垂直化搜索引擎"><a href="#垂直化搜索引擎" class="headerlink" title="垂直化搜索引擎"></a>垂直化搜索引擎</h2><p>垂直搜索引擎既能满足用户对于全文检索、模糊匹配的需求，解决数据库like查询效率低下问题。又能解决分布式分库分表后或者使用nosql无法进行多表关联和复杂查询。<br><img src="/2017/12/21/分布式系统基础设施/luecene.png" alt=""></p>
<h3 id="搜索引擎的重要概念"><a href="#搜索引擎的重要概念" class="headerlink" title="搜索引擎的重要概念"></a>搜索引擎的重要概念</h3><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>将文档的词作为关键字，建立词与文档的映射关系，通过对倒排索引的检索，可以根据词可以迅速获取包含这个词的文档列表。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>分词就是将句子或者段落进行切割，从中提取出包含固定语义的词。对于英语来说，语言的基本单位是单词。但对于中文来说，多个中文字组合一起才能表达一个具体含义的词。这里推荐使用ik-analyer分词库。</p>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><p>对于没有具体含义、区分度低的词，搜索引擎对这些词进行检索没有意义，因此停用词可以忽略。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>最经典的是tf-idf算法。</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是一切域的组合</p>
<h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>每个文档包含了域的名称和域的对应值，域可以是不同值，如整数，浮点数，字符串</p>
<h4 id="词"><a href="#词" class="headerlink" title="词"></a>词</h4><p>term是搜索的基本单元</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>TermQuery、phraseQuery、BoolQuery、TermRangeQuery、NumericRangeQuery、PrefixQuery</p>
<h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><p>文档在被索引之前，需要经过分词器处理建立索引<br><img src="/2017/12/21/分布式系统基础设施/建立索引.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/search.png" alt=""></p>
<h3 id="lucene的使用"><a href="#lucene的使用" class="headerlink" title="lucene的使用"></a>lucene的使用</h3><ol>
<li>建立索引</li>
<li>索引更新与删除<br>lucene还不支持单个阈的更新，而是先删除，后添加</li>
<li>条件查询</li>
<li>结果排序</li>
<li>高亮</li>
<li>中文分词（推荐ik-analyer）</li>
<li>索引优化<br>Lucene索引是由段组成，每个段可能有多个索引文件，即每个段包含一个或者多个document；段结构可以使lucene很好的支持增量索引，新增的document将被添加到新的索引段当中。但是越来越多的段被添加到索引当中，索引文件也越来越多。但是操作系统打开文件的句柄数是有限的。lucene在执行搜索时，分别搜索每一段，然后将结果合并，这样查询的性能会降低。<br>为了提高查询性能，当索引段到达一个上限后，Lucene会自动进行索引段的优化，将索引段合并成一个，以提高查询性能，并减少打开文件句柄数量。但是索引段合并需要大量的io操作，使得查询性能受损。我们可以每隔一段时间对索引进行一次全量的重建操作，以将增量更新所生成的索引段合并。</li>
<li>分布式扩展<br>搜索应用的大部分场景都能接受一定的时间延迟，可以采用最终一致性。<br>索引读写分离架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene读写分离.png" alt=""><br>每份query server保存一份完整的索引，该索引由dump server周期性生成，并进行索引段的合并，索引生成好后推送到每台query server进行替换，这样避免集群索引dump对后端存储造成的压力。当然对于增量索引的更新，dump server可以异步更新推送到每台query server。对于前端应用中，通过对请求进行哈希，将请求均衡地分布到集群的每台服务器。<br>索引切分架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene切分.png" alt=""><br>单机对索引的存储能力有限，随着索引数量的增加，索引的速度也会下降，此时索引本身已经成为系统的瓶颈，这时需要对索引进行切分，将索引分布到各个集群机器上，提高查询性能，降低存储压力。<br>merge server将索引分发给index server，最后将查询结果合并，返回给client应用。但是这有时候会导致排序和真实的结果会存在不一样。<br>综合两种架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene综合.png" alt=""><h3 id="solr"><a href="#solr" class="headerlink" title="solr"></a>solr</h3>安装配置：[<a href="http://blog.csdn.net/jack__ming/article/details/72615162" target="_blank" rel="external">http://blog.csdn.net/jack__ming/article/details/72615162</a>]<h3 id="es和solr的优缺点"><a href="#es和solr的优缺点" class="headerlink" title="es和solr的优缺点"></a>es和solr的优缺点</h3>[<a href="http://www.cnblogs.com/chowmin/articles/4629220.html" target="_blank" rel="external">http://www.cnblogs.com/chowmin/articles/4629220.html</a>]<h2 id="其他设施"><a href="#其他设施" class="headerlink" title="其他设施"></a>其他设施</h2></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式缓存&quot;&gt;&lt;a href=&quot;#分布式缓存&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存&quot;&gt;&lt;/a&gt;分布式缓存&lt;/h2&gt;&lt;p&gt;在高并发环境下，大量的读、写请求涌向数据库，磁盘的读写速度与内存显然不在一个量级，从减轻数据库的压力和提高系统响应两
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向服务的体系架构-SOA(第一章)</title>
    <link href="http://yoursite.com/2017/12/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-SOA/"/>
    <id>http://yoursite.com/2017/12/21/面向服务的体系架构-SOA/</id>
    <published>2017-12-21T02:57:29.000Z</published>
    <updated>2017-12-21T14:48:02.696Z</updated>
    
    <content type="html"><![CDATA[<p>伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提供服务，达成业务之间相互复用，系统也因此演变为分布式应用架构体系。<br>基于http协议之间的系统间的RPC，具有使用灵活、实现便捷、开放且天生支持异构平台间的调用等多个优点。与之对应的是tcp协议的实现版本，效率更高，实现更复杂，但由于协议和标准不同，很难跨平台和企业间的通信。</p>
<h2 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h2><h3 id="RPC名词解释"><a href="#RPC名词解释" class="headerlink" title="RPC名词解释"></a>RPC名词解释</h3><p>remote process call，远程过程调用，拥有着RMI、webservice等诸多成熟的方案。RPC将原来的本地调用转变为调用远端的服务器上的方法。<br>RPC的实现包括客户端和服务器端，即服务的调用方和服务提供方。服务调用方发送RPC请求到服务提供方，服务提供方根据调用方提供的参数执行请求方法，将执行结果返回给调用方。其中参数和返回结果序列化。</p>
<h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>将对象转成二进制流的过程称为对象的序列化<br>将二进制流转成对象的过程称为对象的反序列化<br>对象的序列化和反序列化有很多成熟的方案：Google protocol Buffers协议、java内置的序列化方式、Hessian、json以及xml。</p>
<h3 id="基于TCP实现的RPC"><a href="#基于TCP实现的RPC" class="headerlink" title="基于TCP实现的RPC"></a>基于TCP实现的RPC</h3><p>基于java socket的api，能够实现简单的RPC调用。</p>
<h2 id="基于http协议的RPC"><a href="#基于http协议的RPC" class="headerlink" title="基于http协议的RPC"></a>基于http协议的RPC</h2><h3 id="http协议栈"><a href="#http协议栈" class="headerlink" title="http协议栈"></a>http协议栈</h3><p>Http是Hypertext Transfer Protocol（超文本传输协议）的缩写，当今采用的版本主要是http1.1。<br>http属于应用层，构建在tcp和ip协议之上，处于tcp/ip协议的最顶层，它不需要处理下层协议间诸如丢包补发、握手及数据分段和重新组装的细节。<br><img src="/2017/12/21/面向服务的体系架构-SOA/协议.png" alt=""></p>
<h3 id="http请求与响应"><a href="#http请求与响应" class="headerlink" title="http请求与响应"></a>http请求与响应</h3><p><img src="面向服务的体系架构-SOA/http请求.png" alt=""></p>
<h3 id="通过HttpClient发送http请求"><a href="#通过HttpClient发送http请求" class="headerlink" title="通过HttpClient发送http请求"></a>通过HttpClient发送http请求</h3><h3 id="使用Http协议的优势"><a href="#使用Http协议的优势" class="headerlink" title="使用Http协议的优势"></a>使用Http协议的优势</h3><p>基于http协议的，很多成熟的开源web容器已经帮助解决了很多问题，如tomcat、jboss、Apache，这使得开发人员将更多的精力集中在业务的实现而非处理底层细节。<br>但http也有其劣势的一面，相同内容信息，http协议传输用的字节数肯定比tcp用的字节数更多，同等网络下，效率也比较低，信息传输用的时间更长。</p>
<h3 id="Json和xml"><a href="#Json和xml" class="headerlink" title="Json和xml"></a>Json和xml</h3><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>json是一种轻量级的数据交换语言，以文字为基础，易于阅读。将对象序列化为json格式，可以在网络上很方便的传输，且各个平台几乎都拥有成熟的工具，能很快地将json反序列化为其对应语言的所需要的格式。<br>使用jackson包</p>
<h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><p>xml的全称是可扩展标记语言（extensible markup language），可以标记数据、定义数据类型，是允许用户对自己的标记语言进行定义，用于标记电子文件使其具有结构性的源语言。xml提供统一的方法来描述和交换独立于应用程序和供应商的结构化数据，非常适合web传输。<br>可以使用xstream包</p>
<h3 id="restful和RPC"><a href="#restful和RPC" class="headerlink" title="restful和RPC"></a>restful和RPC</h3><p>主流url链接风格主要有两种：一种是RPC风格，另一种是Rest风格。</p>
<h4 id="RPC风格"><a href="#RPC风格" class="headerlink" title="RPC风格"></a>RPC风格</h4><p>RPC的风格是直接在http请求参数标明需要远程调用的服务接口名称、服务参数即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://hostname/provider.do?service=xxx.sayHello&amp;arg1=xxx</div></pre></td></tr></table></figure></p>
<h4 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h4><p>Rest是Representation state transform，表现层状态转移。<br>在表现层状态转移过程中，表现层指的是资源的表现层，资源是网络的实体，是一张图片、一首歌曲、一段文本，你可以用url进行访问。资源通过表现层呈现出来，比如图片通过png表现，文本通过html表现。访问一个资源，需要客户端和服务器端进行一定的交互，势必涉及数据和状态的变化，http是无状态协议，因此所有的状态都保存在服务器端。如果客户端想要操作服务端，必须通过某种手段，这种手段就是http协议的集中操作方式，如GET、PUT、POST、DELETE。这便是rest原则的思想，符合rest原则设计的就是restful风格。<br>restful风格就是通过http请求对应的GET、POST、PUT、DELETE方法，完成对应的CRUD操作。<br><img src="/2017/12/21/面向服务的体系架构-SOA/restful.png" alt=""></p>
<h3 id="基于http协议的RPC实现"><a href="#基于http协议的RPC实现" class="headerlink" title="基于http协议的RPC实现"></a>基于http协议的RPC实现</h3><p>类似我开发的数据交换平台的http接口</p>
<h2 id="服务的路由和负载均衡"><a href="#服务的路由和负载均衡" class="headerlink" title="服务的路由和负载均衡"></a>服务的路由和负载均衡</h2><h3 id="服务化的演变"><a href="#服务化的演变" class="headerlink" title="服务化的演变"></a>服务化的演变</h3><p>分布式应用架构体系对于业务逻辑复用的需求十分强烈，上层应用都想借用已有的底层服务，来搭建更多、更丰富的应用。公共的业务被拆分出来，形成可共用的服务，最大程度的保障了代码和逻辑的复用，避免重复建设，这种设计也称SOA。<br>SOA架构中，服务消费者通过服务名称，在众多服务中找到要调用的服务的地址列表，称为服务的路由。<br><img src="/2017/12/21/面向服务的体系架构-SOA/服务路由.png" alt=""><br>对于负载比较高的服务来说，往往对应着多台服务器的集群，在请求到来时，为了将请求均衡地分配到后端服务器，负载均衡服务器将从服务对应的地址列表中，通过相应的负载均衡算法和规则，选择一台服务器进行访问，这个过程称为服务的负载均衡。<br>当服务的规模比较小时，可以采用硬编码的方式将服务地址和配置写在代码中，通过编码的方式来解决服务的路由和负载均衡问题，也可以通过传统的硬件负载均衡设备如F5或者采用LVS或者Nginx等软件解决方案，通过相关配置来解决服务的路由和负载均衡问题。<br>当服务越来越多，规模越来越大时，对应的机器数量也越来越大，单靠人工来管理和维护服务和地址的配置信息也越来越困难，依赖单点设备或者使用LVS、Nginx等软件方案进行路由和负载均衡调度，单点问题也开始出现，一旦服务路由和负载均衡服务器宕机，依赖它的所有服务均将失效。<br>此时需要一个能够动态注册和获取服务信息的地方，来统一管理服务名称和其对应的服务器列表信息，称之为服务配置中心。服务在启动时将其服务名、服务器地址注册到配置中心，服务消费者通过服务配置中心获取需要获取服务的机器列表，通过相应的负载均衡列表，选取其中一台服务器进行调用。当服务器进行宕机或者下线时，相应的机器需要能够动态地从服务配置中心里面移除，并通知相应的服务消费者。在这个过程中，服务消费者只有第一次调用需要查询服务配置中心，然后将查询的信息缓存到本地，后面的调用直接使用本地缓存的服务地址信息列表，知道服务的地址列表更新，这种无中心化的结构解决了之前负载均衡的设备导致的单点问题。<br>基于zookeeper的的持久节点和非持久节点，我们能够近乎实时地感觉到后端服务器的状态。通过集群间的zab协议，使得服务配置信息能够保持一致，zookeeper本身的容错和leader选举机制，保障了扩容性。<br><img src="/2017/12/21/面向服务的体系架构-SOA/zookeeper负载均衡.png" alt=""></p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h4><p>将请求按顺序轮流的分配到后端服务器，它均衡地对待后端每一台服务器，而不关心服务器实际的连接数和当前的系统负载</p>
<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>通过系统函数，根据后端服务器列表大小值来随机选取一台访问</p>
<h4 id="源地址哈希表"><a href="#源地址哈希表" class="headerlink" title="源地址哈希表"></a>源地址哈希表</h4><p>获取客户端访问的ip地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表大小进行取模运算，得到的结果就是要访问的服务器序号。同一ip地址的客户端当服务器的列表不变时，它每次都会映射到同一台后端服务器访问。</p>
<h4 id="加权轮询法"><a href="#加权轮询法" class="headerlink" title="加权轮询法"></a>加权轮询法</h4><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此他们的抗压能力也不尽相同。给配置高负载低的机器配置更高的权重，让其处理更多的请求，给配置低负载高的配置更低的权重，降低其系统的负载，</p>
<h4 id="加权随机法"><a href="#加权随机法" class="headerlink" title="加权随机法"></a>加权随机法</h4><h4 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h4><p>最小连接数算法比较灵活和智能，由于后端的服务器不尽相同，对于请求的处理有快有慢，它根据后端服务器当前连接的情况，动态的选取当前积压连接数最小的服务器来处理当前请求，尽可能提高后端服务器的利用效率，将负载合理地分流给每一台机器。</p>
<h3 id="动态配置规则"><a href="#动态配置规则" class="headerlink" title="动态配置规则"></a>动态配置规则</h3><p>把这部分代码剥离出来，采用动态配置规则，使用groovy脚本语言直接编译成java的class字节码，运行在java虚拟机上。</p>
<h3 id="zookeeper介绍和环境搭建"><a href="#zookeeper介绍和环境搭建" class="headerlink" title="zookeeper介绍和环境搭建"></a>zookeeper介绍和环境搭建</h3><h3 id="zk的api使用"><a href="#zk的api使用" class="headerlink" title="zk的api使用"></a>zk的api使用</h3><h3 id="zkclient的使用"><a href="#zkclient的使用" class="headerlink" title="zkclient的使用"></a>zkclient的使用</h3><p>github源码：<a href="https://github.com/sgroschupf/zkclient.git" target="_blank" rel="external">https://github.com/sgroschupf/zkclient.git</a></p>
<h3 id="路由和负载均衡的实现"><a href="#路由和负载均衡的实现" class="headerlink" title="路由和负载均衡的实现"></a>路由和负载均衡的实现</h3><p>通过注册相应的watcher，服务消费者能够第一时间获知服务提供者机器信息的变更。利用其znode的特点和watcher机制，将其作为动态注册和获取服务信息的配置中心。<br><img src="/2017/12/21/面向服务的体系架构-SOA/服务配置节点树.png" alt=""><br>配置中心分三层，根节点为用来聚集服务的节点，通过它可以查询到所有服务，而节点名称挂载的是服务提供者提供的服务地址，服务消费者通过负载均衡算法选择其中一个地址发起远程调用。根节点和服务名称采用的是zk的持久化节点，服务提供者的地址节点是zk的非持久化节点，一旦服务器宕机或者下线，节点就会消失。<br><img src="/2017/12/21/面向服务的体系架构-SOA/zk节点.png" alt=""><br>增加一层，用来表示节点类型，每个服务包含两种节点类型，即consumer和provider，当服务消费者启动时，即在服务配置中心里，在其调用的所有服务的consumer节点下增加自己的机器地址，只需要后台监控程序解析出对应服务的consumer节点的子节点，便能清楚的知道某一服务被哪些机器消费了。</p>
<h2 id="http服务网关"><a href="#http服务网关" class="headerlink" title="http服务网关"></a>http服务网关</h2><p><img src="/2017/12/21/面向服务的体系架构-SOA/网关1.png" alt=""><br>gateway外部各种app的http请求，完成相应的权限和安全验证，当验证通过，根据传过的服务名称，到服务配置中心找到相应的服务名称节点，并加载对应服务提供者提供的地址列表，通过前面的负载均衡算法选取机器发起远程调用，将客户端参数传到服务端。服务提供方根据传入的参数，给出响应，当gateway收到响应后，再将响应返回给App<br>一方面通过网关可以很好解决安全问题，在恶意请求或者非授权请求到达后端会进行拦截。另一方面网关可以通过服务的路由进行负载均衡<br><img src="/2017/12/21/面向服务的体系架构-SOA/网关集群.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化ActiveMQ性能</title>
    <link href="http://yoursite.com/2017/12/20/%E4%BC%98%E5%8C%96ActiveMQ%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2017/12/20/优化ActiveMQ性能/</id>
    <published>2017-12-20T14:25:04.000Z</published>
    <updated>2017-12-20T14:55:09.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化和非持久化传递"><a href="#持久化和非持久化传递" class="headerlink" title="持久化和非持久化传递"></a>持久化和非持久化传递</h2><h3 id="持久化消息"><a href="#持久化消息" class="headerlink" title="持久化消息"></a>持久化消息</h3><p>这是 ActiveMQ 的默认传送模式，此模式保证这些消息只被传送一次和成功使用一次。对于这些消息，可靠性是优先考虑的因素。可靠性的另一个重要方面是确保持久性消息传送至目标后，消息服务在向消费者传送它们之前不会丢失这些消息。这意味着在持久性消息传送至目标时，消息服务将其放入持久性数据存储。如果消息服务由于某种原因导致失败，它可以恢复此消息并将此消息传送至相应的消费者。虽然这样增加了消息传送的开销，但却增加了可靠性。</p>
<h3 id="非持久化消息"><a href="#非持久化消息" class="headerlink" title="非持久化消息"></a>非持久化消息</h3><p>保证这些消息最多被传送一次。对于这些消息，可靠性并非主要的考虑因素。此模式并不要求持久性的数据存储，也不保证消息服务由于某种原因导致失败后消息不会丢失。<br>Non-persistent 传递消息比 Persistents 传递消息速度更快，原因如下：<br>Non-persistent 发送消息是异步的， Producer 不需要等待 Consumer 的 receipt消息。<br>Persisting 传递消息是需要把消息存储起来。然后在传递，这样很慢 。</p>
<h2 id="超快回应消息"><a href="#超快回应消息" class="headerlink" title="超快回应消息"></a>超快回应消息</h2><p>内嵌 broker</p>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>Transaction 比 Non-transaction 的性能高</p>
<h2 id="Tuning-the-OpenWire-protocol"><a href="#Tuning-the-OpenWire-protocol" class="headerlink" title="Tuning the OpenWire protocol"></a>Tuning the OpenWire protocol</h2><p>跨语言协议</p>
<h2 id="uning-the-TCP-Transport"><a href="#uning-the-TCP-Transport" class="headerlink" title="uning the TCP Transport"></a>uning the TCP Transport</h2><p>TCP 协议是 ActiveMQ 使用最常见的协议。<br>有以下两点影响 TCP 协议性能：<br>1) socketBufferSize=缓存，默认是 65536。<br>2) tcpNoDelay=默认是 false，</p>
<h2 id="优化消息消费者"><a href="#优化消息消费者" class="headerlink" title="优化消息消费者"></a>优化消息消费者</h2><h3 id="Prefetch-Limit"><a href="#Prefetch-Limit" class="headerlink" title="Prefetch Limit"></a>Prefetch Limit</h3><p>ActiveMQ 默认的 prefetch 大小不同的：<br>Queue Consumer 默认大小=1000<br>Queue Browser Consumer 默认大小=500<br>Persistent Topic Consumer 默认大小=100<br>Non-persistent Topic Consumer 默认大小=32766</p>
<h3 id="Delivery-and-Acknowledgement-of-messages"><a href="#Delivery-and-Acknowledgement-of-messages" class="headerlink" title="Delivery and Acknowledgement of messages"></a>Delivery and Acknowledgement of messages</h3><p>建议使用 Session.DUPS_ACKNOWLEDGE。<br>JMS 消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中， 消息何时被确认取决于创建会话时的应答模式 （acknowledgement mode） 。<br>该参数有以下三个可选值：<br>Session.AUTO_ACKNOWLEDGE。当客户成功的从 receive 方法返回的时候，或者从MessageListener.onMessage 方法成功返回的时候，会话自动确认客户收到的消息<br>Sessiion.TRANSACTION。用 session.commit()回执确认。<br>Session.CLIENT_ACKNOWLEDGE。客户通过消息的 acknowledge 方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了 10 个消息，然后确认第 5 个消息，那么所有 10 个消息都被确认。<br>Session.DUPS_ACKNOWLEDGE。该选择只是会话迟钝第确认消息的提交。当消息到达一定数量后，才开始消费该消息。如果 JMS provider 失败，那么可能会导致一些重复的消息。如果是重复的消息，那么 JMS provider 必须把消息头的 JMSRedelivered 字段设置为 true。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;持久化和非持久化传递&quot;&gt;&lt;a href=&quot;#持久化和非持久化传递&quot; class=&quot;headerlink&quot; title=&quot;持久化和非持久化传递&quot;&gt;&lt;/a&gt;持久化和非持久化传递&lt;/h2&gt;&lt;h3 id=&quot;持久化消息&quot;&gt;&lt;a href=&quot;#持久化消息&quot; class=&quot;he
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>activemq先进特性和优化性能</title>
    <link href="http://yoursite.com/2017/12/19/activemq%E5%85%88%E8%BF%9B%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/12/19/activemq先进特性/</id>
    <published>2017-12-19T15:07:38.000Z</published>
    <updated>2017-12-20T14:24:32.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先进特性"><a href="#先进特性" class="headerlink" title="先进特性"></a>先进特性</h1><h2 id="Destination-Features"><a href="#Destination-Features" class="headerlink" title="Destination Features"></a>Destination Features</h2><h3 id="Composite-Destinations"><a href="#Composite-Destinations" class="headerlink" title="Composite Destinations"></a>Composite Destinations</h3><p>ActiveMQ 支持 composite destinations。它允许用一个虚拟的destination 代表多个 destinations。例如你可以通过 composite destinations 在一个操作中同时向 12 个 queue 发送消息。在 composite destinations 中，多个 destination之间采用”,”分割。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Queue queue =  new ActiveMQQueue(<span class="string">"FOO.A,FOO.B,FOO.C"</span>)</div><div class="line">&lt;destinationInterceptors&gt;</div><div class="line"> &lt;virtualDestinat ionInterceptor&gt;</div><div class="line"> &lt;virtualDestinations&gt;</div><div class="line"> &lt;compositeQueue name=<span class="string">"MY.QUEUE"</span>&gt;</div><div class="line"> &lt;forwardTo&gt;</div><div class="line"> &lt;queue physicalName=<span class="string">"FOO"</span>  /&gt;</div><div class="line"> &lt;topic physicalName=<span class="string">"BAR"</span>  /&gt;</div><div class="line"> &lt;/forwardTo&gt;</div><div class="line"> &lt;/compositeQueue&gt;</div><div class="line"> &lt;/virtualDestinations&gt;</div><div class="line"> &lt;/virtualDestinationInterceptor&gt;</div><div class="line">&lt;/destinationInterceptors&gt;</div></pre></td></tr></table></figure></p>
<h3 id="mirrored-Queues"><a href="#mirrored-Queues" class="headerlink" title="mirrored Queues"></a>mirrored Queues</h3><p>每个queue中的消息只能被一个 consumer 消费。然而，有时候你可能希望能够监视生产者和消费者之间的消息流。你可以通过使用 Virtual Destinations 来建立一个 virtual queue 来把消息转发到多个 queues 中。但是 为系统中每个queue 都进行如此的配置可能会很麻烦。<br>ActiveMQ支持 Mirrored Queues。Broker 会把发送到某个 queue 的所有消息转发到一个名称类似的 topic，因此监控程序可以订阅这个 mirrored queue topic。为了启用Mirrored Queues，首先要将 BrokerService 的useMirroredQueues属性设置成  true ，然后可以通过destinationInterceptors设置其它属性，如mirror topic的前缀，缺省是”VirtualTopic.Mirror.” 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.org/config/1.0"</span> brokerName=<span class="string">"MirroredQueuesBroker1"</span> useMirroredQueues=<span class="string">"true"</span>&gt; &gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line"> &lt;destinationInterceptors&gt;</div><div class="line"> &lt;mirroredQueue copyMessage = <span class="string">"true"</span> prefix=<span class="string">"Mirror.Topic"</span> /&gt;</div><div class="line"> &lt;/destinationInterceptors&gt;</div><div class="line">&lt;/broker&gt;</div><div class="line">BrokerService answer = new BrokerService();</div><div class="line">answer.setUseMirroredQueues(<span class="literal">true</span>);</div><div class="line">answer.setPersistent(isPersistent());</div><div class="line">answer.addConnector(<span class="built_in">bind</span>Address);</div><div class="line"><span class="built_in">return</span> answer;</div></pre></td></tr></table></figure></p>
<h3 id="Wildcards-Desitination"><a href="#Wildcards-Desitination" class="headerlink" title="Wildcards Desitination"></a>Wildcards Desitination</h3><p>Wildcards 用来支持联合的名字分层体系（federated name hierarchies）。它不是 JMS 规范的一部分， 而是 ActiveMQ 的扩展。 ActiveMQ 支持以下三种 wildcards：<br>“.” 用于作为路径上名字间的分隔符。<br>“*“ 用于匹配路径上的任何名字。<br>“&gt;” 用于递归地匹配任何以这个名字开始的 destination。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PRICE.STOCK.NASDAQ.IBM （IBM 在 NASDAQ 的股价）</div><div class="line">PRICE.STOCK.NYSE.SUNW （SUN 在纽约证券交易所的股价）</div><div class="line">PRICE.&gt; :Any price <span class="keyword">for</span> any product on any exchange</div><div class="line">PRICE.STOCK.NASDAQ.* :Any stock price on NASDAQ</div><div class="line">PRICE.STOCK.*.IBM :Any IBM stock price on any exchange</div></pre></td></tr></table></figure></p>
<h3 id="virtual-Topic"><a href="#virtual-Topic" class="headerlink" title="virtual Topic"></a>virtual Topic</h3><p>虚拟主题，它创建一个逻辑地址并且使用户在客户端可以使用生产者和消费者消息在多个物理地址上关联起来，提高更解耦的消息配置。<br>最好的场景就是应用在发布/订阅上，允许生产者根本无需知道订阅该消息的消费者的数量。<br>ActiveMQ中，topic只有在持久订阅（durablesubscription）下是持久化的。存在持久订阅时，每个持久订阅者，都相当于一个持久化的queue的客户端，它会收取所有消息。这种情况下存在两个问题：<br>1.同一应用内consumer端负载均衡的问题：同一个应用上的一个持久订阅不能使用多个consumer来共同承担消息处理功能。因为每个都会获取所有消息。queue模式可以解决这个问题，broker端又不能将消息发送到多个应用端。所以，既要发布订阅，又要让消费者分组，这个功能jms规范本身是没有的。<br>2.同一应用内consumer端failover的问题：由于只能使用单个的持久订阅者，如果这个订阅者出错，则应用就无法处理消息了，系统的健壮性不高。<br>为了解决这两个问题，ActiveMQ中实现了虚拟Topic的功能。使用起来非常简单。对于消息发布者来说，就是一个正常的Topic，名称以VirtualTopic.开头。例如VirtualTopic.TEST。<br>对于消息接收端来说，是个队列，不同应用里使用不同的前缀作为队列的名称，即可表明自己的身份即可实现消费端应用分组。例如Consumer.A.VirtualTopic.TEST，说明它是名称为A的消费端，同理Consumer.B.VirtualTopic.TEST说明是一个名称为B的客户端。可以在同一个应用里使用多个consumer消费此queue，则可以实现上面两个功能。又因为不同应用使用的queue名称不同（前缀不同），所以不同的应用中都可以接收到全部的消息。每个客户端相当于一个持久订阅者，而且这个客户端可以使用多个消费者共同来承担消费任务。<br>使用同样queue名称的消费者会平分所有消息。<br><a href="http://blog.csdn.net/paul_wei2008/article/details/51252255" target="_blank" rel="external">http://blog.csdn.net/paul_wei2008/article/details/51252255</a></p>
<h3 id="队列选项"><a href="#队列选项" class="headerlink" title="队列选项"></a>队列选项</h3><p>consumer.prefetchSize    不定    consumer持有的未确认最大消息数量<br>consumer.maximumPendingMessageLimit    0    控制非持久主题在慢消费（slow consumer）情况下丢弃消息的最大数量。<br>consumer.noLocal    false<br>consumer.dispatchAsync    true    是否异步分发，参见 dispatch messages asynchronously。<br>consumer.retroactive    false    是否为回溯消费者 Retroactive Consumer.<br>consumer.selector    null    JMS Selector.<br>consumer.exclusive    false    是否为独占消费者 Exclusive Consumer.<br>consumer.priority    0    配置消费者优先级 Consumer Priority.</p>
<h2 id="Message-dispatching-Features"><a href="#Message-dispatching-Features" class="headerlink" title="Message dispatching Features"></a>Message dispatching Features</h2><h3 id="Message-cursor（消息游标）"><a href="#Message-cursor（消息游标）" class="headerlink" title="Message cursor（消息游标）"></a>Message cursor（消息游标）</h3><p>当 producer 发送的持久化消息到达 broker 之后， broker 首先会把它保存在持久存储中。接下来，如果发现当前有活跃的 consumer，而且这个 consumer 消费消息的速度能跟上 producer 生产消息的速度，那么 ActiveMQ 会直接把消息传递给broker 内部跟这个 consumer 关联的 dispatch queue；如果当前没有活跃的consumer 或者 consumer 消费消息的速度跟不上 producer 生产消息的速度，那么ActiveMQ 会使用 Pending Message Cursors 保存对消息的引用。在需要的时候，Pending Message Cursors 把消息引用传递给 broker 内部跟这个 consumer 关联的dispatch queue。<br>总共分为三种消息游标：<br>Store-based cursors<br>broker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。<br>VM cursors<br>若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。<br>File-based cursors<br>对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到临时文件中。<br>Activemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。.</p>
<h3 id="严格调度策略"><a href="#严格调度策略" class="headerlink" title="严格调度策略"></a>严格调度策略</h3><p>有时候需要保证不同的 topic consumer 以相同的顺序接收消息。通常ActiveMQ 会保证 topic consumer 以相同的顺序接收来自同一个 producer 的消息。然而，由于多线程和异步处理，不同的 topic consumer 可能会以不同的顺序接收来自不同 producer 的消息。例如有两个 producer，分别是 P 和 Q。差不多是同一时间内，P 发送了 P1、P2 和 P3 三个消息；Q 发送了 Q1 和 Q2 两个消息。两个不同的 consumer 可能会以以下顺序接收到消息：<br>consumer1: P1 P2 Q1 P3 Q2<br>consumer2: P1 Q1 Q2 P2 P3<br>Strict order dispatch policy 会保证每个 topic consumer 会以相同的顺序接收消息， 代价是性能上的损失。 以下是采用了strict order dispatch policy后，两个不同的 consumer 可能以以下的顺序接收消息：<br>consumer1: P1 P2 Q1 P3 Q2<br>consumer2: P1 P2 Q1 P3 Q2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;destinationPolicy&gt;</div><div class="line"> &lt;policyMap&gt;</div><div class="line"> &lt;policyEntries&gt;</div><div class="line"> &lt;policyEntry topic=<span class="string">"FOO"</span>&gt;</div><div class="line"> &lt;dispatchPolicy&gt;</div><div class="line"> &lt;strictOrderDispatchPolicy  /&gt;</div><div class="line"> &lt;/dispatchPolicy&gt;</div><div class="line"> &lt;/policyEntry&gt;</div><div class="line"> &lt;/policyEntries&gt;</div><div class="line"> &lt;/policyMap&gt;</div><div class="line"> &lt; /destinationPolicy&gt;</div></pre></td></tr></table></figure></p>
<h3 id="轮询分发策略"><a href="#轮询分发策略" class="headerlink" title="轮询分发策略"></a>轮询分发策略</h3><p>ActiveMQ 的缺省参数是针对处理大量消息时的高性能和高吞吐量而设置的。所以缺省的 prefetch 参数比较大，而且缺省的 dispatch policies 会尝试尽可能快的填满 prefetch 缓冲。 然而在有些情况下，例如只有少量的消息而且单个消息的处理时间比较长，那么在缺省的 prefetch 和dispatch policies 下，这些少量的消息总是倾向于被分发到个别的 consumer 上。这样就会因为负载的不均衡分配而导致处理时间的增加。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dispatchPolicy&gt;</div><div class="line">&lt;roundRobinDispatchPolicy  /&gt;</div><div class="line">&lt;/dispatchPolicy&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Configure-Startup-Destinations"><a href="#Configure-Startup-Destinations" class="headerlink" title="Configure Startup Destinations"></a>Configure Startup Destinations</h3><p>启动时 JMS 地址配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;destinations&gt;</div><div class="line">&lt;queue physicalName=<span class="string">"FOO.BAR"</span> /&gt;</div><div class="line">&lt;topic physicalName=<span class="string">"SOME.TOPIC"</span> /&gt;</div><div class="line">&lt;/destinations&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Async-sends"><a href="#Async-sends" class="headerlink" title="Async sends"></a>Async sends</h3><p>Acivemq 支持异步和同步发送消息。在 ActiveMQ4.0 以上，所有的异步或同步对于 Consumer 来说是变得可配置了。默认是在 ConnectionFactory、Connection、Connection URI 等方面配置对于一个基于 Destination 的 Consumer 来说。<br>ActiveMQ 默认设置 dispatcheAsync=true 是最好的性能设置。如果你处理的是Slow Consumer 则使用 dispatcheAsync=true，反之，那你使用的是 Fast Consumer则使用 dispatcheAsync=false<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cf = new ActiveMQConnectionFactory( <span class="string">"tcp://locahost:61616?jms.useAsyncSend= true "</span> );</div></pre></td></tr></table></figure></p>
<h3 id="Optimized-Acknowledgement"><a href="#Optimized-Acknowledgement" class="headerlink" title="Optimized Acknowledgement"></a>Optimized Acknowledgement</h3><p>ActiveMQ缺省支持批量确认消息。由于批量确认会提高性能，因此这是缺省的确认方式。如果希望在应用程序中禁止经过优化的确认方式，那么可以采用如下方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cf = new ActiveMQConnectionFactory(<span class="string">"tcp://locahost:61616?jms.optimizeAcknowledge=false"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Producer-Flow-Control"><a href="#Producer-Flow-Control" class="headerlink" title="Producer Flow Control"></a>Producer Flow Control</h3><p>同步发送消息的producer会自动使用producer flow control ；对于异步发送消息的producer，要使用producer flow control，你先要为connection配置一个ProducerWindowSize参数.ProducerWindowSize 是 producer 在发送消息的过程中， 收到 broker 对于之前发送消息的确认之前， 能够发送消息的最大字节数</p>
<h2 id="Message-Feature"><a href="#Message-Feature" class="headerlink" title="Message Feature"></a>Message Feature</h2><h3 id="Blob-Message"><a href="#Blob-Message" class="headerlink" title="Blob Message"></a>Blob Message</h3><p>配置其地址：包括其上传的 url 的地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tcp://localhost:61616?jms.blobTransferPolicy.uploadUrl=http://foo.com</div><div class="line">方式一：</div><div class="line">BlobMessage message = session.createBlobMessage(new URL(<span class="string">"http://some.shared.site.com"</span>);</div><div class="line">producer.send(message);</div><div class="line">// lets use a <span class="built_in">local</span> file</div><div class="line">方式二：</div><div class="line">BlobMessage message = session.createBlobMessage(new File(<span class="string">"/foo/bar"</span>);</div><div class="line">producer.send(message);</div><div class="line">// lets use a stream</div><div class="line">InputStream <span class="keyword">in</span> = ...;</div><div class="line">BlobMessage message = session.createBlobMessage(<span class="keyword">in</span>);</div><div class="line">producer.send(message);</div><div class="line"></div><div class="line">BlobMessage blobMessage = (BlobMessage) message;</div><div class="line">InputStream <span class="keyword">in</span> = blobMessage.getInputStream();</div></pre></td></tr></table></figure></p>
<h3 id="Advisory-Message"><a href="#Advisory-Message" class="headerlink" title="Advisory Message"></a>Advisory Message</h3><p>ActiveMQ 自身的系统消息地址.我们可以监听该地址来获取 activemq 的系统信息.</p>
<h3 id="ActiveMQ-Stream"><a href="#ActiveMQ-Stream" class="headerlink" title="ActiveMQ Stream"></a>ActiveMQ Stream</h3><p><img src="/2017/12/19/activemq先进特性/stream1.png" alt=""><br><img src="/2017/12/19/activemq先进特性/stream2.png" alt=""></p>
<h3 id="Transformer-message"><a href="#Transformer-message" class="headerlink" title="Transformer message"></a>Transformer message</h3><p>有时候需要在JMS provider内部进行message 的转换</p>
<h2 id="Consumer-Features"><a href="#Consumer-Features" class="headerlink" title="Consumer Features"></a>Consumer Features</h2><h3 id="exclusive-consumer"><a href="#exclusive-consumer" class="headerlink" title="exclusive consumer"></a>exclusive consumer</h3><p>Queue 中的消息是按照顺序被分发到 consumers 的。然而，当你有多个consumers 同时从相同的 queue 中提取消息时，你将失去这个保证。因为这些消息是被多个线程并发的处理。有的时候，保证消息按照顺序处理是很重要的。例如，你可能不希望在插入订单操作结束之前执行更新这个订单的操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue = new ActiveMQQueue(<span class="string">"TEST.QUEUE?consumer.exclusive=true"</span>);</div><div class="line">consumer = session.createConsumer(queue);</div></pre></td></tr></table></figure></p>
<p>如果存在 Exclusive Consumer 和普通的 Consumer，那么 Broker 会首先把消息发送给 Exclusive Consumer。除非该独有消费者死亡。</p>
<h3 id="Message-Group"><a href="#Message-Group" class="headerlink" title="Message Group"></a>Message Group</h3><p>它是 Exclusive Consumer功能的增强。逻辑上，Message Groups 可以看成是一种并发的 Exclusive Consumer。跟所有的消息都由唯一的 consumer 处理不同，JMS 消息属性JMSXGroupID 被用来区分 message group。Message Groups 特性保证所有具有相同 JMSXGroupID 的消息会被分发到相同的 consumer（只要这个consumer保持active）。另外一方面，Message Groups 特性也是一种负载均衡的机制。在一个消息被分发到 consumer 之前，broker 首先检查消息 JMSXGroupID属性。如果存在，那么 broker 会检查是否有某个consumer 拥有这个 message group。如果没有，那么 broker 会选择一个consumer，并将它关联到这个message group。此后，这个 consumer 会接收这个 message group 的所有消息，直到：<br>1.Consumer 被关闭。<br>2.Message group被关闭。通过发送一个消息，并设置这个消息的JMSXGroupSeq为-1</p>
<h4 id="创建一个message-groups"><a href="#创建一个message-groups" class="headerlink" title="创建一个message groups"></a>创建一个message groups</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div></pre></td></tr></table></figure>
<h4 id="关闭一个message-groups"><a href="#关闭一个message-groups" class="headerlink" title="关闭一个message groups"></a>关闭一个message groups</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div><div class="line">message.setIntProperty(<span class="string">"JMSXGroupSeq"</span>, -1);</div></pre></td></tr></table></figure>
<h3 id="JMS-Selectors"><a href="#JMS-Selectors" class="headerlink" title="JMS Selectors"></a>JMS Selectors</h3><p>JMS Selectors 用于在订阅中，基于消息属性和 Xpath 语法对进行消息的过滤</p>
<h3 id="消息重发与死信管理"><a href="#消息重发与死信管理" class="headerlink" title="消息重发与死信管理"></a>消息重发与死信管理</h3><p>出现以下情况时，消息会被redelivered（重发）:</p>
<ul>
<li>使用一个事务session，并且调用了rollback方法.</li>
<li>一个事务session，关闭之前调用了commit.</li>
<li>在session中使用CLIENT_ACKNOWLEDGE签收模式，并且调用了Session.recover方法.<br>当消息试图被传递的次数是配置中 maximumRedeliveries 属性的值时，那么，broker 会任何该消息是一个死消息，并被把该消息发送到死队列中。默认，aciaveMQ 中死队列被声明为“ActivemMQ.DLQ” ，所有不能消费的消息被传递到该死队列中。<br>有时需要直接删除过期的消息而不需要发送到死队列中,xml可以使用属性processExpired=false来设置。<br>存放非持久消息到死队列中;默认情况下，Activemq 不会把非持久的死消息发送到死队列中。如果你想把非持久的消息发送到死队列中，需要设置属性processNonPersistent=“true”<h3 id="consumer-priority"><a href="#consumer-priority" class="headerlink" title="consumer priority"></a>consumer priority</h3>JMS JMSPriority 定义了十个消息优先级值， 0 是最低的优先级， 9 是最高的优先级。另外，客户端应当将0‐4 看作普通优先级，5‐9 看作加急优先级。<br>Consumer 的 Priority 的划分为 0~127 个级别，127 是最高的级别，0 是最低<br>的也是 ActiveMQ 默认的。<br>这种配置可以是 Broker 根据 Consumer 的优先级来发送消息先到较高的优先级的 Consumer 上，如果某个较高的 Consumer 的缓存预先被消息装载慢，则Broker 会把消息发送到仅次于它优先级的 Consumer 上.<h3 id="slow-consumer-handling"><a href="#slow-consumer-handling" class="headerlink" title="slow consumer handling"></a>slow consumer handling</h3>ActiveMQ通过prefetch机制来提高性能，这意味这客户端的内存里可能会缓存一定数量的消息。缓存消息的数量由prefetch limit来控制。当某个consumer的prefetch buffer已经达到上限，那么broker不会再向consumer分发消息，直到consumer向broker发送消息的确认。<h3 id="consumer-dispatcher-Async"><a href="#consumer-dispatcher-Async" class="headerlink" title="consumer dispatcher Async"></a>consumer dispatcher Async</h3>在 activemq4.0 以后， 你肯能选择 broker 执行同步或异步的方法消息给消费者。<br>默认是 true<h3 id="Retroactive-Consumer"><a href="#Retroactive-Consumer" class="headerlink" title="Retroactive Consumer"></a>Retroactive Consumer</h3>消费者回溯消息</li>
</ul>
<ol>
<li>这种策略限制在基于一个静态的计数中对于主题 （Topic） 消息缓存的数量。</li>
<li>这种策略限制在内存使用量中对于主题（Topic）消息缓存的数量</li>
<li>仅仅保持发送到主题（Topic）的最后一个消息。</li>
<li>不保存主题消息，不需要任何配置</li>
<li>基于一个 JMS 属性选择器应用到所有的消息来设置其消息缓存的大小</li>
<li>基于应用到每个消息的过期时间来限制其消息缓存数量。提示这种消息的生命周期时间来源于消息发送者设置其 timeToLive 参数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;先进特性&quot;&gt;&lt;a href=&quot;#先进特性&quot; class=&quot;headerlink&quot; title=&quot;先进特性&quot;&gt;&lt;/a&gt;先进特性&lt;/h1&gt;&lt;h2 id=&quot;Destination-Features&quot;&gt;&lt;a href=&quot;#Destination-Features&quot; cla
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>为大量并发应用程序部署ActiveMQ</title>
    <link href="http://yoursite.com/2017/12/19/%E4%B8%BA%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2ActiveMQ/"/>
    <id>http://yoursite.com/2017/12/19/为大量并发应用程序部署ActiveMQ/</id>
    <published>2017-12-19T13:49:38.000Z</published>
    <updated>2017-12-19T14:57:15.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h2><p>垂直扩展是一种用于增加单个ActiveMQ broker可以处理的连接数（因此增加负载）的技术。默认情况下，ActiveMQ broker设计为尽可能高效地移动消息，以确保低延迟和良好的性能。但是我们可以做一些配置调整，以确保ActiveMQ broker可以处理大量的并发连接和大量的队列。<br>默认情况下，ActiveMQ将使用阻塞I/O来处理传输连接。 这导致每个连接使用一个线程。 我们可以在ActiveMQ broker上使用非阻塞I/O（而客户端上仍然使用默认传输）来减少使用的线程数。broker的非阻塞I/O配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker&gt;</div><div class="line">    &lt;transportConnectors&gt;</div><div class="line">        &lt;transportConnector name=<span class="string">"nio"</span> uri=<span class="string">"nio://localhost:61616"</span>/&gt;</div><div class="line">    &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>除了每个连接使用一个线程来阻塞I/O外，ActiveMQ broker可以使用线程为每个客户端连接分派消息。可以通过将名为org.apache.activemq.UseDedicatedTaskRunner的系统属性设置为false，让ActiveMQ使用线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACTIVEMQ_OPTS=<span class="string">"-Dorg.apache.activemq.UseDedicatedTaskRunner=false"</span></div></pre></td></tr></table></figure></p>
<p>确保ActiveMQ broker具有足够的内存来处理大量并发连接有两步过程。<br>首先，需要确保启动ActiveMQ broker的JVM配置了足够的内存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACTIVEMQ_OPTS=<span class="string">"-Xmx1024M \-Dorg.apache.activemq.UseDedicatedTaskRunner=false"</span></div></pre></td></tr></table></figure></p>
<p>确保专门为ActiveMQ broker在JVM配置适当的内存量。此调整通过&lt; system-Usage &gt;元素的limit属性进行。（最好从512MB开始，如果测试不够再往上加）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;systemUsage&gt;</div><div class="line">    &lt;systemUsage&gt;</div><div class="line">        &lt;memoryUsage&gt;</div><div class="line">            &lt;memoryUsage <span class="built_in">limit</span>=<span class="string">"512 mb"</span>/&gt;</div><div class="line">        &lt;/memoryUsage&gt;</div><div class="line">        &lt;storeUsage&gt;</div><div class="line">            &lt;storeUsage <span class="built_in">limit</span>=<span class="string">"10 gb"</span> name=<span class="string">"foo"</span>/&gt;</div><div class="line">        &lt;/storeUsage&gt;</div><div class="line">        &lt;tempUsage&gt;</div><div class="line">            &lt;tempUsage <span class="built_in">limit</span>=<span class="string">"1 gb"</span>/&gt;</div><div class="line">        &lt;/tempUsage&gt;</div><div class="line">    &lt;/systemUsage&gt;</div><div class="line">&lt;/systemUsage&gt;</div></pre></td></tr></table></figure></p>
<p>还应该降低每一个连接的CPU负载，如果使用的OpenWire连接方式，禁用紧密编码，否则会使得CPU过度紧张。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String uri = <span class="string">"failover://(tcp://localhost:61616?"</span> + <span class="string">" wireFormat.tightEncodingEnabled=false)"</span>;</div><div class="line">ConnectionFactory cf = new ActiveMQConnectionFactory(uri);</div></pre></td></tr></table></figure></p>
<p>前面研究的是broker怎么调整去处理数千个连接，下面开始研究的是怎么调整broker去处理数千个队列。<br>默认队列配置使用单独的线程来将消息从消息存储区分页到队列中，以便分发给感兴趣的消息消费者。 对于大量队列，建议通过为所有队列启用optimize-Dispatch属性来禁用此功能，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;destinationPolicy&gt;</div><div class="line">    &lt;policyMap&gt;</div><div class="line">        &lt;policyEntries&gt;</div><div class="line">            &lt;policyEntry queue=<span class="string">"&gt;"</span> optimizedDispatch=<span class="string">"true"</span>/&gt;</div><div class="line">        &lt;/policyEntries&gt;</div><div class="line">    &lt;/policyMap&gt;</div><div class="line">&lt;/destinationPolicy&gt;</div></pre></td></tr></table></figure></p>
<p>为了确保不仅可以扩展到数千个连接，而且还可以扩展到数万个队列，使用JDBC消息存储库或更新和更快的KahaDB消息存储库。 KahaDB默认情况下在ActiveMQ中启用。</p>
<p>到目前为止，我们已经考虑了扩展连接，减少线程使用，并选择正确的消息存储。 调整用于扩展的ActiveMQ的示例配置如以下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"amq-broker"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span>&gt;</div><div class="line">    &lt;persistenceAdapter&gt;</div><div class="line">        &lt;kahaDB directory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span> journalMaxFileLength=<span class="string">"32mb"</span>/&gt;</div><div class="line">    &lt;/persistenceAdapter&gt;</div><div class="line">    &lt;destinationPolicy&gt;</div><div class="line">        &lt;policyMap&gt;</div><div class="line">            &lt;policyEntries&gt;</div><div class="line">                &lt;policyEntry queue=<span class="string">"&amp;gt;"</span> optimizedDispatch=<span class="string">"true"</span>/&gt;</div><div class="line">            &lt;/policyEntries&gt;</div><div class="line">        &lt;/policyMap&gt;</div><div class="line">    &lt;/destinationPolicy&gt;</div><div class="line">    &lt;systemUsage&gt;</div><div class="line">        &lt;systemUsage&gt;</div><div class="line">            &lt;memoryUsage&gt;</div><div class="line">                &lt;memoryUsage <span class="built_in">limit</span>=<span class="string">"512 mb"</span>/&gt;</div><div class="line">            &lt;/memoryUsage&gt;</div><div class="line">            &lt;storeUsage&gt;</div><div class="line">                &lt;storeUsage <span class="built_in">limit</span>=<span class="string">"10 gb"</span> name=<span class="string">"foo"</span>/&gt;</div><div class="line">            &lt;/storeUsage&gt;</div><div class="line">            &lt;tempUsage&gt;</div><div class="line">                &lt;tempUsage <span class="built_in">limit</span>=<span class="string">"1 gb"</span>/&gt;</div><div class="line">            &lt;/tempUsage&gt;</div><div class="line">        &lt;/systemUsage&gt;</div><div class="line">    &lt;/systemUsage&gt;</div><div class="line">    &lt;transportConnectors&gt;</div><div class="line">        &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"nio://localhost:61616"</span>/&gt;</div><div class="line">    &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h2><p>除了扩展单个broker之外，还可以使用networks来增加可用于应用程序的ActiveMQ broker的数量。 由于networks会自动将消息传递给具有感兴趣的消费者的连接broker，因此可以将客户端配置为连接到一个broker集群，随机选择一个来连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover://(tcp://broker1:61616,tcp://broker2:61616)?randomize=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>为了确保队列或持久主题订阅者的消息不会在broker上孤立，需要将network配置为使用dynamicOnly和低网络prefetchSize<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnector uri=<span class="string">"static://(tcp://remotehost:61617)"</span></div><div class="line">    name=<span class="string">"bridge"</span></div><div class="line">    dynamicOnly=<span class="string">"true"</span></div><div class="line">    prefetchSize=<span class="string">"1"</span>&gt;</div><div class="line">&lt;/networkConnector&gt;</div></pre></td></tr></table></figure></p>
<p>使用network进行水平扩展会带来更多的延迟，因为潜在的消息必须在分发给消费者之前通过多个broker。</p>
<h2 id="流量分区"><a href="#流量分区" class="headerlink" title="流量分区"></a>流量分区</h2><p>客户端流量分割是垂直和水平分割的混合。 通常不使用network，因为客户端应用程序决定什么流量应该到哪个broker上。 客户端应用程序必须维护多个JMS连接，并决定哪些JMS连接应用于哪些目标。<br>不直接使用network connection的优点是，减少在brokers之间转发消息的开销。 需要平衡这与导致典型应用程序的额外复杂性<br><img src="/2017/12/19/为大量并发应用程序部署ActiveMQ/流量分区.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;垂直扩展&quot;&gt;&lt;a href=&quot;#垂直扩展&quot; class=&quot;headerlink&quot; title=&quot;垂直扩展&quot;&gt;&lt;/a&gt;垂直扩展&lt;/h2&gt;&lt;p&gt;垂直扩展是一种用于增加单个ActiveMQ broker可以处理的连接数（因此增加负载）的技术。默认情况下，ActiveMQ
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 笔记一</title>
    <link href="http://yoursite.com/2017/12/15/Apache-ActiveMQ-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/15/Apache-ActiveMQ-笔记/</id>
    <published>2017-12-15T01:52:52.000Z</published>
    <updated>2017-12-19T13:45:59.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>面向消息的中间件：Message-oriented Middleware, MOM<br>基本功能：将信息以消息的形式，从一个应用程序传送到另一个或多个应用程序。<br>主要特点：</p>
<ul>
<li>消息异步接受，类似手机短信的行为，消息发送者不需要等待消息接受者的响应，减少软件多系统集成的耦合度。</li>
<li>消息可靠接收，确保消息在中间件可靠保存，只有接收方收到后才删除消息，多个消息也可以组成原子事务。</li>
</ul>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>java message service</p>
<h3 id="JMS规范"><a href="#JMS规范" class="headerlink" title="JMS规范"></a>JMS规范</h3><p>java消息服务定义了java中访问消息中间件的接口。JMS只是接口，并没有实现，实现JMS的接口的消息中间件称为JMS Provider，例如ActiveMQ。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>JMS Provider：实现JMS接口的消息中间件<br>PTP：point to point，即点对点模型<br>pub/sub：publish/subscribe，即发布/订阅消息模型<br>Queue：队列目标<br>Topic：主题目标<br>ConnectionFactory：连接工厂，JMS用它来创建连接<br>Connection：JMS客户端到JMS provider的连接<br>Destination：消息的目的地<br>Session：会话，一个发送或接收消息的线程<br>MessageProducer：由session对象创建用来发送消息的对象<br>MessageConsumer：由session对象创建用来接收消息的对象<br>Acknowledge：签收<br>Transaction：事务</p>
<h3 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h3><p>在 JMS 编程模型中，JMS 客户端（组件或应用程序）通过 JMS 消息服务交换消息。消息生产者将消息发送至消息服务，消息消费者则从消息服务接收这些消息。这些消息传送操作是使用一组实现 JMS 应用编程接口 (API) 的对象 （由 JMS Provide 提供）来执行的。<br>在 JMS 编程模型中，JMS 客户端使用 ConnectionFactory 对象创建一个连接，向消息服务发送消息以及从消息服务接收消息均是通过此连接来进行。Connection是客户端与消息服务的活动连接。创建连接时，将分配通信资源以及验证客户端。这是一个相当重要的对象，大多数客户端均使用一个连接来进行所有的消息传送。连接用于创建会话。Session 是一个用于生成和使用消息的单线程上下文。它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。客户端使用 MessageProducer 向指定的物理目标 （在 API 中表示为目标身份对象）发送消息。<br>生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息。同样，客户端使用 MessageConsumer 对象从指定的物理目标（在 API 中表示为目标对象）接收消息。消费者可使用消息选择器，借助它，消息服务可以只向消费者发送与选择标准匹配的那些消息。消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 MessageListener 来实现。当会话线程调用 MessageListener 对象的 onMessage 方法时，客户端将使用消息。</p>
<h3 id="JMS编程域"><a href="#JMS编程域" class="headerlink" title="JMS编程域"></a>JMS编程域</h3><p>JMS接收两种截然不同的消息传送模型PTP和Pub/Sub</p>
<ul>
<li>PTP<br>消息从一个生产者传送给一个消费者。在此传送模型中，目标是一个队列。消息首先传送到队列目标，然后根据队列传送策略，从该队列将消息传送到这队列进行注册的某一个消费者，一次只传送一条消息。可以向队列目标发送消息的生产者的数量没有限制，但每条消息只能发送至、并由一个消费者成功使用。如果没有已经向队列目标注册的消费者，队列将保留它收到的消息，并在某个消费者向该队列进行注册时将消息传送给该消费者。</li>
<li>Pub/Sub<br>消息从一个生产者传送至任意数量的消费者。在此传送模型中，目标是一个主题。消息首先被传送至主题目标，然后传送至所有已订阅此主题的活动消费者。可以向主题目标发送消息的生产者的数量没有限制，并且每个消息可以发送至任意数量的订阅消费者。主题目标也支持持久订阅的概念。持久订阅表示消费者已向主题目标进行注册，但在消息传送时此消费者可以处于非活动状态。当此消费者再次处于活动状态时，它将接收此信息。如果没有已经向主题目标注册的消费者，主题不保留其接收到的消息，除非有非活动消费者注册了持久订阅</li>
</ul>
<h2 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h2><p>JMS消息由消息头、属性和消息体组成</p>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>消息头包含消息的识别信息和路由信息，消息头包含一些标准的属性如JMSDestination、JMSMessageID<br>JMSDestination<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/jms消息结构.png" alt=""><br>JMSDestination(自动)：消息发送的目的地主要指Queue和Topic<br>JMSDeliveryMode（自动）：传送模式有两种模式：持久模式和非持久模式，一条持久性消息应该被传递一次仅仅一次，这就意味着如果JMS提供者出现故障，该消息不会丢失，它会在服务器恢复之后再次传递。<br>JMSExpiration（自动）：消息过期时间，等于Destination 的send 方法的timeToLive值加上发送时刻的GMT 时间值。如果timeToLive值等于零则JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除<br>JMSPriority(自动):消息优先级， 从 0-9 十个级别，0-4 是普通消息，5-9 是加急消息。JMS 不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达。默认是4级。<br>JMSMessageID（自动）：唯一识别每个消息的标识，由JMS Provider 产生。<br>JMSTimestamp（自动）：一个JMS Provider在调用send()方法时自动设置的。它是消息被发送和消费者实际接收的时间差。自动分配。<br>JMSCorrelationID（开发者设置）：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对 JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。<br>JMSReplyTo（开发者设置）：提供本消息回复消息的目的地址。<br>JMSType（开发者设置）：消息类型的识别符。由开发者设置<br>JMSRedelivered(自动)：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收 (acknowledged)。如果该消息被重新传送，JMSRedelivered=true反之，JMSRedelivered =false。</p>
<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>TextMessage:java.lang.String 对象，如xml 文件内容<br>MapMessage:名/值对的集合，名是String 对象，值类型可以是Java 任何基本类型。<br>ByteMessage:字节流<br>StreamMessage：java输入输出流<br>ObjectMessage：java中可序列化对象</p>
<h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><h4 id="应用程序特定的属性"><a href="#应用程序特定的属性" class="headerlink" title="应用程序特定的属性"></a>应用程序特定的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextMessage message=session.createTextMessage();</div><div class="line">message.setStringProperty(<span class="string">"username"</span>,username);</div></pre></td></tr></table></figure>
<h4 id="JMS定义的属性"><a href="#JMS定义的属性" class="headerlink" title="JMS定义的属性"></a>JMS定义的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div><div class="line">message.setIntProperty(<span class="string">"JMSXGroupSeq"</span>, -1);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名字</th>
<th>类型</th>
<th>设置者</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>JMSXUserID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送时的用户标识</td>
</tr>
<tr>
<td>JMSXAppID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送消息的应用标识</td>
</tr>
<tr>
<td>JMSXDeliveryCount</td>
<td>int</td>
<td>发送时提供商设置</td>
<td>转发消息重试次数，第一次是1，第二次是2</td>
</tr>
<tr>
<td>JMSXGroupID</td>
<td>String</td>
<td>客户端</td>
<td>消息所在消息组的标识</td>
</tr>
<tr>
<td>JMSXGroupSeq</td>
<td>int</td>
<td>客户端</td>
<td>组内消息的序号第一个消息是1，第二个是2</td>
</tr>
<tr>
<td>JMSXProducerTXID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>产生消息时的事务的事务标识</td>
</tr>
<tr>
<td>JMSXConsumerTXID</td>
<td>String</td>
<td>接收时提供商设置</td>
<td>接收消息的事务的事务标识</td>
</tr>
<tr>
<td>JMSXRcvTimestamp</td>
<td>long</td>
<td>接收时提供商设置</td>
<td>JMS转发到消费者的消息</td>
</tr>
<tr>
<td>JMSXState</td>
<td>int</td>
<td>提供商</td>
<td>假定存在一个消息仓库，它存储了每个消息的拷贝，且这些消息从原始消息被发送开始，每个的拷贝的状态有1(等待),2（准备），3（到期）或者4（保留）。由于状态与生产者和消费者无关，所以它不是由它们来提供。它只和在仓库中查找消息相关，因此JMS没有提供这种API。</td>
</tr>
</tbody>
</table>
<h3 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h3><p>如果会话是事务性的，那么消息确认自动由commit 处理，且恢复自动由rollback 处理。如果会话不是事务性的，有三个确认选择，且手工处理恢复。</p>
<ul>
<li><p>DUPS_OK_ACKNOWLEDGE:这个选项告诉会话懒惰确认消息的传递。如果JMS失败，这很可能造成传递重复消息，因此这个选项只用于可以忍受重复消息的消费者。它的好处是减少了会话为防止重复所要做的工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.DUPS_OK_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>AUTO_ACKNOWLEDGE:使用这个选项，当消息被成功地从调用接收返回或处理消息的MessageListener 成功返回时，会话自动确认客户端的消息接收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>CLIENT_ ACKNOWLEDGE:使用这个选项，客户端通过调用消息的acknowledge方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。当使用 CLIENT_ACKNOWLEDGE 模式时，客户端可以在处理它们时产生大量未确认消息。JMS 提供商应当为管理员提供限制客户端超量运行的途径，以便客户端不会造成资源耗尽并保证当它们使用的资源被临时阻塞时造成失败。 会话的recover 方法用于停止一个会话然后使用第一个未确认消息来重新启动它。事实上，会话的被转发消息序列被重新设置到最后一个确认消息之后。现在转发的消息序列可以与起初转发的消息序列不同， 因为消息到期和收到更高优先级的消息。会话必须设置消息的redelivered 标记，表示它是由于恢复而被重新转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">conn.createTopicSession(<span class="literal">false</span>, Session.CLIENT_ACKNOWLEDGE);</div><div class="line">message.acknowledge();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="PTP模型"><a href="#PTP模型" class="headerlink" title="PTP模型"></a>PTP模型</h2><p>PTP(Point-to-Point)模型是基于队列的，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的异步传输成为可能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConnectionFactory</td>
<td>客户端用ConnectionFactory创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用session创建Message、Producer、Consumer。如果在session关闭有一些消息已经收到但还未被签收，当消费者下次再连接到相同队列时，会被再次接收。</td>
</tr>
<tr>
<td>Destination(Queue或TemporaryQueue)</td>
<td>此处的目标为队列，队列由队列名识别。临时队列只能由创建它的Connection 所创建的消费者消费，但是任何生产者都可向临时队列发送消息。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到队列中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收队列中的消息，如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>可靠性</td>
<td>队列可以长久地保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的连接状态，充分体现了异步传输模式的优势。</td>
</tr>
</tbody>
</table>
<h2 id="PUB-SUB模型"><a href="#PUB-SUB模型" class="headerlink" title="PUB/SUB模型"></a>PUB/SUB模型</h2><p>JMS Pub/Sub 模型定义了如何向一个内容节点发布和订阅消息，这些节点被称作主题。主题可以被认为是消息的传输中介，发布者(publisher)发布消息到主题，订阅者(subscribe) 从主题订阅消息。主题使得消息订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>订阅(subscription)</td>
<td>消息订阅分为非持久订阅和持久订阅，非持久订阅只有当客户端处于激活状态，也就是和JMSProvider 保持连接状态才能收到发送到某个主题的消息，而当客户端处于离线状态，这个时间段发到主题的消息将会丢失，永远不会收到。持久订阅时，客户端向JMS 注册一个识别自己身份的ID，当这个客户端处于离线时，JMS Provider 会为这个ID 保存所有发送到主题的消息，当客户再次连接到JMS Provider 时， 会根据自己的ID 得到所有当自己处于离线时发送到主题的消息</td>
</tr>
<tr>
<td>ConnectionFactory</td>
<td>客户端用 ConnectionFactory 创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用Session 创建MessageProducer 和MessageConsumer 对象。它还提供持久订阅主题，或使用unsubscribe 方法取消消息的持久订阅。</td>
</tr>
<tr>
<td>Destination(Topic和TemporaryTopic)</td>
<td>客户端用 Session 创建Destination 对象。此处的目标为主题，主题由主题名识别。临时主题只能由创建它的Connection 所创建的消费者消费。临时主题不能提供持久订阅功能。JMS 没有给出主题的组织和层次结构的定义，由JMS Provider 自己定义。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到主题中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收主题中的消息， 如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>恢复和重新派送</td>
<td>非持久订阅状态下，不能恢复或重新派送一个未签收的消息。只有持久订阅才能恢复或重新派送一个未签收的消息。</td>
</tr>
<tr>
<td>可靠性</td>
<td>当所有的消息必须被接收，则用持久订阅模式。当丢失消息能够被容忍，则用非持久订阅模式。</td>
</tr>
</tbody>
</table>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>支持并发的对象：Destination、ConnectionFactory、Connection<br>不支持并发的对象：Session、MessageProducer、MessageConsumer</p>
<h1 id="如何配置ActiveMQ"><a href="#如何配置ActiveMQ" class="headerlink" title="如何配置ActiveMQ"></a>如何配置ActiveMQ</h1><blockquote>
<blockquote>
<blockquote>
<p>Master-Slave集群：<br>由至少3个节点组成，一个Master节点，其他为Slave节点。只有Master节点对外提供服务，Slave节点处于等待状态。当主节点宕机后，从节点会推举出一个节点出来成为新的Master节点，继续提供服务。<br>优点是可以解决多服务热备的高可用问题，缺点是无法解决负载均衡和分布式的问题。<br>Broker Cluster集群：<br>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue.当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。<br>优点是可以解决负载均衡和分布式的问题。但不支持高可用。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="如何配置传输连接"><a href="#如何配置传输连接" class="headerlink" title="如何配置传输连接"></a>如何配置传输连接</h2><h3 id="格式配置如下"><a href="#格式配置如下" class="headerlink" title="格式配置如下"></a>格式配置如下</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/配置.png" alt=""></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>activeMQ 的 Broker 和 Client 之间需要一个高稳定性的通信，不难发现，TCP是一个理想的实现。所以我们并不惊讶在 ActiveMQ 频繁的使用 TCP 协议。<br>在做数据交互之前，我们需要知道必须序列化数据，消息是如何通过一个叫wire protocol 的来序列化成字节流。默认情况下，ActiveMQ 把 wire protocol 叫做OpenWire。它的目的是促使网络上的效率和数据快速交互等。默认的 Broker 配置，TCP 的 Client 监听端口是 61616。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://host:port?key=value</div></pre></td></tr></table></figure></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO 协议和 TCP 协议类似，nio 更侧重于底层的访问操作。它不同与传统的I/O 流操作。允许开发人员对同一资源可有更多的 client 调用和服务端有更多的负载。<br>以下场景使用NIO：</p>
<ul>
<li>你可能有大量的 Client 去链接到 Broker 上；<br>般情况下，大量的 Client 去链接 Broker 是被操作系统的线程数所限制的。因此，NIO 的实现比 TCP 需要更少的线程去运行，所以，建议你使用 NIO 协议。</li>
<li>你可能对于 Broker 有一个很迟钝的网络传输。<br>NIO 比 TCP 提供更好的性能。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nio://host:port?key=value</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"tcp"</span> uri=<span class="string">"tcp://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"nio"</span> uri=<span class="string">"nio://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>运行原理如下：Producer 通过 NIO 协议发送数据到 broker，Consumer 通过 TCP 协议接收数据<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/broker.png" alt=""></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP是被用在稳定可靠的场景中使用的，然而，UDP 通常用在快速数据传递和不怕数据丢失的场景中使用的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udp://hostname:port?key=value</div></pre></td></tr></table></figure></p>
<p>TCP 是一个原始的流协议，意味者数据包的传递是有保证的。UDP 则没有保证。<br>TCP 同样也是一个可靠性高的传递协议。意味者数据包不会丢失，反之，UDP 则不能保证</p>
<h3 id="Secure-Sockets-Layer-Protocol-SSL"><a href="#Secure-Sockets-Layer-Protocol-SSL" class="headerlink" title="Secure Sockets Layer Protocol(SSL)"></a>Secure Sockets Layer Protocol(SSL)</h3><p>基于 TCP 之上的安全协议</p>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://hostname:port?key=value</div></pre></td></tr></table></figure>
<h3 id="vm-protocol"><a href="#vm-protocol" class="headerlink" title="vm protocol"></a>vm protocol</h3><p>VM transport 允许在 VM 内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。第一个创建 VM 连接的客户会启动一个 embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个 broker。当这个 broker上所有的连接都关闭的时候，这个broker也会自动关闭</p>
<h2 id="如何配置网络"><a href="#如何配置网络" class="headerlink" title="如何配置网络"></a>如何配置网络</h2><p>一个ActiveMQ Broker对于你的所有的应用来说是非常实用的。但是，某些场景需要一些高级的特性。例如：高稳定性和大传输量。典型的就是用在网络中。Broker集群在多个ActiveMQ的实例中大大优化了消息的传递。这章主要是解释网络链接在 ActiveMQ 的应用，Broker 到 Broker 的通信。网络链接是以通道的形式将一个Broker 和其他的 Broker 链接起来通信。 网络链接默认是单向的， 然而， 一个 Broker在一端发送消息， 在另一 Broker 在另一端接收消息。 这就是所谓的 “桥接” 。 然而，你可能想创建一个双向的通道对于两个 Broker。他将不仅发送消息而且也能从相同的通道来接收消息。ActiveMQ 支持这种双向链接，通常作为 duplex connector来映射。如下图<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/brokers.png" alt=""></p>
<h3 id="如何配置Dynamic-Networks"><a href="#如何配置Dynamic-Networks" class="headerlink" title="如何配置Dynamic Networks"></a>如何配置Dynamic Networks</h3><h4 id="multicast协议"><a href="#multicast协议" class="headerlink" title="multicast协议"></a>multicast协议</h4><p>ActiveMQ 使用 Multicast 协议将一个 Service 和其他的 Broker 的 Service 连接起来。IP multicast是一个被用于网络中传输数据到其它一组接收者的技术。Ip multic 传统的概念称为组地址。组地址是 ip 地址在 224.0.0.0 到 239.255.255.255 之间的 ip 地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">multicast://address:port?transportOptions</div><div class="line">multicast://default</div><div class="line">multicast://224.1.2.3:6255</div><div class="line">multicast://224.1.2.3:6255?group=mygroupname</div><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"localhost"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector name=<span class="string">"default-nc"</span> uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;!-- DOS protection, <span class="built_in">limit</span> concurrent connections to 1000 and frame size to 100MB --&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"</span> discoveryUri=<span class="string">"multicast://default"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>“default”=是 activemq 默认的 ip，默认动态的寻找地址<br>“discoveryUri”=是指在 transport 中用 multicast 的 default 的地址传递。<br>“uri”=指动态寻找可利用的地址<br><em>防止自动寻找地址</em><br>1.名称为 openwire 的 transport，移除discoveryUri=”multicast://default”即可。传输链接用默认的名称 openwire 来配置 broker 的 tcp 多点链接，这将允许其它 broker 能够自动发现和链接到可用的 broker 中<br>2.名称为“default-nc”的 networkConnector，注释掉或者删除即可<br>3.使 brokerName 的名字唯一。默认是 localhost。是为了唯一识别 Broker的实例</p>
<h4 id="discovery协议"><a href="#discovery协议" class="headerlink" title="discovery协议"></a>discovery协议</h4><p>Discovery 是在 multicast 协议的功能上定义的。功能类似与 failover 功能。它将动态的发现 multicast 协议的 broker 的链接并且随机的链接其中一个 broker。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions</div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<h4 id="peer协议"><a href="#peer协议" class="headerlink" title="peer协议"></a>peer协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">peer://peergroup/brokerName?key=value</div></pre></td></tr></table></figure>
<h4 id="fanout协议"><a href="#fanout协议" class="headerlink" title="fanout协议"></a>fanout协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fanout://(fanoutUri)?key=value</div></pre></td></tr></table></figure>
<h3 id="如何配置Static-Networks"><a href="#如何配置Static-Networks" class="headerlink" title="如何配置Static Networks"></a>如何配置Static Networks</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static://(uri1,uri2)</div></pre></td></tr></table></figure>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/static.png" alt=""><br>关于以上视图，两个 Brokers 是网络链接的。Brokers 通过一个 static 的协议来创建一个链接。一个 Consumer 链接到 brokerB 的一个地址上 ，当 Producer 在brokerA 上以相同的地址发送消息时， 此时它将被转移到 brokerB 上。 这种情况下，BrokerA 转发消息到 BrokerB 上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"brokerA"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector uri=<span class="string">"static:(tcp://localhost:61617)"</span>  /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"localhost:61616"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>以上配置broker监听端口在 61617上，它定义了一个 networks 链接到 BrokerB上。以上例子，消息在 BrokerA 上被发送，消息被转发到 BrokerB 上，此时通过Consumer 来消费该消息。</p>
<h4 id="failover-protocol"><a href="#failover-protocol" class="headerlink" title="failover protocol"></a>failover protocol</h4><p>Failover 协议实现了自动重新链接的逻辑。这里有两种方式提供了稳定的brokers 列表对于 Client 链接。 第一种方式：提供一个 static 的可用的 Brokers 列表。第二种方式：提供一个 dynamic 发现的可用 Brokers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp://localhost:61616)</div></pre></td></tr></table></figure></p>
<p>对于 broker 失败 client 不需要重新去启动，而是自动的去连接其它可用的broker</p>
<h1 id="消息存储的持久化"><a href="#消息存储的持久化" class="headerlink" title="消息存储的持久化"></a>消息存储的持久化</h1><p>消息的持久化不仅支持persistence和non-persistence，还支持recovery。</p>
<h2 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/PTP.png" alt=""></p>
<h2 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/pub-sub.png" alt=""></p>
<h2 id="有效存储"><a href="#有效存储" class="headerlink" title="有效存储"></a>有效存储</h2><ul>
<li>AMQ 消息存储-默认的消息存储</li>
<li>KahaDB 消息存储-提供了容量的提升和恢复能力（5.3 以上采用）</li>
<li>JDBC 消息存储-消息基于 JDBC 存储的。</li>
<li>Memory 消息存储-基于内存的消息存储。</li>
</ul>
<h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store 是 ActiveMQ 5.0 缺省的持久化存储。它是一个基于文件、事务存储设计为快速消息存储的一个结构。AMQ 消息存储的初衷是尽可能简单的应用。它用了一个基于文件存储的消息数据库并且不依赖与第三方数据库。ActiveMQ 不会下载数据和不会运行很长时间。反之，AMQ 存储结构是以流的形式来进行消息交互的。如果 AMQ 消息存储没有配置，那么它会使用默认的配置参数。选择性的使用消息存储或者改变 AMQ 消息存储的默认行为。当然了，一个<persistenceadapter>元素必须被配置。<br>Message commands 被保存到 transactional journal（由 rolling data logs 组成）。Messages 被保存到 data logs 中，同时被 reference store 进行索引以提高存取速度。Date logs 由一些单独的 data log 文件组成， 缺省的文件大小是 32M， 如果某个消息的大小超过了 data log 文件的大小， 那么可以修改配置以增加data log 文件的大小。如果某个 data log 文件中所有的消息都被成功消费了，那么这个data log 文件将会被标记，以便在下一轮的清理中被删除或者归档。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook =<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;amqPersistenceAdapter directory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span> maxFileLength=<span class="string">"32mb"</span> /&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">&lt;/boker&gt;</div></pre></td></tr></table></figure></persistenceadapter></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/amq.png" alt=""></p>
<ol>
<li>Journal=包括一些基于消息和命令存储的回滚日志文件。 当数据文件到达最大值时，新的数据文件将会被创建。数据文件中的消息都会被映射， 如果一些消息如果不长时间使用的话， 他将会被移除或者被存档。Journal 仅仅是把当前的最新消息链接到该数据文件上即可， 所以存储相当的快.</li>
<li>Cache:能够快速的是存储在journal目录中的数据恢复到内存中。 Cache还更新当前消息 id 和定位消息在journal中存储的最新映射。映射存储被更新后，消息才被安全的从缓存中移除。在缓存更新到映射存储这个范围段内我们需要配置属性checkpoinInterval。如果ActiveMQ消息 broker 在内存达到上限时 checkpoint将会起作用。</li>
<li>Refernce：在journal中通过消息的id来映射消息。 它能够准确的从FIFO中映射其队列的数据结构和通过指针指向持久化订阅的主题消息。索引指数指的是 hash 索引。它也可以用一个内存 HashMap 类型的。</li>
</ol>
<p>使用场景：<br>AMQ 是 ActiveMQ 的默认消息存储，它提供了在执行中的负载平衡，事实上这种存储是已经在嵌入 broker 和配置 xml 的 broker 中是最理想的存储方式对于用户。<br>它对于独立的和嵌入式的 ActiveMQ 来说是由可靠的持久性依赖于持久的事务处理和高效的索引来存储使其最优化程度高。AMQ 存储的这用易操作性意味这它将被大部分应用所使用， 从高输出应用到存储大数据量的消息。</p>
<h3 id="KahaDB-Message-Store"><a href="#KahaDB-Message-Store" class="headerlink" title="KahaDB Message Store"></a>KahaDB Message Store</h3><p>KahaDB 是一种新的消息消息存储，而且解决了 AMQ 的一些不足，提高了性能。 AMQ 消息存储用两个分离的文件对于每一个索引和如果 broker 没有彻底关闭则恢复很麻烦， 所有的索引文件需要重新构建， broker 需要遍历所有的消息日志文件。<br>为了克服以上限制， KahaDB 消息存储对于它的索引用一个事务日志和仅仅用一个索引文件来存储它所有的地址。不同于 AMQ。而且在生成环境测试链接数到10000，而且每一个链接对应一个队列。<br>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在 Kaha 中，数据被追加到 data logs 中。当不再需要 log 文件中的数据的时候，log 文件会被丢弃。以下是其配置的一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;kahaPersistenceAdapter directory=<span class="string">"activemq-data"</span> maxDataFileLength=<span class="string">"33554432"</span></div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">   &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/kaha.png" alt=""><br>所有的索引文件更新的记录存在 Redo Log 中，这样就不用更新没有变化的索引数据了，仅仅更新变化的数据。额外的，KahaDB 消息存储用了一个 B-Tree 布局恰恰和 AMQ 消息存储相反，KahaBD 消息存储保持所有的索引在一个持久的 hash 表中，然而 hash 索引在时刻的变化，KahaBD 在这方面已经有了很好的性能特征<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;kahaDB directory=<span class="string">"activemq-data"</span> journalMaxFileLength=<span class="string">"32mb"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Message-Store"><a href="#JDBC-Message-Store" class="headerlink" title="JDBC Message Store"></a>JDBC Message Store</h3><p>当我们使用 JDBC 消息存储默认的驱动使用 Apache Derby 数据库。同时也支持其它关系数据库：MySQL、Oracle、SQLServer、Sybase、Informix、MaxDB.<br>JDBC 消息存储提供了三张表， 其中两种表是用于存储消息和第三张表是用于类似与排他锁似的，这样确保 ActiveMQ 仅仅由一个用户进入数据库.<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/msgs.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack1.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;persistence&gt;</div><div class="line">&lt;jdbcPersistence dataSourceRef=<span class="string">"mysql-ds"</span>/&gt;</div><div class="line">&lt;/persistence&gt;</div><div class="line">&lt;bean id=<span class="string">"mysql-ds"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"driverClassName"</span>value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost/activemq?relaxAutoCommit=true"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"username"</span> value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"password"</span>value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h3 id="jdbc-with-journal"><a href="#jdbc-with-journal" class="headerlink" title="jdbc with journal"></a>jdbc with journal</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;persistenceFactory&gt; &lt;journalPersistenceAdapterFactory journalLogFiles=<span class="string">"4"</span> journalLogFileSize=<span class="string">"32768"</span> useJournal=<span class="string">"true"</span> useQuickJournal=<span class="string">"true"</span> dataSource=<span class="string">"#derby-ds"</span> dataDirectory=<span class="string">"activemq-data"</span> /&gt;</div><div class="line">&lt;/persistenceFactory&gt;</div><div class="line">&lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>JDBC Store和JDBC Message Store with ActiveMQ Journal的区别<br>1:Jdbc with journal的性能优于jdbc<br>2:Jdbc用于master/slave模式的数据库分享<br>3:Jdbc with journal不能用于master/slave模式<br>4:一般情况下,推荐使用jdbc with journal</p>
<h3 id="memory-message-Store"><a href="#memory-message-Store" class="headerlink" title="memory message Store"></a>memory message Store</h3><p>内存消息存储主要是存储所有的持久化的消息在内存中。这里没有动态的缓存存在，所以你必须注意设置你的 broker 在 JVM 和内存限制。<br>消息存储基于 Memory，所有的消息都存储在内存里。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> persistent=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61635"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt; &lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h3 id="KahaDB、-AMQ-区别"><a href="#KahaDB、-AMQ-区别" class="headerlink" title="KahaDB、  AMQ 区别"></a>KahaDB、  AMQ 区别</h3><ol>
<li>KahaDB 克服了 AMQ 的一些不足。</li>
<li>kahaDB 性能上优于 AMQ。</li>
<li>KahaDB 用于大量的 broker【500 个以上】 。</li>
<li>AMQ 用于独立和嵌入式的 broker 比较好。</li>
<li>AMQ 在执行的性能和索引方面都比较不错。</li>
<li>kahaDB 和 AMQ 两者是独立的，谁也不包括谁。<h3 id="使用内存消息存储"><a href="#使用内存消息存储" class="headerlink" title="使用内存消息存储"></a>使用内存消息存储</h3>如果你的 broker 仅仅对于一组消息的消费是很快的，那么可以使用内存消息存储，但是他通常用于内部简单的消息测试，而不花费很多时间。或者能够在测试消息后清除消息<h1 id="如何用ActiveMQ构建应用"><a href="#如何用ActiveMQ构建应用" class="headerlink" title="如何用ActiveMQ构建应用"></a>如何用ActiveMQ构建应用</h1><h2 id="用ActiveMQ构建java应用"><a href="#用ActiveMQ构建java应用" class="headerlink" title="用ActiveMQ构建java应用"></a>用ActiveMQ构建java应用</h2><h3 id="嵌入式broker启动"><a href="#嵌入式broker启动" class="headerlink" title="嵌入式broker启动"></a>嵌入式broker启动</h3><h4 id="broker-service启动broker"><a href="#broker-service启动broker" class="headerlink" title="broker service启动broker"></a>broker service启动broker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService();</div><div class="line">broker.setUseJmx(<span class="literal">true</span>);</div><div class="line">broker.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker.start();</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="broker-factory启动"><a href="#broker-factory启动" class="headerlink" title="broker factory启动"></a>broker factory启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String Uri = <span class="string">"properties:resources/broker.properties"</span>;</div><div class="line">//默认不自动启动。</div><div class="line">// BrokerService broker1 = BrokerFactory.createBroker(Uri);</div><div class="line">BrokerService broker1 = BrokerFactory.createBroker(new URI(Uri));</div><div class="line">//<span class="string">"true"</span>表示自动启动。反之，不启动。</div><div class="line">// BrokerService broker2 = BrokerFactory.createBroker(Uri,<span class="literal">true</span>);</div><div class="line">broker1.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker1.start();</div></pre></td></tr></table></figure>
<h4 id="利用spring集成broker"><a href="#利用spring集成broker" class="headerlink" title="利用spring集成broker"></a>利用spring集成broker</h4><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/spring-broker.png" alt=""></p>
<h4 id="activeMQ嵌入到其他应用服务器中"><a href="#activeMQ嵌入到其他应用服务器中" class="headerlink" title="activeMQ嵌入到其他应用服务器中"></a>activeMQ嵌入到其他应用服务器中</h4><h1 id="ActiveMq的安全"><a href="#ActiveMq的安全" class="headerlink" title="ActiveMq的安全"></a>ActiveMq的安全</h1><h2 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h2><p>适用于简单的认证需求，或者用于建立测试环境。它允许在 XML 配置文件中指定用户、用户组和密码等信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"true"</span> persistent=<span class="string">"false"</span></div><div class="line">xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span></div><div class="line">populateJMSXUserID=<span class="string">"true"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;destinations&gt;</div><div class="line">&lt;queue physicalName=<span class="string">"TEST.Q"</span> /&gt;</div><div class="line">&lt;/destinations&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">&lt;simpleAuthenticationPlugin&gt;</div><div class="line">&lt;users&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"system"</span> password=<span class="string">"manager"</span></div><div class="line">groups=<span class="string">"users,admins"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"users"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"guest"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"guests"</span>/&gt;</div><div class="line">&lt;/users&gt;</div><div class="line">&lt;/simpleAuthenticationPlugin&gt;</div><div class="line">&lt;authorizationPlugin&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;authorizationMap&gt;</div><div class="line">&lt;authorizationEntries&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory.&gt;"</span></div><div class="line"><span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">&lt;/authorizationEntries&gt;</div><div class="line">&lt;/authorizationMap&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="JAAS授权插件"><a href="#JAAS授权插件" class="headerlink" title="JAAS授权插件"></a>JAAS授权插件</h2><p>JAAS Authentication Plugin依赖标准的 JAAS 机制来实现认证。通常情况下，你需要通过设置java.security.auth.login.config 系统属性来配置 loginmodules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin 会缺省使用 login.config 作为文件名</p>
<h3 id="在activeMQ-xml中配置"><a href="#在activeMQ-xml中配置" class="headerlink" title="在activeMQ.xml中配置"></a>在activeMQ.xml中配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt;</div><div class="line">    &lt;jaasAuthenticationPlugin configuration=<span class="string">"activemq-domain"</span> /&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="创建login-config"><a href="#创建login-config" class="headerlink" title="创建login.config"></a>创建login.config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123;</div><div class="line">  org.apache.activemq.jaas.PropertiesLoginModule required</div><div class="line">    debug=<span class="literal">true</span></div><div class="line">    org.apache.activemq.jaas.properties.user=<span class="string">"users.properties"</span></div><div class="line">    org.apache.activemq.jaas.properties.group=<span class="string">"groups.properties"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="创建users-properties和groups-properties文件，包含用户和用户组信息"><a href="#创建users-properties和groups-properties文件，包含用户和用户组信息" class="headerlink" title="创建users.properties和groups.properties文件，包含用户和用户组信息"></a>创建users.properties和groups.properties文件，包含用户和用户组信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">users.properties：</div><div class="line">system=password</div><div class="line">user=password</div><div class="line">guest=password</div><div class="line">groups.properties：</div><div class="line">admins=system</div><div class="line">users=system,user</div><div class="line">guests=guest</div></pre></td></tr></table></figure>
<h3 id="Authorization-plugin-in的使用"><a href="#Authorization-plugin-in的使用" class="headerlink" title="Authorization plugin-in的使用"></a>Authorization plugin-in的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">在activemq.xml中如下配置：</div><div class="line">&lt;plugins&gt;</div><div class="line">  &lt;authorizationPlugin&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">      &lt;authorizationMap&gt;</div><div class="line">        &lt;authorizationEntries&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory."</span>&gt; <span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">        &lt;/authorizationEntries&gt;</div><div class="line">      &lt;/authorizationMap&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">  &lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h1 id="ActiveMQ特点"><a href="#ActiveMQ特点" class="headerlink" title="ActiveMQ特点"></a>ActiveMQ特点</h1><h2 id="使用activeMQ进行集群"><a href="#使用activeMQ进行集群" class="headerlink" title="使用activeMQ进行集群"></a>使用activeMQ进行集群</h2><h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>我们支持 Consumer对消息高可靠性的负载平衡消费，如果一个 Consumer 死掉，该消息会转发到其它的Consumer消费的Queue上。如果一个 Consumer 获得消息比其它Consumer快，那么他将获得更多的消息。如果一个 Conseumer消费缓慢，则其它 Consumer会替换它。</p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>大部情况下是使用一系列的 Broker 和 Client 链接到一起。如果一个 Broker死掉了，Client 可以自动链接到其它Broker上。实现以上行为我门需要用failover：//协议作为 Client，如果启动了多个Broker，Client 可以使用static discover 或者Dynamic discovery 容易的从一个 broker 到另一个 broker 直接链接。这样的当一个broker上没有 Consumer 的话， 那么它的消息不会被消费的， 然而该 broker会通过存储和转发的策略来把该消息发到其它 broker 上。这里的 brokers 没有网络链接各个 brokers。</p>
<h3 id="discovery-of-brokers"><a href="#discovery-of-brokers" class="headerlink" title="discovery of brokers"></a>discovery of brokers</h3><p>ActiveMQ 支持使用 static discovery 或者 dynamic discovery 来动态发现brokers，以至于 Client 能够链接到其它发现的 broker，从而形成网络。</p>
<h3 id="networks-of-brokers"><a href="#networks-of-brokers" class="headerlink" title="networks of brokers"></a>networks of brokers</h3><p>如果你正在使用client/server或者hub/spoke类型的拓扑结构并且你有很多的client很多的broker。这就有可能其中一个broker只有生产者没有消费者，这样的话消息会在这个broker上堆积，并且得不到处理。为了避免这种情况，ActiveMQ提供了网络连接模式（Network of brokers），该模式可以提供存储和转发消息的功能，具体就是broker之间可以互相传送消息，这样也允许我们在网络连接模式中提供重分发TOPIC和QUEUES的功能（参见：<a href="http://activemq.apache.org/how-do-distributed-queues-work.html）。" target="_blank" rel="external">http://activemq.apache.org/how-do-distributed-queues-work.html）。</a><br>这允许一个client去连接任意一个broker， 并且当有错误发生的时候可以failover到其他的broker，它提供了从client的角度来观察一个broker集群<br>网络连接模式允许我们放大client群到一个很大的数量级，因为我们可以运行我们需要的任意多个broker.<br>你可以把该模式想象成一个client集群去连接一个broker集群同时拥有failover和discovery功能去做成的一个简单的易用的消息结构。<br>（注：此处的网络连接模式，仅仅只是为了避免集群中的broker只有producer而没有consumer的情况，它会在不同的broker中间传送消息，以便让所有的消息都能有消费者来处理，但是<br>该模式下不会有消费的备份，在任何时刻，对客户端来说同一个消息都只存在一份，若需要消息备份机制则需要Master Slave的支持，这我们下面会说到）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"static:(nio://192.168.9.102:61616)"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;  </div><div class="line">&lt;!-- dynamic discovery config--&gt;  </div><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>  discoveryUri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master Slave"></a>Master Slave</h3><p>运行独立应用部署的 Brokers 由一个问题，它在任何时候其 broker 在物理上都是独有的。 如果一个 broker 断掉， 那么你必须等待重新复制消息才能启动 broker。必须是 persistent=true 的情况下成立。例如：这里指的是 Shared Nonthing Master/Slave模式，就是说如果 master断掉了，消息的备份会存储在slave中。重新拷贝 slave目录下的数据到 master 的目录下即可，重启 master 了。还有一种就是启动 slave 来替换 master。</p>
<h3 id="Replicated-Message-Stores"><a href="#Replicated-Message-Stores" class="headerlink" title="Replicated Message Stores"></a>Replicated Message Stores</h3><p>Master/Slave 模式的另一种方式就是基于Shared File和 DataBase 的共享模式。当master断掉以后，消息应经存储到硬盘上了，此时 slave 获得锁替换了 Master</p>
<h2 id="Master-Slave集群"><a href="#Master-Slave集群" class="headerlink" title="Master/Slave集群"></a>Master/Slave集群</h2><h3 id="纯Master-Slave"><a href="#纯Master-Slave" class="headerlink" title="纯Master/Slave"></a>纯Master/Slave</h3><ul>
<li>Slave broker 消费 master broker 上所有的消息状态，例如消息、确认和事务状态等。只要 slave broker 连接到了 master broker，它不会（也不被允许）启动任何 network connectors 或者 transport connectors，所以唯一的目的就是复制 master broker 的状态。</li>
<li>Master broker 只有在消息成功被复制到 slave broker 之后才会响应客户。例如，客户的 commit 请求只有在 master broker 和 slave broker 都处理完毕 commit 请求之后才会结束。</li>
<li>当 master broker 失效的时候，slave broker 有两种选择，一种是 slave broker 启动所有的 network connectors 和 transport connectors，这允许客户端切换到 slave broker；另外一种是 slave broker 停止。这种情况下，slave broker 只是复制了 master broker 的状态。</li>
<li>客户应该使用 failover transport 并且应该首先尝试连接 master broker。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover://(tcp://masterhost:61616,tcp://slavehost:61615)?random</div><div class="line">ize=<span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>设置randomize为false就可以让客户总是首先尝试连接master broker（slave broker 并不会接受任何连接，直到它成为了 master broker）。<br>限制：</p>
<ul>
<li>只能有一个 slave broker 连接到 master broker。</li>
<li>在因 master broker 失效而导致 slave broker 成为 master 之后，之前的master broker 只有在当前的 master broker（原 slave broker）停止后才能重新生效。</li>
<li>Master broker 失效后而切换到 slave broker 后，最安全的恢复 master broker 的方式是人工处理。首先要停止 slave broker（这意味着所有的客户也要停止） 。 然后把 slave broker 的数据目录中所有的数据拷贝到 master broker 的数据目录中。然后重启 master broker 和 slave broker。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Master broker 不需要特殊的配置。Slave broker 需要进行以下配置</div><div class="line">&lt;broker masterConnectorURI=<span class="string">"tcp://masterhost:62001"</span> shutdownOn MasterFailure=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://slavehost:61616"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h3 id="JDBC-DataBase-master-slave集群"><a href="#JDBC-DataBase-master-slave集群" class="headerlink" title="JDBC DataBase master/slave集群"></a>JDBC DataBase master/slave集群</h3><p>如果你用单纯的 JDBC 而没有用高性能的持久此时你将依赖于你的数据库作为单独的持久存储引擎。如果你没有高性能的要求，类似这种数据库作为存储引擎可以应用很多场景。<br>启动利用数据库作为数据源，采用Master/Slave模式，其中在启动的时候Master首先获得独有锁，其它 Slaves Broker 则等待获取独有锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp: //broker1:61616,tcp://broker2:61616,tcp://broker3:61616)</div></pre></td></tr></table></figure></p>
<p>如果 Master 失败，则它释放独有锁，其他 Slaver 则获取独有锁.其它 Slaver 立即获得独有锁后此时它将变成 Master，并且启动所有的传输链接。同时，Client 将停止链接之前的 Master 和将会轮询链接到其他可以利用的 Broker 即新 Master。</p>
<h3 id="share-file-master-slave集群"><a href="#share-file-master-slave集群" class="headerlink" title="share file master/slave集群"></a>share file master/slave集群</h3><p>希望基于相同的存储目录下运行多个 Broker，首先，该 Broker Master 会首先获得排它锁。如果该 Master Broker 死掉了会释放掉排它锁，则其它的 Slave Broker会替换它。Slave 是一个轮询的从 Master 那里获得排它锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.org/config/1.0"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;journaledJDBC dataDirectory=<span class="string">"/sharedFileSystem/broker"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>如果你使用 SAN 或者共享文件系统，那么你可以使用 Shared File System Master Slave。基本上，你可以运行多个 broker，这些 broker 共享数据目录。当第一个 broker 得到文件上的排他锁之后，其它的 broker 便会在循环中等待获得这把锁。客户端使用 failover transport 来连接到可用的 broker。当 master broker 失效的时候会释放这把锁，这时候其中一个 slave broker 会得到这把锁从而成为master broker。</p>
<h2 id="network-of-brokers-存储和转发集群"><a href="#network-of-brokers-存储和转发集群" class="headerlink" title="network of brokers (存储和转发集群)"></a>network of brokers (存储和转发集群)</h2><h3 id="单向传递"><a href="#单向传递" class="headerlink" title="单向传递"></a>单向传递</h3><p>ActiveMQ默认的两个broker链接是单方向的，brokerA可以消费brokerB的消息<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/单向broker.png" alt=""></p>
<h3 id="双向传递"><a href="#双向传递" class="headerlink" title="双向传递"></a>双向传递</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/双向broker.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/扩展broker.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static://(tcp://backoffice:61617)"</span> name=<span class="string">"brdge"</span> duplex=<span class="string">"true"</span> ConduitSubscriptions=<span class="string">"true"</span>&gt;</div><div class="line">&lt;/networkConnector&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>Duplex=”true”表示双发可以通信.<br>ConduitSubscriptions=“false”表示每个 Consumer 上都会收到所有的发送的消息。<br>Name=“bridge”默认的。</p>
<h3 id="Broker连接集群"><a href="#Broker连接集群" class="headerlink" title="Broker连接集群"></a>Broker连接集群</h3><p>一个常见的场景是有多个 JMS broker，有一个客户连接到其中一个 broker。如果这个 broker 失效，那么客户会自动重新连接到其它的 broker。在 ActiveMQ中使用 failover:// 协议来实现这个功能。ActiveMQ3.x 版本的 reliable://协议已经变更为 failover://。如果某个网络上有多个 brokers 而且客户使用静态发现（使用 Static Transport 或 Failover Transport）或动态发现（使用 Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的 brokers。然而，stand alone brokers并不了解其它brokers上的consumer，也就是说如果某个broker 上没有 consumers，那么这个 broker 上的消息可能会因得不到处理而积压起来。目前的解决方案是使用 Network of brokers，以便在 broker 之间存储转发消息。ActiveMQ 在未来会有更好的特性，用来在客户端处理这个问题。从 ActiveMQ1.1 版本起，ActiveMQ 支持 networks of brokers。它支持分布式的 queues 和 topics。一个 broker 会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程 broker，它都会递送有关的消息拷贝到每个订阅。远程 broker 得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。 有两种方式配置 Network of brokers， 一种是使用 static transport，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"receiver"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:62002"</span> /&gt;</div><div class="line">&lt; /transportConnectors&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static:( tcp://localhost:61616, tcp://remotehost:61616)"</span> /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>或者使用dynamic transport<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=<span class="string">"sender"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt; &gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://localhost:0"</span> discoveryUri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line"> &lt;networkConnectors&gt;</div><div class="line"> &lt;networkConnector uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/networkConnectors&gt;</div><div class="line">  &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Queue-consumer集群"><a href="#Queue-consumer集群" class="headerlink" title="Queue consumer集群"></a>Queue consumer集群</h2><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认的消息都会被发送到这个 queue 上其它的 consumers。如果某个 consumer 的处理速度比其它 consumers 更快，那么这个 consumer 就会消费更多的消息</p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="dynamicOnly"><a href="#dynamicOnly" class="headerlink" title="dynamicOnly"></a>dynamicOnly</h3><p>默认是 false，如果是 true，消息将被动态的转接的在其他 broker 的 consumer上</p>
<h3 id="prefetchSize"><a href="#prefetchSize" class="headerlink" title="prefetchSize"></a>prefetchSize</h3><p>ActiveMQ使用了　消息”预取限制“(prefetch limit)：表示在某个时间段内，可能向消费者传输的最大消息量，如果达到该上限，那么停止发送，直到ActiveMQ收到消费者的acknowledgements(确认，表示已经处理了该消息。prefetch limit可以针对每个不同的consumer来设置。<br>为了获取更高的性能，prefetch limit当然是越大越好，只要consumer有足够大的消息缓冲区(messagevolume)。如果消息的总量非常少，而且每个消息的处理时间非常的长，那么，可以将prefetch设置为1，这样，每次向consumer发送一个消息，等其确认已经处理完毕后，再发送第二个。<br>特别地，如果prefetch设置为0，表示consumer每次　主动向activeMQ要求传输最大的数据量，而不是被动地接收消息</p>
<h3 id="conduitSubscriptons"><a href="#conduitSubscriptons" class="headerlink" title="conduitSubscriptons"></a>conduitSubscriptons</h3><p>关于 conduitSubscriptions 属性，这里稍稍说明一下。设想有两个 brokers，分别是brokerA和brokerB， 它们之间用forwarding bridge连接。 有一个consumer连接到brokerA并订阅 queue： Q.TEST。 有两个 consumers 连接到 brokerB， 也是订阅 queue： Q.TEST。这三个 consumers 有相同的优先级。然后启动一个 producer，它发送了 30 条消息到brokerA。如果 conduitSubscriptions=true，那么 brokerA 上的 consumer 会得到 15 条消息， 另外15条消息会发送给brokerB。 此时负载并不均衡， 因为此时brokerA将brokerB上的两个 consumers 视为一个；如果 conduitSubscriptions=false，那么每个 consumer上都会收到 10 条消息。</p>
<h3 id="decreaseNetwordConsumerPriority"><a href="#decreaseNetwordConsumerPriority" class="headerlink" title="decreaseNetwordConsumerPriority"></a>decreaseNetwordConsumerPriority</h3><p>默认是 false。设定消费者优先权</p>
<h3 id="networkTTL"><a href="#networkTTL" class="headerlink" title="networkTTL"></a>networkTTL</h3><p>默认是 1</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;面向消息的中间件：Message-oriented Middleware, MOM&lt;br&gt;基本功能：将信息以消息的形
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅</title>
    <link href="http://yoursite.com/2017/12/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"/>
    <id>http://yoursite.com/2017/12/06/设计模式之禅/</id>
    <published>2017-12-06T15:21:46.000Z</published>
    <updated>2017-12-11T08:02:44.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一职责-SRP"><a href="#单一职责-SRP" class="headerlink" title="单一职责(SRP)"></a>单一职责(SRP)</h2><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更.<br><img src="/2017/12/06/设计模式之禅/单一职责1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.2.png" alt=""><br>单一职责的优点：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义</li>
<li>可读性提高</li>
<li>可维护性提高</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>继承的优点：</p>
<ul>
<li>代码共享，减少创建类的工作量</li>
<li>提高代码的重用性</li>
<li>提高代码的扩展性</li>
<li>提高产品和项目的开放性<br>缺点：</li>
<li>继承是侵入性的，拥有父类的所有方法和属性</li>
<li>降低代码的灵活性</li>
<li>增强了耦合性</li>
</ul>
<p>里氏替换定义<br>定义一：如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。<br>定义二：所有引用基类的地方都必须能透明的引用其子类对象。第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。<br>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义:</p>
<ol>
<li>子类必须完全实现父类的方法<br><img src="/2017/12/06/设计模式之禅/里氏替换1.1.png" alt=""><br>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
<li>子类可以有自己个性<br>子类当然可以有自己的行为和外观了，也就是方法和属性。但是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</li>
<li>覆盖或实现父类的方法时输入参数可以被放大<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">public Collection <span class="keyword">do</span>Something(HashMap map)&#123;</div><div class="line">System.out.println(<span class="string">"父类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Son extends Father &#123;</div><div class="line">//放大输入参数类型</div><div class="line">public Collection <span class="keyword">do</span>Something(Map map)&#123;</div><div class="line">System.out.println(<span class="string">"子类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Father f = new Father();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div><div class="line">Son f =new Son();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>与父类的方法名相同，但又不是覆写（Override）父类的方法。是重载（Overload）。用子类替换父类，子类代替父类传递到调用者中，子类的方法永远都不会被执行。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。<br>如果你把父类参数放宽变为map，子类的参数变为Hashmap，根据里氏替换子类替换父类，子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</p>
<ol>
<li>覆盖或实现父类方法输出结果可以被缩小<br>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的</li>
</ol>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。依赖倒置原则在Java语言中的表现就是：<br>● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过<br>接口或抽象类产生的；<br>● 接口或抽象类不依赖于实现类；<br>● 实现类依赖接口或抽象类<br>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设<br>计）的精髓之一<br><img src="/2017/12/06/设计模式之禅/依赖倒置1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.3.png" alt=""><br>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，<br>不互相影响，实现模块间的松耦合。只要遵循以下几个规则</p>
<ul>
<li>每个类都尽量有抽象类或者接口</li>
<li>表面类型尽量是接口或者抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆盖父类的方法</li>
<li>结合里氏替换原则使用</li>
</ul>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><p><img src="/2017/12/06/设计模式之禅/接口隔离原则1.1.png" alt=""><br>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探<br>AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。<br>接口隔离原则包含四层含义：</p>
<ul>
<li>接口要尽量小<br>是接口隔离原则的核心定义，不出现臃肿的接口。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</li>
<li>接口要高内聚<br>具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li>
<li>定制服务<br>定制服务就是单独为一个个体提供优良的服务。<br><img src="/2017/12/06/设计模式之禅/接口隔离原则1.2.png" alt=""></li>
<li>接口设计时有粒度的<br>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构<br>的复杂化，开发难度增加，可维护性降低。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多的public方法，我就调用这么多，其他的我一概不关心。</p>
<ol>
<li>只和朋友类交流<br>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类<br><img src="/2017/12/06/设计模式之禅/迪米特1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特1.2.png" alt=""><br>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象</li>
<li>朋友间也是有距离的<br><img src="/2017/12/06/设计模式之禅/迪米特2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特2.2.png" alt=""></li>
<li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ol>
<h2 id="开闭原则-DIP"><a href="#开闭原则-DIP" class="headerlink" title="开闭原则(DIP)"></a>开闭原则(DIP)</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br><img src="/2017/12/06/设计模式之禅/开闭1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/开闭1.2.png" alt=""><br>开闭的好处:</p>
<ol>
<li>开闭对测试有影响</li>
<li>提高复用性</li>
<li>可以提高可维护性</li>
<li>面向对象开发要求</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下：<br>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。<br>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。<br>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。<br>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）<br>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。<br>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h3><ul>
<li>由于单例模式在内存只有一个实例，减少了内存的开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁的性能又无法优化时，单例模式的优势非常明显</li>
<li>由于单例只生成一个实例，较少了系统性能开销，当一个对象产生需要比较多的资源时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>单例模式一般没有接口，扩展很困难</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li>
<li>单例模式与单一职责原则有冲突。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">	private static  volatile Singleton singleton;</div><div class="line"></div><div class="line">	private <span class="function"><span class="title">Singleton</span></span>()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">		<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">			synchronized (this) &#123;</div><div class="line">				<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">					singleton=new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Human &#123;</div><div class="line"></div><div class="line">	public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123;</div><div class="line">		Human human=(Human) Class.forName(c.getName()).newInstance();</div><div class="line">		<span class="built_in">return</span> (T) human;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/06/设计模式之禅/工厂模式1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/工厂模式通用类图.png" alt=""></p>
<h3 id="工厂方法模式优点："><a href="#工厂方法模式优点：" class="headerlink" title="工厂方法模式优点："></a>工厂方法模式优点：</h3><ul>
<li>良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。</li>
<li>屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li>
<li>工厂方法模式是典型的解耦框架。</li>
</ul>
<h3 id="工厂方法的扩展"><a href="#工厂方法的扩展" class="headerlink" title="工厂方法的扩展"></a>工厂方法的扩展</h3><ol>
<li>缩小为简单工厂模式一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了</li>
<li>多个工厂类<br><img src="/2017/12/06/设计模式之禅/多个工厂类.png" alt=""></li>
<li><p>替代单例模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SingletonFactory &#123;</div><div class="line">private static Singleton singleton;</div><div class="line"> static&#123;</div><div class="line">  try &#123;</div><div class="line">    Class cl= Class.forName(Singleton.class.getName());</div><div class="line">    //获得无参构造</div><div class="line">    Constructor constructor=cl.getDeclaredConstructor();</div><div class="line">    //设置无参构造是可访问的</div><div class="line">    constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">    //产生一个实例对象</div><div class="line">    singleton = (Singleton)constructor.newInstance();</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">    //异常处理</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> public static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> singleton;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>延迟初始化<br>一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ProductFactory &#123;</div><div class="line">private static final Map&lt;String,Product&gt; prMap = new HashMap();</div><div class="line">public static synchronized Product createProduct(String <span class="built_in">type</span>) throws Exception&#123;</div><div class="line">Product product =null;</div><div class="line">//如果Map中已经有这个对象</div><div class="line"><span class="keyword">if</span>(prMap.containsKey(<span class="built_in">type</span>))&#123;</div><div class="line">product = prMap.get(<span class="built_in">type</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(type.equals(<span class="string">"Product1"</span>))&#123;</div><div class="line">product = new ConcreteProduct1();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">product = new ConcreteProduct2();</div><div class="line">&#125;</div><div class="line">//同时把对象放到缓存容器中</div><div class="line">prMap.put(<span class="built_in">type</span>,product);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> product;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/2017/12/06/设计模式之禅/抽象1.png" alt=""><br>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：<br>（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）<br><img src="/2017/12/06/设计模式之禅/抽象工厂模式类图.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public abstract class AbstractCreator &#123;</div><div class="line">//创建A产品家族</div><div class="line">public abstract AbstractProductA createProductA();</div><div class="line">//创建B产品家族</div><div class="line">public abstract AbstractProductB createProductB();</div><div class="line">&#125;</div><div class="line">public class Creator1 extends AbstractCreator &#123;</div><div class="line">//只生产产品等级为1的A产品</div><div class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductA1();</div><div class="line">&#125;</div><div class="line">//只生产产品等级为1的B产品</div><div class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductB1();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务</p>
<h3 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h3><p>1.封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。<br>2.产品族内的约束为非公开状态。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码<br>为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序<br>有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><img src="/2017/12/06/设计模式之禅/模板1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/模板2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public abstract class HummerModel &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * 首先，这个模型要能发动起来，别管是手摇发动，还是电力发动，反正 是要能够发动起来，那这个实现要在实现类里了</div><div class="line">	 */</div><div class="line">	public abstract void start();</div><div class="line"></div><div class="line">	// 能发动，还要能停下来，那才是真本事</div><div class="line">	public abstract void stop();</div><div class="line"></div><div class="line">	// 喇叭会出声音，是滴滴叫，还是哔哔叫</div><div class="line">	public abstract void alarm();</div><div class="line"></div><div class="line">	// 引擎会轰隆隆地响，不响那是假的</div><div class="line">	public abstract void engineBoom();</div><div class="line"></div><div class="line">	// 那模型应该会跑吧，别管是人推的，还是电力驱动，总之要会跑</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		// 先发动汽车</div><div class="line">		this.start();</div><div class="line">		// 引擎开始轰鸣</div><div class="line">		this.engineBoom();</div><div class="line">		// 然后就开始跑了，跑的过程中遇到一条狗挡路，就按喇叭</div><div class="line">		this.alarm();</div><div class="line">		// 到达目的地就停车</div><div class="line">		this.stop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class HummerH1Model extends HummerModel&#123;</div><div class="line"></div><div class="line">	//H1型号的悍马车鸣笛</div><div class="line">	public void <span class="function"><span class="title">alarm</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1鸣笛..."</span>);</div><div class="line">	&#125;</div><div class="line">	//引擎轰鸣声</div><div class="line">	public void <span class="function"><span class="title">engineBoom</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1引擎声音是这样的..."</span>);</div><div class="line">	&#125;</div><div class="line">	//汽车发动</div><div class="line">	public void <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1发动..."</span>);</div><div class="line">	&#125;</div><div class="line">	//停车</div><div class="line">	public void <span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1停车..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/2017/12/06/设计模式之禅/模板4.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.封装不变的部分，扩展可变部分<br>2.提取公共部分代码，便于维护<br>3.行为由父类控制，子类实现</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h3 id="模板方法模式使用场景"><a href="#模板方法模式使用场景" class="headerlink" title="模板方法模式使用场景"></a>模板方法模式使用场景</h3><p>● 多个子类有公有的方法，并且逻辑基本相同时。<br>● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。<br>● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/2017/12/06/设计模式之禅/建造0.png" alt=""><br>建造者模式（Builder Pattern）也叫做生成器模式，其定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示<br><img src="/2017/12/06/设计模式之禅/建造1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/建造2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">		//独立业务处理</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Builder &#123;</div><div class="line">	// 设置产品的不同部分，以获得不同的产品</div><div class="line">	public abstract void <span class="built_in">set</span>Part();</div><div class="line"></div><div class="line">	// 建造产品</div><div class="line">	public abstract Product buildProduct();</div><div class="line">&#125;</div><div class="line">public class ConcreteProduct extends Builder &#123;</div><div class="line">	private Product product = new Product();</div><div class="line"></div><div class="line">	// 设置产品零件</div><div class="line">	public void <span class="function"><span class="title">setPart</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 产品类内的逻辑处理</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 组建一个产品</div><div class="line">	public Product <span class="function"><span class="title">buildProduct</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> product;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Director &#123;</div><div class="line">	private Builder builder = new ConcreteProduct();</div><div class="line"></div><div class="line">	// 构建不同的产品</div><div class="line">	public Product <span class="function"><span class="title">getAProduct</span></span>() &#123;</div><div class="line">		builder.setPart();</div><div class="line">		/*</div><div class="line">		 * 设置不同的零件，产生不同的产品</div><div class="line">		 */</div><div class="line">		<span class="built_in">return</span> builder.buildProduct();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>● 封装性<br>使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。<br>● 建造者独立，容易扩展<br>BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。<br>● 便于控制细节风险<br>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。<br>● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。<br>● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。<br>● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</p>
<p><em>建造者模式关注的是零件类型和装配工艺（顺序）</em>。建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义为：为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/2017/12/06/设计模式之禅/代理1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	public void request();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	//实现方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">	//业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Proxy implements Subject &#123;</div><div class="line"></div><div class="line">	// 要代理哪个实现类</div><div class="line">	private Subject subject = null;</div><div class="line"></div><div class="line">	// 默认被代理者</div><div class="line">	public <span class="function"><span class="title">Proxy</span></span>() &#123;</div><div class="line">		this.subject = new RealSubject();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过构造函数传递代理者</div><div class="line">	public Proxy(Object... objects) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 实现接口中定义的方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.before();</div><div class="line">		this.subject.request();</div><div class="line">		this.after();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 预处理</div><div class="line">	private void <span class="function"><span class="title">before</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 善后处理</div><div class="line">	private void <span class="function"><span class="title">after</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><img src="/2017/12/06/设计模式之禅/代理2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/代理3.png" alt=""><br>要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下前面的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/2017/12/06/设计模式之禅/原型1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PrototypeClass implements Cloneable&#123;</div><div class="line">//覆写父类Object方法</div><div class="line">@Override</div><div class="line">public PrototypeClass <span class="function"><span class="title">clone</span></span>()&#123;</div><div class="line">PrototypeClass prototypeClass = null;</div><div class="line">try &#123;</div><div class="line">prototypeClass = (PrototypeClass)super.clone();</div><div class="line">&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">//异常处理</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> prototypeClass;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>● 性能优良<br>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。<br>● 逃避构造函数的约束<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 资源优化场景<br>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>● 性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>● 一个对象多个修改者的场景<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable &#123;</div><div class="line">	// 定义一个私有变量</div><div class="line">	private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Thing <span class="function"><span class="title">clone</span></span>() &#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			thing.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用clone方法，类的成员变量上不要增加final关键字</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p><img src="/2017/12/06/设计模式之禅/中介者1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者3.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractMediator &#123;</div><div class="line">	protected Purchase purchase;</div><div class="line">	protected Sale sale;</div><div class="line">	protected Stock stock;</div><div class="line"></div><div class="line">	// 构造函数</div><div class="line">	public <span class="function"><span class="title">AbstractMediator</span></span>() &#123;</div><div class="line">		purchase = new Purchase(this);</div><div class="line">		sale = new Sale(this);</div><div class="line">		stock = new Stock(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中介者最重要的方法叫做事件方法，处理多个对象之间的关系</div><div class="line">	public abstract void execute(String str, Object... objects);</div><div class="line">&#125;</div><div class="line">public class Mediator extends AbstractMediator &#123;</div><div class="line">	// 中介者最重要的方法</div><div class="line">	public void execute(String str, Object... objects) &#123;</div><div class="line">		<span class="keyword">if</span> (str.equals(<span class="string">"purchase.buy"</span>)) &#123; // 采购电脑</div><div class="line">			this.buyComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.sell"</span>)) &#123; // 销售电脑</div><div class="line">			this.sellComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.offsell"</span>)) &#123; // 折价销售</div><div class="line">			this.offSell();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"stock.clear"</span>)) &#123; // 清仓处理</div><div class="line">			this.clearStock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购电脑</div><div class="line">	private void buyComputer(int number) &#123;</div><div class="line">		int saleStatus = super.sale.getSaleStatus();</div><div class="line">		<span class="keyword">if</span> (saleStatus &gt; 80) &#123; // 销售情况良好</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑:"</span> + number + <span class="string">"台"</span>);</div><div class="line">			super.stock.increase(number);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 销售情况不好</div><div class="line">			int buyNumber = number / 2; // 折半采购</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑："</span> + buyNumber + <span class="string">"台"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售电脑</div><div class="line">	private void sellComputer(int number) &#123;</div><div class="line">		<span class="keyword">if</span> (super.stock.getStockNumber() &lt; number) &#123; // 库存数量不够销售</div><div class="line">			super.purchase.buyIBMcomputer(number);</div><div class="line">		&#125;</div><div class="line">		super.stock.decrease(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价销售电脑</div><div class="line">	private void <span class="function"><span class="title">offSell</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"折价销售IBM电脑"</span> + stock.getStockNumber() + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清仓处理</div><div class="line">	private void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		// 要求清仓销售</div><div class="line">		super.sale.offSale();</div><div class="line">		// 要求采购人员不要采购</div><div class="line">		super.purchase.refuseBuyIBM();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class AbstractColleague &#123;</div><div class="line">	protected AbstractMediator mediator;</div><div class="line"></div><div class="line">	public AbstractColleague(AbstractMediator _mediator) &#123;</div><div class="line">		this.mediator = _mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Purchase extends AbstractColleague &#123;</div><div class="line">	public Purchase(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购IBM电脑</div><div class="line">	public void buyIBMcomputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"purchase.buy"</span>, number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 不再采购IBM电脑</div><div class="line">	public void <span class="function"><span class="title">refuseBuyIBM</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"不再采购IBM电脑"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Sale extends AbstractColleague &#123;</div><div class="line">	public Sale(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售IBM电脑</div><div class="line">	public void sellIBMComputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.sell"</span>, number);</div><div class="line">		System.out.println(<span class="string">"销售IBM电脑"</span> + number + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 反馈销售情况，0～100变化，0代表根本就没人买，100代表非常畅销，出一个卖一个</div><div class="line">	public int <span class="function"><span class="title">getSaleStatus</span></span>() &#123;</div><div class="line">		Random rand = new Random(System.currentTimeMillis());</div><div class="line">		int saleStatus = rand.nextInt(100);</div><div class="line">		System.out.println(<span class="string">"IBM电脑的销售情况为："</span> + saleStatus);</div><div class="line">		<span class="built_in">return</span> saleStatus;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价处理</div><div class="line">	public void <span class="function"><span class="title">offSale</span></span>() &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.offsell"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Stock extends AbstractColleague &#123;</div><div class="line">	public Stock(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 刚开始有100台电脑</div><div class="line">	private static int COMPUTER_NUMBER = 100;</div><div class="line"></div><div class="line">	// 库存增加</div><div class="line">	public void increase(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER + number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 库存降低</div><div class="line">	public void decrease(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER - number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得库存数量</div><div class="line">	public int <span class="function"><span class="title">getStockNumber</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> COMPUTER_NUMBER;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售</div><div class="line">	public void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"清理存货数量为："</span> + COMPUTER_NUMBER);</div><div class="line">		super.mediator.execute(<span class="string">"stock.clear"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/2017/12/06/设计模式之禅/中介者4.png" alt=""><br>● Mediator 抽象中介者角色<br>抽象中介者角色定义统一的接口，用于各同事角色之间的通信。<br>● Concrete Mediator 具体中介者角色<br>具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。<br>● Colleague 同事角色<br>每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br><img src="/2017/12/06/设计模式之禅/命令1.png" alt=""><br>Receive接收者角色<br>该角色就是干活的角色，命令传递到这里是应该被执行的。<br>● Command命令角色<br>需要执行的所有命令都在这里声明。<br>● Invoker调用者角色<br>接收到命令，并执行命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public abstract class Receiver &#123;</div><div class="line">	// 抽象接收者，定义每个接收者都必须完成的业务</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteReciver1 extends Receiver &#123;</div><div class="line">	// 每个接收者都必须处理一定的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"ConcreteReciver1:dosomething"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Command &#123;</div><div class="line">	// 每个命令类都必须有一个执行命令的方法</div><div class="line">	public abstract void execute();</div><div class="line">&#125;</div><div class="line">public class ConcreteCommand1 extends Command &#123;</div><div class="line">	// 对哪个Receiver类进行命令处理</div><div class="line">	private Receiver receiver;</div><div class="line"></div><div class="line">	// 构造函数传递接收者</div><div class="line">	public ConcreteCommand1(Receiver _receiver) &#123;</div><div class="line">		this.receiver = _receiver;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 必须实现一个命令</div><div class="line">	public void <span class="function"><span class="title">execute</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">		this.receiver.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Invoker &#123;</div><div class="line">	private Command <span class="built_in">command</span>;</div><div class="line"></div><div class="line">	// 受气包，接受命令</div><div class="line">	public void <span class="built_in">set</span>Command(Command _command) &#123;</div><div class="line">		this.command = _command;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 执行命令</div><div class="line">	public void <span class="function"><span class="title">action</span></span>() &#123;</div><div class="line">		this.command.execute();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 首先声明调用者Invoker</div><div class="line">		Invoker invoker = new Invoker();</div><div class="line">		// 定义接收者</div><div class="line">		Receiver receiver = new ConcreteReciver1();</div><div class="line">		// 定义一个发送给接收者的命令</div><div class="line">		Command <span class="built_in">command</span> = new ConcreteCommand1(receiver);</div><div class="line">		// 把命令交给调用者去执行</div><div class="line">		invoker.setCommand(<span class="built_in">command</span>);</div><div class="line">		invoker.action();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>● 类间解耦<br>调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。<br>● 可扩展性<br>Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。<br>● 命令模式结合其他模式会更优秀<br>命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。<br><img src="/2017/12/06/设计模式之禅/责任.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Level &#123;</div><div class="line">	// 定义一个请求和处理等级</div><div class="line">&#125;</div><div class="line">public class Request &#123;</div><div class="line">	// 请求的等级</div><div class="line">	public Level <span class="function"><span class="title">getRequestLevel</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Response &#123;</div><div class="line">	// 处理者返回的数据</div><div class="line">&#125;</div><div class="line">public abstract class Handler &#123;</div><div class="line">	private Handler nextHandler;</div><div class="line"></div><div class="line">	// 每个处理者都必须对请求做出处理</div><div class="line">	public final Response handleMessage(Request request) &#123;</div><div class="line">		Response response = null;</div><div class="line">		// 判断是否是自己的处理级别</div><div class="line">		<span class="keyword">if</span> (this.getHandlerLevel().equals(request.getRequestLevel())) &#123;</div><div class="line">			response = this.echo(request);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 不属于自己的处理级别</div><div class="line">		// 判断是否有下一个处理者</div><div class="line">			<span class="keyword">if</span> (this.nextHandler != null) &#123;</div><div class="line">				response = this.nextHandler.handleMessage(request);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				// 没有适当的处理者，业务自行处理</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> response;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置下一个处理者是谁</div><div class="line">	public void <span class="built_in">set</span>Next(Handler _handler) &#123;</div><div class="line">		this.nextHandler = _handler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 每个处理者都有一个处理级别</div><div class="line">	protected abstract Level getHandlerLevel();</div><div class="line"></div><div class="line">	// 每个处理者都必须实现处理任务</div><div class="line">	protected abstract Response <span class="built_in">echo</span>(Request request);</div><div class="line">&#125;</div><div class="line">public class ConcreteHandler1 extends Handler &#123;</div><div class="line">	// 定义自己的处理逻辑</div><div class="line">	protected Response <span class="built_in">echo</span>(Request request) &#123;</div><div class="line">		// 完成处理逻辑</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置自己的处理级别</div><div class="line">	protected Level <span class="function"><span class="title">getHandlerLevel</span></span>() &#123;</div><div class="line">		// 设置自己的处理级别</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><p>责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活<br><img src="/2017/12/06/设计模式之禅/装饰1.png" alt=""><br>● Component抽象构件<br>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当<br>Component抽象构件。<br>● ConcreteComponent 具体构件<br>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。<br>● Decorator装饰角色<br>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。<br>● 具体装饰角色<br>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 抽象的方法</div><div class="line">	public abstract void operate();</div><div class="line">&#125;</div><div class="line">public class ConcreteComponent extends Component &#123;</div><div class="line">	// 具体实现</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"do Something"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Decorator extends Component &#123;</div><div class="line">	private Component component = null;</div><div class="line"></div><div class="line">	// 通过构造函数传递被修饰者</div><div class="line">	public Decorator(Component _component) &#123;</div><div class="line">		this.component = _component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 委托给被修饰者执行</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.component.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteDecorator1 extends Decorator &#123;</div><div class="line">	// 定义被修饰者</div><div class="line">	public ConcreteDecorator1(Component _component) &#123;</div><div class="line">		super(_component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义自己的修饰方法</div><div class="line">	private void <span class="function"><span class="title">method1</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"method1 修饰"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 重写父类的Operation方法</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.method1();</div><div class="line">		super.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Component component = new ConcreteComponent();</div><div class="line">		//第一次修饰</div><div class="line">		component = new ConcreteDecorator1(component);</div><div class="line">		component.operate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><p>● 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道 Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。<br>● 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。<br>● 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如<br>此。</p>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>多层的装饰是比较复杂的</p>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>● 需要扩展一个类的功能，或给一个类增加附加功能。<br>● 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。<br>● 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。<br><img src="/2017/12/06/设计模式之禅/策略1.png" alt=""><br>● Context封装角色<br>它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。<br>● Strategy抽象策略角色<br>策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。<br>● ConcreteStrategy具体策略角色<br>实现抽象策略中的操作，该类含有具体的算法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">	// 策略模式的运算法则</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"具体策略1的运算法则"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 抽象策略</div><div class="line">	private Strategy strategy = null;</div><div class="line"></div><div class="line">	// 构造函数设置具体策略</div><div class="line">	public Context(Strategy _strategy) &#123;</div><div class="line">		this.strategy = _strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 封装后的策略方法</div><div class="line">	public void <span class="function"><span class="title">doAnythinig</span></span>() &#123;</div><div class="line">		this.strategy.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 声明一个具体的策略</div><div class="line">		Strategy strategy = new ConcreteStrategy1();</div><div class="line">		// 声明上下文对象</div><div class="line">		Context context = new Context(strategy);</div><div class="line">		// 执行封装后的方法</div><div class="line">		context.doAnythinig();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><p>● 算法可以自由切换<br>这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。<br>● 避免使用多重条件判断<br>如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</p>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><p>● 策略类数量增多<br>每一个策略都是一个类，复用的可能性很小，类数量增多。<br>● 所有的策略类都需要对外暴露<br>上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式</p>
<h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>● 多个类只有在算法或行为上稍有不同的场景。<br>● 算法需要自由切换的场景。<br>● 需要屏蔽算法规则的场景。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。<br><img src="/2017/12/06/设计模式之禅/适配器1.png" alt=""><br>● Target目标角色<br>该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口就是目标角色。<br>● Adaptee源角色<br>你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。<br>● Adapter适配器角色<br>适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Target &#123;</div><div class="line">	// 目标角色有自己的方法</div><div class="line">	public void request();</div><div class="line">&#125;</div><div class="line">public class ConcreteTarget implements Target &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"if you need any help,pls call me!"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Adaptee &#123;</div><div class="line">	// 原有的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"I'm kind of busy,leave me alone,pls!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Adapter extends Adaptee implements Target &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		super.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 原有的业务逻辑</div><div class="line">		Target target = new ConcreteTarget();</div><div class="line">		target.request();</div><div class="line">		// 现在增加了适配器角色后的业务逻辑</div><div class="line">		Target target2 = new Adapter();</div><div class="line">		target2.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><p>● 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。<br>● 增加了类的透明性<br>想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。<br>● 提高了类的复用度<br>当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员<br>● 灵活性非常好<br>某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</p>
<h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>适配器应用的场景只要记住一点就足够了：比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节<br><img src="/2017/12/06/设计模式之禅/迭代器1.png" alt=""><br>● Iterator抽象迭代器<br>抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法：first获得第一个元素，next访问下一个元素，isDone是否已经访问到底部。<br>● ConcreteIterator具体迭代器<br>具体迭代器角色要实现迭代器接口，完成容器元素的遍历。<br>● Aggregate抽象容器<br>容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator这样的方法，在Java中一般是iterator方法。<br>● Concrete Aggregate具体容器<br>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">	// 遍历到下一个元素</div><div class="line">	public Object next();</div><div class="line"></div><div class="line">	// 是否已经遍历到尾部</div><div class="line">	public boolean hasNext();</div><div class="line"></div><div class="line">	// 删除当前指向的元素</div><div class="line">	public boolean remove();</div><div class="line">&#125;</div><div class="line">public class ConcreteIterator implements Iterator &#123;</div><div class="line"></div><div class="line">	private Vector vector = new Vector();</div><div class="line">	// 定义当前游标</div><div class="line">	public int cursor = 0;</div><div class="line"></div><div class="line">	@SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">	public ConcreteIterator(Vector _vector) &#123;</div><div class="line">		this.vector = _vector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否到达尾部</div><div class="line">	public boolean <span class="function"><span class="title">hasNext</span></span>() &#123;</div><div class="line">		<span class="keyword">if</span> (this.cursor == this.vector.size()) &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回下一个元素</div><div class="line">	public Object <span class="function"><span class="title">next</span></span>() &#123;</div><div class="line">		Object result = null;</div><div class="line">		<span class="keyword">if</span> (this.hasNext()) &#123;</div><div class="line">			result = this.vector.get(this.cursor++);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			result = null;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除当前元素</div><div class="line">	public boolean <span class="function"><span class="title">remove</span></span>() &#123;</div><div class="line">		this.vector.remove(this.cursor);</div><div class="line">		<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public interface Aggregate &#123;</div><div class="line"></div><div class="line">	// 是容器必然有元素的增加</div><div class="line">	public void add(Object object);</div><div class="line"></div><div class="line">	// 减少元素</div><div class="line">	public void remove(Object object);</div><div class="line"></div><div class="line">	// 由迭代器来遍历所有的元素</div><div class="line">	public Iterator iterator();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class ConcreteAggregate implements Aggregate &#123;</div><div class="line"></div><div class="line">	// 容纳对象的容器</div><div class="line">	private Vector vector = new Vector();</div><div class="line"></div><div class="line">	// 增加一个元素</div><div class="line">	public void add(Object object) &#123;</div><div class="line">		this.vector.add(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回迭代器对象</div><div class="line">	public Iterator <span class="function"><span class="title">iterator</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new ConcreteIterator(this.vector);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个元素</div><div class="line">	public void remove(Object object) &#123;</div><div class="line">		this.remove(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性<br><img src="/2017/12/06/设计模式之禅/组合模式.png" alt=""><br>● Component抽象构件角色<br>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>● Leaf叶子构件<br>叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>● Composite树枝构件<br>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 个体和整体都具有的共享</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 编写业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Composite extends Component &#123;</div><div class="line">	// 构件容器</div><div class="line">	private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</div><div class="line"></div><div class="line">	// 增加一个叶子构件或树枝构件</div><div class="line">	public void add(Component component) &#123;</div><div class="line">		this.componentArrayList.add(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个叶子构件或树枝构件</div><div class="line">	public void remove(Component component) &#123;</div><div class="line">		this.componentArrayList.remove(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得分支下的所有叶子构件和树枝构件</div><div class="line">	public ArrayList&lt;Component&gt; <span class="function"><span class="title">getChildren</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> this.componentArrayList;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Leaf extends Component &#123;</div><div class="line">	/*</div><div class="line">	 * 可以覆写父类方法 public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">	 *</div><div class="line">	 * &#125;</div><div class="line">	 */</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个根节点</div><div class="line">		Composite root = new Composite();</div><div class="line">		root.doSomething();</div><div class="line">		// 创建一个树枝构件</div><div class="line">		Composite branch = new Composite();</div><div class="line">		// 创建一个叶子节点</div><div class="line">		Leaf leaf = new Leaf();</div><div class="line">		// 建立整体</div><div class="line">		root.add(branch);</div><div class="line">		branch.add(leaf);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过递归遍历树</div><div class="line">	public static void display(Composite root) &#123;</div><div class="line">		<span class="keyword">for</span> (Component c : root.getChildren()) &#123;</div><div class="line">			<span class="keyword">if</span> (c instanceof Leaf) &#123; // 叶子节点</div><div class="line">				c.doSomething();</div><div class="line">			&#125; <span class="keyword">else</span> &#123; // 树枝节点</div><div class="line">				display((Composite) c);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><p>● 高层模块调用简单<br>一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br>● 节点自由增加<br>使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</p>
<h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>● 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。<br>● 从一个整体中能够独立出部分模块或功能的场景。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。<br><img src="/2017/12/06/设计模式之禅/观察者模式.png" alt=""><br>● Subject被观察者<br>定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。<br>● Observer观察者<br>观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。<br>● ConcreteSubject具体的被观察者<br>定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。<br>● ConcreteObserver具体的观察者<br>每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public abstract class Subject &#123;</div><div class="line">	// 定义一个观察者数组</div><div class="line">	private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</div><div class="line"></div><div class="line">	// 增加一个观察者</div><div class="line">	public void addObserver(Observer o) &#123;</div><div class="line">		this.obsVector.add(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个观察者</div><div class="line">	public void delObserver(Observer o) &#123;</div><div class="line">		this.obsVector.remove(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通知所有观察者</div><div class="line">	public void <span class="function"><span class="title">notifyObservers</span></span>() &#123;</div><div class="line">		<span class="keyword">for</span> (Observer o : this.obsVector) &#123;</div><div class="line">			o.update();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteSubject extends Subject &#123;</div><div class="line">	// 具体的业务</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * <span class="keyword">do</span> something</div><div class="line">		 */</div><div class="line">		super.notifyObservers();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface Observer &#123;</div><div class="line">	// 更新方法</div><div class="line">	public void update();</div><div class="line">&#125;</div><div class="line">public class ConcreteObserver implements Observer &#123;</div><div class="line">	// 实现更新方法</div><div class="line">	public void <span class="function"><span class="title">update</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"接收到信息，并进行处理！"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个被观察者</div><div class="line">		Subject subject = new ConcreteSubject();</div><div class="line">		// 定义一个观察者</div><div class="line">		Observer obs = new ConcreteObserver();</div><div class="line">		// 观察者观察被观察者</div><div class="line">		subject.addObserver(obs);</div><div class="line">		// 观察者开始活动了</div><div class="line">		subject.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><p>● 观察者和被观察者之间是抽象耦合<br>如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实现的抽象层级的定义，在系统扩展方面更是得心应手。<br>● 建立一套触发机制</p>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。多级触发时的效率更是让人担忧，大家在设计时注意考虑</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>● 广播链的问题<br>如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表A上写了一个触发器，内容是一个字段更新后更新表B的一条数据，而表B上也有个触发器，要更新表C，表C也有触发器……完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，既是观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次）这还是比较好控制的。注意它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。<br>● 异步处理问题<br>这个EJB是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。</p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。<br>● Facade门面角色<br>客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。<br>● subsystem子系统角色<br>可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。<br><img src="/2017/12/06/设计模式之禅/门面.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ClassA &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingA</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ClassB &#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomethingB</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassC &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingC</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Facade &#123;</div><div class="line">	// 被委托的对象</div><div class="line">	private ClassA a = new ClassA();</div><div class="line">	private ClassB b = new ClassB();</div><div class="line">	private ClassC c = new ClassC();</div><div class="line"></div><div class="line">	// 提供给外部访问的方法</div><div class="line">	public void <span class="function"><span class="title">methodA</span></span>() &#123;</div><div class="line">		this.a.doSomethingA();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodB</span></span>() &#123;</div><div class="line">		this.b.doSomethingB();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodC</span></span>() &#123;</div><div class="line">		this.c.doSomethingC();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><p>● 减少系统的相互依赖<br>想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模<br>式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。<br>● 提高了灵活性<br>依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。<br>● 提高安全性<br>想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到</p>
<h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><p>门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。</p>
<h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><p>● 为一个复杂的模块或子系统提供一个供外界访问的接口<br>● 子系统相对独立——外界对子系统的访问只要黑箱操作即可<br>比如利息的计算问题，没有深厚的业务知识和扎实的技术水平是不可能开发出该子系统的，但是对于使用该系统的开发人员来说，他需要做的就是输入金额以及存期，其他的都不用关心，返回的结果就是利息，这时候，门面模式是非使用不可了。<br>● 预防低水平人员带来的风险扩散</p>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br><img src="/2017/12/06/设计模式之禅/备忘录.png" alt=""><br>● Originator发起人角色<br>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。<br>● Memento备忘录角色<br>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。<br>● Caretaker备忘录管理员角色<br>对备忘录进行管理、保存和提供备忘录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 创建一个备忘录</div><div class="line">	public Memento <span class="function"><span class="title">createMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new Memento(this.state);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 恢复一个备忘录</div><div class="line">	public void restoreMemento(Memento _memento) &#123;</div><div class="line">		this.setState(_memento.getState());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Memento &#123;</div><div class="line">	// 发起人的内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	// 构造函数传递参数</div><div class="line">	public Memento(String _state) &#123;</div><div class="line">		this.state = _state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Caretaker &#123;</div><div class="line">	// 备忘录对象</div><div class="line">	private Memento memento;</div><div class="line"></div><div class="line">	public Memento <span class="function"><span class="title">getMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> memento;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Memento(Memento memento) &#123;</div><div class="line">		this.memento = memento;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义出发起人</div><div class="line">		Originator originator = new Originator();</div><div class="line">		// 定义出备忘录管理员</div><div class="line">		Caretaker caretaker = new Caretaker();</div><div class="line">		// 创建一个备忘录</div><div class="line">		caretaker.setMemento(originator.createMemento());</div><div class="line">		// 恢复一个备忘录</div><div class="line">		originator.restoreMemento(caretaker.getMemento());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 需要保存和恢复数据的相关状态场景。<br>● 提供一个可回滚（rollback）的操作；比如Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。<br>● 需要监控的副本场景中。例如要监控一个对象的属性，但是监控又不应该作为系统=的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。<br>● 数据库连接的事务管理就是用的备忘录模式</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br><img src="/2017/12/06/设计模式之禅/访问.png" alt=""><br>● Visitor——抽象访问者<br>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。<br>● ConcreteVisitor——具体访问者<br>它影响访问者访问到一个类后该怎么干，要做什么事情。<br>● Element——抽象元素<br>接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。<br>● ConcreteElement——具体元素<br>实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了。<br>● ObjectStruture——结构对象<br>元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目中，一般很少抽象出这个角色。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public abstract class Element &#123;</div><div class="line">	// 定义业务逻辑</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	// 允许谁来访问</div><div class="line">	public abstract void accept(IVisitor visitor);</div><div class="line">&#125;</div><div class="line">public class ConcreteElement1 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteElement2 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface IVisitor &#123;</div><div class="line">	// 可以访问哪些对象</div><div class="line">	public void visit(ConcreteElement1 el1);</div><div class="line"></div><div class="line">	public void visit(ConcreteElement2 el2);</div><div class="line">&#125;</div><div class="line">public class Visitor implements IVisitor &#123;</div><div class="line">	// 访问el1元素</div><div class="line">	public void visit(ConcreteElement1 el1) &#123;</div><div class="line">		el1.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 访问el2元素</div><div class="line">	public void visit(ConcreteElement2 el2) &#123;</div><div class="line">		el2.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ObjectStruture &#123;</div><div class="line">	// 对象生成器，这里通过一个工厂方法模式模拟</div><div class="line">	public static Element <span class="function"><span class="title">createElement</span></span>() &#123;</div><div class="line">		Random rand = new Random();</div><div class="line">		<span class="keyword">if</span> (rand.nextInt(100) &gt; 50) &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement1();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement2();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			// 获得元素对象</div><div class="line">			Element el = ObjectStruture.createElement();</div><div class="line">			// 接受访问者访问</div><div class="line">			el.accept(new Visitor());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><p>● 符合单一职责原则<br>具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。<br>● 优秀的扩展性<br>由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。<br>● 灵活性非常高<br>例如，数据汇总，就以刚刚我们说的Employee的例子，如果我现在要统计所有员工的工资之和，怎么计算？把所有人的工资for循环加一遍？是个办法，那我再提个问题，员工工资×1.2，部门经理×1.4，总经理×1.8，然后把这些工资加起来，你怎么处理？1.2，1.4，1.8是什么？不是吧？！你没看到领导不论什么时候都比你拿得多，工资奖金就不说了，就是过节发个慰问券也比你多，就是这个系数在作祟。我们继续说你想怎么统计？使用for循环，然后使用instanceof来判断是员工还是经理？这可以解决，但不是个好办法，好办法是通过访问者模式来实现，把数据扔给访问者，由访问者来进行统计计算。</p>
<h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><p>● 具体元素对访问者公布细节<br>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。<br>● 具体元素变更比较困难<br>具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？<br>● 违背了依赖倒置转原则<br>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖=于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。<br>● 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。<br>总结一下，在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。访问者模式还有一个用途，就是充当拦截器（Interceptor）角色。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。<br>● State——抽象状态角色<br>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。<br>● ConcreteState——具体状态角色<br>每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。<br>● Context——环境角色<br>定义客户端需要的接口，并且负责具体状态的切换。<br>环境角色有两个不成文的约束：<br>● 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。<br>● 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public abstract class State &#123;</div><div class="line">	// 定义一个环境角色，提供子类访问</div><div class="line">	protected Context context;</div><div class="line"></div><div class="line">	// 设置环境角色</div><div class="line">	public void <span class="built_in">set</span>Context(Context _context) &#123;</div><div class="line">		this.context = _context;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为1</div><div class="line">	public abstract void handle1();</div><div class="line"></div><div class="line">	// 行为2</div><div class="line">	public abstract void handle2();</div><div class="line">&#125;</div><div class="line">public class ConcreteState1 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 设置当前状态为<span class="built_in">stat</span>2</div><div class="line">		super.context.setCurrentState(Context.STATE2);</div><div class="line">		// 过渡到state2状态，由Context实现</div><div class="line">		super.context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteState2 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 设置当前状态为state1</div><div class="line">		super.context.setCurrentState(Context.STATE1);</div><div class="line">		// 过渡到state1状态，由Context实现</div><div class="line">		super.context.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 定义状态</div><div class="line">	public final static State STATE1 = new ConcreteState1();</div><div class="line">	public final static State STATE2 = new ConcreteState2();</div><div class="line">	// 当前状态</div><div class="line">	private State CurrentState;</div><div class="line"></div><div class="line">	// 获得当前状态</div><div class="line">	public State <span class="function"><span class="title">getCurrentState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> CurrentState;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置当前状态</div><div class="line">	public void <span class="built_in">set</span>CurrentState(State currentState) &#123;</div><div class="line">		this.CurrentState = currentState;</div><div class="line">		// 切换状态</div><div class="line">		this.CurrentState.setContext(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为委托</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		this.CurrentState.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		this.CurrentState.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义环境角色</div><div class="line">		Context context = new Context();</div><div class="line">		// 初始化状态</div><div class="line">		context.setCurrentState(new ConcreteState1());</div><div class="line">		// 行为执行</div><div class="line">		context.handle1();</div><div class="line">		context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><p>● 结构清晰<br>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性,提高系统的可维护性。<br>● 遵循设计原则<br>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。<br>● 封装性非常好<br>这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</p>
<h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><p>子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。</p>
<h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><p>● 行为随状态改变而改变的场景<br>这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。<br>● 条件、分支判断语句的替代者<br>在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变<br>化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）是一种按照规定语法进行解析的方案，在现在项目中使用较少。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br><img src="/2017/12/06/设计模式之禅/解释器.png" alt=""><br>● AbstractExpression——抽象解释器<br>具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和 Non-terminalExpression完成。<br>● TerminalExpression——终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达<br>式，但有多个实例，对应不同的终结符。具体到我们例子就是VarExpression类，表达式中的每个终结符都在栈中产生了一个VarExpression对象。<br>● NonterminalExpression——非终结符表达式<br>文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。<br>● Context——环境角色<br>具体到我们的例子中是采用HashMap代替。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public abstract class Expression &#123;</div><div class="line">	// 每个表达式必须有一个解析任务</div><div class="line">	public abstract Object interpreter(Context ctx);</div><div class="line">&#125;</div><div class="line">public class NonterminalExpression extends Expression &#123;</div><div class="line">	// 每个非终结符表达式都会对其他表达式产生依赖</div><div class="line">	public NonterminalExpression(Expression... expression) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		// 进行文法处理</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class TerminalExpression extends Expression &#123;</div><div class="line">	// 通常终结符表达式只有一个，但是有多个对象</div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p>
<h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><p>● 解释器模式会引起类膨胀<br>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。<br>● 解释器模式采用递归调用方法<br>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下使用的，它导致调试非常复杂。想想看，如果要排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。<br>● 效率问题<br>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。</p>
<h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><p>● 重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。<br>● 一个简单语法需要解释的场景</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）是池技术的重要实现方式。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>使用共享对象可有效地支持大量的细粒度的对象。<br><img src="/2017/12/06/设计模式之禅/享元模式.png" alt=""><br>● Flyweight——抽象享元角色<br>它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。<br>● ConcreteFlyweight——具体享元角色<br>具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。<br>● unsharedConcreteFlyweight——不可共享的享元角色<br>不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。<br>● FlyweightFactory——享元工厂<br>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public abstract class Flyweight &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String intrinsic;</div><div class="line">	// 外部状态</div><div class="line">	protected final String Extrinsic;</div><div class="line"></div><div class="line">	// 要求享元角色必须接受外部状态</div><div class="line">	public Flyweight(String _Extrinsic) &#123;</div><div class="line">		this.Extrinsic = _Extrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义业务操作</div><div class="line">	public abstract void operate();</div><div class="line"></div><div class="line">	// 内部状态的getter/setter</div><div class="line">	public String <span class="function"><span class="title">getIntrinsic</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> intrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Intrinsic(String intrinsic) &#123;</div><div class="line">		this.intrinsic = intrinsic;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight1(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight2(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class FlyweightFactory &#123;</div><div class="line">	// 定义一个池容器</div><div class="line">	private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;String, Flyweight&gt;();</div><div class="line"></div><div class="line">	// 享元工厂</div><div class="line">	public static Flyweight getFlyweight(String Extrinsic) &#123;</div><div class="line">		// 需要返回的对象</div><div class="line">		Flyweight flyweight = null;</div><div class="line">		// 在池中没有该对象</div><div class="line">		<span class="keyword">if</span> (pool.containsKey(Extrinsic)) &#123;</div><div class="line">			flyweight = pool.get(Extrinsic);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 根据外部状态创建享元对象</div><div class="line">			flyweight = new ConcreteFlyweight1(Extrinsic);</div><div class="line">			// 放置到池中</div><div class="line">			pool.put(Extrinsic, flyweight);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> flyweight;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><p>元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存<br>的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h3 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h3><p>● 系统中存在大量的相似对象。<br>● 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>● 需要缓冲池的场景。</p>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><p>桥梁模式（Bridge Pattern）也叫做桥接模式，是一个比较简单的模式</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>将抽象和实现解耦，使得两者可以独立地变化。<br><img src="/2017/12/06/设计模式之禅/桥梁.png" alt=""><br>● Abstraction——抽象化角色<br>它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。<br>● Implementor——实现化角色<br>它是接口或者抽象类，定义角色必需的行为和属性。<br>● RefinedAbstraction——修正抽象化角色<br>它引用实现化角色对抽象化角色进行修正。<br>● ConcreteImplementor——具体实现化角色<br>它实现接口或抽象类定义的方法和属性。<br>桥梁模式中的几个名词比较拗口，大家只要记住一句话就成：抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public interface Implementor &#123;</div><div class="line">	// 基本方法</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	public void <span class="keyword">do</span>Anything();</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor1 implements Implementor &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor2 implements Implementor&#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public abstract class Abstraction &#123;</div><div class="line">	// 定义对实现化角色的引用</div><div class="line">	private Implementor imp;</div><div class="line"></div><div class="line">	// 约束子类必须实现该构造函数</div><div class="line">	public Abstraction(Implementor _imp) &#123;</div><div class="line">		this.imp = _imp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 自身的行为和属性</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.imp.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得实现化角色</div><div class="line">	public Implementor <span class="function"><span class="title">getImp</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> imp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class RefinedAbstraction extends Abstraction &#123;</div><div class="line">	// 覆写构造函数</div><div class="line">	public RefinedAbstraction(Implementor _imp) &#123;</div><div class="line">		super(_imp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 修正父类的行为</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 业务处理...</div><div class="line">		 */</div><div class="line">		super.request();</div><div class="line">		super.getImp().doAnything();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义一个实现化角色</div><div class="line">		Implementor imp = new ConcreteImplementor1();</div><div class="line">		// 定义一个抽象化角色</div><div class="line">		Abstraction abs = new RefinedAbstraction(imp);</div><div class="line">		// 执行行文</div><div class="line">		abs.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h3><p>● 抽象和实现分离<br>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。<br>● 优秀的扩充能力<br>看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。<br>● 实现细节对客户透明<br>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p>
<h3 id="场景-8"><a href="#场景-8" class="headerlink" title="场景"></a>场景</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;h2 id=&quot;单一职责-SRP&quot;&gt;&lt;a href=&quot;#单一职责-SRP&quot; class=&quot;headerlink&quot; title=&quot;单
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java8</title>
    <link href="http://yoursite.com/2017/12/02/java8/"/>
    <id>http://yoursite.com/2017/12/02/java8/</id>
    <published>2017-12-02T07:22:38.000Z</published>
    <updated>2017-12-07T13:48:13.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>java8新特性：Lambda（匿名函数）、流、默认方法</p>
<h2 id="java中的函数"><a href="#java中的函数" class="headerlink" title="java中的函数"></a>java中的函数</h2><p>java8新增函数作为值的一种新形式。</p>
<h3 id="方法和-Lambda-作为一等公民"><a href="#方法和-Lambda-作为一等公民" class="headerlink" title="方法和 Lambda 作为一等公民"></a>方法和 Lambda 作为一等公民</h3><p>Java 8的第一个新功能是方法引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> File[] hiddenFiles= new File(<span class="string">"."</span>).listFiles(new <span class="function"><span class="title">FileFilter</span></span>()&#123;</div><div class="line">     public boolean accept(File file)&#123;</div><div class="line">         <span class="built_in">return</span> file.isHidden();</div><div class="line">     &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">File[] hiddenFiles1 = new File(<span class="string">"."</span>).listFiles(File::isHidden);</div></pre></td></tr></table></figure></p>
<h3 id="传递代码"><a href="#传递代码" class="headerlink" title="传递代码"></a>传递代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static boolean isGreenApple(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.color.equals(<span class="string">"green"</span>);</div><div class="line">	&#125;</div><div class="line">	public static boolean isHeavy(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.weight&gt;150;</div><div class="line">	&#125;</div><div class="line">	public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list,Predicate&lt;Apple&gt; p)&#123;</div><div class="line">		List&lt;Apple&gt; result=new ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(Apple apple:list)&#123;</div><div class="line">			<span class="keyword">if</span>(p.test(apple))</div><div class="line">			result.add(apple);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		List&lt;Apple&gt; list=new ArrayList&lt;Apple&gt;();</div><div class="line">		list.add(new Apple(150, <span class="string">"red"</span>));</div><div class="line">		filterApple(list, AppleExample::isHeavy);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从传递方法到Lambda"><a href="#从传递方法到Lambda" class="headerlink" title="从传递方法到Lambda"></a>从传递方法到Lambda</h3><p>不过Java 8也解决了这个问题，它引入了一套新记法（匿名函数或Lambda）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">filterApple(inventory, (Apple a) -&gt; <span class="string">"green"</span>.equals(a.getColor()) );</div><div class="line">filterApple(inventory, (Apple a) -&gt; a.weight &gt; 150 );</div></pre></td></tr></table></figure></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =</div><div class="line">transactions.stream()</div><div class="line">.filter((Transaction t) -&gt; t.getPrice() &gt; 1000)</div><div class="line">.collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<p>Stream允许并提倡并行处理一个 Stream 中的元素。虽然可能乍看上去有点儿怪，但筛选一个 Collection （filterApples 应用在一个List 上）的最快方法常常是将其转换为 Stream ，进行并行处理，然后再转换回 List<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//顺序处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.stream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div><div class="line">//并行处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div></pre></td></tr></table></figure></p>
<p>库会负责分块，即把大的流分成几个小的流，以便并行处理。其次，流提供的这个几乎免费的并行，只有在传递给 filter 之类的库方法的方法不会互动（比方说有可变的共享对象）时才能工作。</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8的解决方法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名<br>了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现） ，而不是由实现类提供。<br>这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明<br>中使用新的 default 关键字来表示这一点。例如，在Java 8里，你现在可以直接对 List 调用 sort 方法。它是用Java 8  List 接口中如下所示的默认方法实现的，它会调用 Collections.sort 静态方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">Collections.sort(this, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这意味着 List 的任何实体类都不需要显式实现 sort ，而在以前的Java版本中，除非提供了sort 的实现，否则这些实体类在重新编译时都会失败。</p>
<h1 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h1><h2 id="应对不断变化的需求"><a href="#应对不断变化的需求" class="headerlink" title="应对不断变化的需求"></a>应对不断变化的需求</h2><h3 id="初试牛刀：筛选绿苹果"><a href="#初试牛刀：筛选绿苹果" class="headerlink" title="初试牛刀：筛选绿苹果"></a>初试牛刀：筛选绿苹果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把颜色作为参数"><a href="#把颜色作为参数" class="headerlink" title="把颜色作为参数"></a>把颜色作为参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory,String color) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(color.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三次尝试对属性做筛选"><a href="#第三次尝试对属性做筛选" class="headerlink" title="第三次尝试对属性做筛选"></a>第三次尝试对属性做筛选</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span> (Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>((flag&amp;&amp;apple.getColor().equals(color))||(!flag&amp;&amp;apple.getWeight()&gt;150))&#123;</div><div class="line">      result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h2><p>1.传递代码/行为，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt;inventory, ApplePredicate p)&#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">   <span class="keyword">if</span>(p.test(apple))&#123;</div><div class="line">      result.add(apple);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">  ApplePredicate p=new AppleRedAndHeavyPredicate();</div><div class="line">  List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.多种行为，一种参数<br>行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应用的行为区分开来。这样你可以重复使用同一个方法，给它不同的行为来达到不同的目的。<br><img src="/2017/12/02/java8/行为参数化.PNG" alt=""></p>
<h2 id="对付啰嗦"><a href="#对付啰嗦" class="headerlink" title="对付啰嗦"></a>对付啰嗦</h2><p>当要把新的行为传递给filterApples方法的时候，你不得不声明好几个实现 ApplePredicate接口的类，然后实例化好几个只会提到一次的ApplePredicate对象.</p>
<h3 id="使用匿名类"><a href="#使用匿名类" class="headerlink" title="使用匿名类"></a>使用匿名类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new <span class="function"><span class="title">ApplePredicate</span></span>() &#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>匿名类在GUI经常用到，但是有缺点：1.很笨重；2.用起来费解。</p>
<h3 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; result=filterApples(list,(Apple a)-&gt;<span class="string">"red"</span>.equals(a.color));</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/参数化和值参数化.PNG" alt=""></p>
<h3 id="List抽象化"><a href="#List抽象化" class="headerlink" title="List抽象化"></a>List抽象化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">   boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list,Predicate&lt;T&gt; p)&#123;</div><div class="line">   List&lt;T&gt; result=new ArrayList&lt;T&gt;();</div><div class="line">   <span class="keyword">for</span>(T t:list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(t))&#123;</div><div class="line">       result.add(t);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="真实的例子"><a href="#真实的例子" class="headerlink" title="真实的例子"></a>真实的例子</h2><h3 id="使用Comparator排序"><a href="#使用Comparator排序" class="headerlink" title="使用Comparator排序"></a>使用Comparator排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a,Apple b)-&gt; a.getWeight().compareTo(b.getWeight()));</div></pre></td></tr></table></figure>
<h3 id="用runnable执行代码块"><a href="#用runnable执行代码块" class="headerlink" title="用runnable执行代码块"></a>用runnable执行代码块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=new Thread(()-&gt;System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure>
<h3 id="GUI例子"><a href="#GUI例子" class="headerlink" title="GUI例子"></a>GUI例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnAction((ActionEvent event)-&gt;lable.setText(<span class="string">"hello"</span>));</div></pre></td></tr></table></figure>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h2><p>Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：没有名称、有参数列表函数主体、返回类型、可能还会有可抛出的异常列表。<br>特点：<br>匿名：不像普通方法有明确的名称：写得少而想得多<br>函数：Lambda函数不像方法那样属于某个特定的类。但和方法一样，有参数列表，函数主体，返回类型，还可能有可抛出的异常列表。<br>传递：Lambda表达式可作为参数传递给方法或者存储在变量中<br>简洁：无需像匿名类写很多模板代码<br><img src="/2017/12/02/java8/Lambda表达式.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//有效Lambda表达式</div><div class="line">(String s)-&gt; s.length()</div><div class="line">(Apple a)-&gt; a.weigth&gt;150</div><div class="line">(int x,int y)-&gt;&#123;</div><div class="line">   System.out.println(<span class="string">"result:"</span>);</div><div class="line">   System.out.println(x+y);</div><div class="line">&#125;</div><div class="line">()-&gt;42</div><div class="line">(Apple a1,Apple a2)-&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<p>Lambda语法：(parameters)-&gt;expression或者(parameters)-&gt;{statements;}</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>布尔表达式：(List<string> list)-&gt; list.isEmpty()<br>创建一个对象:()-&gt;new Apple(10):<br>消费一个对象:(Apple a)-&gt;{System.out.println(a.getWeight());}<br>从一个对象中选择或选取:(String s)-&gt; s.length()<br>组合两个值:(int a,int b)-&gt;a*b<br>三比较两个对象:(Apple a1,Apple a2)-&gt; a1.getWeight.compareTo(12.getWeight())</string></p>
<h2 id="在哪里以及如何使用Lambda"><a href="#在哪里以及如何使用Lambda" class="headerlink" title="在哪里以及如何使用Lambda"></a>在哪里以及如何使用Lambda</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只定义一个抽象方法的接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface Runnable&#123;</div><div class="line">  public void run();</div><div class="line">&#125;</div><div class="line">public interface Comparator&lt;T&gt;&#123;</div><div class="line">  public int compare(T o1,T o2);</div><div class="line">&#125;</div><div class="line">public interface Callable&lt;T&gt;&#123;</div><div class="line">  public T call();</div><div class="line">&#125;</div><div class="line">public interface PrivilegedAction&lt;V&gt;&#123;</div><div class="line">  V run();</div><div class="line">&#125;</div><div class="line">public interface ActionListener extends EventListener&#123;</div><div class="line">  void actionPerformed(ActionEvent e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化。</p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫做函数描述符。例如runnable接口是()-&gt;void.<br>如果你用@FunctionalInterface 定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。@FunctionalInter-face不是必需的，但对于为此设计的接口而言,使用它是比较好的做法。它就像是@Override标注表示方法被重写了.</p>
<h2 id="环绕执行模式"><a href="#环绕执行模式" class="headerlink" title="环绕执行模式"></a>环绕执行模式</h2><p>通过一个例子，看看在实践中如何利用Lambda和行为参数化来让代码更为灵活。资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static String processFile() throws IOException &#123;</div><div class="line">  try (BufferedReader br =new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">    <span class="built_in">return</span> br.readLine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="行为参数化-1"><a href="#行为参数化-1" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>你只能读文件的第一行。如果你想要返回头两行？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String result = processFile((BufferedReader br) -&gt;br.readLine() + br.readLine());</div></pre></td></tr></table></figure></p>
<h3 id="使用函数式接口传递行为"><a href="#使用函数式接口传递行为" class="headerlink" title="使用函数式接口传递行为"></a>使用函数式接口传递行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public class BufferedReaderProcessor&#123;</div><div class="line">  String process(BufferedReader reader) throws IOException;</div><div class="line">&#125;</div><div class="line">public static String processFile(BufferedReaderProcessor p) throws IOException&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="执行一个行为"><a href="#执行一个行为" class="headerlink" title="执行一个行为"></a>执行一个行为</h3><p>任何 BufferedReader -&gt; String 形式的Lambda都可以作为参数来传递，因为它们符合BufferedReaderProcessor 接口中定义的 process 方法的签名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static String processFile(BufferedReaderProcessor p) throws</div><div class="line">IOException &#123;</div><div class="line">  try (BufferedReader br =</div><div class="line">      new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">      <span class="built_in">return</span> p.process(br);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="传递Lambda"><a href="#传递Lambda" class="headerlink" title="传递Lambda"></a>传递Lambda</h3><p>现在你就可以通过传递不同的Lambda重用processFile方法，并以不同的方式处理文件了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String oneLine=processFile((BufferedReader br)-&gt; br.readLine());</div><div class="line">String twoLine= processFile((BufferedReader br)-&gt; br.readLine()+br.readLine());</div></pre></td></tr></table></figure></p>
<h2 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h2><p>java Api已经有几个函数式接口，比如Comparable、Runnable和Callable。</p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>java.util.function.Predicate<t> 接口定义了一个名叫test的抽象方法，它接受泛型T对象并返回一个boolean这恰恰和你先前创建的一样，现在就可以直接使用了。在你需要表示一个涉及类型T的布尔表达式时，就可以使用这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">    boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</div><div class="line"> List&lt;T&gt; results = new ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(s))&#123;</div><div class="line">       results.add(s);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> <span class="built_in">return</span> results;</div><div class="line">&#125;</div><div class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt;!s.isEmpty();</div><div class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings,nonEmptyStringPredicate);</div></pre></td></tr></table></figure></t></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>java.util.Consumer<t>定义了一个名为accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用<br>这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Consumer&lt;T&gt;&#123;</div><div class="line">   void accept(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; void <span class="keyword">for</span>Each(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123;</div><div class="line">   <span class="keyword">for</span>(T i: list)&#123;</div><div class="line">       c.accept(i);</div><div class="line">   &#125;</div><div class="line">&#125;  </div><div class="line"><span class="keyword">for</span>Each(Arrays.asList(1,2,3,4,5),(Integer i)-&gt;System.out.println(i));</div></pre></td></tr></table></figure></t></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>java.util.function.Function<t, r=""> 接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Function&lt;T,R&gt;&#123;</div><div class="line">  R apply(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list,Function&lt;T,R&gt; f)&#123;</div><div class="line">  List&lt;R&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">    result.add(f.apply(s));</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">List&lt;Integer&gt; l = map(</div><div class="line">Arrays.asList(<span class="string">"lambdas"</span>,<span class="string">"in"</span>,<span class="string">"action"</span>),</div><div class="line">(String s) -&gt; s.length()</div><div class="line">);</div></pre></td></tr></table></figure></t,></p>
<p>Java类型要么是引用类型（比如Byte、Integer、Object、List），要么是原始类型（比如int、double、byte、char）。但是泛型（比如Consumer<t> 中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的.因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing）。相反的是拆箱操作。</t></p>
<h2 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h2><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>Lambda的类型是从使用Lambda的上下文推断。上下文中Lambda表达式的需要的类型称为目标类型。<br><img src="/2017/12/02/java8/Lambda类型检查.png" alt=""><br>首先，你要找出filter方法的声明。<br>第二，要求它是Predicate<apple>（目标类型）对象的第二个正式参数。<br>第三，Predicate<apple>是一个函数式接口，定义了一个叫作test的抽象方法<br>第四，test 方法描述了一个函数描述符，它可以接受一个 Apple ，并返回一个 boolean 。<br>最后，filter 的任何实际参数都必须匹配这个要求</apple></apple></p>
<h3 id="同样的Lambda，不同的接口"><a href="#同样的Lambda，不同的接口" class="headerlink" title="同样的Lambda，不同的接口"></a>同样的Lambda，不同的接口</h3><p>有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Callable&lt;Integer&gt; c = () -&gt; 42;</div><div class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; 42;</div></pre></td></tr></table></figure></p>
<p>类型检查<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为什么下面的代码不能编译</div><div class="line">Object o = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div><div class="line">答案：Lambda表达式的上下文是 Object （目标类型） 。但 Object 不是一个函数式接口。</div><div class="line">为了解决这个问题，你可以把目标类型改成 Runnable ，它的函数描述符是 () -&gt; void ：</div><div class="line">Runnable r = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。显示类型可读性更高<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div></pre></td></tr></table></figure></p>
<p>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，或事实上是final 。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量 this） 例如，下面的代码无法编译，因为 portNumber变量被赋值两次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div><div class="line">portNumber = 31337</div></pre></td></tr></table></figure></p>
<p>为什么局部变量有这些限制。<br>第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。<br>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式.<br>闭包<br>你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。 这些变量必须是隐式最终的。 可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的） 。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
<h3 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h3><p>如果一个Lambda代表的只是直接调用这个方法，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。<br>当你需要使用方法引用时，目标引用放在分隔符 :: 前，方法的名称放在后面。例如，Apple::getWeight 就是引用了 Apple 类中定义的方法 getWeight，，不需要括号，因为你没有实际调用这个方法。<br>构建方法引用的方式：</p>
<ol>
<li>指向静态方法的引用(Integer.parseInt方法，写做Integer::parseInt)</li>
<li>指向任意实例化类型方法的方法引用，(String的length写做String::length)</li>
<li>指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放 Transaction 类型的对象，它支持实例方法getValue ，那么你就可以写 expensive-Transaction::getValue ）</li>
</ol>
<p>二种和第三种方法引用可能乍看起来有点儿晕。类似于 String::length 的第二种方法引用的思想就是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数。例如，Lambda表达式 (String s) -&gt; s.toUppeCase() 可以写作 String::toUpperCase。但第三种方法引用指的是，你在Lambda中调用一个已经存在的外部对象中的方法。例如，Lambda表达式()-&gt; expensiveTransaction.getValue() 可以写作expensiveTransaction::getValue。<br><img src="/2017/12/02/java8/lambda方法引用.png" alt=""></p>
<h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>你可以利用它的名称和关键字new来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。假设有一个构造函数没有参数，它适合Supplier的签名() -&gt; Apple。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//无参数的构造函数</div><div class="line">Supplier&lt;Apple&gt; c1=Apple::new;</div><div class="line">Apple a=c1.get();</div><div class="line">或者</div><div class="line">Supplier&lt;Apple&gt; c1=()-&gt;new Apple();</div><div class="line">//带参数的构造函数</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=Apple::new;</div><div class="line">等价于</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=(weight)-&gt;new Apple(weight);</div><div class="line">Apple a=function.apply(110);</div><div class="line">//两个参数的构造函数</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=Apple::new;</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=(color,weight)-&gt;new Apple(color,weight);</div><div class="line">Apple a=biFunction.apply(<span class="string">"red"</span>,100);</div></pre></td></tr></table></figure></p>
<h2 id="Lambda和方法引用实战"><a href="#Lambda和方法引用实战" class="headerlink" title="Lambda和方法引用实战"></a>Lambda和方法引用实战</h2><h2 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h2><p>许多函数式接口，比如用<br>于传递Lambda表达式的 Comparator 、Function 和 Predicate 都提供了允许你进行复合的方法。可以让两个谓词之间做一个 or 操作，组合成一个更大的谓词。而且，你还可以让一个函数的结果成为另一个函数的输入。窍门在于，我们即将介绍的方法都是默认方法。</p>
<h3 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h3><h4 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h4><p>按照重量递减排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed());</div></pre></td></tr></table></figure></p>
<h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><p>按照重量递减排序,相同体重的苹果在根据国家排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry));</div></pre></td></tr></table></figure></p>
<h3 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h3><p>谓词接口包括三个接口:negate、and和or，可以让你重用已有的predicate来创建更复杂的谓词。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//苹果不是红的</div><div class="line">Predicate&lt;Apple&gt; notRedApple=redApple.negate();</div><div class="line">//苹果又红又重</div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApples=redApple.and(a-&gt;a.ggetWeight()&gt;150);</div><div class="line">//又红又重的苹果或者绿苹果,a.and(b).or(c),代表(a&amp;b)||c,从左到右确定优先级</div><div class="line">Predicate&lt;Apple&gt; redAndHeadvyOrGreen=redApple.and(a-&gt;a.getWeight()&gt;150).or(a-&gt;a.getColor().equals(<span class="string">"green"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p>可以把Function接口所代表的Lambda表达式复合，Function提供了andThen和compose两个默认方法，它们都返回一个Function的实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</div><div class="line">       Objects.requireNonNull(before);</div><div class="line">       <span class="built_in">return</span> (V v) -&gt; apply(before.apply(v));</div><div class="line">   &#125;</div><div class="line">default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</div><div class="line">     Objects.requireNonNull(after);</div><div class="line">     <span class="built_in">return</span> (T t) -&gt; after.apply(apply(t));</div><div class="line"> &#125;</div><div class="line">Function&lt;Integer, Integer&gt; f= x -&gt; x + 1;</div><div class="line">Function&lt;Integer, Integer&gt; g= x -&gt; x * 2;</div><div class="line">对于g(f(x))</div><div class="line">Function&lt;Integer,Integer&gt; h=f.andThen(g);</div><div class="line">Function&lt;Integer,Integer&gt; h=g.compose(f);</div><div class="line">int result=h.apply(1);</div></pre></td></tr></table></figure></p>
<p>用String表示一封信的文本转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Letter &#123;</div><div class="line">	public static String addHeader(String text) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"From Raoul, Mario and Alan: "</span> + text;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String addFooter(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text + <span class="string">" Kind regards"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String checkSpelling(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</div><div class="line">	&#125;</div><div class="line">  Function&lt;String, String&gt; addHeader =Letter::addHeader;</div><div class="line">  Function&lt;String, String&gt; transformationPipeline=addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h1><h2 id="引入流"><a href="#引入流" class="headerlink" title="引入流"></a>引入流</h2><p>流允许你使用声明性方式处理数据集合，就现在来说，你可以把他们看成遍历数据集的高级迭代器，此外，流可以透明并行处理。下面两段代码都是用来返回低热量的菜肴名称的，并按照卡路里排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//java7</div><div class="line">List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  <span class="keyword">if</span>(d.getCalories() &lt; 400)&#123;</div><div class="line">   lowCaloricDishes.add(d);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() &#123;</div><div class="line">  public int compare(Dish d1, Dish d2)&#123;</div><div class="line">     <span class="built_in">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)&#123;</div><div class="line"> lowCaloricDishesName.add(d.getName());</div><div class="line">&#125;</div><div class="line">//java8</div><div class="line">menu.parallelStream()</div><div class="line">				.filter((Dish d) -&gt; d.getCalories() &lt; 400)</div><div class="line">				.sorted((Dish d1, Dish d2) -&gt; d1.getCalories()</div><div class="line">				- d2.getCalories()).map((Dish d)-&gt;d.name).collect(toList());</div></pre></td></tr></table></figure></p>
<h2 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h2><p>从支持数据处理操作的源生成的元素序列。集合强调的是数据，流强调的是计算</p>
<ul>
<li>元素序列–流提供了一个接口，可以访问特定元素类型的一组有序值。</li>
<li>源–流会使用提供数据的源，如集合、数组或输入输出资源。从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作–流的数据处理功能类似于数据库的操作，如filter、map、reduce、find、match、sort。流操作可以顺序执行，也可以并行执行。<br>流操作的特点</li>
<li>流水线–很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li>
<li>内部迭代–使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.parallelStream()</div><div class="line">				.filter((d) -&gt; d.getCalories() &lt; 500).limit(1)</div><div class="line">				.map((d) -&gt; d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/menu.png" alt=""></p>
<h2 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h2><p>java现有的集合概念和新的流概念都提供了接口，来代表元素型有序值的有序接口。所谓有序，就是我们一般按照顺序取用值，而不是随机取用。<br>集合和流的之间的差异在于什么时候进行计算。集合是内存的数据结构，它包含数据结构目前所有值–集合中每个元素都得算出来才能添加到集合里面。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）流在概念上是固定的数据结构，你不能添加或者删除元素，其元素是按需计算的。类比质数流，尽管质数有无穷多个，但是仅仅从流提取需要的值，这样实现会很简单。这是一种生产者消费者关系，换另外的角度来讲，流就像是个延迟创建的集合：只有在消费者要求的时候才会计算其值。而集合是急切创建的，以质数为例，要想创建一个包含所有质数的集合，那么集合永远创建不完，消费者永远获取不到这个集合。</p>
<h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h3><p>和迭代器类似，流只能遍历一次，遍历完后，这个流就已经被消费掉了，你可以从原始数据源那里在获得一个新的流重新遍历一遍。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; title = Arrays.asList(<span class="string">"Java8"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</div><div class="line">Stream&lt;String&gt; s = title.stream();</div><div class="line">s.forEach(System.out::println);</div><div class="line">//java.lang.IllegalStateException:流已被操作</div><div class="line">或关闭</div><div class="line">s.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h3><h4 id="用for-Each循环外部迭代"><a href="#用for-Each循环外部迭代" class="headerlink" title="用for-Each循环外部迭代"></a>用for-Each循环外部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用背后迭代器"><a href="#用背后迭代器" class="headerlink" title="用背后迭代器"></a>用背后迭代器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line">Iterator&lt;String&gt; iterator = menu.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">   Dish d = iterator.next();</div><div class="line">   names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="流：内部迭代"><a href="#流：内部迭代" class="headerlink" title="流：内部迭代"></a>流：内部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names=menu.stream().map(d-&gt;d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/迭代.png" alt=""></p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; name=menu.stream().filter(d-&gt;d.getCalories()&lt;300).map(d-&gt;g.getName())<span class="built_in">limit</span>(3).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>filter、map、limit可以连成一条流水线，collect触发流水线执行并关闭。可以连起来的流操作称为中间操作，关闭流的操作称为终端操作。</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>诸如filter、sorted等中间操作会返回另外一个流，这让多个操作可以连接起来形成一个查询。除非流水线触发一个终端操作，否则中间操作不会执行任何处理。</p>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p>终端操作会从流的流水线生成结果，其结果是任何不是流的值，比如List、Integer甚至是void。</p>
<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>一个数据源来执行一个查询、一个中间操作链形成一条流的流水线、一个终端形成流水线，并能生成结果。<br>中间操作：<br>filter|Stream<t>|Predicate<t>|T-&gt;boolean<br>map|Stream<t>|Function<t,r>|T-&gt;R<br>limit|Stream<t><br>sorted|Stream<t>|Comparator<t>|(T,T)-&gt;int<br>distinct|Stream<t><br>终端操作<br>forEach 消费流中的每个元素并对其使用应用Lambda。这一操作返回void。<br>count 消费流中的元素个数，返回long<br>collect 把流规约成一个集合，比如list、map甚至是Integer。</t></t></t></t></t,r></t></t></t></p>
<h1 id="使用流-1"><a href="#使用流-1" class="headerlink" title="使用流"></a>使用流</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><p>用谓词筛选，筛选出各不相同的元素，忽略流中的头几个元素，或将流截短至指定长度</p>
<h3 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h3><p>streams支持filter方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.stream().filter(i-&gt;i%2==0).distinct().forEach(System.out::println);</div></pre></td></tr></table></figure>
<h3 id="截断流"><a href="#截断流" class="headerlink" title="截断流"></a>截断流</h3><p>limit(n)，会返回不超过n的流。</p>
<h3 id="跳过流"><a href="#跳过流" class="headerlink" title="跳过流"></a>跳过流</h3><p>skip(n),返回一个扔掉前n个元素的流。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p>
<h3 id="对流中每个元素应用函数"><a href="#对流中每个元素应用函数" class="headerlink" title="对流中每个元素应用函数"></a>对流中每个元素应用函数</h3><p>流支持 map 方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; wordLengths = words.stream().map(String::length).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharacters =words.stream().map(w -&gt;w.split(<span class="string">""</span>)).</div><div class="line">flatMap(Arrays::stream).distinct().collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/flatmap.png" alt=""><br>给定两个数字列表，如何返回所有的数对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);</div><div class="line">List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);</div><div class="line">List&lt;int[]&gt; pairs=numbers1.stream().flatMap(i-&gt;number2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(asList);</div></pre></td></tr></table></figure></p>
<h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><h3 id="检查谓词至少符合一个元素"><a href="#检查谓词至少符合一个元素" class="headerlink" title="检查谓词至少符合一个元素"></a>检查谓词至少符合一个元素</h3><p>anyMatch可以回答流中是否有一个元素匹配给定谓词。nyMatch 方法返回一个boolean ，因此是一个终端操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.stream().anyMatch(Dish::isVegetarian)&#123;</div><div class="line">  System.out.println(<span class="string">"The menu is (somewhat) vegetarian friendly!!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="检查谓词是否都符合所有元素"><a href="#检查谓词是否都符合所有元素" class="headerlink" title="检查谓词是否都符合所有元素"></a>检查谓词是否都符合所有元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean isHealthy = menu.stream().allMatch(d-&gt;d.getCalories() &lt; 1000);</div></pre></td></tr></table></figure>
<h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>确保流中没有任何元素与给定的谓词匹配.anyMatch 、 allMatch 和 noneMatch 这三个操作都用到了我们所谓的短路， 这就是大家熟悉的Java中 &amp;&amp; 和 || 运算符短路在流中的版本。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>isPresent() 将在 Optional 包含值的时候返回 true , 否则返回 false 。<br>ifPresent(Consumer<t> block) 会在值存在的时候执行给定的代码块。Consumer 函数式接口；它让你传递一个接收 T 类型参数，并返回 void 的Lambda<br>表达式。<br>T get() 会在值存在时返回值，否则抛出一个 NoSuchElement 异常。<br>T orElse(T other) 会在值存在时返回值，否则返回一个默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).findAny().ifPresent(d-&gt;System.out.println(d.getName());</div></pre></td></tr></table></figure></t></p>
<h3 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h3><p>findFirst.如果你不关心返回的元素是哪个，请使用 findAny ，因为它在使用并行流<br>时限制较少。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree =someNumbers.stream()</div><div class="line">.map(x -&gt; x * x)</div><div class="line">.filter(x -&gt; x % 3 == 0)</div><div class="line">.findFirst();</div></pre></td></tr></table></figure></p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>你将看到如何把一个流中的元素组合起来，使用reduce操作来表达更复杂的查询</p>
<h3 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</div><div class="line">//reduce 还有一个重载的变体，它不接受初始值，但是会返回一个 Optional 对象：</div><div class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</div></pre></td></tr></table></figure>
<p>Integer 类现在有了一个静态的sum方法来对两个数求和，这恰好是我们想要的，用不着反复用Lambda写同一段代码了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, Integer::sum);</div></pre></td></tr></table></figure></p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; max=numbers.stream().reduce(Integer::max);</div><div class="line">Optional&lt;Integer&gt; min=numbers.stream().reduce(Integer::min);</div></pre></td></tr></table></figure>
<p>诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内部可变状态）。但诸如reduce、sum、max等操作需要内部状态来累积结果。<br><img src="/2017/12/02/java8/stream.png" alt=""></p>
<h2 id="数据值"><a href="#数据值" class="headerlink" title="数据值"></a>数据值</h2><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream 和LongStream ，分别将流中的元素特化为int、long和double ，从而避免了暗含的装箱成本。</p>
<h4 id="映射到数值"><a href="#映射到数值" class="headerlink" title="映射到数值"></a>映射到数值</h4><p>将流转换为特化版本的常用方法是 mapToInt 、mapToDouble和mapToLong.如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如max、min 、 average<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int calories = menu.stream().mapToInt(Dish::getCalories).sum();</div></pre></td></tr></table></figure></p>
<h4 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories)</div><div class="line">.max();</div></pre></td></tr></table></figure>
<h4 id="默认值OptionalInt"><a href="#默认值OptionalInt" class="headerlink" title="默认值OptionalInt"></a>默认值OptionalInt</h4><p>Optional 可以用Integer 、 String 等参考类型来参数化。对于三种原始流特化，也分别有一个 Optional 原始类型特化版本： OptionalInt 、 OptionalDouble 和 OptionalLong 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt max=menu.stream().mapToInt(Dish::getCalories).max();</div><div class="line">int m=max.orElse(1);</div></pre></td></tr></table></figure></p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。 range 是不包含结束值的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntStream evenNumbers = IntStream.rangeClosed(1, 100)</div><div class="line">.filter(n -&gt; n % 2 == 0);</div><div class="line">System.out.println(evenNumbers.count());</div></pre></td></tr></table></figure></p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>);</div></pre></td></tr></table></figure>
<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int[] numbers=&#123;1,2,,3&#125;;</div><div class="line">int sum=Arrays.stream(numbers).sum();</div></pre></td></tr></table></figure>
<h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>java.nio.file.Files 中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines ，它会返回一个由指定文件中的各行构成的字符串流。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long uniqueWords=0;</div><div class="line">try&#123;</div><div class="line">  Stream&lt;String&gt; line=Files.lines(Paths.get(<span class="string">"data.txt"</span>),Charset.defaultCharset());</div><div class="line">  uniqueWords=line.flatMap(i-&gt;Arrays.stream(i.split(<span class="string">" "</span>))).distinct().count();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.iterator(0,n-&gt;n+2).limit.forEach(System.out::println);</div></pre></td></tr></table></figure>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</div></pre></td></tr></table></figure>
<h1 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency,List&lt;Transaction&gt;&gt; transactionsByCurrencies=transactions.stream().collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<h2 id="收集器简介"><a href="#收集器简介" class="headerlink" title="收集器简介"></a>收集器简介</h2><p>多级分组里函数式版本只要再加上一个收集器就可以轻松地增强功能了。</p>
<h3 id="收集器用做高级归约"><a href="#收集器用做高级归约" class="headerlink" title="收集器用做高级归约"></a>收集器用做高级归约</h3><p>Collector会对元素应用一个转换函数（很多时候是不体现任何效果的恒等转换例如toList），并将结果累积在一个数据结构中，从而产生这一过程的最终输出。Collectors实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，只要拿来用就可以了。最直接和最常用的收集器是 toList静态方法，它会把流中所有的元素收集到一个 List 中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Transaction&gt; transactions=transactionStream.collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<h3 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h3><p>Collectors提供的工厂方法groupingBy创建的收集器，主要提供三大功能：把流元素归约和汇总为一个值、元素分组、元素分区</p>
<h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long total=menu.stream().collect(counting());</div></pre></td></tr></table></figure>
<h3 id="寻找流中最小值和最大值"><a href="#寻找流中最小值和最大值" class="headerlink" title="寻找流中最小值和最大值"></a>寻找流中最小值和最大值</h3><p>Collectors.maxBy 和Collectors.minBy ，来计算流中的最大或最小值。这两个收集器接收一个Comparator 参数来比较流中的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</div><div class="line">Comparator.comparingInt(Dish::getCalories);</div><div class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));</div></pre></td></tr></table></figure></p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</div><div class="line">double average=menu.stream().collect(averagingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics menuStatistics =</div><div class="line">menu.stream().collect(summarizingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics&#123;count=9, sum=4300, min=120,average=477.777778, max=800&#125;</div></pre></td></tr></table></figure></p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>joining 工厂方法返回的收集器会把对流中每一个对象应用 toString 方法得到的所有字符串连接成一个字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String shortMenu = menu.stream().collect(joining(<span class="string">", "</span>));</div></pre></td></tr></table></figure></p>
<h3 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//第一个参数是归约操作的起始值,第二个是转换函数，第三个是BinaryOperator，累积函数</div><div class="line">int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j));</div></pre></td></tr></table></figure>
<p>reduce 方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反， collect 方法的设计就是要改变容器，从而累积要输出的结果。使用 reduce 方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏 List 本身。果你想要线程安全，就需要每次分配一个新的 List ，而对象分配又会影响性能。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type,List&lt;Dish&gt;&gt; map=menu.stream().collect(groupingBy(Dish::getType));</div><div class="line">public enum CaloricLevel &#123;</div><div class="line">   DIET, NORMAL, FAT</div><div class="line">&#125;</div><div class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; caloricLevel = menu.stream().collect(</div><div class="line">groupingBy(</div><div class="line">dish-&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(dish.getCalories() &lt;= 400)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= 700)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125;));</div><div class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(groupingBy(</div><div class="line">Dish::getCalories,counting()</div><div class="line">));</div></pre></td></tr></table></figure>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</div><div class="line">menu.stream().collect(groupingBy(Dish::getType,groupingBy(dish -&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(dish.getCalories()&lt;=400)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories()&lt;=700)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125; )</div><div class="line">)</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>由一个谓词作为一个返回函数，分区函数返回一个布尔值，意味着分组Map的键值是boolean，最多可以分成两组-true是一组，false是一组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</div><div class="line">menu.stream().collect(partitioningBy(Dish::isVegetarian));</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/分区.png" alt=""></p>
<h2 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Collector&lt;T, A, R&gt; &#123;</div><div class="line">   Supplier&lt;A&gt; supplier();</div><div class="line">   BiConsumer&lt;A, T&gt; accumulator();</div><div class="line">   Function&lt;A, R&gt; finisher();</div><div class="line">   BinaryOperator&lt;A&gt; combiner();</div><div class="line">   Set&lt;Characteristics&gt; characteristics();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>T 是流中要收集的项目的泛型。<br>A 是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。<br>R 是收集操作得到的对象（通常但并不一定是集合）的类型</p>
<h3 id="理解collector接口声明的方法"><a href="#理解collector接口声明的方法" class="headerlink" title="理解collector接口声明的方法"></a>理解collector接口声明的方法</h3><h4 id="建立新的结果容器-supplier方法"><a href="#建立新的结果容器-supplier方法" class="headerlink" title="建立新的结果容器:supplier方法"></a>建立新的结果容器:supplier方法</h4><p>supplier 方法必须返回一个结果为空的 Supplier ，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> ()-&gt;new ArrayList&lt;T&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="把元素添加到结果容器-accumulator"><a href="#把元素添加到结果容器-accumulator" class="headerlink" title="把元素添加到结果容器:accumulator"></a>把元素添加到结果容器:accumulator</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BiConsumer&lt;List&lt;T&gt; ,T&gt;()&#123;</div><div class="line">  <span class="built_in">return</span> (list,item)-&gt;list.add(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="把结果应用最终转换：finisher"><a href="#把结果应用最终转换：finisher" class="headerlink" title="把结果应用最终转换：finisher"></a>把结果应用最终转换：finisher</h4><p>在遍历完流后， finisher 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line">     <span class="built_in">return</span> Function.identity();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/顺序归约.png" alt=""></p>
<h4 id="合并两个结果容器"><a href="#合并两个结果容器" class="headerlink" title="合并两个结果容器"></a>合并两个结果容器</h4><p>四个方法中的最后一个—— combiner 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line">   <span class="built_in">return</span> (list1, list2) -&gt; &#123;list1.addAll(list2);<span class="built_in">return</span> list1; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/combine规约.png" alt=""></p>
<h4 id="characteristics方法"><a href="#characteristics方法" class="headerlink" title="characteristics方法"></a>characteristics方法</h4><p>characteristics 会返回一个不可变的 Characteristics 集合， 它定义<br>了收集器的行为:<br>UNORDERED ——归约结果不受流中项目的遍历和累积顺序的影响。<br>CONCURRENT —— accumulator 函数可以从多个线程同时调用，且该收集器可以并行归<br>约流。如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约<br>IDENTITY_FINISH ——这表明完成器方法返回的函数是一个恒等函数，可以跳过。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">import java.util.function.*;</div><div class="line">import java.util.stream.Collector;</div><div class="line">import static java.util.stream.Collector.Characteristics.*;</div><div class="line">public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt; &#123;</div><div class="line">@Override</div><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> ArrayList::new;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BiConsumer&lt;List&lt;T&gt;, T&gt; <span class="function"><span class="title">accumulator</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> List::add;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Function.indentity();</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> (list1, list2) -&gt; &#123;</div><div class="line">list1.addAll(list2);</div><div class="line"><span class="built_in">return</span> list1;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Set&lt;Characteristics&gt; <span class="function"><span class="title">characteristics</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Collections.unmodifiableSet(EnumSet.of(</div><div class="line">IDENTITY_FINISH, CONCURRENT));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">List&lt;Dish&gt; dishes = menuStream.collect(</div><div class="line">new ToListCollector&lt;Dish&gt;()</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h1 id="并行数据处理与性能"><a href="#并行数据处理与性能" class="headerlink" title="并行数据处理与性能"></a>并行数据处理与性能</h1><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p>
<h2 id="并行流-1"><a href="#并行流-1" class="headerlink" title="并行流"></a>并行流</h2><p>可以通过对收集源调用parallelStream把集合转换成并行流。并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<h3 id="将顺序流转化成并行流"><a href="#将顺序流转化成并行流" class="headerlink" title="将顺序流转化成并行流"></a>将顺序流转化成并行流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static long sequentialSum(long n) &#123;</div><div class="line">		<span class="built_in">return</span> Stream.iterate(1L, i -&gt; i + 1)</div><div class="line">		.limit(n)</div><div class="line">		.reduce(0L, Long::sum);</div><div class="line">&#125;</div><div class="line">public static long parallelSum(long n) &#123;</div><div class="line">  	<span class="built_in">return</span> Stream.iterate(1L, i -&gt; i + 1)</div><div class="line">  	.limit(n)</div><div class="line">  	.parallel()</div><div class="line">  	.reduce(0L, Long::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并行流内部使用了默认的 ForkJoinPool，它默认的线程数量 就是 你 的 处 理器 数 量 ， 这个 值 是 由 Runtime.getRuntime().available-<br>Processors() 得到的。但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.<br>parallelism来改变线程池大小，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>,<span class="string">"12"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="测量流性能"><a href="#测量流性能" class="headerlink" title="测量流性能"></a>测量流性能</h3><p>真实的情况反而并发流反而更慢了，造成的原因有两点</p>
<ol>
<li>iterate生成的是装箱的对象，必须拆箱成数字才能求和.</li>
<li>我们很难把 iterate 分成多个独立块来并行执行;因为每次应用这个函数都要依赖前一次应用的结果.</li>
</ol>
<p>更有效的针对方案：<br>LongStream.rangeClosed 直接产生原始类型的 long 数字，没有装箱拆箱的开销。<br>LongStream.rangeClosed 会生成数字范围,很容易拆分为独立的小块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static long rangedSum(long n)&#123;</div><div class="line">		<span class="built_in">return</span> LongStream.rangeClosed(0, n).reduce(0L,Long::sum );</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="正确使用并行流"><a href="#正确使用并行流" class="headerlink" title="正确使用并行流"></a>正确使用并行流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static long sideEffectSum(long n) &#123;</div><div class="line">Accumulator accumulator = new Accumulator();</div><div class="line">LongStream.rangeClosed(1, n).forEach(accumulator::add);</div><div class="line"><span class="built_in">return</span> accumulator.total;</div><div class="line">&#125;</div><div class="line">public class Accumulator &#123;</div><div class="line">public long total = 0;</div><div class="line">public void add(long value) &#123; total += value; &#125;</div><div class="line">&#125;</div><div class="line">public static long sideEffectParallelSum(long n) &#123;</div><div class="line">Accumulator accumulator = new Accumulator();</div><div class="line">LongStream.rangeClosed(1,n).parallel().forEach(accumulator::add);</div><div class="line"><span class="built_in">return</span> accumulator.total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它在本质上就是顺序的。每次访问 total 都会出现数据竞争。如果你尝试用同步来修复，那就完全失去并行的意义了.这回方法的性能无关紧要了，唯一要紧的是每次执行都会返回不同的结果，都离正确值<br>50000005000000 差很远。这是由于多个线程在同时访问累加器，执行 total += value ，而这一句虽然看似简单，却不是一个原子操作。问题的根源在于，forEach 中调用的方法有副作用，它会改变多个线程共享的对象的可变状态。</p>
<h3 id="高效使用并行流"><a href="#高效使用并行流" class="headerlink" title="高效使用并行流"></a>高效使用并行流</h3><ul>
<li>如果有疑问，测量。</li>
<li>留意装箱。自动装箱和拆箱操作会大大降低性能。java8的原始类型流（IntStream、DoubleStream、LongStream）来避免这些操作。</li>
<li>有些操作本身在并行流上的性能比顺序流的性能要差。特别是findFirst和limit这些依赖于元素顺序。</li>
<li>还要考虑流操作流水线的总计算成本。N是要处理的元素总数，Q是一个元素通过流水线的大致成本，N*Q是对这个成本的粗略估计，Q值比较高时代表使用并行流性能好的可能性比较大。</li>
<li>对于较小的数据量，选择并行流不是个好的选择</li>
<li>要考虑流的数据结构是否容易分解ArrayList的拆分效率比LinkedList拆分效率高，后者需要遍历。</li>
<li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能</li>
<li>还要考虑终端操作中合并步骤的代价是大是小</li>
</ul>
<p><img src="/2017/12/02/java8/流拆分性能.png" alt=""></p>
<h2 id="分支-合并框架"><a href="#分支-合并框架" class="headerlink" title="分支/合并框架"></a>分支/合并框架</h2><h3 id="使用RecursiveTask"><a href="#使用RecursiveTask" class="headerlink" title="使用RecursiveTask"></a>使用RecursiveTask</h3><p><img src="/2017/12/02/java8/使用RecursiveTask.png" alt=""></p>
<h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题。在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool 中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。<br><img src="/2017/12/02/java8/工作窃取.png" alt=""></p>
<h2 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h2><p>Spliterator是Java8中加入的另一个新接口；这个名字代表“可分迭代器”（splitable iterator）。和 Iterator 一样，Spliterator 也用于遍历数据源中的元素，但它是为了并行执行而设计的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Spliterator&lt;T&gt; &#123;</div><div class="line"> boolean tryAdvance(Consumer&lt;? super T&gt; action);</div><div class="line"> Spliterator&lt;T&gt; trySplit();</div><div class="line"> long estimateSize();</div><div class="line"> int characteristics();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>T 是 Spliterator 遍历的元素的类型。tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。但trySplit是专为 Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator（由该方法返回），让它们两个并行处理。Spliterator还可通过estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值,也有助于让拆分均匀一点.<br><img src="/2017/12/02/java8/递归拆分.png" alt=""><br><img src="/2017/12/02/java8/spliterator.png" alt=""></p>
<h1 id="默认方法-1"><a href="#默认方法-1" class="headerlink" title="默认方法"></a>默认方法</h1><p>Java 8中的接口现在支持在声明方法的同时提供实现，这听起来让人惊讶！通过两种方式可以完成这种操作。其一，Java 8允许在接口内声明静态方法。其二，Java 8引入了一个新功能，叫默认方法，通过默认方法你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现。</p>
<h2 id="不断演进Api"><a href="#不断演进Api" class="headerlink" title="不断演进Api"></a>不断演进Api</h2><p>你的库中包含了一个 Resizable接口，它定义了一个简单的可缩放形状必须支持的很多方法， 比如： setHeight 、 setWidth 、getHeight 、 getWidth 以及 setAbsoluteSize 。 此外， 你还提供了几个额外的实现 （out-of-box implementation） ，如正方形、长方形。由于你的库非常流行，你的一些用户使用 Resizable 接口创建了他们自己感兴趣的实现，比如椭圆。<br>发布API几个月之后，你突然意识到 Resizable 接口遗漏了一些功能。比如，如果接口提供一个 setRelativeSize 方法，可以接受参数实现对形状的大小进行调整，那么接口的易用性会更好。你要考虑已经使用了你接口的用户，他们已经按照自身的需求实现了 Resizable 接口。</p>
<h3 id="初始版本的-API"><a href="#初始版本的-API" class="headerlink" title="初始版本的 API"></a>初始版本的 API</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Resizable extends Drawable&#123;</div><div class="line"> int getWidth();</div><div class="line"> int getHeight();</div><div class="line"> void <span class="built_in">set</span>Width(int width);</div><div class="line"> void <span class="built_in">set</span>Height(int height);</div><div class="line"> void <span class="built_in">set</span>AbsoluteSize(int width, int height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>void setRelativeSize(int wFactor, int hFactor);<br>二进制级的兼容性表示现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行。比如，为接口添加一个方法就是二进制级的兼容，这种方式下，如果新添加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。简单地说， 源代码级的兼容性表示引入变化之后， 现有的程序依然能成功编译通过。 比如，向接口添加新的方法就不是源码级的兼容， 因为遗留代码并没有实现新引入的方法， 所以它们无法顺利通过编译。最后，函数行为的兼容性表示变更发生之后，程序接受同样的输入能得到同样的结果。比如，为接口添加新的方法就是函数行为兼容的，因为新添加的方法在程序中并未被调用</p>
<h2 id="概述默认方法"><a href="#概述默认方法" class="headerlink" title="概述默认方法"></a>概述默认方法</h2><p>缺失的方法实现会作为接口的一部分由实现类继承（所以命名为默认实现） ，而无需由实现类提供。默认方法由 default 修饰符修饰，并像类中声明的其他方法一样包含方法体。</p>
<h2 id="默认方法的使用模式"><a href="#默认方法的使用模式" class="headerlink" title="默认方法的使用模式"></a>默认方法的使用模式</h2><h3 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h3><p>Java 8之前，由于用户通常不会使用该方法， remove 方法常被忽略。因此，实现 Interator 接口的类通常会为 remove 方法放置一个空的实现，这些都是些毫无用处的模板代码。 Iterator 接口就为remove方法提供了一个默认实现</p>
<h3 id="行为的多继承"><a href="#行为的多继承" class="headerlink" title="行为的多继承"></a>行为的多继承</h3><h2 id="解决冲突的规则"><a href="#解决冲突的规则" class="headerlink" title="解决冲突的规则"></a>解决冲突的规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface A &#123;</div><div class="line">default void <span class="function"><span class="title">hello</span></span>() &#123;</div><div class="line">  System.out.println(<span class="string">"Hello from A"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public interface B extends A &#123;</div><div class="line">default void <span class="function"><span class="title">hello</span></span>() &#123;</div><div class="line">System.out.println(<span class="string">"Hello from B"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class C implements B, A &#123;</div><div class="line">public static void main(String... args) &#123;</div><div class="line">new C().hello();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解决问题的三条规则"><a href="#解决问题的三条规则" class="headerlink" title="解决问题的三条规则"></a>解决问题的三条规则</h3><p>(1) 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。<br>(2) 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A ，那么 B 就比 A 更加具体。<br>(3) 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法<br>Java 8中引入了一种新的语法 X.super.m(…) ，其中 X 是你希望调用的 m<br>方法所在的父接口。如果你希望 C 使用来自于 B 的默认方法，它的调用方式看起来就如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class C implements B, A &#123;</div><div class="line">void <span class="function"><span class="title">hello</span></span>()&#123;</div><div class="line">B.super.hello();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;java8新特性：Lambda（匿名函数）、流、默认方法&lt;/p&gt;
&lt;h2 id=&quot;java中的函数&quot;&gt;&lt;a href=&quot;#j
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络通讯</title>
    <link href="http://yoursite.com/2017/12/01/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2017/12/01/高性能网络通讯/</id>
    <published>2017-12-01T01:31:02.000Z</published>
    <updated>2017-12-02T07:58:36.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的RPC调用问题"><a href="#简单的RPC调用问题" class="headerlink" title="简单的RPC调用问题"></a>简单的RPC调用问题</h2><h3 id="简单的远程调用"><a href="#简单的远程调用" class="headerlink" title="简单的远程调用"></a>简单的远程调用</h3><h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HelloService helloService=getProxy(HelloService.class,<span class="string">"127.0.0.1"</span>,<span class="string">"2580"</span>);</div><div class="line">System.out.println(helloService.sayHello(<span class="string">"hi, charles"</span>));</div><div class="line">Public &lt;T&gt; T getProxy(Class&lt;T&gt; interfaceClass, String host, int port)&#123;</div><div class="line"><span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new</div><div class="line">Class&lt;?&gt;[] &#123;interfaceClass&#125;,</div><div class="line">new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</div><div class="line">public Object invoke(Object proxy, Method method, Object[]</div><div class="line">arguments) throws Throwable &#123;</div><div class="line">Socket socket = new Socket(host, port);</div><div class="line">ObjectOutputStream output = new</div><div class="line">ObjectOutputStream(socket.getOutputStream());</div><div class="line">output.writeUTF(method.getName());</div><div class="line">output.writeObject(method.getParameterTypes());</div><div class="line">output.writeObject(arguments);</div><div class="line">ObjectInputStream input = new</div><div class="line">ObjectInputStream(socket.getInputStream());</div><div class="line"><span class="built_in">return</span> input.readObject();&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务器端调用"><a href="#服务器端调用" class="headerlink" title="服务器端调用"></a>服务器端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = new ServerSocket(port);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">   final Socket socket= server.accept();</div><div class="line">   new Thread(new Runnable(</div><div class="line">     public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">       ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</div><div class="line">       String methodName=input.readUTF();</div><div class="line">       Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();</div><div class="line">       Object[] arguments = (Object[])input.readObject();</div><div class="line">       ObjectOutputStream output = new</div><div class="line">       ObjectOutputStream(socket.getOutputStream());</div><div class="line">       Method method = service.getClass().getMethod(methodName,</div><div class="line">       parameterTypes);</div><div class="line">       Object result = method.invoke(service, arguments);</div><div class="line">       output.writeObject(result);</div><div class="line">     &#125;</div><div class="line">   )).start();</div><div class="line">&#125;</div><div class="line">Public String sysHello(String input)&#123;</div><div class="line">  <span class="built_in">return</span> input+<span class="string">":wellcome."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>网络传输方式：BIO</li>
<li>序列化方式：java序列化</li>
<li>线程模型：每次连接每线程</li>
<li>jdk代理</li>
</ol>
<h3 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h3><ol>
<li>协议；用什么数据格式进行传输。双方的约定</li>
<li>传输；用什么样的通道将数据发送给对方</li>
<li>线程；当接收到数据时，如何分发数据进行处理</li>
</ol>
<p><img src="/2017/12/01/高性能网络通讯/dataProtocol.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dataFlow.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dubbohead.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/datahead.png" alt=""></p>
<h3 id="data-Header"><a href="#data-Header" class="headerlink" title="data Header"></a>data Header</h3><p>magic code<br>多协议支持<br>Telnet<br>兼容<br>Long id vs id轮转<br>同步转异步<br>过期策略+id轮转<br>扩展header（拥塞控制&amp;response header增加服务器状态）</p>
<h4 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h4><p>并行发起多个请求，但只使用一个线程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxxService.find();</div><div class="line">Future&lt;Xxx&gt; future=RpcContext.getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/01/高性能网络通讯/asy.png" alt=""></p>
<h4 id="body序列化"><a href="#body序列化" class="headerlink" title="body序列化"></a>body序列化</h4><p>数据大小（传输速度）<br>序列化和反序列速度(CPU资源)<br>兼容性和易用性<br><img src="/2017/12/01/高性能网络通讯/序列化.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/size_dfl.png" alt=""></p>
<ul>
<li>远程服务调用时间主要消耗<br>网络开销主要是数据包大小<br>生产环境某应用容量测试</li>
<li>dubbo序列化主要优化目标：<br>减少数据包大小<br>提高序列化反序列化性能</li>
</ul>
<h2 id="IO-model"><a href="#IO-model" class="headerlink" title="IO model"></a>IO model</h2><p>IO Model、NIO、TCP选项、IRQ</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>IO请求分为两个阶段：<br>等待数据就绪；从内存缓存区拷贝数据到进程缓存区<br>Unix5种IO模型：<br>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO<br><img src="/2017/12/01/高性能网络通讯/io.png" alt=""></p>
<h3 id="NIO的好处"><a href="#NIO的好处" class="headerlink" title="NIO的好处"></a>NIO的好处</h3><ul>
<li>事件驱动模型，避免多线程和单线程处理多任务。</li>
<li>IO读写不再阻塞，而是返回0.</li>
<li>基于block的传输，比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了java网络应用的可伸缩性和实用性</li>
</ul>
<h3 id="NIO-reactor模式"><a href="#NIO-reactor模式" class="headerlink" title="NIO reactor模式"></a>NIO reactor模式</h3><ul>
<li>NIO网络框架典型模式</li>
<li>核心组件<br>同步事件多路复用器(event loop 事件分离)<br>分发器（事件派发，可以多线程）<br>请求处理（事件处理，业务代码）</li>
<li>mina netty都是此模式的实现</li>
</ul>
<p><img src="/2017/12/01/高性能网络通讯/reactor.png" alt=""></p>
<h3 id="NIO优化-TCP选项"><a href="#NIO优化-TCP选项" class="headerlink" title="NIO优化-TCP选项"></a>NIO优化-TCP选项</h3><p>合理设置tcp/ip在某些时候可以起到显著的效果</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><ul>
<li>Socket缓冲区至少应该是连接的MSS的四倍，MSS=MTU+40，一般以太网的MTU等于1500字节，MSS：最大分段大小，MTU：最大传输单元</li>
<li>在以太网上4k是不够的，增加到16k，吞吐量增加40%</li>
<li>对于一次性发送大量数据的应用，增加发送缓冲区到48k、64k才是可能唯一有效提高性能的方式。为了最大化性能，发送缓冲区可能至少要跟BDP（带宽延迟乘积）一样大小。</li>
<li>对于大量接收数据的应用，提高接收缓冲区，能减少发送端的阻塞。</li>
<li>如果应用既发送大量数据，也接收大量数据，recvbuffer和send buffer应该同时增加</li>
</ul>
<h3 id="带宽延迟乘积–BDP"><a href="#带宽延迟乘积–BDP" class="headerlink" title="带宽延迟乘积–BDP"></a>带宽延迟乘积–BDP</h3><p>为了优化TCP 吞吐量（假设为合理的无差错传输路径），发送端应该发送足够的数据包以填满发送端和接收端之间的逻辑管道。<br>逻辑管道的容量计算：BDP= 带宽x RTT</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>nagle算法通过将缓冲区的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。<br>实时性要求较高的应用，需要关闭算法，否则响应时间会受影响。</p>
<h3 id="SO-KeepAlive"><a href="#SO-KeepAlive" class="headerlink" title="SO_KeepAlive"></a>SO_KeepAlive</h3><p>Socket.setKeepAlive(boolean)<br>这是TCP层，而非HTTP协议的keep-alive概念,默认一般为false，用于TCP连接保活，默认间<br>隔2个小时.TCP心跳间隔是全局设置，建议在应用层做心跳</p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断此时都是运行在在硬件中断相应的cpu上。<br>如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>
<h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS (Receive Packet Steering) 基本原理<br>– 根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，<br>– 从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="线程模型内容"><a href="#线程模型内容" class="headerlink" title="线程模型内容"></a>线程模型内容</h3><ul>
<li>Reactor线程模型</li>
<li>序列化线程</li>
<li>业务线程派发策略</li>
</ul>
<h3 id="Reator单线程模型"><a href="#Reator单线程模型" class="headerlink" title="Reator单线程模型"></a>Reator单线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor单线程.png" alt=""></p>
<h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor多线程.png" alt=""></p>
<h3 id="线程派发策略"><a href="#线程派发策略" class="headerlink" title="线程派发策略"></a>线程派发策略</h3><p>五个事件：连接建立（Connection）、连接断开（Disconnection）、消息已接受(MessageReceived)、消息已发送（sent）、异常（Exception  caught）<br>派发策略：1.五个事件共享一个线程池；2.Connection和disconnect使用独立的线程池，size为1；3.全部不派发线程池，IO线程处理</p>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p>有这样一个模块<br>cpu 计算时间 18ms （ running ）<br>查询数据库，网络 io 时间 80ms （ waiting ）<br>解析结果 2ms 如果服务器 2CPU ，大家看看这里多少线程合适<br>充分利用cpu资源：<br>线程数量=100/20*2=10<br>从CPU角度而言<br>线程数量=（cpu时间+cpu等待时间）/cpu时间*cpu数量</p>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p>有这样一个模块：<br>线程同步锁 ( 数据库事务锁 )50ms<br>cpu 时间 18ms<br>查询数据库，网络 io 时间 80ms<br>解析结果 2ms  如果服务器有 2 个 CPU ，这个模块线程多少合适？<br>CPU计算为瓶颈，计算线程数量<br>线程数=(18 + 2 + 50 + 80) /20 *2 = 15<br>以线程同步锁为瓶颈，计算线程数<br>线程数=(50 + 18 + 2 + 80) / 50 * 1/1 = 3<br>公式一：<br>线程数量= （线程总时间/ 瓶颈资源时间）*  瓶颈资源的线程并行数<br>准确的讲<br>瓶颈资源的线程并行数= 瓶颈资源的总份数/ 单次请求占用瓶颈资源的份数<br>约束：<br>在计算的时候，对同一类资源的消耗时间进行合并<br>公式二：<br>QPS=1000/线程总时间*线程数<br>注意：如果线程数不够，则QPS减少。线程本身也要消耗资源，如果线程太多，同样QPS会下降。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>• 其他优化<br>– Lock free data structure（无锁数据结构）<br>– Buffer copy (Zero Copy)：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。一个关键的api是java.nio.channel.FileChannel的transferTo()方法。我们可以用transferTo()来把bytes直接从调用它的channel传输到另一个writable byte channel，中间不会使data经过应用程序。<br>– JVM GC tuning<br>– Context Switch 线程上下文切换<br>– 同步转异步<br>– JavassistProxy改进JDK proxy<br>  注意性能的短板效应，避免过度优化<br>– 优化的代价，通常是牺牲未来的可能性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的RPC调用问题&quot;&gt;&lt;a href=&quot;#简单的RPC调用问题&quot; class=&quot;headerlink&quot; title=&quot;简单的RPC调用问题&quot;&gt;&lt;/a&gt;简单的RPC调用问题&lt;/h2&gt;&lt;h3 id=&quot;简单的远程调用&quot;&gt;&lt;a href=&quot;#简单的远程调用&quot; class
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch深入搜索</title>
    <link href="http://yoursite.com/2017/11/27/es%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2017/11/27/es全文搜索/</id>
    <published>2017-11-27T02:55:25.000Z</published>
    <updated>2017-12-24T07:39:08.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><h2 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h2><h3 id="基于词项查询"><a href="#基于词项查询" class="headerlink" title="基于词项查询"></a>基于词项查询</h3><p>如 term 或 fuzzy 这样的底层查询不需要分析阶段，它们对单个词项进行操作。用 term 查询词项 Foo 只要在倒排索引中查找 准确词项 ，并且用 TF/IDF 算法为每个包含该词项的文档计算相关度评分score 。<br>记住 term 查询只对倒排索引的词项精确匹配，这点很重要，它不会对词的多样性进行处理（如， foo 或 FOO ）。这里，无须考虑词项是如何存入索引的。如果是将 [“Foo”,”Bar”] 索引存入一个不分析的（ not_analyzed ）包含精确值的字段，或者将 Foo Bar 索引到一个带有 whitespace 空格分析器的字段，两者的结果都会是在倒排索引中有 Foo 和 Bar 这两个词。</p>
<h3 id="基于全文查询"><a href="#基于全文查询" class="headerlink" title="基于全文查询"></a>基于全文查询</h3><p>像 match 或 query_string 这样的查询是高层查询，它们了解字段映射的信息：<br>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。<br>如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。<br>但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分。<br>当我们想要查询一个具有精确值的 not_analyzed 未分析字段之前， 需要考虑，是否真的采用评分查询，或者非评分查询会更好。<br>单词项查询通常可以用是、非这种二元问题表示，所以更适合用过滤， 而且这样做可以有效利用缓存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"constant_score"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">          <span class="string">"term"</span>:&#123;</div><div class="line">            <span class="string">"sex"</span>:<span class="string">"男"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h2><p>匹配查询match是核心查询，它是一个高级全文查询 ，这表示它既能处理全文字段，又能处理精确字段。</p>
<h3 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:<span class="string">"quick"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询步骤如下：</p>
<ol>
<li>检查字段类型；标题 title 字段是一个 string 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。</li>
<li>分析查询字符串；将查询的字符串quick传入标准分析器中，输出的结果是单个项 quick 。因为只有一个单词项，所以 match 查询执行的是单个底层 term 查询。</li>
<li>查找匹配文档；用 term 查询在倒排索引中查找 quick 然后获取一组包含该项的文档，本例的结果是文档：1、2 和 3 。</li>
<li>为每个文档评分；用 term 查询计算每个文档相关度评分score ，这是种将 词频（term frequency，即词 quick 在相关文档的 title 字段中出现的频率）和反向文档频率（inverse document frequency，即词 quick 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。<h3 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">        <span class="string">"title"</span>:<span class="string">"BROWN DOG"</span></div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//返回结果解释</div><div class="line">文档 4 最相关，因为它包含词 <span class="string">"brown"</span> 两次以及 <span class="string">"dog"</span> 一次。</div><div class="line">文档 2、3 同时包含 brown 和 dog 各一次，而且它们 title 字段的长度相同，所以具有相同的评分。</div><div class="line">文档 1 也能匹配，尽管它只有 brown 没有 dog 。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 match 查询必须查找两个词（ [“brown”,”dog”] ），它在内部实际上先执行两次 term 查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个 term 查询包入一个 bool 查询中。<br>以上示例告诉我们一个重要信息：即任何文档只要 title 字段里包含 指定词项中的至少一个词 就能匹配，被匹配的词项越多，文档就越相关。</p>
<h3 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h3><p>用 任意 查询词项匹配文档可能会导致结果中出现不相关的长尾。 这是种散弹式搜索。可能我们只想搜索包含 所有 词项的文档，也就是说，不去匹配 brown OR dog ，而通过匹配 brown AND dog 找到所有文档。<br>match 查询还可以接受 operator 操作符作为输入参数，默认情况下该操作符是 or 。我们可以将它修改成 and 让所有指定词项都必须匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:&#123;</div><div class="line">           <span class="string">"query"</span>: <span class="string">"brown dog"</span>,</div><div class="line">           <span class="string">"operator"</span>:<span class="string">"and"</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h3><p>在 所有 与 任意 间二选一有点过于非黑即白。 如果用户给定 5 个查询词项，想查找只包含其中 4 个的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。<br>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。<br>match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">        <span class="string">"query"</span>:<span class="string">"a brown dog"</span>,</div><div class="line">        <span class="string">"minimun_should_match"</span>:<span class="string">"75%"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当给定百分比的时候， minimum_should_match 会做合适的事情：在之前三词项的示例中， 75% 会自动被截断成 66.6% ，即三个里面两个词。无论这个值设置成什么，至少包含一个词项的文档才会被认为是匹配的。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>在 组合过滤器 中，我们讨论过如何使用 bool 过滤器通过 and 、 or 和 not 逻辑组合将多个过滤器进行组合。在查询中， bool 查询有类似的功能，只有一个重要的区别。<br>过滤器做二元判断：文档是否应该出现在结果中？但查询更精妙，它除了决定一个文档是否应该被包括在结果中，还会计算文档的 相关程度 。<br>与过滤器一样， bool 查询也可以接受 must 、 must_not 和 should 参数下的多个查询语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"must"</span>:     &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;,</div><div class="line">      <span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"lazy"</span>  &#125;&#125;,</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h3><p>以上的查询结果返回 title 字段包含词项 quick 但不包含 lazy 的任意文档。目前为止，这与 bool 过滤器的工作方式非常相似。<br>区别就在于两个 should 语句，也就是说：一个文档不必包含 brown 或 dog 这两个词项，但如果一旦包含，我们就认为它们更相关。<br>bool查询会为每个文档计算相关度评分，再将所有匹配must和should语句的分数score求和，最后除以must和should语句总数，must_not不会影响评分，只会将不想关的文档排除。</p>
<h3 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h3><p>所有 must 语句必须匹配，所有 must_not 语句都必须不匹配，但有多少 should 语句应该匹配呢？ 默认情况下，没有 should 语句是必须匹配的，只有一个例外：那就是当没有 must 语句的时候，至少有一个 should 语句必须匹配。<br>就像我们能控制 match 查询的精度 一样，我们可以通过 minimum_should_match 参数控制需要匹配的 should 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ],</div><div class="line">      <span class="string">"minimum_should_match"</span>: 2</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个查询结果会将所有满足以下条件的文档返回： title 字段包含 “brown” AND “fox” 、 “brown” AND “dog” 或 “fox” AND “dog” 。如果有文档包含所有三个条件，它会比只包含两个的文档更相关。</p>
<h2 id="bool匹配"><a href="#bool匹配" class="headerlink" title="bool匹配"></a>bool匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">//以下两两是等价的</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown fox"</span>&#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//must</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>:    <span class="string">"brown fox"</span>,</div><div class="line">            <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"must"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>: <span class="string">"quick brown fox"</span>,</div><div class="line">            <span class="string">"minimum_should_match"</span>: <span class="string">"75%"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"minimum_should_match"</span>: 2</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询语句提升比重"><a href="#查询语句提升比重" class="headerlink" title="查询语句提升比重"></a>查询语句提升比重</h2><p>我们可以通过指定 boost 来控制任何查询语句的相对的权重， boost 的默认值为 1 ，大于 1 会提升一个语句的相对权重。<br>boost 参数被用来提升一个语句的相对权重（ boost 值大于 1 ）或降低相对权重（ boost 值处于 0 到 1 之间），但是这种提升或降低并不是线性的，换句话说，如果一个 boost 值为 2 ，并不能获得两倍的评分score 。<br>相反，新的评分score 会在应用权重提升之后被 归一化 ，每种类型的查询都有自己的归一算法，细节超出了本书的范围，所以不作介绍。简单的说，更高的 boost 值为我们带来更高的评分 score 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    <span class="string">"query"</span>: &#123;</div><div class="line">        <span class="string">"bool"</span>: &#123;</div><div class="line">            <span class="string">"must"</span>: &#123;</div><div class="line">                <span class="string">"match"</span>: &#123;  </div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>:    <span class="string">"full text search"</span>,</div><div class="line">                        <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"should"</span>: [</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Elasticsearch"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 3</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;,</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Lucene"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 2</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="控制分析"><a href="#控制分析" class="headerlink" title="控制分析"></a>控制分析</h2><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>在搜索时，顺序有些许不同：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>有时，在索引时和搜索时使用不同的分析器是合理的。 我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。<br>为了区分，Elasticsearch 也支持一个可选的 search_analyzer 映射，它仅会应用于搜索时（ analyzer 还用于索引时）。还有一个等价的 default_search 映射，用以指定索引层的默认配置。<br>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 search_analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default_search 的分析器，默认为索引设置中名为 default 的分析器，默认为standard 标准分析器</p>
<h2 id="被破坏的相关度！"><a href="#被破坏的相关度！" class="headerlink" title="被破坏的相关度！"></a>被破坏的相关度！</h2><p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。<br>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤： 用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。<br>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。<br>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。<br>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。 相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。<br>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。<br>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。<br>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。<br>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF。不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h1 id="多字段搜索"><a href="#多字段搜索" class="headerlink" title="多字段搜索"></a>多字段搜索</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html</a></p>
<h1 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html</a></p>
<h1 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a>控制相关度</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全文搜索&quot;&gt;&lt;a href=&quot;#全文搜索&quot; class=&quot;headerlink&quot; title=&quot;全文搜索&quot;&gt;&lt;/a&gt;全文搜索&lt;/h1&gt;&lt;h2 id=&quot;基于词项与基于全文&quot;&gt;&lt;a href=&quot;#基于词项与基于全文&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>dubbo_framework_extensions</title>
    <link href="http://yoursite.com/2017/11/27/dubbo-framework-extensions/"/>
    <id>http://yoursite.com/2017/11/27/dubbo-framework-extensions/</id>
    <published>2017-11-27T02:41:29.000Z</published>
    <updated>2017-11-30T03:31:12.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/27/dubbo-framework-extensions/do.png" alt="do"></p>
<h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><h3 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h3><p><img src="/2017/11/27/dubbo-framework-extensions/framework1.png" alt="do"><br><img src="/2017/11/27/dubbo-framework-extensions/extension.png" alt="do"></p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p><img src="/2017/11/27/dubbo-framework-extensions/modules.png" alt="do"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="IOC-amp-AOP"><a href="#IOC-amp-AOP" class="headerlink" title="IOC&amp;AOP"></a>IOC&amp;AOP</h3><p>对于扩展实现IOC依赖注入功能：<br>举例来说：接口A，实现者A1、A2。接口B，实现者B1、B2。<br>现在实现者A1含有setB()方法，会自动注入一个接口B的实现者，此时注入B1还是B2呢？都不是，而是注入一个动态生成的接口B的实现者B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能.对扩展采用装饰器模式进行功能增强，类似AOP实现的功能.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//IOC</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private LoadBalance loadbalance;</div><div class="line">   public void <span class="built_in">set</span>LoadBalance(LoadBalance loadbalance) &#123;</div><div class="line">       this.loadbalance = loadbalance;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">//AOP</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private Cluster cluster;</div><div class="line">   public XxxCluster(Cluster cluster) &#123;</div><div class="line">      this.cluster = cluster;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/27/dubbo-framework-extensions/protocol.png" alt="protocol"><br><img src="/2017/11/27/dubbo-framework-extensions/filter.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/proxyFactory.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/javassist.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/cluster.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/remoting.png" alt=""></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//Application shared</div><div class="line">&lt;dubbo:application name=<span class="string">"xxx"</span> /&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"127.0.0.1"</span> /&gt;</div><div class="line">//provider</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"7777"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> /&gt;</div><div class="line">//consumer</div><div class="line">&lt;dubbo:reference interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:consumer timeout /&gt;</div></pre></td></tr></table></figure>
<h3 id="config-type"><a href="#config-type" class="headerlink" title="config type"></a>config type</h3><ul>
<li>Service Identification<br>group<br>version<br>interface</li>
<li>Service Governance<br>deprecated<br>application</li>
<li>performance optimize<br>timeout<br>threads</li>
</ul>
<h3 id="config-Override"><a href="#config-Override" class="headerlink" title="config Override"></a>config Override</h3><p>method 继承 接口 继承缺失，消费者继承服务提供者</p>
<h3 id="编程配置"><a href="#编程配置" class="headerlink" title="编程配置"></a>编程配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServiceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“xxx”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– <span class="built_in">export</span>();</div><div class="line">• ReferenceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“yyy”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– get();</div></pre></td></tr></table></figure>
<h3 id="context-amp-trace"><a href="#context-amp-trace" class="headerlink" title="context&amp;trace"></a>context&amp;trace</h3><p><img src="/2017/11/27/dubbo-framework-extensions/context&amp;trace.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadLocal context</div><div class="line">RpcContext.getContext().getRemoteHost();</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>,<span class="string">"1"</span>);</div><div class="line">RpcContext.getContext().getAttachment(<span class="string">"index"</span>);</div><div class="line">like http cookie</div></pre></td></tr></table></figure></p>
<h3 id="GenericService"><a href="#GenericService" class="headerlink" title="GenericService"></a>GenericService</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// java interface</div><div class="line">MemberService memberService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">memberService.findPeople(memberId);</div><div class="line">//Generic interface POJO需要转化为map</div><div class="line">GenericService genericService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">genericService.invoke(<span class="string">"findPeople"</span>,new String[]&#123;<span class="string">"java.lang.String"</span>&#125;,new Object[]&#123;memberId&#125;);</div><div class="line">//java implement</div><div class="line">public class MemberServiceImpl implements MemberService&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//Generic implement</div><div class="line">public class MemberServiceImpl implement GenericService&#123;</div><div class="line">  public Object invoke(String method,String[] ptypes,Object[] args)&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="local-amp-mock"><a href="#local-amp-mock" class="headerlink" title="local&amp;mock"></a>local&amp;mock</h3><p><img src="/2017/11/27/dubbo-framework-extensions/mock.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dubbo://10.20.153.10?<span class="built_in">local</span>=<span class="literal">true</span>&amp;mock=<span class="literal">true</span></div><div class="line">Constructor:</div><div class="line">public XxxServiceLocal(XxxService xxxService)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public <span class="function"><span class="title">XxxServiceMock</span></span>()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/27/dubbo-framework-extensions/do.png&quot; alt=&quot;do&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;framework&quot;&gt;&lt;a href=&quot;#framework&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>dubbo功能介绍</title>
    <link href="http://yoursite.com/2017/11/24/dubbo%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/11/24/dubbo功能介绍/</id>
    <published>2017-11-24T14:53:33.000Z</published>
    <updated>2017-12-08T02:08:38.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo简要介绍"><a href="#dubbo简要介绍" class="headerlink" title="dubbo简要介绍"></a>dubbo简要介绍</h1><h2 id="dubbo是什么"><a href="#dubbo是什么" class="headerlink" title="dubbo是什么"></a>dubbo是什么</h2><p>它是分布式服务框架，高性能和透明化的RPC远程服务调用方案；SOA服务治理方案</p>
<h2 id="如何使用dubbo"><a href="#如何使用dubbo" class="headerlink" title="如何使用dubbo"></a>如何使用dubbo</h2><p>本地服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>远程服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxInterface"</span> ref=<span class="string">"xxxService"</span>&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span> interface=<span class="string">"xxxInterface"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="dubbo能做什么"><a href="#dubbo能做什么" class="headerlink" title="dubbo能做什么"></a>dubbo能做什么</h2><h3 id="透明化的远程调用"><a href="#透明化的远程调用" class="headerlink" title="透明化的远程调用"></a>透明化的远程调用</h3><p>就像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p>
<h3 id="软负载均衡和容错机制"><a href="#软负载均衡和容错机制" class="headerlink" title="软负载均衡和容错机制"></a>软负载均衡和容错机制</h3><p>可在内网替代F5等硬件负载均衡器</p>
<h3 id="服务自动注册与发现"><a href="#服务自动注册与发现" class="headerlink" title="服务自动注册与发现"></a>服务自动注册与发现</h3><p>不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加和删除服务提供者。</p>
<h2 id="dubbo基本原理"><a href="#dubbo基本原理" class="headerlink" title="dubbo基本原理"></a>dubbo基本原理</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本原理.png" alt="dubbo基本原理"></p>
<h2 id="dubbo-rpc基本功能"><a href="#dubbo-rpc基本功能" class="headerlink" title="dubbo rpc基本功能"></a>dubbo rpc基本功能</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本功能.png" alt="dubbo-rpc 基本功能"></p>
<h3 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h3><p>实际使用中发现服务器比消费者更清楚一个方法的执行时间和是否允许重试等信息，所以增加允许服务提供者为消费者设置缺省值，并采用继承风格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//服务提供者配置</div><div class="line">&lt;dubbo:service timeout=<span class="string">"3000"</span> retries=<span class="string">"0"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=3000&amp;retries=0</div><div class="line">服务提供者提供配置参考值</div><div class="line">//注册中心</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=4000&amp;retries=1</div><div class="line">注册中心可在服务治理过程中修改配置值，如果不修改则使用provider的配置值</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">""</span> interface=<span class="string">""</span> timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=5000&amp;retries=2</div><div class="line">服务消费者如果出现网络慢等因素，可再修改配置值，如果不修改使用前面的配置值</div></pre></td></tr></table></figure></p>
<h3 id="可编程配置"><a href="#可编程配置" class="headerlink" title="可编程配置"></a>可编程配置</h3><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 服务实现</div><div class="line">XxxService xxxService = new XxxServiceImpl();</div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"xxx"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务提供者协议配置</div><div class="line">ProviderConfig provider = new ProviderConfig();</div><div class="line">provider.setProtocol(<span class="string">"dubbo"</span>);</div><div class="line">provider.setPort(12345);</div><div class="line">provider.setThreads(200);</div><div class="line">// 服务提供者暴露服务配置</div><div class="line">ServiceConfig service = new ServiceConfig();</div><div class="line">service.setApplication(application);</div><div class="line">service.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">service.setProvider(provider); // 多个提供者可以用<span class="built_in">set</span>Providers()</div><div class="line">service.setInterfaceClass(XxxService.class);</div><div class="line">service.setRef(xxxService);</div><div class="line">service.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">service.export(); // 触发服务注册</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!--服务实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"com.alibaba.xxx.XxxServiceImpl"</span> /&gt;</div><div class="line">&lt;!--当前应用配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"morgan"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者协议配置 --&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> port=<span class="string">"12345"</span> threads=<span class="string">"200"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者暴露服务配置 --&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> ref=<span class="string">"xxxService"</span> /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"yyy"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务消费者缺省值配置</div><div class="line">ConsumerConfig consumer = new ConsumerConfig();</div><div class="line">consumer.setTimeout(5000);</div><div class="line">consumer.setRetries(2);</div><div class="line">// 引用远程服务</div><div class="line">ReferenceConfig reference = new ReferenceConfig();</div><div class="line">reference.setApplication(application);</div><div class="line">reference.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">reference.setConsumer(consumer);</div><div class="line">reference.setInterfaceClass(XxxService.class);</div><div class="line">reference.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">XxxService xxxService = reference.get(); // 获取远程xxxService代理</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!-- 当前应用信息配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"kylin"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务消费者缺省值配置 --&gt;</div><div class="line">&lt;dubbo:consumer timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">&lt;!-- 引用远程服务 --&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span></div><div class="line">interface=<span class="string">"com.alibaba.xxx.XxxService"</span> version=<span class="string">"1.0.0 /&gt;</span></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h3><p>当一个接口有不同实现，可以用group区分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;dubbo:service group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:service group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"fsService"</span> group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"mservice"</span> group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用<br>一般处理步骤<br>1）在低压力时间段，先升级一半提供者为新版本<br>2）再将所有消费者升级为新版本<br>3）然后将剩下的一半提供者升级为新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">服务提供者</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div><div class="line">服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="指定调用"><a href="#指定调用" class="headerlink" title="指定调用"></a>指定调用</h3><p>点对点直连/指定调用需求（开发/测试环境）。在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表。</p>
<ol>
<li><p>spring配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference interface=<span class="string">"com.alibaba.xxx.XxxService"</span> url=<span class="string">"dubbo://localhost:20890"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>java -D参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>映射文件方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">– java -Ddubbo.resolve.file=xxx.properties</div><div class="line">– com.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>路由方式<br>– 参数匹配 host、clssifier</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//对于所有调用com.foo.BarService接口的消费者，如果消费者的ip是<span class="string">"10.20.153.10"</span>，那么这个消费者将调用ip为<span class="string">"10.20.153.11"</span>的提供者，这样，通过动态配置注册中心的路由规则，就实现了动态指定某个提供者的需求。</div><div class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</div><div class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</div><div class="line">registry.register(URL.valueOf(<span class="string">"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule="</span>+ URL.encode(<span class="string">"http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11"</span>)));</div></pre></td></tr></table></figure>
</li>
<li><p>修改version<br>不推荐</p>
</li>
</ol>
<h3 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h3><p>共用注册中心，开发人员机器上的服务提供者被误调，影响其他开发人员（开发、测试环境）<br>场景：为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p><dubbo:registry register="false"><br><img src="/2017/11/24/dubbo功能介绍/只订阅结构.png" alt="只订阅"></dubbo:registry></p>
<h3 id="集群和容错"><a href="#集群和容错" class="headerlink" title="集群和容错"></a>集群和容错</h3><p><img src="/2017/11/24/dubbo功能介绍/集群容错.png" alt="集群容错"><br>将Directory中的多个Invoker伪装成一个Invoker, 对上层透明，包含集群的容错机制<br>Cluster接口定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SPI(FailoverCluster.NAME)</div><div class="line">public interface Cluster &#123;</div><div class="line">    @Adaptive</div><div class="line">    &lt;T&gt; Invoker&lt;T&gt;join(Directory&lt;T&gt; directory) throws RpcException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cluster可以看做是工厂类， 将目录directory下的invoker合并成一个统一的Invoker，根据不同集群策略的Cluster创建不同的Invoker我们来看下默认的失败转移，当出现失败重试其他服务的策略, 这个Cluster实现很简单就是创建FailoverCluseterInvoker对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FailoverCluster implements Cluster &#123;</div><div class="line">    public final static String NAME =<span class="string">"failover"</span>;</div><div class="line">    public&lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory)throws RpcException&#123;</div><div class="line">        <span class="built_in">return</span> new FailoverClusterInvoker&lt;T&gt;(directory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/集群方案.png" alt="集群方案"><br>1）AvailableCluster: 获取可用的调用。遍历所有Invokers判断Invoker.isAvalible,只要一个有为true直接调用返回，不管成不成功<br>2）BroadcastCluster: 广播调用。遍历所有Invokers, 逐个调用每个调用catch住异常不影响其他invoker调用<br>3）FailbackCluster: 失败自动恢复， 对于invoker调用失败， 后台记录失败请求，任务定时重发, 通常用于通知<br>4）FailfastCluster: 快速失败，只发起一次调用，失败立即保错，通常用于非幂等性操作<br>5）FailoverCluster: 失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟<br>（1）   目录服务directory.list(invocation) 列出方法的所有可调用服务<br>获取重试次数，默认重试两次<br>（2）   根据LoadBalance负载策略选择一个Invoker<br>（3）   执行invoker.invoke(invocation)调用<br>（4）   调用成功返回<br>调用失败小于重试次数，重新执行从3）步骤开始执行<br>       调用次数大于等于重试次数抛出调用失败异常<br>6）FailsafeCluster: 失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。<br>7）ForkingCluster: 并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。<br>8）  MergeableCluster: 分组聚合， 按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。<br>这个还蛮有意思，我们分析下是如何实现的<br>（1）   根据MERGE_KEY从url获取参数值<br>（2）   为空不需要merge， 正常调用<br>（3）   按group分组调用，将返回接口保存到集合中<br>（4）   获取MERGE_KEY如果是默认的话，获取默认merge策略，主要根据返回类型判断<br>（5）   如果不是，获取自定义的merge策略<br>（6）   Merge策略合并调用结果返回<br><img src="/2017/11/24/dubbo功能介绍/merge.png" alt="merge"><br>9）MockClusterWrapper: 具备调用mock功能是其他Cluster包装<br>获取url的MOCK_KEY属性<br>（1）   不存在直接调用其他cluster<br>（2）   存在值startsWith(“force”) 强制mock调用<br>（3）   存在值不是startsWith(“force”) 先正常调用， 出现异常在mock调用<br>集群模式的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:service cluster=<span class="string">"failsafe"</span> /&gt;    服务提供方</div><div class="line">&lt;dubbo:reference cluster=<span class="string">"failsafe"</span> /&gt;  服务消费方</div></pre></td></tr></table></figure></p>
<h3 id="多注册中心引用"><a href="#多注册中心引用" class="headerlink" title="多注册中心引用"></a>多注册中心引用</h3><p>解决CRM需同时调用中文站和国际站PC2相同接口相同版本服务的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">定义多个注册中心：</div><div class="line">&lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"172.29.63.18:9090"</span> /&gt;</div><div class="line">&lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"172.29.61.132:9090"</span> /&gt;</div><div class="line">不同注册中心使用不同引用：</div><div class="line">&lt;dubbo:reference id=<span class="string">"chinaXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"intlXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="graceful-shutdown"><a href="#graceful-shutdown" class="headerlink" title="graceful shutdown"></a>graceful shutdown</h3><p><img src="/2017/11/24/dubbo功能介绍/shutdown.png" alt="shutdown"></p>
<h2 id="dubbo-Rpc高级功能"><a href="#dubbo-Rpc高级功能" class="headerlink" title="dubbo-Rpc高级功能"></a>dubbo-Rpc高级功能</h2><p><img src="/2017/11/24/dubbo功能介绍/高级功能.png" alt="高级功能"></p>
<h3 id="telnet互操作"><a href="#telnet互操作" class="headerlink" title="telnet互操作"></a>telnet互操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\&gt; telnet localhost 20880</div><div class="line">dubbo&gt; <span class="built_in">help</span></div><div class="line">ls <span class="_">-l</span></div><div class="line">ps <span class="_">-l</span></div><div class="line">status <span class="_">-l</span></div><div class="line">trace XxxService 10</div><div class="line">count XxxService</div><div class="line">invoke XxxService.xxxMethod(args)</div><div class="line"><span class="built_in">log</span> 100</div></pre></td></tr></table></figure>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>泛接口调用方式主要用于客户端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过GenericService调用所有服务实现。所谓泛化调用是使用通用服务接口.GenericService来invoke需要调用的服务方法，这种设计无疑是可复用、可扩展之典范。 GenericService只有一个方法Object$invoke(String method,String[] parameterTypes,Object[] args)throwsGenericException;invoke接受三个参数，分别为方法名，参数类型组以及参数值组，其中参数类型和参数值一一对应.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> generic=<span class="string">"true"</span> /&gt;</div><div class="line">GenericService barService = (GenericService) applicationContext.getBean(<span class="string">"barService"</span>);</div><div class="line">Object result = barService.<span class="variable">$invoke</span>(<span class="string">"sayHello"</span>, new String[] &#123; <span class="string">"java.lang.String"</span> &#125;, new Object[] &#123; <span class="string">"World"</span> &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="显示回调"><a href="#显示回调" class="headerlink" title="显示回调"></a>显示回调</h3><p><img src="/2017/11/24/dubbo功能介绍/回调.png" alt="回调"><br>参数回调方式与调用本地callback或listener相同，只需要在Spring的配置文件中声明哪个参数是callback类型即可，Dubbo将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>并行发起多个请求，但只使用一个线程,基于NIO非阻塞实现并行调用，不用开启多线程，开销变小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:method name=<span class="string">"findXxx"</span> async=<span class="string">"true"</span> /&gt;</div><div class="line">xxxService.findXxx();//返回null</div><div class="line">Future&lt;Xxx&gt; future=RpcContext。getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/async.png" alt="async"></p>
<h3 id="框架事件"><a href="#框架事件" class="headerlink" title="框架事件"></a>框架事件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Dubbo:service … ondisconnected= xxx &gt;</div><div class="line">&lt;Dubbo:reference … ondisconnected =xxx&gt;</div></pre></td></tr></table></figure>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>在客户端执行部分代码，比如：<br>– 在客户端缓存已查询过的数据<br>– 当服务器端全部不可用时，伪造容错数据<br><img src="/2017/11/24/dubbo功能介绍/本地执行.png" alt="本地执行"></p>
<h3 id="隐式传参"><a href="#隐式传参" class="headerlink" title="隐式传参"></a>隐式传参</h3><p>隐式传参，比如：<br>– 验权扩展点需要携带一些用户凭证信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">• ThreadLocal Context</div><div class="line">– RpcContext.setAttachment(<span class="string">"password"</span>, <span class="string">"xxx"</span>);</div><div class="line">– RpcContext.getAttachment(<span class="string">"password"</span>);</div><div class="line"></div><div class="line">//Consumer</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"parm"</span>, <span class="string">"test"</span>+i);</div><div class="line">//server</div><div class="line">Map&lt;String, String&gt; attachments = RpcContext.getContext()</div><div class="line">               .getAttachments();</div><div class="line">String parm = attachments.get(<span class="string">"parm"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>注册中心路由<br>注册中心根据路由规则挑选服务提供者列表<br>RPC路由<br>根据类、方法、参数级别的路由规则<br>数据sharding<br>– 开发阶段的服务过滤(classifier)<br>– 可扩展的路由接口&amp;基于ScriptEngine的实现<br>• simpleEL<br>• Groovy ..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(invokers,invocation,context)&#123;</div><div class="line">var result = new java.util.ArrayList();</div><div class="line"><span class="keyword">if</span> (invokers.size()&gt;1 &amp;&amp;</div><div class="line">invocation.getMethodName() .equals(<span class="string">"method1"</span>)) &#123;</div><div class="line">result.add(invokers.get(0)) ;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">result.add(invokers.get(1)) ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;;</div><div class="line">route(invokers,invocation,context);</div></pre></td></tr></table></figure></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>actives:consumer并发数限制<br>executes:provider并发数限制<br>connections：consumer连接数限制<br>accept：provider连接数限制<br>短连接是连接上限，长连接则是启用的连接数<br>LeastActive LoadBalance:<br>调用并发数最少的provider，调节provider的并发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">并发控制</div><div class="line">限制com.foo.BarService的每个方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">限制com.foo.BarService的每个方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了actives，&lt;dubbo:reference&gt;优先，参见：配置的覆盖策略。</div><div class="line">Load Balance均衡：</div><div class="line">配置服务的客户端的loadbalance属性为leastactive，此Loadbalance会调用并发数最小的Provider（Consumer端并发数）。</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">连接控制</div><div class="line">限制服务器端接受的连接不能超过10个：（以连接在Server上，所以配置在Provider上）</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">限制客户端服务使用连接连接数：(如果是长连接，比如Dubbo协议，connections表示该服务对每个提供者建立的长连接数)</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了connections，&lt;dubbo:reference&gt;优先</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dubbo简要介绍&quot;&gt;&lt;a href=&quot;#dubbo简要介绍&quot; class=&quot;headerlink&quot; title=&quot;dubbo简要介绍&quot;&gt;&lt;/a&gt;dubbo简要介绍&lt;/h1&gt;&lt;h2 id=&quot;dubbo是什么&quot;&gt;&lt;a href=&quot;#dubbo是什么&quot; class=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch权威后续</title>
    <link href="http://yoursite.com/2017/11/15/elasticsearch%E6%9D%83%E5%A8%81%E5%90%8E%E7%BB%AD/"/>
    <id>http://yoursite.com/2017/11/15/elasticsearch权威后续/</id>
    <published>2017-11-15T13:44:09.000Z</published>
    <updated>2017-12-23T12:39:05.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式增删改查"><a href="#分布式增删改查" class="headerlink" title="分布式增删改查"></a>分布式增删改查</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard=<span class="built_in">hash</span>(routing)%number_of_primary_shards</div></pre></td></tr></table></figure>
<p>routing是一个字符串，默认是_id；这也就解释了主分片的数量只能在创建索引时定义且不能修改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档也就永远找不到了</p>
<h2 id="分片交互"><a href="#分片交互" class="headerlink" title="分片交互"></a>分片交互</h2><p>我们能够发送请求给集群中任意一个节点。每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。下面的例子中，我们将发送所有请求给 Node 1  ，这个节点我们将会称之为请求节点</p>
<h2 id="新建、索引、删除文档"><a href="#新建、索引、删除文档" class="headerlink" title="新建、索引、删除文档"></a>新建、索引、删除文档</h2><p>新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。<br>罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：</p>
<ul>
<li>客户端给Node1发送新建、索引或删除请求。</li>
<li>节点使用文档的_id  确定文档属于分片0。它转发请求到 Node3，分片0位于这个节点上</li>
<li>Node3在主分片上执行请求，如果成功，它转发请求到相应的位于 Node1和 Node2的复制节点上当所有的复制节点报告成功,Node 3报告成功到请求的节点，请求的节点再报告给客户端。客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</li>
</ul>
<h3 id="replication（注意在ElasticSearch-5-0开始被废弃）"><a href="#replication（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="replication（注意在ElasticSearch 5.0开始被废弃）"></a>replication（注意在ElasticSearch 5.0开始被废弃）</h3><p>复制默认的值是 sync。这将导致主分片得到复制分片的成功响应后才返回。<br>如果你设置 replication为 async，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。</p>
<h3 id="consistency（注意在ElasticSearch-5-0开始被废弃）"><a href="#consistency（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="consistency（注意在ElasticSearch 5.0开始被废弃）"></a>consistency（注意在ElasticSearch 5.0开始被废弃）</h3><p>默认主分片在尝试写入时需要<strong>规定数量(quorum)或过半的分片（可以是主节点或复制节点）可用。这是防止数据被写入到错的网络分区</strong>。规定的数量计算公式如下：<br>int( (primary + number_of_replicas) / 2 ) + 1<br>consistency允许的值为one（只有一个主分片），all（所有主分片和复制分片）或者默认的quorum或过半分片。<br>注意number_of_replicas是在索引中的的设置，用来定义复制分片的数量，而不是现在活动的复制节点的数量。如果你定义了索引有3个复制节点，那规定数量是：int( (primary + 3 replicas) / 2 ) + 1 = 3<br>但如果你只有2个节点，那你的活动分片不够规定数量，也就不能索引或删除任何文档。<br>注意: 新索引默认有1个复制分片，这意味着为了满足quorum的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在number_of_replicas大于一时才生效。</p>
<h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。默认等待一分钟。如果需要，你可以设置 timeout参数让它终止的更早： 100  表示100毫秒， 30s  表示30秒。</p>
<blockquote>
<p>新索引默认有 1  个复制分片，这意味着为了满足 quorum  的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在 number_of_replicas  大于一时才生效</p>
</blockquote>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><ol>
<li>客户端给Node1发送get请求。</li>
<li>节点使用文档的id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。此时，它转发请求到 Node2。</li>
<li>Node2返回endangered给Node1然后返回给客户端。</li>
</ol>
<p>对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本。可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol>
<li>客户端给Node1发送更新请求。</li>
<li>它转发请求到主分片所在节点Node3。</li>
<li>Node3从主分片检索出文档，修改source字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以retry_on_conflict设置的次数重复步骤3，都未成功则放弃。</li>
<li>如果 Node3成功更新文档，它同时转发文档的新版本到Node1和Node2上的复制节点以重建索引。当所有复制节点报告成功,Node3返回成功给请求节点，然后返回给客户端.<blockquote>
<p>当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本。记住这些修改转发到复制节点是异步的，它们并不能保证到达的顺序与发送相同。如果Elasticsearch转发的仅仅是修改请求，修改的顺序可能是错误的，那得到的就是个损坏的文档。</p>
</blockquote>
</li>
</ol>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget请求检索多个文档的顺序步骤：</p>
<ol>
<li>客户端向Node1发送mget请求。</li>
<li>Node1为每个分片构建一个多条数据检索请求，然后转发到这些请求所需的主分片或复制分片上。当所有回复被接收，Node1构建响应并返回给客户端</li>
</ol>
<p>bulk执行多个create、index、delete和update请求的顺序步骤：</p>
<ol>
<li>客户端向Node1发送bulk请求。</li>
<li>Node1为每个分片构建批量请求，然后转发到这些请求所需的主分片上。</li>
<li>主分片一个接一个的按序执行操作。当一个操作执行完，主分片转发新文档（或者删除部分）给对应的复制节点，然后执行下一个操作。复制节点为报告所有操作完成，节点报告给请求节点，请求节点整理响应并返回给客户端。</li>
</ol>
<p>这里我们可以解释bulk的格式，而不是包装成json格式请求：意味着我们需要解析JSON为数组（包括文档数据，可能非常大）、检查每个请求决定应该到哪个分片上、为每个分片创建一个请求的数组、序列化这些数组为内部传输格式、发送请求到每个分片。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><table>
<thead>
<tr>
<th>概念</th>
<th style="text-align:right">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mappings(映射)</td>
<td style="text-align:right">数据在每个字段中的解释说明</td>
</tr>
<tr>
<td>analysis(分析)</td>
<td style="text-align:right">全文是如何处理的可以被搜索的</td>
</tr>
<tr>
<td>领域特定语句查询(query DSL)</td>
<td style="text-align:right">Elasticsearch使用的灵活的、强大的查询语言</td>
</tr>
</tbody>
</table>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>没有指定任何的查询条件，只返回集群索引中的所有文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure></p>
<h2 id="多索引和多类别"><a href="#多索引和多类别" class="headerlink" title="多索引和多类别"></a>多索引和多类别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/_search  //在所有索引的所有类型中搜索</div><div class="line">/gb/_search //在索引gb的所有类型中搜索</div><div class="line">/gb,us/_search //在索引gb us的所有类型中搜索</div><div class="line">/g*,u*/_search //在索引g或u开头的所有类型中搜索</div><div class="line">/gb/user/_search //在索引 gb的类型user中搜索</div><div class="line">/gb,us/user,tweet/_search //在gb、us的user和tweet类型中搜索</div><div class="line">/_all/user,tweet/_search //在user和tweet类型中搜索</div></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>size默认为10 from默认为0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure></p>
<p>注意：现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长</p>
<h1 id="映射分析"><a href="#映射分析" class="headerlink" title="映射分析"></a>映射分析</h1><h2 id="确切值和全文文本"><a href="#确切值和全文文本" class="headerlink" title="确切值和全文文本"></a>确切值和全文文本</h2><p>确切值是确定的，正如它的名字一样。比如一个date或用户ID，也可以包含更多的字符串比如username或email地址。全文文本，从另一个角度来说是文本化的数据(常常以人类的语言书写)，比如一片推文(Twitter的文章)或邮件正文<br>确切值是很容易查询的，因为结果是二进制的 – 要么匹配，要么不匹配。</p>
<h2 id="分析和分析器"><a href="#分析和分析器" class="headerlink" title="分析和分析器"></a>分析和分析器</h2><p>分析(analysis)是这样一个过程：<br>首先，表征化一个文本块为适用于倒排索引单独的词(term)<br>然后标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><table>
<thead>
<tr>
<th>类型</th>
<th>标识的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
</tr>
<tr>
<td>whole number</td>
<td>byte、short、integer、long</td>
</tr>
<tr>
<td>floating point</td>
<td>float、double</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Date</td>
<td>date</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>field type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean:true,false</td>
<td>“boolean”</td>
</tr>
<tr>
<td>whole number:123</td>
<td>“long”</td>
</tr>
<tr>
<td>floating point:123.45</td>
<td>“double”</td>
</tr>
<tr>
<td>String:”123”</td>
<td>“string”</td>
</tr>
<tr>
<td>string valid date:”2016-05-01”</td>
<td>date”</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这意味着，如果你索引一个带引号的数字—— “123”  ，它将被映射为 “string”  类型，而不是 “long”  类型。然而，如果字段已经被映射为 “long”  类型，Elasticsearch将尝试转换字符串为long，并在转换失败时会抛出异常。</p>
</blockquote>
<h3 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get sjjhpt/_mapping/fwjbl</div></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>analyzed</td>
<td>首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。</td>
</tr>
<tr>
<td>not_analyzed</td>
<td>索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段</td>
</tr>
<tr>
<td>no</td>
<td>不索引这个字段。这个字段不能为搜索到</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="string">"userid"</span>:&#123;</div><div class="line">     <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">     <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line"></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其他简单类型——long、double、date等等——也接受index参数，但相应的值只能是 no和not_analyzed,它们的值不能被分析</p>
</blockquote>
<h3 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PUT /gb/_mapping/tweet</div><div class="line">&#123;</div><div class="line"><span class="string">"properties"</span> : &#123;</div><div class="line"><span class="string">"tag"</span> :&#123;</div><div class="line"><span class="string">"type"</span> : <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复合核心字段类型"><a href="#复合核心字段类型" class="headerlink" title="复合核心字段类型"></a>复合核心字段类型</h2><h3 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h3><p>数组：{ “tag”: [ “search”, “nosql” ]}<br>对于数组不需要特殊的映射。任何一个字段可以包含零个、一个或多个值，同样对于全文字段将被分析并产生多个词。这意味着数组中所有值必须为同一类型。你不能把日期和字符窜混合。如果你创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型。</p>
<h3 id="空字段"><a href="#空字段" class="headerlink" title="空字段"></a>空字段</h3><p>Lucene没法存放null值，所以一个null值的字段被认为是空字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"empty_string"</span>: <span class="string">""</span>,</div><div class="line"><span class="string">"null_value"</span>: null,</div><div class="line"><span class="string">"empty_array"</span>: [],</div><div class="line"><span class="string">"array_with_null_value"</span>: [ null ]</div></pre></td></tr></table></figure></p>
<h3 id="多层对象"><a href="#多层对象" class="headerlink" title="多层对象"></a>多层对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="string">"gb"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123;</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"user"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"id"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"gender"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"age"</span>: &#123; <span class="string">"type"</span>: <span class="string">"long"</span> &#125;,</div><div class="line">      <span class="string">"name"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"full"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"first"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"last"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;</div><div class="line">       &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多层对像user的first，我们需要制定他的完整路径，像”user.name.first”或者tweet.user.name.first，而对于lucene，我们不能检索user或者user.name,我们不能检索复杂的结构体.</p>
<h1 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h1><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 30,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结构化查询-1"><a href="#结构化查询-1" class="headerlink" title="结构化查询"></a>结构化查询</h2><p>使用结构化查询，你需要传递query参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: your_query_here</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">       <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询子句"><a href="#查询子句" class="headerlink" title="查询子句"></a>查询子句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> QUERY_NAME: &#123;</div><div class="line"> ARGUMENT: VALUE</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">  <span class="string">"match"</span>: &#123;</div><div class="line">  <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并多字句"><a href="#合并多字句" class="headerlink" title="合并多字句"></a>合并多字句</h3><p>复合子句(compound)用以合并其他的子句。bool子句允许你合并其他的合法子句，无论是must，must_not还是should<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"> <span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"spam"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#125;&#125;</div><div class="line">],</div><div class="line"><span class="string">"minimum_should_match"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>一条查询语句会计算每个文档与查询语句的相关性，会给出一个相关性评分_score并且按照相关性对匹配到的文档进行排序。这种评分方式非常适用于一个没有完全配置结果的全文本搜索。</p>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p>使用过滤语句得到的结果集 – 一个简单的文档列表，快速匹配运算并存入内存是十分方便的，每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。<br>查询语句不仅要查找相匹配的文档，还需要计算每个文档的相关性，所以一般来说查询语句要比过滤语句更耗时，并且查询结果也不可缓存。<br>原则上来说，使用查询语句做全文本搜索或其他需要进行相关性评分的时候，剩下的全部用过滤语句</p>
<h2 id="查询过滤语句"><a href="#查询过滤语句" class="headerlink" title="查询过滤语句"></a>查询过滤语句</h2><h3 id="term过滤"><a href="#term过滤" class="headerlink" title="term过滤"></a>term过滤</h3><p>term用于精确匹配哪些值，比如数字，日期，布尔值或not_analyzed的字符串(未经分析的文本数据类型)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="terms过滤"><a href="#terms过滤" class="headerlink" title="terms过滤"></a>terms过滤</h3><p>terms允许指定多个匹配条件.如果某个字段指定了多个值，那么文档需要一起去做匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"terms"</span>:&#123;</div><div class="line">      <span class="string">"jkbsf"</span>:[<span class="string">"test"</span>,<span class="string">"test1"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="range过滤"><a href="#range过滤" class="headerlink" title="range过滤"></a>range过滤</h3><p>用于查询范围<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"range"</span>:&#123;</div><div class="line">      <span class="string">"age"</span>:&#123;</div><div class="line">          <span class="string">"gte"</span>:10,</div><div class="line">          <span class="string">"lt"</span>:20</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gt：大于、gte:大于等于、lt:小于、lte：小于等于</p>
<h3 id="exists和missing过滤"><a href="#exists和missing过滤" class="headerlink" title="exists和missing过滤"></a>exists和missing过滤</h3><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"exists"</span>:   &#123;</div><div class="line">        <span class="string">"field"</span>:    <span class="string">"title"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="bool过滤"><a href="#bool过滤" class="headerlink" title="bool过滤"></a>bool过滤</h3><p>bool 过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含一下操作符：<br>must :: 多个查询条件的完全匹配,相当于 and。<br>must_not :: 多个查询条件的相反匹配，相当于 not。<br>should :: 至少有一个查询条件匹配, 相当于 or。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">        <span class="string">"must"</span>:     &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line">        <span class="string">"must_not"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>:    <span class="string">"spam"</span>  &#125;&#125;,</div><div class="line">        <span class="string">"should"</span>: [</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span>   &#125;&#125;,</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"unread"</span>:  <span class="literal">true</span>   &#125;&#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">### match查询</span></div><div class="line">match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它</div><div class="line">如果你使用  match  查询一个全文本字段，它会在真正查询之前用分析器先分析 match  一下查询字符</div><div class="line">``` bash</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"About Search"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 match下指定了一个确切值，在遇到数字，日期，布尔值或者 not_analyzed的字符串时，它将为你搜索你给定的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。</p>
</blockquote>
<h3 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"full text search"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询与bool过滤相似，用于合并多个查询子句。不同的是，bool过滤可以直接给出是否匹配成功，而bool查询要计算每一个查询子句的score（相关性分值）。<br>must  :: 查询指定文档一定要被包含。<br>must_not  :: 查询指定文档一定不要被包含。<br>should  :: 查询指定文档，有则可以为文档相关性加分。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"spam"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"range"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 如果bool查询下没有must子句，那至少应该有一个should子句。但是如果有must子句，那么没有should子句也可以进行查询。</p>
</blockquote>
<h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>查询语句和过滤语句可以放在各自的上下文中。在 ElasticSearch API 中我们会看到许多带有query或 filter的语句。这些语句既可以包含单条 query 语句，也可以包含一条 filter子句。换句话说，这些语句需要首先创建一个query或filter的上下文关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"filtered"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /gb/tweet/_validate/query</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span> : &#123;</div><div class="line"><span class="string">"match"</span> : <span class="string">"really powerful"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="字段值排序"><a href="#字段值排序" class="headerlink" title="字段值排序"></a>字段值排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="默认排序"><a href="#默认排序" class="headerlink" title="默认排序"></a>默认排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//默认以顺序排序，_score以倒序排序</div><div class="line"><span class="string">"sort"</span>: <span class="string">"number_of_children"</span></div></pre></td></tr></table></figure>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: [</div><div class="line">&#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</div></pre></td></tr></table></figure>
<h3 id="多值字段字符串排序"><a href="#多值字段字符串排序" class="headerlink" title="多值字段字符串排序"></a>多值字段字符串排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//改变前的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">//改变后的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span>,</div><div class="line"><span class="string">"fields"</span>: &#123;</div><div class="line"><span class="string">"raw"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//现在，在给数据重建索引后，我们既可以使用  tweet  字段进行全文本搜索，也可以用 tweet.raw  字段进行排序</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></div><div class="line">&#125;</div><div class="line">对analyzed字段进行强制排序会消耗大量内存</div></pre></td></tr></table></figure>
<h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><p>每个文档都有相关性评分，用一个相对的浮点数字段_score来表示,_score的评分越高，相关性越高.fuzzy查询会计算与关键词的拼写相似程度,terms查询会计算 找到的内容与关键词组成部分匹配的百分比，但是一般意义上我们说的全文本搜索是指计算内容与关键词的类似程度。<br>es的相似度算法被定义为TF/IDF,即检索词频率和反向文档频率，<br>检索词频率：检索词在该字段出现的频率；也就是出现频率越高，相关性越高。<br>反向文档频率：每个检索词在索引中出现的频率；频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低，即检验一个检索词在文档中的普遍重要性<br>字段长度准则：长度越长，相关度越低。<br>如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<h3 id="理解评分规则"><a href="#理解评分规则" class="headerlink" title="理解评分规则"></a>理解评分规则</h3><p>explain参数可以让返回结果添加一个_score评分的得来依据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /_search?explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Explain-Api"><a href="#Explain-Api" class="headerlink" title="Explain Api"></a>Explain Api</h3><p> explain  选项加到某一文档上时，它会告诉你为何这个文档会被匹配，以及一个文档为何没有被匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /us/tweet/12/_explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;,</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//response</div><div class="line"><span class="string">"failure to match filter: cache(user_id:[2 TO 2])"</span></div></pre></td></tr></table></figure></p>
<h2 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h2><p>为了提高排序效率，ElasticSearch 会将所有字段的值加载到内存中，这就叫做”数据字段”</p>
<blockquote>
<p>es将所有字段数据加载到内存中并不是匹配到的那部分数据,而是索引下所有文档中的值，包括所有类型</p>
</blockquote>
<p>将所有字段数据加载到内存中是因为从硬盘反向倒排索引是非常缓慢的。尽管你这次请求需要的是某些文档中的部分数据，但你下个请求却需要另外的数据，所以将所有字段数据一次性加载到内存中是十分必要的。<br>ElasticSearch中的字段数据常被应用到以下场景：</p>
<ol>
<li>对一个字段进行排序</li>
<li>对一个字段进行聚合</li>
<li>某些过滤，比如地理位置过滤</li>
<li>某些与字段相关的脚本计算<br>这会消耗掉很多内存，尤其是大量的字符串数据 – string字段可能包含很多不同的值，比如邮件内容。 值得庆幸的是，内存不足是可以通过横向扩展解决的，我们可以增加更多的节点到集群。</li>
</ol>
<h1 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h1><p>一个CRUD操作只处理一个单独的文档。文档的唯一性由 _index  ,  _type  和 routing-value  （通常默认是该文档的 _id  ）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。但如果针对复杂的搜索模型，由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上）。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。搜索的执行过程分两个阶段，称为查询然后取回（query then fetch）</p>
<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2><p>在初始化查询阶段，查询被向索引中的每个分片或者副本广播，每个分片会在本地执行搜索并建立匹配文档的优先队列。</p>
<blockquote>
<p>优先队列<br>一个优先队列（priority queue is）只是一个存有前n个（top-n）匹配document的有序列表。这个优先队列的大小由分页参数from和size决定。例如，下面这个例子中的搜索请求要求优先队列要能够容纳100个document</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 90,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询阶段包含以下三步：<br>1.客户端发送一个search给node3，node3创建一个from+size的空优先队列；<br>2.node3转发请求到索引中每个分片的原本或者副本，每个分片在本地执行这个查询并且将结果放到一个from+size的优先队列里；<br>3.每个分片返回documentid和它优先队列里所有document的排序值给协调节点node3.协调节点node3把这些值合并到自己的优先队列产生全局排列的结果<br>当一个搜索请求被发送到一个节点node时，这个节点就成了协调节点，这个节点工作是向所有相关的分片广播搜索请求并把他们的响应整合成全局的有序结果集。<br>第一步是向索引里的每个节点的分片副本广播请求。就像document的 GET  请求一样，搜索请求可以被每个分片的原本或任意副本处理。对于后续请求，协调节点会轮询所有的分片副本以分摊负载。<br>每一个分片在本地执行查询和建立一个长度为 from+size  的有序优先队列——这个长度意味着它自己的结果数量就足够满足全局的请求要求。分片返回一个轻量级的结果列表给协调节点。只包含documentID值和排序需要用到的值，例如 _score。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>分布式搜索取回阶段如下：<br>1.协调节点需要辨别哪个document需要取回，并且向相关分片发送GET请求。<br>2.每个分片加载document并根据需要丰富他，然后再将document返回给协调节点。<br>3.一旦所有的document都被取回，协调节点会将结果返回给客户端<br>分片加载document主体—— _source  field。如果需要，还会根据元数据丰富结果和高亮搜索片断。一旦协调节点收到所有结果，会将它们汇集到单一的回答响应里，这个响应将会返回给客户端。  </p>
<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>是机器人或者网络爬虫的行为。它们会持续不断地一页接着一页地获取页面直到服务器到底崩溃的边缘<br>查询然后取回过程虽然支持通过使用 from  和 size  参数进行分页，但是要在有限范围内（within limited）。还记得每个分片必须构造一个长度为 from+size  的优先队列吧，所有这些都要传回协调节点。这意味着协调节点要通过对 分片数量 * (from +size)  个document进行排序来找到正确的 size  个document。</p>
<h2 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h2><h3 id="preference（偏爱）"><a href="#preference（偏爱）" class="headerlink" title="preference（偏爱）"></a>preference（偏爱）</h3><p>preference  参数允许你控制使用哪个分片或节点来处理搜索请求。她接受如下一些参数<br>primary：搜索只在主分片执行搜索请求，副本不参与搜索；性能会打折扣，达不到性能的水平扩展。<br>_primary_first：优先在主分片执行，如果主分片挂掉，会在副本执行请求。<br>_local：搜索请求优先于在本地执行。<br>_only_node:xyz：只在xyz节点执行搜索。<br>_prefer_node:xyz：搜索请求优先在节点xyz执行。<br>_shards:2,3：搜索只在分片2、3执行，可以与_primary参数一起使用如：_shards:2,3;_primary<br>随机字符串：指定一个随机字符串，可以保证同样的请求，被分配到同样的副本上面，从而保证同一请求结果的稳定性。<br>结果震荡<br>想像一下，你正在按照 timestamp  字段来对你的结果排序，并且有两个document有相同的timestamp。由于搜索请求是在所有有效的分片副本间轮询的，这两个document可能在原始分片里是一种顺序，在副本分片里是另一种顺序.这就是被称为结果震荡（bouncing results）的问题：用户每次刷新页面，结果顺序会发生变化。避免这个问题方法是对于同一个用户总是使用同一个分片。方法就是使用一个随机字符串例如用户的会话ID（session ID）来设置 preference  参数</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。<br>timeout参数告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回。返回部分结果总比什么都没有好<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"timed_out"</span>: <span class="literal">true</span>, (1)</div><div class="line"><span class="string">"_shards"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: 5,</div><div class="line"><span class="string">"successful"</span>: 4,</div><div class="line"><span class="string">"failed"</span>: 1 (2)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>在搜索时，你可以指定一个或多个 routing  值来限制只搜索那些分片而不是搜索index里的全部分片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?routing=user_1,user2</div></pre></td></tr></table></figure></p>
<h3 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h3><p>默认的搜索类型是query_then_fetch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?search_type=count</div></pre></td></tr></table></figure></p>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>count（计数）搜索类型只有一个 query（查询）  的阶段。当不需要搜索结果只需要知道满足查询的document的数量时，可以使用这个查询类型。</p>
<h4 id="query-then-fetch-查询并且取回"><a href="#query-then-fetch-查询并且取回" class="headerlink" title="query_then_fetch 查询并且取回"></a>query_then_fetch 查询并且取回</h4><p>query_and_fetch（查询并且取回）  搜索类型将查询和取回阶段合并成一个步骤。这是一个内部优化选项，当搜索请求的目标只是一个分片时可以使用，例如指定了 routing（路由选择）  值时。虽然你可以手动选择使用这个搜索类型，但是这么做基本上不会有什么效果</p>
<h4 id="dfs-query-then-fetch-和-dfs-query-and-fetch"><a href="#dfs-query-then-fetch-和-dfs-query-and-fetch" class="headerlink" title="dfs_query_then_fetch 和 dfs_query_and_fetch"></a>dfs_query_then_fetch 和 dfs_query_and_fetch</h4><p>dfs  搜索类型有一个预查询的阶段，它会从全部相关的分片里取回项目频数来计算全局的项目频数。我们将在relevance-is-broken（相关性被破坏）里进一步讨论这个</p>
<h4 id="scan-扫描"><a href="#scan-扫描" class="headerlink" title="scan(扫描)"></a>scan(扫描)</h4><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API连在一起使用的，可以高效地取回巨大数量的结果。它是通过禁用排序来实现的</p>
<h2 id="扫描和滚屏"><a href="#扫描和滚屏" class="headerlink" title="扫描和滚屏"></a>扫描和滚屏</h2><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价。<br>为了使用scan-and-scroll（扫描和滚屏），需要执行一个搜索请求，将 search_type  设置成 scan  ，并且传递一个 scroll  参数来告诉Elasticsearch滚屏应该持续多长时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl -XGET <span class="string">'localhost:9200/twitter/tweet/_search?scroll=1m'</span> <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query": &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "title" : "elasticsearch"</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    size:1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个请求的应答没有包含任何命中的结果，但是包含了一个Base-64编码的 _scroll_id（滚屏id）  字符串。现在我们可以将 _scroll_id  传递给 _search/scroll  末端来获取第一批结果</div><div class="line">curl -XGET  'localhost:9200/_search/scroll<span class="string">'  -d'</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"scroll"</span> : <span class="string">"1m"</span>,</div><div class="line">    <span class="string">"scroll_id"</span> : <span class="string">"c2Nhbjs2OzM0NDg1ODpzRlBLc0FXNlNyNm5JWUc1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(1) 保持滚屏开启另一分钟。<br>(2)  _scroll_id  可以在body或者URL里传递，也可以被当做查询参数传递。注意，要再次指定 ?scroll=1m  。滚屏的终止时间会在我们每次执行滚屏请求时刷新，所以他只需要给我们足够的时间来处理<br>当前批次的结果而不是所有的匹配查询的document。<br>这个滚屏请求的应答包含了第一批次的结果。虽然指定了一个1000的size，但是获得了更多的document。当扫描时,size被应用到每一个分片上，所以我们在每个批次里最多或获得 size <em> number_of_primary_shards（size</em>主分片数）个document。</p>
<blockquote>
<p>滚屏请求也会返回一个新的_scroll_id  。每次做下一个滚屏请求时，必须传递前一次请求返回的_scroll_id  。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /_index</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"mappings"</span>:&#123;</div><div class="line">    <span class="string">"type_one"</span>:&#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>config/elasticsearch.yml,添加下面的配置来防止自动创建索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action.auto_create_index: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">number_of_shards 定义一个索引的主分片个数，默认值是 `5`。这个配置在索引创建后不能修改。</div><div class="line">number_of_replicas 每个主分片的复制分片个数，默认是 `1`。这个配置可以随时在活跃的索引上修改</div><div class="line">PUT /my_temp_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"number_of_shards"</span> : 1,</div><div class="line"><span class="string">"number_of_replicas"</span> : 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//修改</div><div class="line">PUT /my_temp_index/_settings</div><div class="line">&#123;</div><div class="line"><span class="string">"number_of_replicas"</span>: 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置分词器"><a href="#配置分词器" class="headerlink" title="配置分词器"></a>配置分词器</h2><p>standard分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了这几点<br>standard  分词器，在词层级上分割输入的文本。<br>standard  表征过滤器，被设计用来整理分词器触发的所有表征（但是目前什么都没做）。<br>lowercase  表征过滤器，将所有表征转换为小写。<br>stop  表征过滤器，删除所有可能会造成搜索歧义的停用词，如a、the、and、is  。</p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>字符过滤器、分词器、表征过滤器</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>字符过滤器是让字符串在被分词前变得更加“整洁”。例如，如果我们的文本是 HTML 格式，它可能会包含一些我们不想被索引的 HTML 标签，诸如</p><p>或<div>。我们可以使用html_strip字符过滤器 来删除所有的HTML标签，并且将HTML实体转换成对应的 Unicode字符，比如将&Aacute;  转成Á。一个分析器可能包含零到多个字符过滤器</div></p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>一个分析器必须包含一个分词器。分词器将字符串分割成单独的词（terms）或表征（tokens）。standard分析器使用standard分词器将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。</p>
<h3 id="表征过滤器"><a href="#表征过滤器" class="headerlink" title="表征过滤器"></a>表征过滤器</h3><p>表征过滤器可能修改，添加或删除表征。我们已经提过lowercase和stop表征过滤器，但是 Elasticsearch 中有更多的选择。</p>
<h3 id="创建自定义的分词器"><a href="#创建自定义的分词器" class="headerlink" title="创建自定义的分词器"></a>创建自定义的分词器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123; ... custom character filters ... &#125;,</div><div class="line"><span class="string">"tokenizer"</span>: &#123; ... custom tokenizers ... &#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; ... custom token filters ... &#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123; ... custom analyzers ... &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//实例</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123;</div><div class="line"><span class="string">"&amp;_to_and"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"mapping"</span>,</div><div class="line"><span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"my_stopwords"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"stop"</span>,</div><div class="line"><span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123;</div><div class="line"><span class="string">"my_analyzer"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"custom"</span>,</div><div class="line"><span class="string">"char_filter"</span>: [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</div><div class="line"><span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</div><div class="line"><span class="string">"filter"</span>: [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</div><div class="line">&#125;&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>除非我们告诉es在哪里使用，否则分析器不会起作用。我们可以通过下面的映射将它应用在一个string类型的字段上.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">PUT /_index/_mapping/_type</div><div class="line">&#123;</div><div class="line">  <span class="string">"properties"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">          <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">          <span class="string">"analyzer"</span>:<span class="string">"my_analyzer"</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">## 映射</span></div><div class="line">Lucene 中，一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换成多个值。Lucene 不关心这些值是字符串，数字或日期，所有的值都被当成不透明字节</div><div class="line"><span class="comment">### 预防类型陷阱</span></div><div class="line">想象一下我们的索引中有两种类型： blog_en  表示英语版的博客， blog_es  表示西班牙语版的博客。两种类型都有  title字段，但是其中一种类型使用  english  分析器，另一种使用  spanish  分析器。</div><div class="line">``` bash</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"The quick brown fox"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"blog_en.title"</span>, <span class="string">"blog_es.title"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>多个元数据字段，每一个都以下划线开头，例如  _type  ,  _id  和  _source<br>设置项，控制如何动态处理新的字段，例如analyzer,dynamic_date_formats和dynamic_templates  。其他设置，可以同时应用在根对象和其他object类型的字段上，例如enabled,dynamic和 include_in_all<br>属性重要有三个type、index、analyzer</p>
<h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>默认情况下，Elasticsearch 用 JSON 字符串来表示文档主体保存在  _source  字段中。像其他保存的字段一样,_source字段也会在写入硬盘前压缩<br>需要source的理由：</p>
<ol>
<li>搜索结果中能得到完整的文档 —— 不需要额外去别的数据源中查询文档</li>
<li>如果缺少_source字段，部分更新请求不会起作用</li>
<li>当你的映射有变化，而且你需要重新索引数据时，你可以直接在 Elasticsearch 中操作而不需要重新从别的数据源中取回数据</li>
<li>你可以从  _source  中通过  get  或  search  请求取回部分字段，而不是整个文档</li>
<li>这样容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆ID中猜测他们的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//禁用<span class="built_in">source</span></div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_source"</span>: &#123;</div><div class="line"><span class="string">"enabled"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</div><div class="line"><span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="元数据-all字段"><a href="#元数据-all字段" class="headerlink" title="元数据:_all字段"></a>元数据:_all字段</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//当你还不清楚最终文档的结构时，可以将任何查询用于这个字段</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 禁用_all</div><div class="line">PUT /my_index/_mapping/my_type</div><div class="line">&#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过  include_in_all  选项可以控制字段是否要被包含在_all字段中，默认值是true。</p>
<h2 id="文档id"><a href="#文档id" class="headerlink" title="文档id"></a>文档id</h2><p>文档唯一标识由_index、_type、_id、_uid组成</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>它通过动态映射来确定字段的数据类型且自动将该字段加到类型映射中，通过dynamic设置来控制这些行为，它接受下面几个选项true：自动添加字段（默认）、false：忽略字段、strict：当遇到未知字段时抛出异常<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic"</span>: <span class="string">"strict"</span>, &lt;1&gt;</div><div class="line"><span class="string">"properties"</span>: &#123;</div><div class="line"><span class="string">"title"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</div><div class="line"><span class="string">"stash"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line"><span class="string">"dynamic"</span>: <span class="literal">true</span> &lt;2&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断字符串为日期的规则可以通过dynamic_date_formats配置来修改</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用dynamic_templates，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//es  : 字段名以  _es  结尾需要使用spanish分析器 ;en:所有其他字段使用english分析器。</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic_templates"</span>: [</div><div class="line">自定义动态索引</div><div class="line">日期检测</div><div class="line">动态模板</div><div class="line">&#123; <span class="string">"es"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*_es"</span>, &lt;1&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"spanish"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"en"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*"</span>, &lt;2&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="默认映射"><a href="#默认映射" class="headerlink" title="默认映射"></a>默认映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"_default_"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"blog"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><p>_source字段的一个最大的好处是你已经在 Elasticsearch 中有了完整的文档，你不再需要从数据库中重建你的索引。你可以在同一时间执行多个重新索引的任务，但是你显然不愿意它们的结果有重叠。所以，可以将重建大索引的任务通过日期或时间戳字段拆分成较小的任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"range"</span>: &#123;</div><div class="line"><span class="string">"date"</span>: &#123;</div><div class="line"><span class="string">"gte"</span>: <span class="string">"2014-01-01"</span>,</div><div class="line"><span class="string">"lt"</span>: <span class="string">"2014-02-01"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"size"</span>: 1000</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建一个索引  my_index_v1  ，然后将别名  my_index  指向它</div><div class="line">PUT /my_index_v1 &lt;1&gt;</div><div class="line">PUT /my_index_v1/_alias/my_index &lt;2&gt;</div><div class="line">//你可以检测这个别名指向哪个索引</div><div class="line">GET /*/_alias/my_index</div><div class="line">//哪些别名指向这个索引</div><div class="line">GET /my_index_v1/_alias/*</div><div class="line">//别名可以指向多个索引，所以我们需要在新索引中添加别名的同时从旧索引中删除它</div><div class="line">POST /_aliases</div><div class="line">&#123;</div><div class="line"><span class="string">"actions"</span>: [</div><div class="line">&#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="深入分片"><a href="#深入分片" class="headerlink" title="深入分片"></a>深入分片</h1><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。<br>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：<br>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。<br>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h2 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h2><p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件<br>新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存，不时地, 缓存被提交</li>
<li>不时地, 缓存被 提交 ：<br>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。新的段被开启，让它包含的文档可见以被搜索。内存缓存被清空，等待接收新的文档。</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<h2 id="删除更新"><a href="#删除更新" class="headerlink" title="删除更新"></a>删除更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。<br>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。<br>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。<br>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。<br>但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<h3 id="refresh-api"><a href="#refresh-api" class="headerlink" title="refresh api"></a>refresh api</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST /_refresh //刷新所有索引</div><div class="line">POST /blogs/_refresh //刷新blogs索引</div><div class="line">//正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率</div><div class="line">PUT /my_logs</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>: &#123;</div><div class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> //每30秒刷新 my_logs 索引</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//当你在建立一个大索引时，可以关闭自动刷新</div><div class="line">PUT /my_logs/_settings</div><div class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125;</div></pre></td></tr></table></figure></p>
<h2 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h2><p>1.新的文档被添加到内存缓冲区并且被追加到了事务日志<br>2.刷新（refresh）完成后, 缓存被清空但是事务日志不会<br>3.事务日志不断积累文档<br>4.在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST /blogs/_flush //刷新（flush） blogs 索引</div><div class="line">POST /_flush?wait_for_ongoing //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</div></pre></td></tr></table></figure></p>
<h2 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h2><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。启动段合并不需要你做任何事。进行索引和搜索时会自动进行。步骤如下：</p>
<ol>
<li>两个提交了的段和一个未提交的段正在被合并到一个更大的段</li>
<li>一旦合并结束，老的段被删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</div><div class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索是查询包含内部结构的数据。日期、数字、时间都是结构化的，或者是结构化文本，比如蜡笔的颜色或者博客的标签。通过结构化搜索，你的查询结果始终是 是或非；是否应该属于集合。结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档</p>
<h2 id="查找准确的值"><a href="#查找准确的值" class="headerlink" title="查找准确的值"></a>查找准确的值</h2><p>对于准确值，你需要使用过滤器。过滤器的重要性在于它们非常的快。它们不计算相关性（避过所有计分阶段）而且很容易被缓存。<br>在5里filtered被去掉，放在bool里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"query"</span>:&#123;</div><div class="line">			<span class="string">"filter"</span>:&#123;</div><div class="line">				<span class="string">"terms"</span>:&#123;</div><div class="line">					<span class="string">"jkbsf"</span>:[<span class="string">"tyws-AddCaseTrial"</span>,<span class="string">"mrshjbs tyws-AddCaseTrial"</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SELECT document FROM products WHERE price = 20</div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;</div><div class="line"><span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合过滤"><a href="#组合过滤" class="headerlink" title="组合过滤"></a>组合过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">SELECT product</div><div class="line">FROM products</div><div class="line">WHERE (price = 20 OR productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</div><div class="line">AND (price != 30)</div><div class="line"></div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"bool"</span> : &#123;</div><div class="line"><span class="string">"should"</span> : [</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, &lt;2&gt;</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; &lt;2&gt;</div><div class="line">],</div><div class="line"><span class="string">"must_not"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; &lt;3&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嵌套布尔过滤器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT document</div><div class="line">FROM products</div><div class="line">WHERE productID = <span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">OR ( productID = <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">AND price = 30</div><div class="line"></div><div class="line">&#123;</div><div class="line">   <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"filtered"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">           <span class="string">"bool"</span>:&#123;</div><div class="line">             <span class="string">"should"</span>:[</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"term"</span>:&#123;</div><div class="line">                    <span class="string">"productID"</span>:<span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">                  &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"bool"</span>:&#123;</div><div class="line">                    <span class="string">"must"</span>:[</div><div class="line">                    &#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">                      &#125;</div><div class="line">                    &#125;,&#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"price"</span>: 30</div><div class="line">                      &#125;</div><div class="line">                    &#125;</div><div class="line">                    ]</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">             ]</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询多个准确值"><a href="#查询多个准确值" class="headerlink" title="查询多个准确值"></a>查询多个准确值</h2><p>terms过滤器是term过滤器的复数版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"terms"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"price"</span> : [20, 30]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="包含而不是相等"><a href="#包含而不是相等" class="headerlink" title="包含而不是相等"></a>包含而不是相等</h2><p>假如你有一个 term 过滤器  { “term” : { “tags” : “search” } }  ，它将匹配下面两个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>] &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>假如你真的需要完全匹配这种行为，最好是通过添加另一个字段来实现。在这个字段中，你索引原字段包含值的个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>], <span class="string">"tag_count"</span> : 1 &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="string">"tag_count"</span> : 2</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"filtered"</span>:&#123;</div><div class="line">      <span class="string">"filter"</span>:&#123;</div><div class="line">        <span class="string">"bool"</span>:&#123;</div><div class="line">          <span class="string">"must"</span>:[</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tags"</span>:<span class="string">"search"</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tag_count"</span>:1</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="范围过滤"><a href="#范围过滤" class="headerlink" title="范围过滤"></a>范围过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"price"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : 20,</div><div class="line"><span class="string">"lt"</span> : 40</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用于日期字段时,range过滤器支持日期数学操作。例如，我们想找到所有最近一个小时的文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"now-1h"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日期计算也能用于实际的日期，而不是仅仅是一个像 now 一样的占位符。只要在日期后加上双竖线  ||  ，就能使用日期数学表达式了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"2014-01-01 00:00:00"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"2014-01-01 00:00:00||+1M"</span> &lt;1&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>range  过滤器也可以用于字符串。字符串范围根据字典或字母顺序来计算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"title"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : <span class="string">"a"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"b"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字符串范围适用于一个基数较小的字段，一个唯一短语个数较少的字段。你的唯一短语数越多，搜索就越慢</p>
<h2 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h2><p>本质上来说null[]（空数组）和[null]是相等的。它们都不存在于倒排索引中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"exists"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"missing"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>它们的核心是一个字节集来表示哪些文档符合这个过滤器。Elasticsearch 主动缓存了这些字节集留作以后使用。一旦缓存后，当遇到相同的过滤时，这些字节集就可以被重用，而<br>不需要重新运算整个过滤。<br>缓存的字节集很“聪明”：他们会增量更新。你索引中添加了新的文档，只有这些新文档需要被添加到已存的字节集中，而不是一遍遍重新计算整个缓存的过滤器。过滤器和整个系统的其他部分一样是实时的，你不需要关心缓存的过期时间。<br>独立的过滤缓存<br>每个过滤器都被独立计算和缓存，而不管它们在哪里使用。如果两个不同的查询使用相同的过滤器，则会使用相同的字节集。同样，如果一个查询在多处使用同样的过滤器，只有一个字节集会被计算和重用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这两个过滤器相同，而且会使用同一个字节集</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: [</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;, &lt;1&gt;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"read"</span>: <span class="literal">false</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must_not"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125; &lt;1&gt;</div><div class="line">&#125;,</div><div class="line"><span class="string">"must"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"important"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤顺序"><a href="#过滤顺序" class="headerlink" title="过滤顺序"></a>过滤顺序</h2><p>在  bool  条件中过滤器的顺序对性能有很大的影响。更详细的过滤条件应该被放置在其他过滤器之前，以便在更早的排除更多的文档。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式增删改查&quot;&gt;&lt;a href=&quot;#分布式增删改查&quot; class=&quot;headerlink&quot; title=&quot;分布式增删改查&quot;&gt;&lt;/a&gt;分布式增删改查&lt;/h1&gt;&lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
</feed>
