<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-16T02:30:43.471Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 基础</title>
    <link href="http://yoursite.com/2019/01/12/python-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/01/12/python-基础/</id>
    <published>2019-01-12T08:47:37.000Z</published>
    <updated>2019-01-16T02:30:43.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h1><p>列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">元组:(1, 2, 3)</div><div class="line">列表:[1,2,3]</div></pre></td></tr></table></figure></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list(<span class="string">'Hello'</span>)</div><div class="line">[<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</div></pre></td></tr></table></figure>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = [1, 1, 1]</div><div class="line">x[1] = 2</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">del names[2]</div></pre></td></tr></table></figure>
<h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name = list(<span class="string">'Perl'</span>)</div><div class="line">name[1:] = list(<span class="string">'ython'</span>)</div><div class="line">name</div><div class="line">[<span class="string">'P'</span>, <span class="string">'y'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>]</div></pre></td></tr></table></figure>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">st.append(4)</div></pre></td></tr></table></figure>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">st.clear()</div></pre></td></tr></table></figure>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [[1, 2], 1, 1, [2, 1, [1, 2]]]</div><div class="line">&gt;&gt;&gt; x.count(1)</div><div class="line">2</div></pre></td></tr></table></figure>
<h3 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; b = [4, 5, 6]</div><div class="line">&gt;&gt;&gt; a.extend(b)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">[1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; knights = [<span class="string">'We'</span>, <span class="string">'are'</span>, <span class="string">'the'</span>, <span class="string">'knights'</span>, <span class="string">'who'</span>, <span class="string">'say'</span>, <span class="string">'ni'</span>]</div><div class="line">&gt;&gt;&gt; knights.index(<span class="string">'who'</span>)</div><div class="line">4</div></pre></td></tr></table></figure>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 6, 7]</div><div class="line">&gt;&gt;&gt; numbers.insert(3, <span class="string">'four'</span>)</div><div class="line">&gt;&gt;&gt; numbers</div><div class="line">[1, 2, 3, <span class="string">'four'</span>, 5, 6, 7]</div></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; x.pop()</div><div class="line">3</div></pre></td></tr></table></figure>
<p>python没有提供 push ，但可使用 append 来替代</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>方法 remove 用于删除第一个为指定值的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [<span class="string">'to'</span>, <span class="string">'be'</span>, <span class="string">'or'</span>, <span class="string">'not'</span>, <span class="string">'to'</span>, <span class="string">'be'</span>]</div><div class="line">&gt;&gt;&gt; x.remove(<span class="string">'be'</span>)</div><div class="line">&gt;&gt;&gt; x</div><div class="line">[<span class="string">'to'</span>, <span class="string">'or'</span>, <span class="string">'not'</span>, <span class="string">'to'</span>, <span class="string">'be'</span>]</div></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; x.reverse()</div><div class="line">&gt;&gt;&gt; x</div><div class="line">[3, 2, 1]</div></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [4, 6, 2, 1, 7, 9]</div><div class="line">&gt;&gt;&gt; y = x.copy()</div><div class="line">&gt;&gt;&gt; y.sort()</div><div class="line">&gt;&gt;&gt; x</div><div class="line">[4, 6, 2, 1, 7, 9]</div><div class="line">&gt;&gt;&gt; y</div><div class="line">[1, 2, 4, 6, 7, 9]</div></pre></td></tr></table></figure>
<h3 id="高级sort"><a href="#高级sort" class="headerlink" title="高级sort"></a>高级sort</h3><p>方法 sort 接受两个可选参数： key 和 reverse 。这两个参数通常是按名称指定的，称为关键字参数。参数 key 类似于参数 cmp ：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键， 再根据这些键对元素进行排序。 因此， 要根据长度对元素进行排序， 可将参数 key 设置为函数 len<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [<span class="string">'aardvark'</span>, <span class="string">'abalone'</span>, <span class="string">'acme'</span>, <span class="string">'add'</span>, <span class="string">'aerate'</span>]</div><div class="line">&gt;&gt;&gt; x.sort(key=len)</div><div class="line">&gt;&gt;&gt; x</div><div class="line">[<span class="string">'add'</span>, <span class="string">'acme'</span>, <span class="string">'aerate'</span>, <span class="string">'abalone'</span>, <span class="string">'aardvark'</span>]</div><div class="line">&gt;&gt;&gt; x = [4, 6, 2, 1, 7, 9]</div><div class="line">&gt;&gt;&gt; x.sort(reverse=True)</div><div class="line">&gt;&gt;&gt; x</div><div class="line">[9, 7, 6, 4, 2, 1]</div></pre></td></tr></table></figure></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>函数 tuple 的工作原理与 list 很像：它将一个序列作为参数，并将其转换为元组。如果参数已经是元组，就原封不动地返回它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tuple([1, 2, 3])</div><div class="line">(1, 2, 3)</div></pre></td></tr></table></figure></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="center"><a href="#center" class="headerlink" title="center"></a>center</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">"The Middle by Jimmy Eat World"</span>.center(39)</div><div class="line"><span class="string">' The Middle by Jimmy Eat World '</span></div></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>方法 find 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回 -1 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">'With a moo-moo here, and a moo-moo there'</span>.find(<span class="string">'moo'</span>)</div><div class="line">7</div></pre></td></tr></table></figure></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; seq = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</div><div class="line">&gt;&gt;&gt; sep = <span class="string">'+'</span></div><div class="line">&gt;&gt;&gt; sep.join(seq)</div></pre></td></tr></table></figure>
<h3 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">'Trondheim Hammer Dance'</span>.lower()</div><div class="line"><span class="string">'trondheim hammer dance'</span></div></pre></td></tr></table></figure>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">'This is a test'</span>.replace(<span class="string">'is'</span>, <span class="string">'eez'</span>)</div><div class="line"><span class="string">'Theez eez a test'</span></div></pre></td></tr></table></figure>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">'1+2+3+4+5'</span>.split(<span class="string">'+'</span>)</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</div></pre></td></tr></table></figure>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="string">' internal whitespace is kept '</span>.strip()</div><div class="line"><span class="string">'internal whitespace is kept'</span></div></pre></td></tr></table></figure>
<h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; table = str.maketrans(<span class="string">'cs'</span>, <span class="string">'kz'</span>, <span class="string">' '</span>)</div><div class="line">&gt;&gt;&gt; <span class="string">'this is an incredible test'</span>.translate(table)</div><div class="line"><span class="string">'thizizaninkredibletezt'</span></div></pre></td></tr></table></figure>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">phonebook = &#123;<span class="string">'Alice'</span>: <span class="string">'2341'</span>, <span class="string">'Beth'</span>: <span class="string">'9102'</span>, <span class="string">'Cecil'</span>: <span class="string">'3258'</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>函数dict从其他映射（如其他字典）或键值对序列创建字典<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; items = [(<span class="string">'name'</span>, <span class="string">'Gumby'</span>), (<span class="string">'age'</span>, 42)]</div><div class="line">&gt;&gt;&gt; d = dict(items)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">&#123;<span class="string">'age'</span>: 42, <span class="string">'name'</span>: <span class="string">'Gumby'</span>&#125;</div><div class="line">&gt;&gt;&gt; d = dict(name=<span class="string">'Gumby'</span>, age=42)</div></pre></td></tr></table></figure></p>
<h2 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h2><p>len(d) 返回字典 d 包含的项（键值对）数。<br>d[k] 返回与键 k 相关联的值。<br>d[k] = v 将值 v 关联到键 k 。<br>del d[k] 删除键为 k 的项。<br>k in d 检查字典 d 是否包含键为 k 的项。</p>
<h2 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h2><h3 id="clear-1"><a href="#clear-1" class="headerlink" title="clear"></a>clear</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&#125;</div><div class="line">&gt;&gt;&gt; d[<span class="string">'name'</span>] = <span class="string">'Gumby'</span></div><div class="line">d.clear()</div></pre></td></tr></table></figure>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = &#123;<span class="string">'username'</span>: <span class="string">'admin'</span>, <span class="string">'machines'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]&#125;</div><div class="line">&gt;&gt;&gt; y = x.copy()</div><div class="line">//深拷贝</div><div class="line">&gt;&gt;&gt; from copy import deepcopy</div><div class="line">&gt;&gt;&gt; d = &#123;&#125;</div><div class="line">&gt;&gt;&gt; d[<span class="string">'names'</span>] = [<span class="string">'Alfred'</span>, <span class="string">'Bertrand'</span>]</div><div class="line">&gt;&gt;&gt; dc = deepcopy(d)</div></pre></td></tr></table></figure>
<h3 id="fromkeys"><a href="#fromkeys" class="headerlink" title="fromkeys"></a>fromkeys</h3><p>方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是 None 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &#123;&#125;.fromkeys([<span class="string">'name'</span>, <span class="string">'age'</span>])</div><div class="line">&#123;<span class="string">'age'</span>: None, <span class="string">'name'</span>: None&#125;</div></pre></td></tr></table></figure></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="built_in">print</span>(d.get(<span class="string">'name'</span>))</div><div class="line">None</div></pre></td></tr></table></figure>
<h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><p>items<br>方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;<span class="string">'title'</span>: <span class="string">'Python Web Site'</span>, <span class="string">'url'</span>: <span class="string">'http://www.python.org'</span>, <span class="string">'spam'</span>: 0&#125;</div><div class="line">&gt;&gt;&gt; d.items()</div><div class="line">dict_items([(<span class="string">'url'</span>, <span class="string">'http://www.python.org'</span>), (<span class="string">'spam'</span>, 0), (<span class="string">'title'</span>, <span class="string">'Python Web Site'</span>)])</div></pre></td></tr></table></figure></p>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>方法 keys 返回一个字典视图，其中包含指定字典中的键。</p>
<h3 id="pop-1"><a href="#pop-1" class="headerlink" title="pop"></a>pop</h3><p>方法 pop 可用于获取与指定键相关联的值，并将该键值对从字典中删除。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;<span class="string">'x'</span>: 1, <span class="string">'y'</span>: 2&#125;</div><div class="line">&gt;&gt;&gt; d.pop(<span class="string">'x'</span>)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; d</div><div class="line">&#123;<span class="string">'y'</span>: 2&#125;</div></pre></td></tr></table></figure></p>
<h3 id="popitem"><a href="#popitem" class="headerlink" title="popitem"></a>popitem</h3><p>popitem 随机地弹出一个字典项</p>
<h3 id="setDefault"><a href="#setDefault" class="headerlink" title="setDefault"></a>setDefault</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&#125;</div><div class="line">&gt;&gt;&gt; d.setdefault(<span class="string">'name'</span>, <span class="string">'N/A'</span>)</div><div class="line"><span class="string">'N/A'</span></div></pre></td></tr></table></figure>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>方法 update 使用一个字典中的项来更新另一个字典。</p>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&#125;</div><div class="line">&gt;&gt;&gt; d[1] = 1</div><div class="line">&gt;&gt;&gt; d[2] = 2</div><div class="line">&gt;&gt;&gt; d[3] = 3</div><div class="line">&gt;&gt;&gt; d[4] = 1</div><div class="line">&gt;&gt;&gt; d.values()</div><div class="line">dict_values([1, 2, 3, 1])</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;列表和元组&quot;&gt;&lt;a href=&quot;#列表和元组&quot; class=&quot;headerlink&quot; title=&quot;列表和元组&quot;&gt;&lt;/a&gt;列表和元组&lt;/h1&gt;&lt;p&gt;列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python基础用法" scheme="http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>sql查询优化</title>
    <link href="http://yoursite.com/2018/02/23/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/02/23/sql查询优化/</id>
    <published>2018-02-23T03:08:16.000Z</published>
    <updated>2018-02-23T09:01:19.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取有性能问题sql的三种方法"><a href="#获取有性能问题sql的三种方法" class="headerlink" title="获取有性能问题sql的三种方法"></a>获取有性能问题sql的三种方法</h1><ul>
<li>通过用户反馈存在性能问题的sql</li>
<li>通过慢查日志获取存在性能问题的sql</li>
<li>实时获取存在问题的sql</li>
</ul>
<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><h2 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h2><p>slow_query_log 启动停止慢查询日志<br>slow_query_log_file 指定慢查询存储路径和文件<br>long_query_time 指定慢查询日志sql执行时间的阀值，默认为10秒<br>log_queries_not_using_indexes 是否记录未使用索引的sql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> global slow_query_log=on;</div></pre></td></tr></table></figure></p>
<h2 id="慢查询分析工具"><a href="#慢查询分析工具" class="headerlink" title="慢查询分析工具"></a>慢查询分析工具</h2><p>mysqldumpslow<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysqldumpslow <span class="_">-s</span> r -t 10 slow.log</div><div class="line"><span class="_">-s</span> order(c,t,l,r,at,al,ar) c总次数 t总时间 l锁时间 r总数据行，a开头表示平均</div><div class="line">-t top 去前几条作为输出</div></pre></td></tr></table></figure></p>
<p>pt-query-digest<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pt-query-digest --explain h=localhost xxx.log &gt;slow.rep</div></pre></td></tr></table></figure></p>
<h2 id="实时获取性能问题的sql"><a href="#实时获取性能问题的sql" class="headerlink" title="实时获取性能问题的sql"></a>实时获取性能问题的sql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT id ,user,host,DB,<span class="built_in">command</span>,time,state,info from information_schema.processlist <span class="built_in">where</span> time&gt;=60;</div></pre></td></tr></table></figure>
<h1 id="sql执行预处理及生成执行计划"><a href="#sql执行预处理及生成执行计划" class="headerlink" title="sql执行预处理及生成执行计划"></a>sql执行预处理及生成执行计划</h1><h2 id="查询步骤"><a href="#查询步骤" class="headerlink" title="查询步骤"></a>查询步骤</h2><p>客户端发送sql请求给服务器<br>服务器检查是否在查询缓存中命中该sql<br>服务端进行sql解析，预处理，再由优化器生成对应的执行计划<br>跟踪执行计划，调用存储引擎api查询数据<br>返回结果给客户端</p>
<h2 id="缓存影响"><a href="#缓存影响" class="headerlink" title="缓存影响"></a>缓存影响</h2><p>优先检查是否缓存命中，通过对一个大小写敏感的哈希查找，全值匹配。如果表更新，会对缓存刷新，就会导致缓存无法命中，而且会加锁，对于读写频繁不建议打开。<br>query_cache_type:缓存是否可用<br>query_cache_size:内存大小<br>query_cache_limit:最大值</p>
<h2 id="解析sql，预处理，优化sql执行计划"><a href="#解析sql，预处理，优化sql执行计划" class="headerlink" title="解析sql，预处理，优化sql执行计划"></a>解析sql，预处理，优化sql执行计划</h2><p>解析sql，预处理，优化sql执行计划，语法解析器解析是否关键字正确，关键字顺序正确，预处理根据规则进一步解析树是否合法，检查表和数据列准确，通过以后生成计划<br>造成mysql生成错误执行计划原因：<br>统计信息不准确<br>成本估算时间不等于实际时间<br>mysql认为的最优和你认为的最优不一样<br>mysql不考虑并发查询<br>有需要根据固定规则来生成执行计划<br>mysql不考虑不受其控制的成本</p>
<h2 id="优化器优化类型"><a href="#优化器优化类型" class="headerlink" title="优化器优化类型"></a>优化器优化类型</h2><p>重新定义表的关联顺序<br>将外连接转成内连接 外连接同时过滤<br>等价变换<br>count min max优化<br>子查询优化<br>提前终止查询<br>对in条件进行优化</p>
<h1 id="如何确定查询处理各个阶段所消耗的时间"><a href="#如何确定查询处理各个阶段所消耗的时间" class="headerlink" title="如何确定查询处理各个阶段所消耗的时间"></a>如何确定查询处理各个阶段所消耗的时间</h1><p>使用profile<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> profiling=1;</div><div class="line">show profiles;</div><div class="line">show profile <span class="keyword">for</span> query N(queryID);</div><div class="line">show profile cpu <span class="keyword">for</span> query N</div></pre></td></tr></table></figure></p>
<p>使用performance_schema</p>
<h1 id="特定的sql查询优化"><a href="#特定的sql查询优化" class="headerlink" title="特定的sql查询优化"></a>特定的sql查询优化</h1><ul>
<li>大表的数据修改最好要分批处理</li>
<li>如何修改大表的表结构，对表中列的字段类型进行修改，改变字段的宽度还会锁表，无法解决主从数据库延迟问题</li>
<li>建立一个新表，把老表数据导入新表，重新命名新表，删除老表(pt-online-schema-change)</li>
<li>如何优化not in和&lt;&gt;</li>
<li>使用汇总表优化查询，把慢查询统计的放在一个表中</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;获取有性能问题sql的三种方法&quot;&gt;&lt;a href=&quot;#获取有性能问题sql的三种方法&quot; class=&quot;headerlink&quot; title=&quot;获取有性能问题sql的三种方法&quot;&gt;&lt;/a&gt;获取有性能问题sql的三种方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;通过用户反馈存在性能问题
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://yoursite.com/2018/02/22/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/02/22/mysql索引/</id>
    <published>2018-02-22T12:23:22.000Z</published>
    <updated>2018-02-22T16:22:43.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="b-tree索引"><a href="#b-tree索引" class="headerlink" title="b-tree索引"></a>b-tree索引</h1><p>b-tree索引是通过B+树结构存储数据，Innodb叶子节点是指向主键，而myisam指向的是物理地址。<br>特点：能够加快数据的查询速度，更适合进行范围查找。</p>
<h2 id="使用b-tree索引"><a href="#使用b-tree索引" class="headerlink" title="使用b-tree索引"></a>使用b-tree索引</h2><ol>
<li>全值匹配的查询 where orderno=3</li>
<li>匹配最左前缀的查询 where no=… and one=…</li>
<li>匹配列前缀 like ‘123%’</li>
<li>范围值查询 &gt; … and &lt;…</li>
<li>精确 匹配左前列并范围匹配另外一列</li>
<li>至访问索引的查询</li>
</ol>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ol>
<li>如果不是按照索引最左列开始查找，则无法使用索引</li>
<li>使用索引时不能跳过索引中的列，例如A,B，C索引，查询A，C，C这列无法使用索引</li>
<li>not in 和&lt;&gt;无法使用索引</li>
<li>查询有某个列的范围查询，则其右边所有列都无法使用索引</li>
</ol>
<h1 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h1><p>哈希索引基于哈希表，只有查询条件精确匹配hash索引中的所有列时，才能够使用到hash索引。对于hash索引中的所有列，存储引擎都会为每一行计算一个hash码，hash索引存储的就是hash码。</p>
<h2 id="hash索引的限制"><a href="#hash索引的限制" class="headerlink" title="hash索引的限制"></a>hash索引的限制</h2><p>hash索引必须进行二次查找，无法用于排序，哈希索引不支持部分索引查找也不支持范围查找，哈希索引中的hash码的计算可能存在hash冲突。</p>
<h1 id="索引的好处"><a href="#索引的好处" class="headerlink" title="索引的好处"></a>索引的好处</h1><p>索引大大减少存储引擎需要扫描的数据量、索引可以帮助我们排序避免使用临时表、把随机IO转化为顺序IO</p>
<h1 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h1><ol>
<li>索引列不能使用表达式或者函数</li>
<li>前缀索引和索引列的选择性(create index index_name on table(col_name(n)))</li>
<li>联合索引<br>如何选取索引的顺序：经常会被使用到的列优先，选择性高的列优先，宽度比较小的列优先</li>
<li>覆盖索引（哈希索引不适合，查询太多列，双百分号like查询）<br>包含查询的全部值的索引，包括where、group by、order by，可以优化缓存，变少磁盘IO，可以减少随时IO，变为顺序IO，可以避免对Innodb主键索引的二次查询、可以避免myisam表进行系统调用</li>
</ol>
<h1 id="使用索引优化查询"><a href="#使用索引优化查询" class="headerlink" title="使用索引优化查询"></a>使用索引优化查询</h1><p>索引的列顺序和order by子句的顺序完全一致<br>索引中所有列的方向（升序、降序）和order by子句完全一致<br>order by中的字段全部在关联表中的第一张表中</p>
<h2 id="模拟哈希索引"><a href="#模拟哈希索引" class="headerlink" title="模拟哈希索引"></a>模拟哈希索引</h2><p>新增一列，使用触发器进行更新，使用哈希函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">analyze table table_name;//分析表</div><div class="line">optimize table table_name;//优化表</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;b-tree索引&quot;&gt;&lt;a href=&quot;#b-tree索引&quot; class=&quot;headerlink&quot; title=&quot;b-tree索引&quot;&gt;&lt;/a&gt;b-tree索引&lt;/h1&gt;&lt;p&gt;b-tree索引是通过B+树结构存储数据，Innodb叶子节点是指向主键，而myisam指向
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>sql优化大全</title>
    <link href="http://yoursite.com/2018/01/23/sql%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2018/01/23/sql优化大全/</id>
    <published>2018-01-23T13:30:26.000Z</published>
    <updated>2018-01-25T09:48:33.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h1><h2 id="通过show-status和应用特点了解各种SQL的执行频率"><a href="#通过show-status和应用特点了解各种SQL的执行频率" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率"></a>通过show status和应用特点了解各种SQL的执行频率</h2><p>通过show status可以提供服务器状态信息，可以根据需要显示session级别的统计结果和global级别的统计结果。如显示session级别：show status like ‘com%’;显示global级别：show global status;<br>以下几个参数对innodb和myisam存储引擎都计数</p>
<ol>
<li>Com_select执行select的次数，一次查询只累加1；</li>
<li>Com_insert执行insert的次数，对于批量插入的insert操作，只累加一次；</li>
<li>Com_update执行update的次数；</li>
<li>Com_delete执行delete的次数；</li>
</ol>
<p>以下几个参数是针对innodb引擎计数的，累计的算法也略有不同</p>
<ol>
<li>Innodb_rows_read: 查询返回的行数</li>
<li>Innodb_rows_inserted:操作insert插入的行数</li>
<li>Innodb_rows_updated:操作更新的行数</li>
<li>Innodb_rows_deleted:操作删除的行数</li>
</ol>
<p>通过以上几个参数可以了解到当前数据库应用是以插入更新为主还是查询为主，以及各种类型的sql大致执行比例是多少。对于更新操作的计数，是对执行的次数，不论提交还是回滚都会累加。<br>对于事务型应用，通过Com_commit和Com_rollback可以了解事务提交和回滚情况，对于回滚频繁的数据库，可能意味着应用编写存在问题。此外，以下几个参数可以让我们了解数据库基本情况：</p>
<ol>
<li>Connections 试图连接mysql服务器的次数</li>
<li>Uptime 服务器工作时间</li>
<li>Slow_queries 慢查询的次数</li>
</ol>
<h2 id="定位执行效率较低的sql语句"><a href="#定位执行效率较低的sql语句" class="headerlink" title="定位执行效率较低的sql语句"></a>定位执行效率较低的sql语句</h2><h3 id="通过慢查询日志定位那些执行效率比较低的sql语句"><a href="#通过慢查询日志定位那些执行效率比较低的sql语句" class="headerlink" title="通过慢查询日志定位那些执行效率比较低的sql语句"></a>通过慢查询日志定位那些执行效率比较低的sql语句</h3><p>用-log-slow-queries[=filename]选项启动时，mysqlId写一个包含所有执行时间超过long_query_time的sql语句的日志文件。<br>启用 slow log，有两种启用方式:</p>
<ol>
<li>在my.cnf 里 通过 log-slow-queries[=file_name]</li>
<li>在mysqld进程启动时,指定–log-slow-queries[=file_name]选项</li>
</ol>
<p>比较常用的五种分析工具，MySQLdumpslow、mysqlsla、mysqlprofi、mysql-explain-slow-log、mysqllogfilter.具体可以查看[<a href="https://wenku.baidu.com/view/2b1b230e01f69e3143329499.html" target="_blank" rel="external">https://wenku.baidu.com/view/2b1b230e01f69e3143329499.html</a>]</p>
<h3 id="使用show-processlist查看当前mysql线程"><a href="#使用show-processlist查看当前mysql线程" class="headerlink" title="使用show processlist查看当前mysql线程"></a>使用show processlist查看当前mysql线程</h3><p>命令慢查询日志在查询结束后才记录日志，所以在应用反应执行效率出现问题时，查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前mysql进行的线程，包括线程状态、是否锁表，可以实时查看sql执行情况，同时对一些缩表操作进行优化。</p>
<h2 id="通过explain分析低效sql的执行计划"><a href="#通过explain分析低效sql的执行计划" class="headerlink" title="通过explain分析低效sql的执行计划"></a>通过explain分析低效sql的执行计划</h2><p>通过上面查询到效率低的sql后，我们可以通过explain或者desc获取mysql如何执行select语句的信息，包括select语句执行过程表如何连接和连接的次序。<br>[<a href="https://www.cnblogs.com/xiaoboluo768/p/5400990.html" target="_blank" rel="external">https://www.cnblogs.com/xiaoboluo768/p/5400990.html</a>]</p>
<h1 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h1><h2 id="mysql如何使用索引"><a href="#mysql如何使用索引" class="headerlink" title="mysql如何使用索引"></a>mysql如何使用索引</h2><p>索引用于快速查找某个列具有特定值的行，对相关列使用索引是提高select操作性能的最佳途径。<br>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时(前缀索引)，才会使用索引，否则将不能使用索引。<br>下面情况，将不会使用索引</p>
<ol>
<li><p>如果mysql估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀地分布在1和100之间，下列查询中使用索引就不是很好：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM table_name <span class="built_in">where</span> key_part1 &gt; 1 and key_part1 &lt; 90</div></pre></td></tr></table></figure>
</li>
<li><p>如果使用heap表并且where条件中不用=索引列，其他 &gt; 、 &lt; 、 &gt;= 、 &lt;= 均不使 用索引（MyISAM和innodb表使用索引）；</p>
</li>
<li>使用or分割的条件，如果or前面的条件列有索引，后面的列中没有索引，那么涉及到的索引都不会使用。</li>
<li>如果创建复合索引，如果条件中使用的列不是索引列的第一部分（前缀索引）。</li>
<li>如果like是以%开始。</li>
<li>对where语句后面条件为字符串的一定要加引号，字符串如果是数字mysql会自动转为字符串，但是不使用索引。</li>
</ol>
<h2 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h2><p>如果索引正在工作，Handler_read_key的值将很高，这个值代表一个行被索引值读的次数，很低说明增加索引得到的性能改善不高，所以索引并不经常使用。<br>Handler_read_rnd_next的值高代表查询运行低效，并且应该建立索引补救，这个值含义是在数据文件中读下一行的请求数。如果你进行大量的表扫描，该值较高，通常说明索引不正确或写入查询没有利用索引。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show global status like <span class="string">'Handler_read%'</span>;</div></pre></td></tr></table></figure></p>
<h1 id="具体优化查询语句"><a href="#具体优化查询语句" class="headerlink" title="具体优化查询语句"></a>具体优化查询语句</h1><h2 id="避免全表查询"><a href="#避免全表查询" class="headerlink" title="避免全表查询"></a>避免全表查询</h2><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在where以及order by涉及的列建立索引。尝试下面的技巧以避免优化器错选了表扫描：</p>
<ul>
<li>使用analyze table tbl_name为扫描的表更新关键字。<br>[<a href="http://blog.csdn.net/alongken2005/article/details/6394016" target="_blank" rel="external">http://blog.csdn.net/alongken2005/article/details/6394016</a>]</li>
<li>对扫描的表使用FORCEINDEX告知MySQL，相对于使用给定的索引表扫描将非常耗时。SELECT * FROM t1, t2 FORCE INDEX (index_for_column) WHERE t1.col_name=t2.col_name；[<a href="http://blog.csdn.net/bruce128/article/details/46777567" target="_blank" rel="external">http://blog.csdn.net/bruce128/article/details/46777567</a>]</li>
<li>用–max-seeks-for-key=1000选项启动mysqld或使用SET max_seeks_for_key=1000告知优化器假设关键字扫描不会超过1,000次关键字搜索。</li>
</ul>
<h3 id="where中避免null值判断"><a href="#where中避免null值判断" class="headerlink" title="where中避免null值判断"></a>where中避免null值判断</h3><p>null值将导致引擎放弃索引而进行全表扫描，如select id from t where num is null<br>null对大多数数据库都需要特殊处理，mysql也一样，它需要更多的代码，更多的检查和特殊的索引逻辑，有些开发人员完全没有意识到，创建表时null是默认值，但大多数时候应该使用not null，或者使用一个特殊的值，如0，-1作为默认值。<br>不能用null作为索引，任何包含null值的列都不会被包含在索引中。即使索引中有一列含有null，该列就会从索引中排除。也就是说如果某列存在空值，即使对该列建索引也不会提高性能。任何在where子句中使用is null或者is not null的语句优化器是不允许使用索引。</p>
<h3 id="where中避免使用-或-lt-gt-操作符"><a href="#where中避免使用-或-lt-gt-操作符" class="headerlink" title="where中避免使用!=或&lt;&gt;操作符"></a>where中避免使用!=或&lt;&gt;操作符</h3><p>否则引擎放弃索引进行全表扫描<br>mysql只有对以下操作符才会使用索引:&lt; &lt;= = &gt; &gt;= between in 某些时候的like，可以在like操作中使用索引的情形是指另一个操作数以通配符(%或者_)开头的情形，如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT id FROM  t WHERE col LIKE <span class="string">'Mich%'</span>; <span class="comment">#这个查询将使用索引</span></div><div class="line">SELECT id FROM  t WHERE col  LIKE <span class="string">'%i'</span>; <span class="comment">#这个查询不会使用索引</span></div></pre></td></tr></table></figure></p>
<h3 id="where中避免or"><a href="#where中避免or" class="headerlink" title="where中避免or"></a>where中避免or</h3><p>否则引擎将会放弃索引进行全表扫描，如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT id from t <span class="built_in">where</span> num=10 or num=20;</div><div class="line">//一般or语句改为union</div><div class="line">SELECT id from t <span class="built_in">where</span> num=10 union all SELECT id from t <span class="built_in">where</span> num=20;</div></pre></td></tr></table></figure></p>
<p>在某些条件，or条件也是可以避免全表扫描</p>
<ol>
<li>where语句如果带有or条件，myisam表能用到索引，Innodb不能</li>
<li>必须所有的or条件都必须是独立索引</li>
</ol>
<h3 id="in和not-in会导致全表扫描"><a href="#in和not-in会导致全表扫描" class="headerlink" title="in和not in会导致全表扫描"></a>in和not in会导致全表扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT id from t <span class="built_in">where</span> num <span class="keyword">in</span> (1,2,3);</div></pre></td></tr></table></figure>
<p>对用户连续的值，能用between就别用in:select id from t where num between 1 and 3;</p>
<h3 id="下面的查询也将导致全表扫描"><a href="#下面的查询也将导致全表扫描" class="headerlink" title="下面的查询也将导致全表扫描"></a>下面的查询也将导致全表扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT id from t <span class="built_in">where</span> name like <span class="string">'%abc%'</span></div><div class="line">SELECT id from t <span class="built_in">where</span> name like <span class="string">'%abc'</span></div></pre></td></tr></table></figure>
<p>若要考虑效率可以用全文检索<br>而select id from t where name like ‘abc%’</p>
<h3 id="where使用参数，也会导致全表扫描"><a href="#where使用参数，也会导致全表扫描" class="headerlink" title="where使用参数，也会导致全表扫描"></a>where使用参数，也会导致全表扫描</h3><p>因为sql只有在运行时才会解析局部变量，而优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>select id from t where num=@num<br>可以改为强制查询使用索引：<br>select id from t with(index(索引名)) where num=@num</p>
<h3 id="避免字段进行表达式操作"><a href="#避免字段进行表达式操作" class="headerlink" title="避免字段进行表达式操作"></a>避免字段进行表达式操作</h3><p>如select id from t where num/2=100应改为select id from t where num=200</p>
<h3 id="where中避免对字段进行函数操作"><a href="#where中避免对字段进行函数操作" class="headerlink" title="where中避免对字段进行函数操作"></a>where中避免对字段进行函数操作</h3><p>select id from t where substring(name,1,3)=’abc’<br>select id from t where datediff(day,createdate,’2005-11-30’)=0<br>应改为<br>select id from t where name like ‘abc%’<br>select id from t where createdate&gt;=’2015-11-30’ and createdate &lt; ‘2015-12-01’</p>
<h3 id="where子句避免-左边进行函数、算数运算或其他表达式运算"><a href="#where子句避免-左边进行函数、算数运算或其他表达式运算" class="headerlink" title="where子句避免=左边进行函数、算数运算或其他表达式运算"></a>where子句避免=左边进行函数、算数运算或其他表达式运算</h3><p>否则系统将可能无法正确使用索引</p>
<h3 id="索引字段不是复合索引的前缀"><a href="#索引字段不是复合索引的前缀" class="headerlink" title="索引字段不是复合索引的前缀"></a>索引字段不是复合索引的前缀</h3><p>在使用索引作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，并且尽可能让字段顺序和索引顺序相一致</p>
<h2 id="其他一些注意的优化"><a href="#其他一些注意的优化" class="headerlink" title="其他一些注意的优化"></a>其他一些注意的优化</h2><h3 id="不要写一些没有意义的查询"><a href="#不要写一些没有意义的查询" class="headerlink" title="不要写一些没有意义的查询"></a>不要写一些没有意义的查询</h3><p>如需要生成一张空表：select col1,col2 into #t where 1=0<br>这类代码不会返回任何结果集，但是会消耗系统资源，应改成create table #t(…)</p>
<h3 id="很多时候下用exists代替in"><a href="#很多时候下用exists代替in" class="headerlink" title="很多时候下用exists代替in"></a>很多时候下用exists代替in</h3><p>外层查询表小于子查询表，则用exists，外层查询表大于子查询表，则用in，如果外层和子查询表差不多，则爱用哪个用哪个。<br>[<a href="https://segmentfault.com/a/1190000008709410" target="_blank" rel="external">https://segmentfault.com/a/1190000008709410</a>]<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num)</p>
<h3 id="并不是所有索引对查询都有效"><a href="#并不是所有索引对查询都有效" class="headerlink" title="并不是所有索引对查询都有效"></a>并不是所有索引对查询都有效</h3><p>sql是根据表中的数据进行查询优化，当索引列有大量数据重复时，sql查询可能不会去利用索引，如一张表中有字段，sex，male和female几乎各占一半，那么即使在sex上建立索引也对查询起不了什么作用。</p>
<h3 id="索引不是越多越好"><a href="#索引不是越多越好" class="headerlink" title="索引不是越多越好"></a>索引不是越多越好</h3><p>索引固然可以提高相应的select的效率，但同时也降低了insert和delete的效率，因为insert或update会导致索引的重建，所以怎么建索引需要慎重考虑，视情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建立索引是否有必要。</p>
<h3 id="避免更新聚簇索引数据列"><a href="#避免更新聚簇索引数据列" class="headerlink" title="避免更新聚簇索引数据列"></a>避免更新聚簇索引数据列</h3><p>因为聚簇索引的索引列的顺序就是表记录的物理存储位置，一旦该列值改变，将导致整个表记录的顺序调整，会耗费相当大的资源。若应用程序需要频繁更新聚簇索引的索引数据列，那么应该考虑是否将该索引建为聚簇索引。</p>
<h3 id="尽量使用数字型字段"><a href="#尽量使用数字型字段" class="headerlink" title="尽量使用数字型字段"></a>尽量使用数字型字段</h3><p>若只含数值信息的字段尽量不要设置为字符型，这会降低查询和连接的空间，并会增加开销。这是因为引擎在处理查询和连接时会逐个比较字符串的每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<h3 id="使用varchar或nvarchar代替char和nchar"><a href="#使用varchar或nvarchar代替char和nchar" class="headerlink" title="使用varchar或nvarchar代替char和nchar"></a>使用varchar或nvarchar代替char和nchar</h3><p>首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要更高些。</p>
<h3 id="避免-返回所有"><a href="#避免-返回所有" class="headerlink" title="避免*返回所有"></a>避免*返回所有</h3><p>用具体的字段代替*，不要返回用不到的字段</p>
<h2 id="临时表问题"><a href="#临时表问题" class="headerlink" title="临时表问题"></a>临时表问题</h2><h3 id="尽量表变量来代替临时表"><a href="#尽量表变量来代替临时表" class="headerlink" title="尽量表变量来代替临时表"></a>尽量表变量来代替临时表</h3><p>如果表变量包含大量数据，请注意索引有限</p>
<h3 id="避免频繁创建和删除临时表，以减少系统表的资源损耗"><a href="#避免频繁创建和删除临时表，以减少系统表的资源损耗" class="headerlink" title="避免频繁创建和删除临时表，以减少系统表的资源损耗"></a>避免频繁创建和删除临时表，以减少系统表的资源损耗</h3><h3 id="临时表并不是不可使用"><a href="#临时表并不是不可使用" class="headerlink" title="临时表并不是不可使用"></a>临时表并不是不可使用</h3><p>适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表</p>
<h3 id="避免造成大量log"><a href="#避免造成大量log" class="headerlink" title="避免造成大量log"></a>避免造成大量log</h3><p>如：在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度<br>如果数据量不大，为了缓和系统表的资源，应先create table，然后insert</p>
<h3 id="及时删除临时表"><a href="#及时删除临时表" class="headerlink" title="及时删除临时表"></a>及时删除临时表</h3><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<h2 id="游标的问题"><a href="#游标的问题" class="headerlink" title="游标的问题"></a>游标的问题</h2><h3 id="尽量避免游标"><a href="#尽量避免游标" class="headerlink" title="尽量避免游标"></a>尽量避免游标</h3><p>因为游标效率太差，游标操作数据超过一万行，就应该考虑改写</p>
<h3 id="使用基于游标的方法或临时表之前"><a href="#使用基于游标的方法或临时表之前" class="headerlink" title="使用基于游标的方法或临时表之前"></a>使用基于游标的方法或临时表之前</h3><p>应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<h3 id="游标并不是不可用"><a href="#游标并不是不可用" class="headerlink" title="游标并不是不可用"></a>游标并不是不可用</h3><p>对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<h3 id="存储过程和触发器"><a href="#存储过程和触发器" class="headerlink" title="存储过程和触发器"></a>存储过程和触发器</h3><p>在所有的存储过程和触发器开始处设置set nocount on，在结束时设置set nocount off。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<h2 id="事务的问题"><a href="#事务的问题" class="headerlink" title="事务的问题"></a>事务的问题</h2><p>尽量避免大事务操作，提高系统并发能力</p>
<h2 id="数据量的问题"><a href="#数据量的问题" class="headerlink" title="数据量的问题"></a>数据量的问题</h2><p>尽量避免向客户端返回大数据量。若数据量过大，应该考虑相应需求是否合理</p>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><h3 id="count-优于cout-1-和count-primary"><a href="#count-优于cout-1-和count-primary" class="headerlink" title="count(*)优于cout(1)和count(primary)"></a>count(*)优于cout(1)和count(primary)</h3><p>很多人为了统计记录条数，就使用count(1)和count(primary)，而不是使用count(*),这是一个误区。对于有些场景下，可能性能会更差。应为数据库对count(*)计数操作做了一些特别的优化</p>
<h3 id="count-column-和count-是不一样的"><a href="#count-column-和count-是不一样的" class="headerlink" title="count(column)和count(*)是不一样的"></a>count(column)和count(*)是不一样的</h3><p>count(column)是表示结果集中有多少个Column字段不为空的记录<br>count(*)是代表结果集有多少条记录</p>
<h3 id="优化order-by记录"><a href="#优化order-by记录" class="headerlink" title="优化order by记录"></a>优化order by记录</h3><p>mysql的弱点是它的排序，虽然mysql可以在1秒内查询大约15000条数据，但mysql在查询时最多只能使用一个索引。因此如果where条件已经占据了一个索引，那么排序将不使用索引，这将大大降低查询速度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM SALES WHERE NAME = <span class="string">'name'</span> ORDER BY SALE_DATE DESC;</div></pre></td></tr></table></figure></p>
<p>在以上的SQL的WHERE子句中已经使用了NAME字段上的索引，因此，在对SALE_DATE进行排序时将不再使用索引。为了解决这个问题，我们可以对SALES表建立复合索引:<br>ALTER TABLE SALES DROP INDEX NAME, ADD INDEX (NAME,SALE_DATE)<br>这样再使用上述的SELECT语句进行查询时速度就会大副提升。但要注意，在使用这个方法时，要确保WHERE子句中没有排序字段，在上例中就是不能用SALE_DATE进行查询，否则虽然排序快了，但是SALE_DATE字段上没有单独的索引，因此查询又会慢下来。<br>在某些情况中，mysql需要使用一个索引来满足order by子句，而不需要额外的排序。where语句和order by使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者降序。例如下面语句可以使用索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT from t order by key_part1,key_part2;</div><div class="line">SELECT from t key_part1=1 order by key_part1 desc,key_part2 desc;</div><div class="line">SELECT from t order by key_part1 desc,key_part2 desc;</div></pre></td></tr></table></figure></p>
<p>但是以下情况不使用索引：<br>SELECT FROM t1 ORDER BY key_part1 DESC, key_part2 ASC –order by 的字段混合 ASC 和 DESC<br>SELECT FROM t1 WHERE key2=constant ORDER BY key1– 用于查询行的关键字与 ORDER BY 中所使用的不相同<br>SELECT FROM t1 ORDER BY key1, key2 – 对不同的关键字使用 ORDER BY</p>
<h2 id="优化group-by"><a href="#优化group-by" class="headerlink" title="优化group by"></a>优化group by</h2><p>默认情况下，mysql排序所有group by col1,col2。查询方法如同查询指定order by col1,col2，如果显式包括一个包含相同列的order by，mysql可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括group by，但你想要避免排序结果的消耗，你可以指定order by null禁止排序。例如<br>INSERT INTO foo SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</p>
<h1 id="sql核心语句"><a href="#sql核心语句" class="headerlink" title="sql核心语句"></a>sql核心语句</h1><h2 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">INSERT mytable (first_column,second_column,third_column)  </div><div class="line">VALUES (<span class="string">'some data'</span>,<span class="string">'some more data'</span>,<span class="string">'yet more data'</span>) ,  </div><div class="line">VALUES (<span class="string">'some data'</span>,<span class="string">'some more data'</span>,<span class="string">'yet more data'</span>) ,  </div><div class="line">VALUES (<span class="string">'some data'</span>,<span class="string">'some more data'</span>,<span class="string">'yet more data'</span>);</div></pre></td></tr></table></figure>
<h2 id="清空数据库表"><a href="#清空数据库表" class="headerlink" title="清空数据库表"></a>清空数据库表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truncate table <span class="string">'mytable'</span></div></pre></td></tr></table></figure>
<p>删除表中的所有记录，应使用TRUNCATE TABLE语句。注意这里为什么要用TRUNCATE TABLE语句代替DELETE语句:当你使用TRUNCATE TABLE语句时，记录的删除是不作记录的。也就是说，这意味着TRUNCATE TABLE要比DELETE快得多。</p>
<h2 id="使用select创建记录和表"><a href="#使用select创建记录和表" class="headerlink" title="使用select创建记录和表"></a>使用select创建记录和表</h2><p>insert语句和delete语句和update语句有一点不同的是，它一次只操作一个记录，然而有一个方法可以使insert语句一次添加多个记录，要做到这需要insert和select语句结合在一起。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insert mytable(first_column,second_column)  SELECT another_first,another_second from anothertable <span class="built_in">where</span> another_first=<span class="string">'me'</span>;</div></pre></td></tr></table></figure></p>
<p>这个语句从anothertable拷贝记录到mytable.只有表anothertable中字段another_first的值为’me’的记录才被拷贝。<br>当为一个表中的记录建立备份时，这种形式的INSERT语句是非常有用的。在删除一个表中的记录之前，你可以先用这种方法把它们拷贝到另一个表中。<br>如果你需要拷贝整个表，你可以使用SELECT INTO语句。例如，下面的语句创建了一个名为newtable的新表，该表包含表mytable的所有数据:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * into newTable from mytable;</div></pre></td></tr></table></figure></p>
<p>你也可以指定只有特定的字段被用来创建这个新表。要做到这一点，只需在字段列表中指定你想要拷贝的字段。另外，你可以使用WHERE子句来限制拷贝到新表中的记录。下面的例子只拷贝字段second_columnd的值等于’me’的记录的first_column字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT first_column into newTable from mytable <span class="built_in">where</span> second_column=<span class="string">'me'</span>;</div></pre></td></tr></table></figure></p>
<p>使用SQL修改已经建立的表是很困难的。例如，如果你向一个表中添加了一个字段，没有容易的办法来去除它。另外，如果你不小心把一个字段的数据类型给错了，你将没有办法改变它。但是，使用本节中讲述的SQL语句，你可以绕过这两个问题。<br>例如，假设你想从一个表中删除一个字段。使用SELECT INTO语句，你可以创建该表的一个拷贝，但不包含要删除的字段。这使你既删除了该字段，又保留了不想删除的数据。<br>如果你想改变一个字段的数据类型，你可以创建一个包含正确数据类型字段的新表。创建好该表后，你就可以结合使用UPDATE语句和SELECT语句，把原来表中的所有数据拷贝到新表中。通过这种方法，你既可以修改表的结构，又能保存原有的数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化SQL步骤&quot;&gt;&lt;a href=&quot;#优化SQL步骤&quot; class=&quot;headerlink&quot; title=&quot;优化SQL步骤&quot;&gt;&lt;/a&gt;优化SQL步骤&lt;/h1&gt;&lt;h2 id=&quot;通过show-status和应用特点了解各种SQL的执行频率&quot;&gt;&lt;a href=&quot;#通过s
    
    </summary>
    
      <category term="sql优化" scheme="http://yoursite.com/categories/sql%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>feign和zuul</title>
    <link href="http://yoursite.com/2018/01/22/feign%E5%92%8Czuul/"/>
    <id>http://yoursite.com/2018/01/22/feign和zuul/</id>
    <published>2018-01-22T14:06:30.000Z</published>
    <updated>2018-02-12T01:53:16.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>我们在使用Ribbon时，通常会利用它来对RestTemplate的请求拦截来实现对依赖服务的接口调用。RestTemplate已经实现了对http请求的封装处理，形成一套模板化的调用方法。在实际开发中，对服务依赖的调用可能不止一处，往往一个接口会被多处调用，我们需要封装一些客户端类来包装这些依赖服务的调用。在Feign实现下，我们只需要创建一个接口并用注解配置它，即可完成对服务提供方的接口绑定。</p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">      //pom文件</div><div class="line">      &lt;!--feign--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">@EnableFeignClients</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">@FeignClient(<span class="string">"hello-service"</span>)</div><div class="line">public interface HelloService&#123;</div><div class="line">  @RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">  String hello();</div><div class="line">&#125;</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	HelloService helloService;</div><div class="line"></div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">     <span class="built_in">return</span> helloService.hello();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>[<a href="http://blog.didispace.com/spring-cloud-tips-feign-rpc/" target="_blank" rel="external">http://blog.didispace.com/spring-cloud-tips-feign-rpc/</a>]</p>
<h2 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>ribbon.key=value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ribbon.ConnectTimeout=500</div><div class="line">ribbon.readTimeout=5000</div></pre></td></tr></table></figure></p>
<h3 id="指定服务配置"><a href="#指定服务配置" class="headerlink" title="指定服务配置"></a>指定服务配置</h3><p><client>.ribbon.key=value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello-service.ribbon.ConnectTimeout=500</div><div class="line">hello-service.ribbon.readTimeout=5000</div></pre></td></tr></table></figure></client></p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><h3 id="全局配置-1"><a href="#全局配置-1" class="headerlink" title="全局配置"></a>全局配置</h3><p>跟ribbon全局配置一样，使用hystrix.command.default.xxx</p>
<h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3><p>通过feign.hystrix.enabled=false关闭</p>
<h2 id="服务降级配置"><a href="#服务降级配置" class="headerlink" title="服务降级配置"></a>服务降级配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@FeignClient(<span class="string">"hello-service"</span>,fallback=HelloServiceFallback.class)</div><div class="line">public interface HelloService&#123;</div><div class="line">  @RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">  String hello();</div><div class="line">&#125;</div><div class="line">@Component</div><div class="line">public HelloServiceFallback implements HelloService&#123;</div><div class="line">String <span class="function"><span class="title">hello</span></span>()&#123;</div><div class="line">retur <span class="string">"error"</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>大多数情况下，为了保证对外服务的安全性，我们在服务端实现的微服务接口，往往都会有一定的权限验证机制，比如用户登录状态的校验。同时为了防止客户端在发起请求时防止篡改等安全方面的考虑，还会有一些签名验证的机制存在。由于微服务，我们将一个应用拆成多个应用，但这些应用都需要这些校验逻辑，随着微服务规模扩大，校验逻辑冗余越来越多，不便于扩展和优化。<br>API网关是一个更为智能的应用服务器，它的定义有点像设计模式的Facade模式，它的存在就像整个微服务架构系统的门面一样，所有外部客户端访问都需要经过它来进行调度和过滤。它除了要实现请求路由、负载均衡、验证校验等功能，还需要跟服务治理框架、熔断机制的结合。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div><div class="line"></div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">spring.application.name=api-gateway</div><div class="line">server.port=5555</div><div class="line"></div><div class="line">zuul.routes.a.path=/a/**</div><div class="line">zuul.routes.a.url=ribbon-consumer</div><div class="line"></div><div class="line">zuul.routes.b.path=/b/**</div><div class="line">zuul.routes.b.url=feign-consumer</div><div class="line"></div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</div></pre></td></tr></table></figure>
<h2 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class AccessFilter extends ZuulFilter &#123;</div><div class="line"></div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(AccessFilter.class);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String <span class="function"><span class="title">filterType</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="string">"pre"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">filterOrder</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="function"><span class="title">shouldFilter</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        logger.info(<span class="string">"AccessFilter run"</span>);</div><div class="line"></div><div class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">        HttpServletRequest httpServletRequest = requestContext.getRequest();</div><div class="line"></div><div class="line">        logger.info(httpServletRequest.getRequestURI());</div><div class="line"></div><div class="line">        Object accessToken = httpServletRequest.getParameter(<span class="string">"accessToken"</span>);</div><div class="line">        <span class="keyword">if</span>(accessToken == null) &#123;</div><div class="line">            requestContext.setSendZuulResponse(<span class="literal">false</span>);</div><div class="line">            requestContext.setResponseStatusCode(401);</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        logger.info(<span class="string">"access token ok"</span>);</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public AccessFilter <span class="function"><span class="title">accessFilter</span></span>()&#123;</div><div class="line">       <span class="built_in">return</span> new AccessFilter();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>filterType：过滤器的类型，pre代表请求在被路由之前执行<br>filterOrder：过滤器的执行顺序，根据这个返回值来依次执行<br>shouldFilter：判断是否需要被过滤<br>run：过滤的具体逻辑，这里通过requestContext.setSendZuulResponse(false);来过滤请求，不对骑进行路由，通过requestContext.setResponseStatusCode(401);设置返回状态码，也可以通过requestContext.setResponseBody(body);来设置内容</p>
<h2 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h2><h3 id="传统路由配置"><a href="#传统路由配置" class="headerlink" title="传统路由配置"></a>传统路由配置</h3><ul>
<li>单实例配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.url=http://localhost:8080/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对符合/user-service/** 规则的请求路径，转发到<a href="http://localhost:8080/地址的路由规则上，比如，当有一个请求http://localhost:5555/user-service/hello,能够匹配，因而api网关会转发请求到http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/地址的路由规则上，比如，当有一个请求http://localhost:5555/user-service/hello,能够匹配，因而api网关会转发请求到http://localhost:8080/hello</a></p>
<ul>
<li>多实例配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div><div class="line">ribbon.eureka.enabled=<span class="literal">false</span></div><div class="line">user-service.ribbon.listOfServers=http://localhost:8080,http://localhost:8081</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h3><p>在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为serviceId指定具体的服务实例地址，只需要通过zuul.routes.<route>.path与zuul.routes.<route>.serviceId参数对进行配置就好。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div></pre></td></tr></table></figure></route></route></p>
<h2 id="服务路由的默认规则"><a href="#服务路由的默认规则" class="headerlink" title="服务路由的默认规则"></a>服务路由的默认规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.user-service.path=/user-service/**</div><div class="line">zuul.routes.user-service.serviceId=user-service</div></pre></td></tr></table></figure>
<p>对于这样具备规则性的配置内容，我们总是希望可以自动完成，在zuul构建的网关引入Eureka后，它会为每个服务自动创建一个默认路由规则，这些默认路由会使用serviceId配置的服务名作为请求前缀。<br>由于默认情况下，所有Eureka上的服务都会被Zuul自动创建映射关系进行路由，这会使得我们不希望对外开放的服务也可能被外部访问。这个时候，我们需要使用zuul.ignored-services参数来设置一个匹配表达式来定义不自动创建路由的规则。如果服务名匹配，将不为创建路由规则。</p>
<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>?是匹配任意单个字符，<em> 匹配任意数量字符，*</em> 匹配任意数量字符，支持多级目录。</p>
<h2 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h2><p>全局为路由规则增加前缀信息，提供zuul.prefix参数进行设置。</p>
<h2 id="本地跳转"><a href="#本地跳转" class="headerlink" title="本地跳转"></a>本地跳转</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zuul.routes.api-b.path=/api-b/**</div><div class="line">zuul.routes.api-b.url=forward:/<span class="built_in">local</span></div></pre></td></tr></table></figure>
<h2 id="Cookie与头信息"><a href="#Cookie与头信息" class="headerlink" title="Cookie与头信息"></a>Cookie与头信息</h2><p>zuul在请求路由时，或过滤掉http请求头信息的一些敏感信息。默认的敏感头信息通过zuul.sensitiveHeaders参数定义，包括set-cookie、cookie、Authorization三个属性。</p>
<ul>
<li><p>通过全局设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zuul.sensitiveHeaders=</div></pre></td></tr></table></figure>
</li>
<li><p>通过制定路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zuul.routes.&lt;router&gt;.customSensitiveHeaders=<span class="literal">true</span></div><div class="line">或</div><div class="line">zuul.routes.&lt;router&gt;.sensitiveHeaders=</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重定向问题，避免跳转暴露内部调用细节<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zuul.addHostHeader=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器详解"><a href="#过滤器详解" class="headerlink" title="过滤器详解"></a>过滤器详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public String filterType();</div><div class="line">public int filterOrder();</div><div class="line">public boolean shouldFilter();</div><div class="line">public Object run();</div></pre></td></tr></table></figure>
<p>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<br>pre：路由之前<br>routing：路由之时<br>post： 路由之后<br>error：发送错误调用<br>filterOrder：过滤的顺序，数值越小优先级越高<br>shouldFilter：这里可以写逻辑判断，是否要过滤，true,永远过滤。<br>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</p>
<h3 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h3><p>第一阶段是pre，会被pre过滤器进行处理，该过滤器主要是在请求路由之前做一些前置工作，比如请求校验。<br>第二阶段是routing，路由请求转发阶段，请求会被routing过滤器处理，当服务实例请求结果都返回之后，routing阶段结束。<br>第三阶段是post，此时请求会被post类型的过滤器处理，我们可以对处理结果进行加工或者转换。<br>还有个特殊的阶段error阶段，前面三个阶段发生异常时才会触发。</p>
<h2 id="核心过滤器"><a href="#核心过滤器" class="headerlink" title="核心过滤器"></a>核心过滤器</h2><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// pom</div><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div><div class="line"></div><div class="line">@EnableZuulProxy</div><div class="line">@SpringCloudApplication</div><div class="line">public class Application &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new SpringApplicationBuilder(Application.class).web(<span class="literal">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line">    @RefreshScope</div><div class="line">    @ConfigurationProperties(<span class="string">"zuul"</span>)</div><div class="line">    public ZuulProperties <span class="function"><span class="title">zuulProperties</span></span>()&#123;</div><div class="line">      <span class="built_in">return</span> new ZuulProperties();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">spring.application.name=api-gateway</div><div class="line">server.port=5555</div><div class="line">spring.cloud.config.uri=http://localhost:7001/</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</div></pre></td></tr></table></figure>
<p>在git仓库上增加网关配置文件,api-gateway.properties<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zuul.routes.a.path=/a/**</div><div class="line">zuul.routes.a.url=ribbon-consumer</div><div class="line">zuul.routes.b.path=/b/**</div><div class="line">zuul.routes.b.url=feign-consumer</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Feign&quot;&gt;&lt;a href=&quot;#Feign&quot; class=&quot;headerlink&quot; title=&quot;Feign&quot;&gt;&lt;/a&gt;Feign&lt;/h1&gt;&lt;p&gt;我们在使用Ribbon时，通常会利用它来对RestTemplate的请求拦截来实现对依赖服务的接口调用。RestTe
    
    </summary>
    
      <category term="spring cloud 微服务实战" scheme="http://yoursite.com/categories/spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="zuul" scheme="http://yoursite.com/tags/zuul/"/>
    
      <category term="feign" scheme="http://yoursite.com/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>服务容错保护-Hystrix</title>
    <link href="http://yoursite.com/2018/01/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4-Hystrix/"/>
    <id>http://yoursite.com/2018/01/22/服务容错保护-Hystrix/</id>
    <published>2018-01-22T03:11:14.000Z</published>
    <updated>2018-01-22T13:54:06.175Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务架构中，存在很多单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪。为了解决这个问题，产生了断路器等一系列的服务保护机制。<br>Hystrix实现了断路器、线程隔离等一系列服务保护功能。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并和请求监控<br>[<a href="http://blog.csdn.net/forezp/article/details/69934399" target="_blank" rel="external">http://blog.csdn.net/forezp/article/details/69934399</a>]</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//pom 文件</div><div class="line">      &lt;!--hystrix--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      &lt;!--hystrix-dashboard 监控--&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">//开启断路器</div><div class="line">@EnableCircuitBreaker</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	RestTemplate <span class="function"><span class="title">restTemplate</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//改造服务器消费规则，Hystrix默认的超时时间是2000毫秒</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	RestTemplate restTemplate;</div><div class="line"></div><div class="line">	@HystrixCommand(fallbackMethod=<span class="string">"helloFallback"</span>)</div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		String serviceString=<span class="string">"http://PROVIDER-SERVICE/hello"</span>;</div><div class="line">		<span class="built_in">return</span> restTemplate.getForEntity(serviceString,String.class).getBody();</div><div class="line">	&#125;</div><div class="line">  public String <span class="function"><span class="title">helloFallback</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"error"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/22/服务容错保护-Hystrix/hystrix1.png" alt=""></p>
<ol>
<li>创建HystrixCommand或HystrixObservableCommand对象<br>使用命令模式，HystrixCommand用在依赖的服务返回单个操作结果的时候，HystrixObservableCommand用在依赖的服务返回多个操作结果的时候。</li>
<li>命令执行<br>以上存在四种命令的执行方式，HystrixCommand实现两个执行方式，<br>execute:同步执行，从依赖的服务返回一个单一的结果对象或是在发生错误的时候抛出异常。<br>queue：异步执行，直接返回一个Future对象。其中包含一个服务执行结束时要返回的单一结果对象<br>HystrixObservableCommand<br>observer：是一个hot Observable<br>toObservable：cold Observable</li>
<li>结果是否被缓存<br>若当前命令的请求缓存功能被启用，并且该命令缓存命中，那么缓存结果立即以Observable对象的形式返回。</li>
<li>断路器是否打开<br>在命令结果没有缓存命中时，Hystrix需要检测断路器是否打开，如果打开调到第8步，如果没有打开，跳到第5步。</li>
<li>线程池或请求队列或信号量是否占满<br>如果已被占满，则不会执行命令，转向fallback。</li>
<li>HystrixObservable.construct()或HystrixObservable.run()<br>run返回单一结果，construct返回多个结果，如果执行时间超过命令设置的超时阈值，会抛出一个异常，Hystrix就会转向fallback处理逻辑。</li>
<li>计算断路器的健康度<br>Hystrix会将成功、失败、拒绝、超时等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会根据这些数据来决定是否要将断路器打开，来对某个依赖服务进行熔断/短路，直到恢复期结束。</li>
<li>fallback处理<br>当命令执行失败后，Hystrix会进入fallback尝试回退处理，我们也称为服务降级。<br>以下四种情况将触发getFallback调用：<br>(1):run()方法抛出非HystrixBadRequestException异常。<br>(2):run()方法调用超时<br>(3):熔断器开启拦截调用<br>(4):线程池/队列/信号量是否饱满</li>
<li>返回成功的响应</li>
</ol>
<h1 id="断路器原理"><a href="#断路器原理" class="headerlink" title="断路器原理"></a>断路器原理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface HystrixCircuitBreaker &#123;</div><div class="line">      //判断命令的请求是否被执行</div><div class="line">      boolean allowRequest();</div><div class="line">      //判断当前断路器是否被打开</div><div class="line">      boolean isOpen();</div><div class="line">      //用来闭合断路器</div><div class="line">      void markSuccess();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>断路器打开逻辑主要看请求总数、错误百分比，如果QPS大于20或者错误百分比大于50，则打开</p>
<h1 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h1><p>使用舱壁模式实现线程池的隔离，它会为每个依赖服务创建一个独立的线程池，这样就算某个服务延迟过高，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</p>
<h1 id="自定义请求命令"><a href="#自定义请求命令" class="headerlink" title="自定义请求命令"></a>自定义请求命令</h1><p>[<a href="http://blog.csdn.net/u012702547/article/details/78032191?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/u012702547/article/details/78032191?utm_source=tuicool&amp;utm_medium=referral</a>]</p>
<h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><h2 id="开启缓存功能"><a href="#开启缓存功能" class="headerlink" title="开启缓存功能"></a>开启缓存功能</h2><p>Spring Cloud Hystrix 请求缓存的使用非常简单，我们只需要在实现 HystrixCommand 或 HystrixObservableCommand 时，通过重载 getCacheKey()方法来开启请求缓存。</p>
<h2 id="缓存失效功能"><a href="#缓存失效功能" class="headerlink" title="缓存失效功能"></a>缓存失效功能</h2><p>在请求缓存时，如果只是读操作，那么不需要考虑缓存内容是否正确的问题，但是如果请求命令中还有更新数据的写操作，那么缓存中的数据就需要我们在进行写操作时及时处理，以防止读操作的请求命令获取到失效的数据，我们可以使用 HystrixRequestCache.clear 方法来进行缓存清理。<br>可以通过注解开启cache和清除缓存，例如@CacheResult,@CacheRemove</p>
<h1 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h1><p>通过HystrixCollasper来实现请求的合并，以减少通信消耗和线程数的占用。<br>[<a href="http://blog.csdn.net/zhuchuangang/article/details/74663755" target="_blank" rel="external">http://blog.csdn.net/zhuchuangang/article/details/74663755</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务架构中，存在很多单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪。为了解决这个问题，产生了断路器等一系列的服务保护机制。&lt;br&gt;Hystrix实现了断路器、线程隔离等一系列服务保护功能。Hystrix具备服务降级、服务熔断、线程和
    
    </summary>
    
      <category term="spring cloud 微服务实战" scheme="http://yoursite.com/categories/spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="spring cloud，Hystrix" scheme="http://yoursite.com/tags/spring-cloud%EF%BC%8CHystrix/"/>
    
  </entry>
  
  <entry>
    <title>客户端负载均衡:ribbon</title>
    <link href="http://yoursite.com/2018/01/21/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-ribbon/"/>
    <id>http://yoursite.com/2018/01/21/客户端负载均衡-ribbon/</id>
    <published>2018-01-21T10:07:05.000Z</published>
    <updated>2018-03-12T06:28:25.746Z</updated>
    
    <content type="html"><![CDATA[<p>例子参考：[<a href="http://blog.csdn.net/forezp/article/details/69934399" target="_blank" rel="external">http://blog.csdn.net/forezp/article/details/69934399</a>]</p>
<h1 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h1><p>负载均衡指的是服务端负载均衡，其中分为硬件负载均衡、软件负载均衡。硬件负载均衡是通过服务器节点之间安装专门用于负载均衡的设备，比如F5等；而软件负载均衡是通过在服务器上安装一些具有均衡负载的模块或软件来完成请求分发工作，比如Nginx。<br>硬件负载均衡设备或是软件负载均衡的软件模块都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求给负载均衡设备时，从维护可用的列表中取出一台服务器的地址，然后进行转发。<br>客户端负载均衡和服务端负载均衡最大不同是在于上面所提到的服务清单所存储的位置。在客户端负载均衡中，所有客户端节点都要维护着自己访问的服务端清单，而这些服务端清单来自于服务注册中心。<br>spring ribbon的封装，使得使用客户端负载均衡调用非常简单，只需两步：</p>
<ul>
<li>服务提供者只需要启动多个实例并注册在一个注册中心或多个相关联的注册中心。</li>
<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。</li>
</ul>
<h1 id="RestTemplate详解"><a href="#RestTemplate详解" class="headerlink" title="RestTemplate详解"></a>RestTemplate详解</h1><h1 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h1><p>getForEntity函数<br>该方法返回ResponseEntity，该对象是Spring对Http请求响应的封装，其中主要存储了HTTP的几个重要元素，比如说HTTP请求码的枚举对象HttpStatus（404，405，500等错误码），它的父类事HttpEntity中还存储着HTTP请求的头信息对象HttpHeaders以及泛型类型的请求体对象。<br>getForEntity有三种重载的方法：具体例子[<a href="https://www.jianshu.com/p/470a30f493cf" target="_blank" rel="external">https://www.jianshu.com/p/470a30f493cf</a>]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)</div><div class="line">getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</div><div class="line">getForEntity(URI url, Class&lt;T&gt; responseType)</div></pre></td></tr></table></figure></p>
<p>也可以通过getForObject</p>
<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>具体也通过postForEntity和postForObject，例子如上链接</p>
<h1 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">put(String url, Object request, Object... uriVariables)</div><div class="line">put(String url, Object request, Map&lt;String, ?&gt; uriVariables)</div><div class="line">put(URI url, Object request)</div></pre></td></tr></table></figure>
<h1 id="Delete请求"><a href="#Delete请求" class="headerlink" title="Delete请求"></a>Delete请求</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">delete(String url, Object... uriVariables)</div><div class="line">delete(String url, Map&lt;String, ?&gt; uriVariables)</div><div class="line">delete(URI url)</div></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>[<a href="http://blog.csdn.net/dyc87112/article/details/73739482" target="_blank" rel="external">http://blog.csdn.net/dyc87112/article/details/73739482</a>]</p>
<h1 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h1><p>当一个请求发送，通过拦截这个请求，随机或者算法到其中的一个服务上去处理<br>那么，这中间关键的一点就是：拦截<br>最精简的LB需求：</p>
<ul>
<li>设置添加和读取后端服务器的列表</li>
<li>能从中选择一个服务器去执行<br>代码实现思路就是：<br>读取后端服务，标记一个服务不可用，最主要是选择一个后端服务来提供服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//使用负载均衡加载服务</div><div class="line">public interface ILoadBalancer &#123;</div><div class="line">void addServers(List var1);向负载均衡器中维护的实例列表增加服务实例。</div><div class="line">Server chooseServer(Object var1);通过某种策略，从负载均衡器中挑选出一个具体的服务实例。</div><div class="line">void markServerDown(Server var1);用来通知和标识负载均衡器中某个具体实例已经停止服务，不然负载均衡器在下一次获取服务实例清单前都会认为服务实例均是正常服务的。</div><div class="line">List getServerList(boolean var1);//目的兼容2.1.3以前的。（之后本方法拆分下面两个）</div><div class="line">List getReachableServers();获取当前正常服务的实例列表。</div><div class="line">List getAllServers();获取所有已知的服务实例列表，包括正常服务和停止服务的实例。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h2><p>是ILoadBalancer的实现，定义了分组枚举类，分别为ALL、STATUS_UP、STATUS_NOT_UP<br><img src="/2018/01/21/客户端负载均衡-ribbon/AbstractLoadBalancer.png" alt=""></p>
<h2 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h2><h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p>服务实例清单在运行期的动态更新，还能过滤</p>
<h2 id="ZoneAwareLoadBalancer"><a href="#ZoneAwareLoadBalancer" class="headerlink" title="ZoneAwareLoadBalancer"></a>ZoneAwareLoadBalancer</h2><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><ul>
<li>RandomRule：随机选择一个server</li>
<li>RoundRobinRule：roundRobin方式轮询选择， 轮询index，选择index对应位置的server</li>
<li>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低</li>
<li>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</li>
<li>BestAvailable：选择一个最小的并发请求的server，逐个考察Server，如果Server被tripped了，则忽略</li>
<li>AvailabilityFilteringRule：过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值） | 使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</li>
<li>ZoneAvoidanceRule：复合判断server所在区域的性能和server的可用性选择server ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule</li>
</ul>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p><img src="/2018/01/21/客户端负载均衡-ribbon/自动化配置.png" alt=""></p>
<h1 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h1><p>由于Eureka实现的服务治理机制强调了CAP原理的AP，即可用性和可靠性，与zookeeper这类强调CP（一致性、可靠性）最大的区别是Eureka为了实现更高的服务可用性，牺牲了一定的一致性，在极端情况下，它宁愿接受故障实例，也不要丢掉健康实例，比如，当服务注册中心发生故障断开时，由于所有的服务实例无法维持续约心跳，在强调AP的服务治理中，将会把所有的服务实例剔除掉，而Eureka则会因为超过百分之85的实例丢失心跳而触发保护机制，注册中心将会保留此时的所有节点，以实现服务间依然可以进行相互调用的场景，即使其中有部分故障节点，但这样做仍然能够保障大多数服务能正常消费。<br>由于在可用性和一致性上的取舍，不论是由于触发了保护机制或是服务剔除的延迟，引起服务调用到失败的实例时候，我们希望还是能够增强对这类问题的容错。所以我们会在服务调用时候加入一些重试机制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spring.cloud.loadbalancer.retry.enabled=<span class="literal">true</span></div><div class="line">xxService.ribbon.ConnectTimeout //请求连接超时时间</div><div class="line">xxService.ribbon.ReadTimeout //请求处理超时时间</div><div class="line">xxxService.ribbon.maxAutoRetriesNextServer //切换实例重试次数</div><div class="line">xxxService.ribbon.maxAutoRetries //重试次数</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;例子参考：[&lt;a href=&quot;http://blog.csdn.net/forezp/article/details/69934399&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/forezp/article/d
    
    </summary>
    
      <category term="spring cloud 微服务实战" scheme="http://yoursite.com/categories/spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="spring cloud，ribbon" scheme="http://yoursite.com/tags/spring-cloud%EF%BC%8Cribbon/"/>
    
  </entry>
  
  <entry>
    <title>服务治理Eureka</title>
    <link href="http://yoursite.com/2018/01/17/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86Eureka/"/>
    <id>http://yoursite.com/2018/01/17/服务治理Eureka/</id>
    <published>2018-01-17T03:02:50.000Z</published>
    <updated>2018-01-22T01:48:51.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>通常会构建一个注册中心，每个服务单元向注册中心注册自己的服务，将主机与端口号、版本号、通信协议等一些信息按服务名分类组织服务清单。另外，服务注册中心还需要以心跳的方式监测清单中的服务是否可用，若不可用需要将服务清单剔除，达到排除故障的效果。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务间的调用不再指定具体实例地址来实现，而是通过服务名发起请求调用。</p>
<h1 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h1><p>Eureka用来实现服务注册和发现，既包含了服务端组件，也包含了客户端组件。Eureka服务端的服务治理机制提供了完备的Restful Api，所以也支持非java语言构建的微服务。<br>Eureka服务端，也称服务注册中心，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种故障场景。如果Eureka以集群模式部署，当集群分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障继续提供服务的发现和注册，当故障分片恢复时，集群中其他分片会把他们的状态再次同步回来。以AWS为例，每个可用区域运行一个Eureka服务端，通过他形成集群，不同区域的服务注册中心通过异步模式互相复制各自的状态<br>Eureka客户端主要处理服务的注册和发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka向注册中心注册自身提供的服务并周期性地发送心跳来更新他的服务租约。同时，它能从服务端查询当前的注册服务信息并把他缓存到本地并周期性的刷新服务状态。</p>
<h1 id="搭建服务注册中心"><a href="#搭建服务注册中心" class="headerlink" title="搭建服务注册中心"></a>搭建服务注册中心</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//pom 文件</div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.example&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;cloudserver&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;cloudserver&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div><div class="line">//application.properties配置</div><div class="line">server.port=11111</div><div class="line">eureka.instance.hostname=localhost</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div><div class="line">//java代码启动</div><div class="line">@EnableEurekaServer</div><div class="line">@SpringBootApplication</div><div class="line">public class CloudserverApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new SpringApplicationBuilder(CloudserverApplication.class).web(<span class="literal">true</span>).run(args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/eureka.png" alt=""></p>
<h1 id="注册服务提供者"><a href="#注册服务提供者" class="headerlink" title="注册服务提供者"></a>注册服务提供者</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">          &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line"></div><div class="line">	&lt;/dependencies&gt;</div><div class="line">&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8081</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka</div><div class="line">spring.application.name=provider-service</div><div class="line">//java代码</div><div class="line">@SpringBootApplication</div><div class="line">public class DemoApplication &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(DemoApplication.class, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//新建个web包，提供服务</div><div class="line">@RestController</div><div class="line">@EnableEurekaClient</div><div class="line">public class HelloController &#123;</div><div class="line">	@Value(<span class="string">"<span class="variable">$&#123;server.port&#125;</span>"</span>)</div><div class="line">	String port;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hi"</span>)</div><div class="line">	public String home(@RequestParam String name) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"hi "</span> + name + <span class="string">",i am from port:"</span> + port;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/01/17/服务治理Eureka/服务.png" alt=""></p>
<h1 id="高可用注册中心"><a href="#高可用注册中心" class="headerlink" title="高可用注册中心"></a>高可用注册中心</h1><p>在微服务架构中，我们需要充分考虑发生故障的情况，所以在生产环境中必须对各个组件进行高可用部署。Eureka的设计一开始就考虑了搞可用问题，在Eureka的设计中一开始就考虑了高可用问题，在Eureka的服务治理设计中，所有节点既是服务提供方，也是服务消费方，服务注册中心也不例外。例如我们需要让设置两个参数，让服务注册中心不注册自己。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>Eureka的高可用就是将自己作为服务向其他服务中心注册自己，这样形成一组互相注册的服务注册中心，达到高可用。现在构建一个双节点的服务注册集群<br>创建application-peer1-properties作为peer1的服务中心配置。并将serviceUrl指向peer2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11111</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer1</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer2:11112/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>创建application-peer2-properties作为peer2的服务中心配置。并将serviceUrl指向peer1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server.port=11112</div><div class="line">spring.application.name=eureka-server</div><div class="line">eureka.instance.hostname=master-peer2</div><div class="line">eureka.client.register-with-eureka=<span class="literal">false</span></div><div class="line">eureka.client.fetch-registry=<span class="literal">false</span></div><div class="line">eureka.client.serviceUrl.defaultZone=http://master-peer1:11111/eureka/</div><div class="line">server.enable-self-preservation=<span class="literal">false</span></div><div class="line">server.eviction-interval-time-in-ms=4000</div></pre></td></tr></table></figure></p>
<p>接着修改etc/hosts<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1	master-peer1</div><div class="line">127.0.0.1	master-peer2</div></pre></td></tr></table></figure></p>
<p>通过–spring.profiles.active=peer1、–spring.profiles.active=peer2分别启动peer1和peer2然后修改服务提供者客户端的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.port=8888</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=provider-service</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/17/服务治理Eureka/高可用2.png" alt=""><br><img src="/2018/01/17/服务治理Eureka/高可用.png" alt=""></p>
<h1 id="服务发现和消费"><a href="#服务发现和消费" class="headerlink" title="服务发现和消费"></a>服务发现和消费</h1><p>程序是注册在Eureka注册中心上，现在有服务注册中心和服务提供者，还需要服务消费者，它主要完成发现服务和以及消费服务的功能。服务发现的任务由Eureka的客户端完成，而服务消费由Ribbon完成。Ribbon是一个基于http和tcp的客户端均衡器，它可以在通过客户端配置的ribbonServerList服务器列表去轮询访问以达到负载均衡的作用。当Ribbon与Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成Eureka注册中心中获取服务列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">//pom文件</div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">		&lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</div><div class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line">//application.properties</div><div class="line">server.port=8082</div><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div><div class="line">spring.application.name=consumer-invoke</div><div class="line">//java启动类</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class ConsumerApplication &#123;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	RestTemplate <span class="function"><span class="title">restTemplate</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(ConsumerApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//访问服务</div><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	RestTemplate restTemplate;</div><div class="line"></div><div class="line">	@RequestMapping(value=<span class="string">"/ribbon-consumer"</span>,method= RequestMethod.GET)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		String serviceString=<span class="string">"http://PROVIDER-SERVICE/hello"</span>;</div><div class="line">		<span class="built_in">return</span> restTemplate.getForEntity(serviceString, String.class).getBody();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Eureka详解"><a href="#Eureka详解" class="headerlink" title="Eureka详解"></a>Eureka详解</h1><p>构建Eureka服务治理体系中的三个核心角色：服务注册中心、服务提供者、服务消费者。</p>
<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><ul>
<li>服务注册中心：Eureka提供的服务端，提供服务注册与发现的功能，也就是eureka-server</li>
<li>服务提供者：提供服务的应用，可以是springboot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现。</li>
<li>服务消费者：消费者需要从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。</li>
</ul>
<h1 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h1><p><img src="/2018/01/17/服务治理Eureka/eureka服务治理.png" alt=""></p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><h3 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务提供者在启动时候会通过发送REST请求的方式将自己注册到Eureka Server，同时带上了自身服务的一些元数据信息。Eureka server接收到这个REST请求后，将元数据信息存储在一个双层结构map中，第一层key是服务名，第二层key是具体服务的实例名，在ribbon负载均衡中，Eureka一个服务有多个实例，所以采用了双层map。<br>在服务注册时，需要确认一下eureka.client.register-with-eureka=true,是否正确，该值默认为true，若设置为false将不会注册。</p>
<h3 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h3><p>服务提供者分别注册到两个不同的服务注册中心上，他们的信息分别被两个服务注册中心所维护。由于服务注册中心之间相互注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群相连的其他注册中心。</p>
<h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><p>在注册完服务之后，服务提供者会维护一个心跳来持续告诉Eureka server：我还活着，以防止Eureka Server的剔除任务将该实例从服务列表中排除出去。我们称这个为服务续约。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//服务续约任务调用间隔时间</div><div class="line">eureka.instance.lease-renewal-interval-in-seconds=30</div><div class="line">//服务时效时间</div><div class="line">eureka.instance.lease-expiration-duration-in-seconds=90</div></pre></td></tr></table></figure></p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>当我们启动服务消费者，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。eureka server会维护一份只读的服务清单来返回客户端，同时该缓存清单会每隔30s更新一次。</p>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在ribbon会默认采用轮询的方式调用，从而实现客户端的负载均衡。<br>对于访问实例的选择，Eureka中有region和zone的概念，一个region中可以包含多个zone，每个服务客户端需要被注册一个Zone，所以每个客户端对应一个region和一个zone。</p>
<h3 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h3><p>在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。在客户端程序中，在服务实例进行正常的关闭操作，它会触发一个服务下线的REST请求给Eureka Server，告诉服务中心：我要下线了，服务端在接收请求之后，将该服务状态置为下线，并把该下线时间传播出去。</p>
<h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h3><p>服务器可能由于内存溢出、网络故障等原因使得服务不能正常工作。为了从服务列表中将这些无法提供服务的实例剔除，Eureka在启动时会创建一个定时任务，默认每隔一段时间（60s）将当前清单中超时（默认是90s）没有续约的服务剔除出去。</p>
<h3 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h3><p>自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况：<br>1、Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。<br>2、Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。<br>3、当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。<br>但在本地开发，会使得注册中心维护的服务实例不那么准确，下面关闭保护机制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.server.enable-self-preservation=<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>[<a href="https://www.jianshu.com/p/ef2591899597" target="_blank" rel="external">https://www.jianshu.com/p/ef2591899597</a>]</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在Eureka的服务治理体系中，主要分为客户端和服务器端两个不同的角色，服务端为服务注册中心，客户端为各个提供接口的微服务应用。Eureka客户端的配置如下：1.服务注册相关的配置信息。包括服务注册中心的地址、服务获取的间隔时间、可用区域。2.服务实例相关的配置信息。包括服务实例的名称、IP地址、端口号、健康检查路径。</p>
<h1 id="服务注册类配置"><a href="#服务注册类配置" class="headerlink" title="服务注册类配置"></a>服务注册类配置</h1><p>这些配置信息主要以eureka.client为前缀，以指定注册中心为例，主要通过eureka.client.serviceUrl参数实现，默认的值为defaultZone，value为<a href="http://127.0.0.1:8761/eureka/。当然也可以更改" target="_blank" rel="external">http://127.0.0.1:8761/eureka/。当然也可以更改</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/</div></pre></td></tr></table></figure></p>
<p>也可以是高可用注册中心集群，不同的值用逗号隔开<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.client.serviceUrl.defaultZone=http://localhost:11111/eureka/,</div></pre></td></tr></table></figure></p>
<p>为了服务注册中心的安全，可以加入安全认证，在配置serviceUrl时，需要在value值的url加入相应的安全验证信息。比如http://<uusername>:<password>@localhost:1111/eureka</password></uusername></p>
<h1 id="服务实例类配置"><a href="#服务实例类配置" class="headerlink" title="服务实例类配置"></a>服务实例类配置</h1><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据是Eureka客户端在向服务注册中心发送请求时，用来描述自身服务信息的对象，其中包含一些标准化的元数据，比如服务名称、实例名称、实例ip、实例端口等用于服务服务治理的相关信息。以及一些负载均衡策略，或是其他特殊用途的自定义元数据的信息。<br>在使用Eureka的时候，所有的配置信息都通过org.springframework.cloud.Netflix.eureka.EurekaInstanceConfigBean进行加载，但在真正进行注册，还是会包装成instanceInfo发送给服务端，其中使用ConcurrentHashMap来存储。可以通过eureka.instance.<properties>=<value>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.instance.metadataMap.zone=shanghai</div></pre></td></tr></table></figure></value></properties></p>
<h2 id="实例名配置"><a href="#实例名配置" class="headerlink" title="实例名配置"></a>实例名配置</h2><p>实例名即InstanceInfo中的instanceId参数，它是区分同一服务不同实例的唯一标识。在Netflix原生实现中，采用主机名作为默认值，导致同一主机无法启动多个相同的服务实例。现在的cloud Eureka配置，采用的规则是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$&#123;spring.cloud.client.hostname&#125;</span>:<span class="variable">$&#123;spring.application.name&#125;</span>:<span class="variable">$&#123;spring.application.instance_id&#125;</span>:<span class="variable">$&#123;server.port&#125;</span></div><div class="line">eureka.instance.instanceId=<span class="variable">$&#123;spring.application.name&#125;</span>+<span class="variable">$&#123;random.int&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="端点的配置"><a href="#端点的配置" class="headerlink" title="端点的配置"></a>端点的配置</h2><p>在instanceInfo中，我们可以看到URL的配置信息，比如homePageURL、StatusPageUrl、HealthCheckUrl，分别代表着主页、状态检查、健康检查，其中状态和健康由actuator模块提供的info和health端点。</p>
<h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>各个服务实例的健康检测并不是通过health端点来实现，而是依靠客户端的心跳，来保持服务实例的存活。默认的心跳实现方式可以有效检查客户端进程是否正常运作，却无法保证客户端能正常提供服务。spring cloud 配置 health端点</p>
<ul>
<li>在pom包引入spring-boot-starter-actuator依赖</li>
<li>在application.properties加入eureka.client.healthcheck.enabled=true<h1 id="跨平台的支持"><a href="#跨平台的支持" class="headerlink" title="跨平台的支持"></a>跨平台的支持</h1>Eureka的通信机制是通过http的rest接口实现，由于http的平台无关性，虽然server可以通过java实现，但微服务应用并不限于使用java开发。比如python、js也能支持。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务治理&quot;&gt;&lt;a href=&quot;#服务治理&quot; class=&quot;headerlink&quot; title=&quot;服务治理&quot;&gt;&lt;/a&gt;服务治理&lt;/h1&gt;&lt;h2 id=&quot;服务注册&quot;&gt;&lt;a href=&quot;#服务注册&quot; class=&quot;headerlink&quot; title=&quot;服务注册&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="spring cloud 微服务实战" scheme="http://yoursite.com/categories/spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="spring cloud，eureka" scheme="http://yoursite.com/tags/spring-cloud%EF%BC%8Ceureka/"/>
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="http://yoursite.com/2018/01/16/springboot/"/>
    <id>http://yoursite.com/2018/01/16/springboot/</id>
    <published>2018-01-16T07:25:25.000Z</published>
    <updated>2018-01-16T16:06:03.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p>springboot的宗旨并非是重写spring或是替代spring，而是希望通过设计大量的自动化配置等方式来简化spring原有样版化的配置，使得开发者可以快速构建应用。<br>除了解决配置问题外，springboot还可以通过一系列starter poms的定义，让我们整合各项功能时，不需要在maven的pom.xml维护那些错综复杂的依赖关系，而是通过类似模块化的starter模块定义来引用，使得依赖管理变得更为简单。<br>springboot除了可以很好的融入docker之外，其自身支持嵌入式的tomcat、jetty等容器。通过springboot构建的应用不需要安装tomcat，只需将springboot应用打成jar包，通过java-jar命令直接运行并启动一个标准化的web应用，这使得应用变得很轻量。<br>整个springboot生态系统都用到了groovy，完全可以通过gradle和groovy来开发springboot应用。</p>
<h1 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.software&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;demo&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;demo&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.7&lt;/java.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">    		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>打包的为jar包，parent配置指定spring-boot-starter-parent为1.5.9，该父项定义了springboot版本的基础依赖和一些默认配置内容，比如application.properties的位置等</p>
<ul>
<li>spring-boot-starter-web:全栈web开发模块，包含嵌入式tomcat、spring MVC</li>
<li>spring-boot-starter-test:通用测试模块，包含Junit、Hamcrest、Mockito</li>
<li>spring-boot-starterjdbc或者spring-boot-starter-data-jpa：访问数据库的能力</li>
</ul>
<p>在使用springboot构建应用时，各项功能模块的整合不再像传统spring应用开发一样，需要在pom文件里做大量依赖配置，而是通过starter POMs定义的依赖包，使得功能模块整合变得非常轻巧。</p>
<h1 id="实现Restful接口"><a href="#实现Restful接口" class="headerlink" title="实现Restful接口"></a>实现Restful接口</h1><p>在springboot中创建一个restful api的实现代码同spring mvc应用一样，只是不用做很多配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class HelloController &#123;</div><div class="line"></div><div class="line">	@RequestMapping(<span class="string">"/hello"</span>)</div><div class="line">	public String <span class="function"><span class="title">sayHello</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"say hello"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>springboot默认的配置文件位置是src/main/resources/application.properties,根据我们引入的不同starter模块，可以在这里定义容器端口号，数据库连接信息，日志级别等各种配置信息。比如添加server.port=8888，指定端口号是8888.springboot除了用传统的properties文件外，还支持现在广泛使用的yaml。<br>yaml配置格式不像properties配置那样以单纯的键值对形式来表示，而是以类似缩进形式表现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">environments:</div><div class="line">   dev:</div><div class="line">      url: http://dev.bar.com</div><div class="line">      name: Developer Setup</div><div class="line">   prod:</div><div class="line">      url: http://foo.bar.com</div><div class="line">      name: My cool app</div><div class="line">等价于properties</div><div class="line">environments.dev.url=http://dev.bar.com</div><div class="line">environments.dev.name=Developer Setup</div><div class="line">environments.prod.url=http://foo.bar.com</div><div class="line">environments.prod.name=My cool app</div></pre></td></tr></table></figure></p>
<h1 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h1><p>除了可以预定义各个starter模块预定义的配置属性，也可以在配置文件中定义一些我们需要定义的属性。比如在application.properties添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">book.name=java并发</div><div class="line">book.author=lr</div><div class="line">//通过@value加载自定义参数</div><div class="line">@Component</div><div class="line">public class Book&#123;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.name&#125;</span>"</span>)</div><div class="line">  private String name;</div><div class="line">  @Value(<span class="string">"<span class="variable">$&#123;book.author&#125;</span>"</span>)</div><div class="line">  private String author;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h1><p>我们希望有些参数被加载时不是一个固定的值，比如密钥，服务端口。可以使用${random}产生随机的int、long或者String字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//随机字符串</div><div class="line">blog.value=<span class="variable">$&#123;random.value1&#125;</span></div><div class="line">//随机int</div><div class="line">blog.number=<span class="variable">$&#123;random.int&#125;</span></div><div class="line">//随机long</div><div class="line">blog.bignumber=<span class="variable">$&#123;random.long&#125;</span></div><div class="line">//10以内的随机数</div><div class="line">blog.test1=<span class="variable">$&#123;random.int(10)&#125;</span></div><div class="line">//10~20的随机数</div><div class="line">blog.test2=<span class="variable">$&#123;random.int[10,20]&#125;</span></div></pre></td></tr></table></figure></p>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>可以在命令行指定应用的参数，比如设置应用端口java -jar xxx.jar –server.port=8888</p>
<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>通常同一套程序会被应用和安装在不同环境中，比如开发、测试、生产，其中每个环境的数据库地址、服务端口等配置都不同，如果在不同环境打包时都要频繁修改配置文件，那必然十分繁琐。<br>在springboot中，多环境配置的文件名需要满足application-{profile}.properties的格式，其中profile是你的环境标识，例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">application-dev.properties 开发环境</div><div class="line">application-test.properties 测试环境</div><div class="line">application-prod.properties 生产环境</div><div class="line">在application设置spring-profiles-active=dev，默认选择开发</div><div class="line">执行时 java -jar xx.jar --spring-profiles-active=<span class="built_in">test</span> 修改</div></pre></td></tr></table></figure></p>
<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p><img src="/2018/01/16/springboot/加载顺序.png" alt=""></p>
<h1 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h1><p>spring-boot-starter-actuator模块能够为springboot提供监控，spring cloud在实现各个微服务组件时，进一步为该模块做了不少扩展，比如为原生端增加了不少指标和度量信息。</p>
<h1 id="初识actuator"><a href="#初识actuator" class="headerlink" title="初识actuator"></a>初识actuator</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">/health</div><div class="line">&#123;<span class="string">"status"</span>:<span class="string">"UP"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="原生端"><a href="#原生端" class="headerlink" title="原生端"></a>原生端</h1><ul>
<li>应用配置类：获取应用程序的应用配置、环境变量、自动化配置报告</li>
<li>度量指标类：获取运行过程监控的度量指标，比如内存信息、线程池信息、http请求统计。</li>
<li>操作控制类：提供对应用关闭等操作类功能</li>
</ul>
<h2 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h2><ul>
<li>/autoconfig 获取应用自动化配置报告</li>
<li>/beans 获取应用上下文创建的所有bean</li>
<li>/configprops 获取配置的属性信息</li>
<li>/env 环境属性报告，包括环境变量、jvm命令行、应用配置</li>
<li>/mappings 所有spring mvc控制器映射关系</li>
<li>/info 自定义信息</li>
</ul>
<h2 id="指标度量类"><a href="#指标度量类" class="headerlink" title="指标度量类"></a>指标度量类</h2><ul>
<li>metrics 内存信息、线程、垃圾回收</li>
<li>health 各类健康指标</li>
<li>dump 暴露运行中的线程信息</li>
<li>trace 返回基本http跟踪信息</li>
</ul>
<h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/shutdown</div><div class="line">endpoints.shutdown.enabled=<span class="literal">true</span> //修改配置文件</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;框架简介&quot;&gt;&lt;a href=&quot;#框架简介&quot; class=&quot;headerlink&quot; title=&quot;框架简介&quot;&gt;&lt;/a&gt;框架简介&lt;/h1&gt;&lt;p&gt;springboot的宗旨并非是重写spring或是替代spring，而是希望通过设计大量的自动化配置等方式来简化sprin
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>线程池和Executor</title>
    <link href="http://yoursite.com/2018/01/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CExecutor/"/>
    <id>http://yoursite.com/2018/01/10/线程池和Executor/</id>
    <published>2018-01-10T01:53:55.000Z</published>
    <updated>2018-01-14T09:12:54.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h1><p>线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:</p>
<ul>
<li>降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>1）线程池判断核心线程池是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已满。如果工作队列没有满，则新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<br><img src="/2018/01/10/线程池和Executor/线程池流程.png" alt=""></p>
<p><img src="/2018/01/10/线程池和Executor/线程池执行.png" alt=""><br>ThreadPoolExecutor执行execute分下面四种情况：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则新建新的线程来执行任务，执行这一步需要全局锁。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务。执行这一步骤需要获取全局锁</li>
<li>如果创建新的线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>采用上述步骤的总体思路是，是为了在执行execute方法时，尽量避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前的运行线程数大于等于corePoolSize），几乎所有的execute方法都是执行步骤2，而步骤2不需要获取全局锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable <span class="built_in">command</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">command</span> == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    // 如果线程数小于基本线程数，则创建线程并执行当前任务</div><div class="line">    <span class="keyword">if</span>(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(<span class="built_in">command</span>)) &#123;</div><div class="line">        // 如线程数大于等于核心线程数或线程创建失败，则将当前任务放到工作队列中。</div><div class="line">        <span class="keyword">if</span>(runState == RUNNING &amp;&amp; workQueue.offer(<span class="built_in">command</span>)) &#123;</div><div class="line">            <span class="keyword">if</span>(runState != RUNNING || poolSize == 0)</div><div class="line">                ensureQueuedTaskHandled(<span class="built_in">command</span>);</div><div class="line">        &#125;</div><div class="line">        // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!addIfUnderMaximumPoolSize(<span class="built_in">command</span>))</div><div class="line">            // 抛出RejectedExecutionException异常</div><div class="line">            reject(<span class="built_in">command</span>); // is shutdown or saturated</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程worker，woker在执行完任务后，还会循环获取工作队列里的任务来执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            try &#123;</div><div class="line">                Runnable task = firstTask;</div><div class="line">                firstTask = null;</div><div class="line">                <span class="keyword">while</span>(task != null || (task =getTask()) != null) &#123;</div><div class="line">                    runTask(task);</div><div class="line">                    task = null;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                workerDone(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/执行任务.png" alt=""><br>线程池执行任务分两种情况：1.在execute方法中创建一个线程时，会让这个线程执行当前任务。2.这个线程执行完任务后，会反复从BlockingQueue获取任务来执行。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>
<ol>
<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，及时其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用prestartAllCoreThreads方法，线程池会提前创建并启动所有线程。</li>
<li>runnableTaskQueue（任务队列）:用于保存等待执行任务的阻塞队列。可选择以下几个阻塞队列：<br>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另外一个线程调用移除操作，否则操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，Executors.newCachedThreadPool使用了这个队列<br>PriorityBlockingQueue：一个具有优先队列的无限阻塞队列</li>
<li>maximumPoolSize（线程池最大数量）：线程允许创建的最大线程数，如果队列满了并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用无界的任务队列这个参数就没意义。</li>
<li><p>ThreadFactory：用来创建线程的工厂，可以通过线程工厂给每个创建的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速地给线程池里的线程设置有意义的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</div></pre></td></tr></table></figure>
</li>
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池满时，说明线程池处于饱和状态，那么必须采用一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理任务时抛异常。<br>AbortPolicy：直接抛出异常<br>CallerRunsPolicy：只用调用者所在线程来运行任务<br>DiscardOldestPolicy：丢弃队列里最后一个任务，来执行当前任务<br>DiscardPolicy：不处理，丢弃掉</p>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行时间都比较短，，可以调大时间，提高cpu的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的时间有Days、HOUSRS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS</li>
</ol>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute和submit方法。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>()&#123;</div><div class="line">  public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>submit方法用于提交需要返回值的任务，线程池会返回一个Future对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成。而使用get(long timeout,TimeUnit unit)则会阻塞当前线程一段时间后立即返回，这时候有可能任务还未执行完。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future=executor.submit(harReturnValuetask);</div><div class="line">try&#123;</div><div class="line">  Object s=future.get();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;finally&#123;</div><div class="line">  executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他的原理是遍历线程池中的工作线程，然后逐个调用线程的interupt方法来中断线程，所以无法中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow是先把线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。而shoutdown只是将线程池的状态设置为shutdown状态，然后中断所有没有正在执行任务的线程。<br>只要调用这两个关闭方法中的其中一个，isshutdown方法就会返回true，当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。<br>任务的性质：CPU密集任务、IO密集任务、混合型任务<br>任务的优先级：高、中、低<br>任务执行的时间：长、中、短<br>任务的依赖性：是否依赖其他系统资源，如数据库连接<br>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应该配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。对于混合型任务，如果可以拆分，将其拆分成CPU密集型任务和IO密集型任务，只要这两个任务执行时间相差不是很大，那么拆分后的吞吐量将高于串行的执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRunTime().availableProcessors()方法获取当前设备的cpu数量。<br>优先级不同可以使用PriorityBlockingQueue来处理，它可以让优先级高的任务先执行。<br>执行时间不同交给不同规模的线程池来处理或者可以使用优先级队列，让执行时间段的任务先执行。<br>依赖数据库连接池任务，因为线程提交SQl后需要等待数据库返回结果，等待的时间越长，cpu的空余时间越长，那么线程数应该设置越大，才能更好地利用cpu。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便出现问题时定位。监控线程池可使用如下属性<br>taskCount：线程需要执行的任务数量<br>completedTaskCount：线程池在运行过程时已完成的任务数量，小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量<br>getPoolSize：线程池的线程数量<br>getActiveCount：获取活动线程数<br>通过扩展线程池进行监控，可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间。这几个方法在线程池里是空方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void beforeExecute(Thread t, Runnable r)&#123; &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>java线程被一对一映射为本地操作系统线程。java线程启动时会创建一个本地操作系统线程；当该线程终止时，这个操作系统线程会被回收。操作系统会调度所有线程并将它们分配给可用的cpu。<br>在上层，java多线程程序通常把应用分解为若干个任务，然后使用用户级调度器(Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。简单的说，应用程序通过Executor框架控制上层的调度，下层的调度通过操作系统内核控制，下层的调度不受应用程序的控制。<br><img src="/2018/01/10/线程池和Executor/二级调度.png" alt=""></p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><h4 id="Executor框架的架构"><a href="#Executor框架的架构" class="headerlink" title="Executor框架的架构"></a>Executor框架的架构</h4><p>Executor框架主要由3大部分组成。</p>
<ul>
<li>任务，包括被执行任务需要实现的接口Runnable或Callable接口。</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口，包括ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>
<p>Executor是一个接口，它是Executor框架的基础，它将任务的提交和任务的执行分离开来。<br>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。比Timer更灵活，功能更强大。<br>Future接口和实现Future接口的实现类FutureTask，代表异步计算的结果。<br>Runnable和Callable的实现类，都可以被ThreadPoolExecutor和ScheduledThreadPoolExecutor执行<br><img src="/2018/01/10/线程池和Executor/class.png" alt=""><br><img src="/2018/01/10/线程池和Executor/#x.png" alt=""><br>主线程首先要创建实现Runnable或者Callable接口的任务对象，工具类Executors可以把一个Runnable对象封装成Callable对象(Executors.callable(Runnble task)或Executors.callable(Runnable task,Object result))。<br>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runable command)),或者可以把Ruunable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit(Callable task))。<br>如果执行ExecutorService.submit(…)，ExecutorService将返回一个Future对象，（目前jdk返回的是FutureTask对象），由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService运行。<br>最后，主线程可以调用FutureTask.get()方法等待任务执行完成，主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)取消任务的运行。</p>
<h4 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h4><p>主要成员有：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建三种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</p>
<h6 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h6><p>创建固定线程数的FixedThreadPool。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h6><p>创建单个线程的SingleThreadExecutor的API<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h6><p>创建一个会根据需要创建新线程的CachedThreadPool<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>通常使用Executors创建，可以创建两种类型的ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor.包含若干线程的ScheduledThreadPoolExecutor<br>SingleThreadScheduledExecutor.包含一个线程的ScheduledThreadPoolExecutor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果，当我们把Callable接口或Runnable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会返回一个FutureTask对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</div><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</div><div class="line">Future&lt;&gt; submit(Runnable task)</div></pre></td></tr></table></figure></p>
<p>目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。在将来的JDK实现中，返回的可能不一定是FutureTask。</p>
<h5 id="Runnable和Callable接口"><a href="#Runnable和Callable接口" class="headerlink" title="Runnable和Callable接口"></a>Runnable和Callable接口</h5><p>Runnable和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。区别是Runnable不会返回结果，而Callable可以返回结果。除了可以创建实现Callable接口的对象外，还可以使用工厂类Executors把一个Runnable接口包装成Callable接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Callable&lt;Object&gt; callable(Runnable task) // 假设返回对象Callable1</div><div class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) // 假设返回对象Callable2</div></pre></td></tr></table></figure></p>
<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。例如，如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p>可重用固定线程数的线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<br>当线程池的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多于的线程将被终止。这里设置为0，意味着多余的线程会被立即终止。<br><img src="/2018/01/10/线程池和Executor/execute.png" alt=""><br>说明：<br>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。<br>2）在线程池预热后，将任务加入LinkedBlockingQueue<br>3）线程执行完1任务后，会在循环中反复从LinkedBlockingQueue获取任务执行<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE)，使用无界队列作为工作队列将会对线程池带来如下影响<br>1）当线程池中的线程数达到corePoolSize，新任务将在无界队列中等待，因此线程池的线程数不会超过corePoolSize，<br>2）由于1，使用无界队列时maximumPoolSize将是无效参数。<br>3）由于1和2，keepAlive将是无效参数<br>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown或shutdownNow）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</p>
<h3 id="SingleThreadExecutor-1"><a href="#SingleThreadExecutor-1" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newSingleThreadExecutor</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">));&#125;</div></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize都设为1，其他参数与fixedThreadPool一样。SingleThreadExecutor使用无界队列LinkedBlickedQueue。<br><img src="/2018/01/10/线程池和Executor/single.png" alt=""></p>
<h3 id="CachedThreadPool-1"><a href="#CachedThreadPool-1" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newCachedThreadPool</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()</div><div class="line">);&#125;</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界，这里把keepalive的时间设置为60L，意味着CachedThreadPool的空余线程等待新任务的最长时间为60s，空余线程超过60s会被终止。<br>CachedThreadPool采用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPoolSize是无界的，这意味者如果主线程提交的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新线程，极端情况下，CachedThreadPool会因为创建过多线程而耗尽cpu和内存资源。<br><img src="/2018/01/10/线程池和Executor/cached_execute.png" alt=""><br>1）首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有空余的时间正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行的offer操作与poll操作配对成功，主线程把任务交给空余的线程执行，execute方法执行完成；否则执行步骤2<br>2）当初始maximumPool为空时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），这种情况下步骤1）将会失败，将会创建一个新线程来执行任务。<br>3）在步骤2新建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空余线程最多在SynchronousQueue中等待60秒，如果60秒内主线程提交了一个任务，这个空余线程将执行主线程提交的任务，否则这个空余线程将会终止。<br>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。</p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承来自ThreadPoolExecutor，它主要用来给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor与Timer类似，但功能更强大且更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义。<br><img src="/2018/01/10/线程池和Executor/scheduled任务传递.png" alt=""><br>ScheduledThreadPoolExecutor的执行分为两个部分：<br>1）当调用scheduleAtFixRate方法或者scheduleWithFixedDelay时，会向DelayQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask<br>2）线程池中的线程从DelayQueue获取ScheduleFutureTask，然后执行任务。<br><img src="/2018/01/10/线程池和Executor/schedule.png" alt=""><br>ScheduleThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了修改：使用DelayQueue作为任务队列；获取任务的方式不同；执行周期任务后，增加了额外处理。</p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduleThreadPoolExecutor会把待调度的任务（ScheduledFutureTask）放到一个DelayQueue里。<br>ScheduledFutureTask有三个参数：<br>long型成员变量time，标识这个任务被执行的时间；<br>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor的序号；<br>long型成员变量period，表示任务执行的周期；<br>DelayQueue封装了一个PriorityQueue，它会对ScheduledFutureTask按照time的大小进行排序，如果time一样，就比较SequenceNumber。<br><img src="/2018/01/10/线程池和Executor/schedule任务执行.png" alt=""><br>1）线程1从DelayQueue中获取已到期的ScheduledFutureTask(delayQueue.take())，到期任务指的是time小于等于当前时间。<br>2）线程1执行这个ScheduledFutureTask<br>3）线程1修改time为下次将要被执行时间<br>4）修改time后将ScheduledFutureTask放回到DelayQueue中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lockInterruptibly(); //1</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            E first = q.peek();</div><div class="line">            <span class="keyword">if</span>(first == null) &#123;</div><div class="line">                available.await();//2.1</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                long delay =  first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                <span class="keyword">if</span>(delay &gt; 0) &#123;</div><div class="line">                    long tl = available.awaitNanos(delay);//2.2</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    E x = q.poll();  //2.3.1</div><div class="line">                    assert x != null;</div><div class="line">                    <span class="keyword">if</span>(q.size() != 0)</div><div class="line">                        available.signalAll(); //2.3.2 wake up other takers</div><div class="line">                    <span class="built_in">return</span> x;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/scheduled_condition.png" alt=""><br>1)获取Lock<br>2）获取周期任务；<br>如果PriorityQueue为空，当前线程到Condition等待，否则执行下面2.2<br>如果如果Priority的头元素的时间比当前时间大，到condition等待time时间，否则执行2.3<br>3）释放锁<br>ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。<br>最后，让我们看看ScheduledThreadPoolExecutor中的线程执行任务的步骤4，把ScheduledFutureTask放入DelayQueue中的过程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();//1</div><div class="line">    try &#123;</div><div class="line">        E first = q.peek();</div><div class="line">        q.offer(e);//2.1</div><div class="line">        <span class="keyword">if</span>(first == null || e.compareTo(first) &lt; 0)</div><div class="line">            available.signalAll();//2.2</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/schedule-delay.png" alt=""><br>1)获取锁<br>2）添加任务；向PriorityQueue添加任务，如果添加的是头元素，则唤醒其他线程<br>3）释放锁</p>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现类FutureTask，代表异步计算的结果</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口还实现了Runnable接口。FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行时机，FutureTask可以处于下面三种状态。<br>1）未启动。FutureTask.run还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，在没有执行run方法之前，处于未启动状态。<br>2）已启动。run方法被执行过程，处于已启动状态<br>3）已完成。执行完正常结束，或被取消(FutureTask.cancel())，或执行run方法过程中抛出异常而异常结束。<br><img src="/2018/01/10/线程池和Executor/FutureTask状态.png" alt=""><br>但FutureTask处于未启动或已启动状态时，执行FutureTask.get()会导致线程阻塞，当FutureTask处于已完成状态，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<br>当FutureTask处于未启动状态时，FutureTask.cancel()将导致任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成)；当FutureTask处于已完成状态时，执行FutureTask.cancel()方法将返回false。<br><img src="/2018/01/10/线程池和Executor/cancel.png" alt=""></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<br>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final  ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = new ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</div><div class="line">	private static String executionTask(final String taskName)</div><div class="line">			throws ExecutionException, InterruptedException &#123;</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">			Future&lt;String&gt; future = taskCache.get(taskName);// 1.1,2.1</div><div class="line">			<span class="keyword">if</span>(future == null) &#123;</div><div class="line">				Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;</div><div class="line">					public String call() throws InterruptedException &#123;</div><div class="line">						<span class="built_in">return</span> taskName;</div><div class="line">					&#125;</div><div class="line">				&#125;; // 1.2创建任务</div><div class="line">				FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(task);</div><div class="line">				future = taskCache.putIfAbsent(taskName, futureTask);// 1.3</div><div class="line">				<span class="keyword">if</span>(future == null) &#123;</div><div class="line">					future = futureTask;</div><div class="line">					futureTask.run();// 1.4执行任务</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				<span class="built_in">return</span> future.get();// 1.5,2.2线程在此等待任务执行完成</div><div class="line">			&#125; catch (CancellationException e) &#123;</div><div class="line">				taskCache.remove(taskName, future);</div><div class="line">			&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/future.png" alt=""><br>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread 2将在2.2等待，直到Thread 1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现是基于AQS，concurrent包中很多阻塞类(ReentrantLock)都是基于阻塞类实现的.AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程。基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、FutureTask<br>每一个基于AQS实现的同步器都会包含两种类型的操作，如下。<br>至少一个acquire操作。这个操作阻塞调用线程，除非直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get/get（long timeout，TimeUnit unit）方法调用。<br>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run方法和cancel（…）方法。<br>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。<br>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br><img src="/2018/01/10/线程池和Executor/FutureTask设计.png" alt=""><br>Sync是一个内部私有类，它继承自AQS，创建FutureTask时会创建Sync，FutureTask的所有共有方法都委托给Sync。<br>FutureTask.get()会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法执行过程如下<br>1）首先会回调在子类Sync的tryAcquireShared方法来判断是否可以成功，acquire成功的条件为：state为执行成功状态或已取消状态，且runner不为null。<br>2）如果成功则在get方法中立即返回，失败了就在等待队列中去等待其他线程执行release操作。<br>3）当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel()）唤醒当前线程。当前线程再次执行tryAcquireShared将返回正值1，当前线程将离开等待队列并且唤醒他的后继线程。<br>4）最后返回计算结果或返回抛出异常。<br>FutureTask.run()执行过程如下：<br>FutureTask.run()的执行过程如下。<br>1）执行在构造函数中指定的任务（Callable.call()）。<br>2）以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。<br>3）AQS.releaseShared（int arg）首先会回调在子类Sync中实的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。<br>4）调用FutureTask.done()。<br>当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程<br><img src="/2018/01/10/线程池和Executor/级联唤醒.png" alt=""><br>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从<br>队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java中的线程池&quot;&gt;&lt;a href=&quot;#java中的线程池&quot; class=&quot;headerlink&quot; title=&quot;java中的线程池&quot;&gt;&lt;/a&gt;java中的线程池&lt;/h1&gt;&lt;p&gt;线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程6~8</title>
    <link href="http://yoursite.com/2018/01/05/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6-8/"/>
    <id>http://yoursite.com/2018/01/05/java并发编程6-8/</id>
    <published>2018-01-05T13:51:00.000Z</published>
    <updated>2018-01-11T09:28:02.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java并发容器和框架"><a href="#java并发容器和框架" class="headerlink" title="java并发容器和框架"></a>java并发容器和框架</h1><h2 id="ConcurrentHashMap实现原理与使用"><a href="#ConcurrentHashMap实现原理与使用" class="headerlink" title="ConcurrentHashMap实现原理与使用"></a>ConcurrentHashMap实现原理与使用</h2><h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p>
<h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">concurrencyLevel = MAX_SEGMENTS;</div><div class="line">int sshift = 0;</div><div class="line">int ssize = 1;</div><div class="line"><span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123;</div><div class="line">++sshift;</div><div class="line">ssize = ssize&lt;&lt;1;</div><div class="line">&#125;</div><div class="line">segmentShift = 32 - sshift;</div><div class="line">segmentMask = ssize - 1;</div><div class="line">this.segments = Segment.newArray(ssize);</div></pre></td></tr></table></figure>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16</p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。SegmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个Segment"><a href="#初始化每个Segment" class="headerlink" title="初始化每个Segment"></a>初始化每个Segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadFactor是每个Segment的负载因子。在构造方法里需要通过这两个参数来初始化数组中的每个Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">int c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">++c;</div><div class="line">int <span class="built_in">cap</span> = 1;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cap</span> &lt; c)</div><div class="line"><span class="built_in">cap</span> &lt;&lt;= 1;</div><div class="line"><span class="keyword">for</span> (int i = 0; i &lt; this.segments.length; ++i)</div><div class="line">this.segments[i] = new Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</div></pre></td></tr></table></figure></p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取数据的时候，必须先通过散列算法定位到Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static int <span class="built_in">hash</span>(int h) &#123;</div><div class="line">h += (h &lt;&lt; 15) ^ 0xffffcd7d;</div><div class="line">h ^= (h &gt;&gt;&gt; 10);</div><div class="line">h += (h &lt;&lt; 3);</div><div class="line">h ^= (h &gt;&gt;&gt; 6);</div><div class="line">h += (h &lt;&lt; 2) + (h &lt;&lt; 14);</div><div class="line"><span class="built_in">return</span> h ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以进行再散列，目的是减少哈希冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存储效率。通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Segment&lt;K,V&gt; segmentFor(int <span class="built_in">hash</span>) &#123;</div><div class="line"><span class="built_in">return</span> segments[(<span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int <span class="built_in">hash</span> = <span class="built_in">hash</span>(key.hashCode());</div><div class="line"><span class="built_in">return</span> segmentFor(<span class="built_in">hash</span>).get(key, <span class="built_in">hash</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get的高效就在于整个get过程中不用加锁，除非读到的值是空的才会加锁重读，ConcurrentHashMap在它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值。但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">transient volatile int count;</div><div class="line">volatile V value;</div></pre></td></tr></table></figure></p>
<p>定位HashEntry和定位Segment的算法虽然一样，都与数组长度减1，定位Segment使用的是元素Hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是hashcode的值，其目的是避免两次散列的值一样。虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的<span class="built_in">hash</span>算法</div><div class="line">int index = <span class="built_in">hash</span> &amp; (tab.length - 1);　　// 定位HashEntry所使用的<span class="built_in">hash</span>算法</div></pre></td></tr></table></figure></p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法需要对共享变量进行写操作，为了线程安全，操作共享变量时必须加锁。put首先定位到Segment，然后在Segment里进行插入操作，插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二部定位添加元素的位置，然后将其放入HashEntry数组中。<br>（1）是否扩容<br>在插入元素前会先判断Segment的HashEntry数组是否超过容量（threadhold），如果超过阈值，则对数组进行扩容。Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量的，如果到达就进行扩容，但是很可能扩容之后没有新元素插入，这时HashMap进行了一次无效的扩容。<br>（2）如何扩容<br>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组中，为了高效，ConcurrentHashMap不会对整个容器扩容，而只对某个Segment进行扩容。</p>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>在并发过程中有时候需要线程安全的队列，如果要实现一个线程安全队列有两种方式：一种是阻塞算法，另一种是非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队使用同一把锁）或者两个锁等方式实现。非阻塞算法可以使用循环CAS方式来实现。<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到尾部，当我们获取一个元素时，它会返回队列头部的元素，。它采用CAS算法实现。<br><img src="/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png" alt=""><br>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient volatile Node&lt;E&gt; tail = head;</div></pre></td></tr></table></figure></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><ol>
<li>入队列的过程</li>
</ol>
<p>入队列就是将入队节点添加到队列尾部。<br><img src="/2018/01/05/java并发编程6-8/添加元素.png" alt=""><br>入队主要做两件事：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null) throw new NullPointerException();</div><div class="line">// 入队前，创建一个入队节点</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line">retry:</div><div class="line">// 死循环，入队不成功反复入队。</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">// 创建一个指向tail节点的引用</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line">// p用来表示队列的尾节点，默认情况下等于tail节点。</div><div class="line">Node&lt;E&gt; p = t;</div><div class="line"><span class="keyword">for</span> (int hops = 0; ; hops++) &#123;</div><div class="line">// 获得p节点的下一个节点。</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</div><div class="line"><span class="keyword">if</span> (next != null) &#123;</div><div class="line">// 循环了两次及其以上，并且当前节点还是不等于尾节点</div><div class="line"><span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</div><div class="line"><span class="built_in">continue</span> retry;</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line">// 如果p是尾节点，则设置p节点的next节点为入队节点。</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(null, n)) &#123;</div><div class="line">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</div><div class="line">更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</div><div class="line">casTail(t, n); // 更新tail节点，允许失败</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">p = succ(p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<ol>
<li>定位尾节点</li>
</ol>
<p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123;</div><div class="line">Node&lt;E&gt; next = p.getNext();</div><div class="line"><span class="built_in">return</span> (p == next) head : next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>设置入队节点为尾节点</li>
</ol>
<p>p.casNext(null,n)方法用于将入队节点设置为当前队列尾节点的next节点，如果当前尾节点的next节点是null时，则代表当前节点为尾节点，如果不为null时，则需要重新获取当前队列的尾节点</p>
<ol>
<li>Hops的设计意图</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null)</div><div class="line">throw new NullPointerException();</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line"><span class="keyword">if</span> (t.casNext(null, n) &amp;&amp; casTail(t, n)) &#123;</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让tail节点永远作为尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列是从队列返回一个节点元素，并清空该节点对该元素的引用。并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。<br><img src="/2018/01/05/java并发编程6-8/出队.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public E <span class="function"><span class="title">poll</span></span>() &#123;</div><div class="line">Node&lt;E&gt; h = head;</div><div class="line">// p表示头节点，需要出队的节点</div><div class="line">Node&lt;E&gt; p = h;</div><div class="line"><span class="keyword">for</span> (int hops = 0;; hops++) &#123;</div><div class="line">// 获取p节点的元素</div><div class="line">E item = p.getItem();</div><div class="line">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</div><div class="line">// 如果成功则返回p节点的元素。</div><div class="line"><span class="keyword">if</span> (item != null &amp;&amp; p.casItem(item, null)) &#123;</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS) &#123;</div><div class="line">// 将p节点下一个节点设置成head节点</div><div class="line">Node&lt;E&gt; q = p.getNext();</div><div class="line">updateHead(h, (q != null) q : p);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> item;</div><div class="line">&#125;</div><div class="line">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</div><div class="line">// 一个线程修改了。那么获取p节点的下一个节点</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// 如果p的下一个节点也为空，说明这个队列已经空了</div><div class="line"><span class="keyword">if</span> (next == null) &#123;</div><div class="line">// 更新头节点。</div><div class="line">updateHead(h, p);</div><div class="line"><span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先获取头节点元素，然后判断头结点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点元素取走，如果不为空，则使用CAS方式将头结点引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列是支持两个附加操作的队列。附加操作指的是支持阻塞的插入和移除。<br>1）支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者消费者场景。生产者是向队列里添加的线程，消费者是从队列里取元素的线程。阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常:当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
<h3 id="java的阻塞队列"><a href="#java的阻塞队列" class="headerlink" title="java的阻塞队列"></a>java的阻塞队列</h3><p>jdk7提供了7个阻塞队列<br>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列<br>DelayBlockingQueue：一个使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：一个不存储元素的阻塞队列<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是用一个数组实现有界的阻塞队列，此队列按照先进先出原则对元素进行排序。默认情况下不保证线程公平访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue fairQueue=new ArrayBlockingQueue(100,<span class="literal">true</span>);</div><div class="line">//公平性是使用可重入锁</div><div class="line">public ArrayBlockingQueue(int capacity,boolean fair)&#123;</div><div class="line">  <span class="keyword">if</span>(capacity&lt;0)&#123;</div><div class="line">    throw  new IllegalArgumentException();</div><div class="line">  &#125;</div><div class="line">  this.items=new Object[capacity];</div><div class="line">  lock=new ReentrantLock(fair);</div><div class="line">  notEmpty=lock.newCondition();</div><div class="line">  notFull=lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，此队列默认最大长度为Integer.MAX_VALUE，此队列按照先进先出的原则。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue来实现。队列中的元素必须实现Delay接口，在创建元素时，可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列提取元素。<br>DelayQueue使用场景：1.缓存系统的设计；可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素，说明缓存有效期到了；2.定时任务调度，使用DelayQueue保存当天会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的<br>如何实现DelayQueue,参考ScheduledThreadPoolExecutor里ScheduledFutureTask：<br>1）在对象创建时候，初始化基本数据，使用time记录当前记录延迟到什么时候可以使用，使用SequenceNumber来标识元素在队列中的先后顺序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static final AtomicLong sequencer = new AtomicLong(0);</div><div class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</div><div class="line">super(r, result);</div><div class="line">this.time = ns;</div><div class="line">this.period = period;</div><div class="line">this.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）实现delay方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public long getDelay(TimeUnit unit) &#123;</div><div class="line">    <span class="built_in">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>3)实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int compareTo(Delayed other) &#123;</div><div class="line">     <span class="keyword">if</span> (other == this) // compare zero ONLY <span class="keyword">if</span> same object</div><div class="line">         <span class="built_in">return</span> 0;</div><div class="line">     <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</div><div class="line">         ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</div><div class="line">         long diff = time - x.time;</div><div class="line">         <span class="keyword">if</span> (diff &lt; 0)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; 0)</div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">     &#125;</div><div class="line">     long d = (getDelay(TimeUnit.NANOSECONDS) -</div><div class="line">               other.getDelay(TimeUnit.NANOSECONDS));</div><div class="line">     <span class="built_in">return</span> (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如何实现延时阻塞队列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                   <span class="keyword">if</span> (delay &lt;= 0)</div><div class="line">                       <span class="built_in">return</span> q.poll();</div><div class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != null)</div><div class="line">                       available.await();</div><div class="line">                   <span class="keyword">else</span> &#123;</div><div class="line">                       Thread thisThread = Thread.currentThread();</div><div class="line">                       leader = thisThread;</div><div class="line">                       try &#123;</div><div class="line">                           available.awaitNanos(delay);</div><div class="line">                       &#125; finally &#123;</div><div class="line">                           <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                               leader = null;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div></pre></td></tr></table></figure></p>
<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能添加。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。<br>SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
<h4 id="LinkedTransformQueue"><a href="#LinkedTransformQueue" class="headerlink" title="LinkedTransformQueue"></a>LinkedTransformQueue</h4><p>LinkedTransformQueue是一个由链表结构组成的无界阻塞TransformQueue队列。，相比较其他阻塞队列，增加了tryTransform和transform方法如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node pred = tryAppend(s, haveData);</div><div class="line"><span class="built_in">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</div></pre></td></tr></table></figure></p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用通知模式实现，所谓的通知模式，就是生产者往满的队列添加元素时会阻塞住生产者，当消费者消费一个队列后，会通知生产者当前队列可用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private final Condition notFull;</div><div class="line">private final Condition notEmpty;</div><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">// 省略其他代码</div><div class="line">notEmpty = lock.newCondition();</div><div class="line">notFull = lock.newCondition();</div><div class="line">&#125;</div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">checkNotNull(e);</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == items.length)</div><div class="line">notFull.await();</div><div class="line">insert(e);</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == 0)</div><div class="line">notEmpty.await();</div><div class="line"><span class="built_in">return</span> extract();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">private void insert(E x) &#123;</div><div class="line">items[putIndex] = x;</div><div class="line">putIndex = inc(putIndex);</div><div class="line">++count;</div><div class="line">notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当队列插入一个元素，如果队列不可用，那么阻塞生产者主要通过Locksupport.park实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(this);</div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="built_in">set</span>Blocker(t, blocker);</div><div class="line">    unsafe.park(<span class="literal">false</span>, 0L);</div><div class="line">    <span class="built_in">set</span>Blocker(t, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.park是个native方法</p>
<h2 id="fork-join任务"><a href="#fork-join任务" class="headerlink" title="fork/join任务"></a>fork/join任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class CountNumber extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private static final int THRESHOLD = 2;</div><div class="line">	private int start;</div><div class="line">	private int end;</div><div class="line"></div><div class="line">	public CountNumber(int start, int end) &#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer <span class="function"><span class="title">compute</span></span>() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		// 如果任务足够小就计算任务</div><div class="line">		boolean canCompute = (end - start) &lt;= THRESHOLD;</div><div class="line">		<span class="keyword">if</span> (canCompute) &#123;</div><div class="line">			<span class="keyword">for</span> (int i = start; i &lt;= end; i++) &#123;</div><div class="line">				sum += i;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 如果任务大于阈值，就分裂成两个子任务计算</div><div class="line">			int middle = (start + end) / 2;</div><div class="line">			CountNumber leftTask = new CountNumber(start, middle);</div><div class="line">			CountNumber rightTask = new CountNumber(middle + 1, end);</div><div class="line">			// 执行子任务</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			// 等待子任务执行完，并得到其结果</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			// 合并子任务</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> sum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		// 生成一个计算任务，负责计算1+2+3+4</div><div class="line">		CountNumber task = new CountNumber(1, 4);</div><div class="line">		// 执行一个任务</div><div class="line">		Future&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ForkJoinTask与一般任务的区别是它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常<br>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>1）当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。<br>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final ForkJoinTask&lt;V&gt; <span class="function"><span class="title">fork</span></span>() &#123;</div><div class="line">((ForkJoinWorkerThread) Thread.currentThread())</div><div class="line">.pushTask(this);</div><div class="line"><span class="built_in">return</span> this;</div><div class="line">&#125;</div><div class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;</div><div class="line">ForkJoinTask&lt;&gt;[] q; int s, m;</div><div class="line"><span class="keyword">if</span> ((q = queue) != null) &#123;　　　　// ignore <span class="keyword">if</span> queue removed</div><div class="line">long u = (((s = queueTop) &amp; (m = q.length - 1)) &lt;&lt; ASHIFT) + ABASE;</div><div class="line">UNSAFE.putOrderedObject(q, u, t);</div><div class="line">queueTop = s + 1;　　　　　　// or use putOrderedInt</div><div class="line"><span class="keyword">if</span> ((s -= queueBase) &lt;= 2)</div><div class="line">pool.signalWork();</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == m)</div><div class="line">growQueue();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)ForkJoinTask的join实现原理<br>join方法主要是阻塞当前线程并等待获取结果,它调用了doJoin()方法，通过doJoin()方法到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public final V <span class="function"><span class="title">join</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">do</span>Join() != NORMAL)</div><div class="line"><span class="built_in">return</span> reportResult();</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private V <span class="function"><span class="title">reportResult</span></span>() &#123;</div><div class="line">int s; Throwable ex;</div><div class="line"><span class="keyword">if</span> ((s = status) == CANCELLED)</div><div class="line">throw new CancellationException();</div><div class="line"><span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)</div><div class="line">UNSAFE.throwException(ex);</div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private int <span class="function"><span class="title">doJoin</span></span>() &#123;</div><div class="line">Thread t; ForkJoinWorkerThread w; int s; boolean completed;</div><div class="line"><span class="keyword">if</span> ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &#123;</div><div class="line"><span class="keyword">if</span> ((s = status) &lt; 0)</div><div class="line"><span class="built_in">return</span> s;</div><div class="line"><span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(this)) &#123;</div><div class="line">try &#123;</div><div class="line">completed = <span class="built_in">exec</span>();</div><div class="line">&#125; catch (Throwable rex) &#123;</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>ExceptionalCompletion(rex);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (completed)</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>Completion(NORMAL);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> w.joinTask(this);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> externalA<span class="built_in">wait</span>Done();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h1 id="java中的13个原子操作类"><a href="#java中的13个原子操作类" class="headerlink" title="java中的13个原子操作类"></a>java中的13个原子操作类</h1><p>java.util.concurrent.atomic提供了一种用法简单、性能高效、线程安全地更新一个变量的方式，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>AtomicBoolean:原子更新布尔类型<br>AtomicInteger：原子更新整数类型<br>AtomicLong：原子更新长整型<br>这三个类提供的方法几乎一模一样，以AtomicInteger为例<br>int addAndGet(int delta)：以原子方式将输入的数值与实例的值相加，并返回结果。<br>boolean compareAndSet(int expect,intupdate):如果输入的值等于预期，则以原子的方式将该值设为输入的值。<br>int getAndIncrement():以原子的方式将当前值加1，这里返回的值是自增前的值。<br>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。<br>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final int <span class="function"><span class="title">getAndIncrement</span></span>() &#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line"><span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line"><span class="built_in">return</span> current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。<br>Atomic包提供了3种基本类型的原子更新，但是java基本类型还有char、float、double，Atomic包是使用unsafe实现的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapObject(Object o,</div><div class="line">long offset,</div><div class="line">Object expected,</div><div class="line">Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">int expected,</div><div class="line">int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,</div><div class="line">long expected,</div><div class="line">long x);</div></pre></td></tr></table></figure></p>
<p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。</p>
<h2 id="原子数组更新"><a href="#原子数组更新" class="headerlink" title="原子数组更新"></a>原子数组更新</h2><p>AtomicIntegerArray：原子更新整型数组里的元素<br>AtomicLongArray：原子更新长整型数组里的元素<br>AtomicReferenceArray：原子更新引用数组里的元素<br>·int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。<br>·boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerArratTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		int[] value=new int[]&#123;1,2,3&#125;;</div><div class="line">		AtomicIntegerArray atomicIntegerArray=new AtomicIntegerArray(value);</div><div class="line">		atomicIntegerArray.set(0, 3);</div><div class="line">		System.out.println(atomicIntegerArray.get(0));</div><div class="line">		System.out.println(value[0]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//3</div><div class="line">//1</div></pre></td></tr></table></figure></p>
<p>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，需要使用这个原子更新引用类型提供的类，Atomic包括以下几个类：<br>AtomicReference：原子更新引用类型<br>AtomicReferenceFieldUpdater：原子更新引用类型的字段<br>AtomicMarkableReference：原子更新带有标记位的引用类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AtomicRefernceTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicReference&lt;User&gt; atomicReference=new AtomicReference&lt;&gt;();</div><div class="line">		User user=new User(<span class="string">"student"</span>, 15);</div><div class="line">		atomicReference.set(user);</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">		atomicReference.compareAndSet(user, new User(<span class="string">"teacher"</span>, 30));</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		private int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>AtomicIntegerFieldUpdater：原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicStampedReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可用于原子更新数据和数据的版本号，可以解决使用CAS进行原子更新时出现的ABA问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerFieldUpdaterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</div><div class="line">        User user=new User(<span class="string">"lr"</span>, 10);</div><div class="line">        atomicIntegerFieldUpdater.getAndIncrement(user);</div><div class="line">        System.out.println(atomicIntegerFieldUpdater.get(user));</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		public volatile int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="java中并发工具类"><a href="#java中并发工具类" class="headerlink" title="java中并发工具类"></a>java中并发工具类</h1><h2 id="等待多线程完成countDownLatch"><a href="#等待多线程完成countDownLatch" class="headerlink" title="等待多线程完成countDownLatch"></a>等待多线程完成countDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。要实现主线程等待所有线程完成任务，最简单的做法是使用join<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class JoinCountDownLatchTest &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * @throws S</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread task1=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        Thread task2=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        task1.start();</div><div class="line">        task2.start();</div><div class="line">        task1.join();</div><div class="line">        task2.join();</div><div class="line">        System.out.println(<span class="string">"total task finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>join用于执行线程等待join执行结束，原理是不同地检查线程是否存活，如果join线程存活则让当前线程永远等待，其中wait（0）是永远等待<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(isAlive())&#123;</div><div class="line">  <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>知道join线程终止后，线程的this.notifyAll()方法会被调用，调用notifyAll方法是在JVM实现的，在JDK看不到<br>并发包CountDownLatch可以实现join功能，并且比join功能更多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		final CountDownLatch countDownLatch = new CountDownLatch(2);</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		countDownLatch.await();</div><div class="line">		System.out.println(<span class="string">"all finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch构造函数接收一个int类型的参数作为计数器，如果你想等N个点完成，就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变为0。我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier字面意思是可循环使用的屏障，它要做的事情是让一组线程到达屏障时被阻塞，直到最后一个线程到达屏障时，屏障才开门，所有被屏障拦截的线程才会继续运行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障要拦截的线程数，每个线程调用await方法告诉CyclicBarrier我已经到达屏障，然后当前线程阻塞<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException, BrokenBarrierException&#123;</div><div class="line">	final CyclicBarrier cyclicBarrier=new CyclicBarrier(2);</div><div class="line">	new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			try &#123;</div><div class="line">				cyclicBarrier.await();</div><div class="line">			&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"1"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">	cyclicBarrier.await();</div><div class="line">	System.out.println(<span class="string">"2"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CyclicBarrier还提供了一个更高级的构造函数，CyclicBarrier(int parties,Runnable action)，用于在线程到达屏障时，优先执行action，方便处理更复杂的业务场景。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2, new A());</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class A implements Runnable &#123;</div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			System.out.println(3);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier应用场景"><a href="#CyclicBarrier应用场景" class="headerlink" title="CyclicBarrier应用场景"></a>CyclicBarrier应用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BankWaterService implements Runnable&#123;</div><div class="line">	/**</div><div class="line">	* 创建4个屏障，处理完之后执行当前类的run方法</div><div class="line">	*/</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	/**</div><div class="line">	* 假设只有4个sheet，所以只启动4个线程</div><div class="line">	*/</div><div class="line">	private ExecutorService executor = Executors.newFixedThreadPool(4);</div><div class="line">	/**</div><div class="line">	* 保存每个sheet计算出的银流结果</div><div class="line">	*/</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt;sheetBankWaterCount = new</div><div class="line">	ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	public void <span class="function"><span class="title">count</span></span>()&#123;</div><div class="line">		<span class="keyword">for</span>(int i=0;i&lt;4;i++)&#123;</div><div class="line">		executor.submit(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		&#125;</div><div class="line">		executor.shutdown();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		int result = 0;</div><div class="line">		<span class="keyword">for</span>(Entry&lt;String,Integer&gt; entry:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result=result+entry.getValue();</div><div class="line">		&#125;</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		new BankWaterService().count();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody>
</table>
<p>CyclicBarrier计数器可以使用reset方法重置，而CountDownLatch的计数器只能使用一次，所以CyclicBarrier可以用在更复杂的业务场景。例如计算错误了，可以重置计数器，让线程重算。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting可以获得阻塞的线程数量，isbroken可以用来了解阻塞的线程是否中断。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">importjava.util.concurrent.BrokenBarrierException;</div><div class="line">importjava.util.concurrent.CyclicBarrier;</div><div class="line">public class CyclicBarrierTest3 &#123;</div><div class="line">staticCyclicBarrier c = new CyclicBarrier(2);</div><div class="line">public static void main(String[] args) throws InterruptedException，</div><div class="line">BrokenBarrierException &#123;</div><div class="line">Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">thread.interrupt();</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">System.out.println(c.isBroken());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class SemophoreTest &#123;</div><div class="line"></div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	private static ExecutorService threadPool = Executors</div><div class="line">			.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</div><div class="line">			final int num=i;</div><div class="line">			threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">				@Override</div><div class="line">				public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						System.out.println(<span class="string">"save data"</span>+num);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Semaphore还提供一些其他方法，具体如下。<br>·int availablePermits()：返回此信号量中当前可用的许可证数。<br>·int getQueueLength()：返回正在等待获取许可证的线程数。<br>·boolean hasQueuedThreads()：是否有线程正在等待获取许可证。<br>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。<br>·Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</p>
<h2 id="线程之间的交换"><a href="#线程之间的交换" class="headerlink" title="线程之间的交换"></a>线程之间的交换</h2><p>Exchanger是一个线程间协作工具类，Exchanger可用来线程间的数据交换。它提供一个同步点，在这个同步点，线程间可以交换彼此的数据，两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程执行exchange方法，当两个线程都到达同步点，这两个线程就可以交换数据，将本线程生产的数据传递给对方。<br>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = <span class="string">"银行流水A"</span>;// A录入银行流水数据</div><div class="line">					exgr.exchange(A);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = <span class="string">"银行流水B"</span>;// B录入银行流水数据</div><div class="line">					String A = exgr.exchange(<span class="string">"B"</span>);</div><div class="line">					System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></div><div class="line">							+ A + <span class="string">"，B录入是："</span> + B);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java并发容器和框架&quot;&gt;&lt;a href=&quot;#java并发容器和框架&quot; class=&quot;headerlink&quot; title=&quot;java并发容器和框架&quot;&gt;&lt;/a&gt;java并发容器和框架&lt;/h1&gt;&lt;h2 id=&quot;ConcurrentHashMap实现原理与使用&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能管理及架构设计</title>
    <link href="http://yoursite.com/2018/01/01/MySQL%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%8F%8A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/01/01/MySQL性能管理及架构设计/</id>
    <published>2018-01-01T14:21:08.000Z</published>
    <updated>2018-02-20T14:12:18.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么影响了mysql的性能"><a href="#什么影响了mysql的性能" class="headerlink" title="什么影响了mysql的性能"></a>什么影响了mysql的性能</h1><h2 id="影响性能的几个方面"><a href="#影响性能的几个方面" class="headerlink" title="影响性能的几个方面"></a>影响性能的几个方面</h2><ol>
<li>服务器的硬件</li>
<li>操作系统或参数配置</li>
<li>数据库的存储引擎选择<br>MyIsam：不支持事务，表级锁；Innodb：事务存储引擎，完美支持行级锁，支持事务ACID特性</li>
<li>数据库参数配置</li>
<li>数据库结构设计和sql语句</li>
</ol>
<h2 id="CPU资源和内存大小"><a href="#CPU资源和内存大小" class="headerlink" title="CPU资源和内存大小"></a>CPU资源和内存大小</h2><p>CPU资源和内存大小<br>网络，memcache失效时会产生大量网络传输</p>
<h3 id="考虑cpu"><a href="#考虑cpu" class="headerlink" title="考虑cpu"></a>考虑cpu</h3><p>cpu密集型选择更好的Cpu，mysql暂不支持多cpu对同一sql并发处理</p>
<h3 id="系统的并发量"><a href="#系统的并发量" class="headerlink" title="系统的并发量"></a>系统的并发量</h3><p>QPS：同时处理sql的数量</p>
<h3 id="Mysql的版本"><a href="#Mysql的版本" class="headerlink" title="Mysql的版本"></a>Mysql的版本</h3><p>最新的版本对多核支持，尤其是5.5以后的版本</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存比SSD和Fusion-IO比也要快很多<br>myisam将索引缓存到内存，数据放在通过操作系统缓存<br>innodb同时缓存数据和索引到内存<br>选择内存的主频，频率越高速度越快</p>
<h2 id="磁盘的配置和选择"><a href="#磁盘的配置和选择" class="headerlink" title="磁盘的配置和选择"></a>磁盘的配置和选择</h2><ol>
<li>使用传统机器硬盘；<br>使用最多、存储空间大、价格低、读写速度较慢、最常见。读取数据的时间分为访问时间和传输时间。考虑的因素是存储容量、传输速度、访问时间、主轴转速（7000多转或一万）、物理尺寸</li>
<li>使用raid增强传统机器硬盘的性能<br>raid是磁盘冗余队列的简称，把多个小的磁盘组成一组容量更大的磁盘。主要有raid0、raid1、raid5、raid10</li>
<li>使用固态硬盘ssd和pcied卡<br>比机械磁盘固态磁盘有更好的随机读写功能、更好的支持并发、更容易损坏</li>
<li>使用网络存储NAS和SAN</li>
</ol>
<h2 id="服务器硬件对性能的影响"><a href="#服务器硬件对性能的影响" class="headerlink" title="服务器硬件对性能的影响"></a>服务器硬件对性能的影响</h2><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><ul>
<li>64位的cpu一定要工作在64位的系统上</li>
<li>对于并发比较高的场景cpu的数量比频率重要</li>
<li>对于cpu密集性场景和复杂sql来说则频率越高越好</li>
</ul>
<h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><ul>
<li>选择主板所使用最高频率的内存</li>
<li>尽可能大</li>
</ul>
<h3 id="IO子系统"><a href="#IO子系统" class="headerlink" title="IO子系统"></a>IO子系统</h3><p>PCIE&gt;SSD&gt;RAID&gt;磁盘&gt;SAN</p>
<h2 id="mysql常用存储引擎MyISAM"><a href="#mysql常用存储引擎MyISAM" class="headerlink" title="mysql常用存储引擎MyISAM"></a>mysql常用存储引擎MyISAM</h2><p>mysql5.5之前版本默认存储引擎<br>系统表和临时表，这里的临时表和create 临时表不一样。临时表是在排序、分组等操作中，当数量超过一定的大小后，由查询优化器建立的临时表<br>.frm–文件存储表定义。<br>.myd–数据文件的扩展名。<br>.myi–索引文件的扩展名。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>锁的级别是表锁，读取和插入是互斥。读写混合的并发性不太好。<br>表损坏修复<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">check table table_name</div><div class="line">repair table table_name</div></pre></td></tr></table></figure></p>
<p>myisam支持全文索引、支持数据压缩（myisampack命令，在进行压缩数据后不能进行插入操作）、版本小于5.0时默认表大小为4G，版本大时默认使用256TB<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myisampack -b <span class="_">-f</span> mysiam.MYI(myisam文件)</div></pre></td></tr></table></figure></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>非事务型应用、只读类应用、空间类应用</p>
<h2 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h2><p>mysql5.5以后版本默认存储引擎，Innodb使用表空间进行存储。Innodb_file_per_table为on时独立表空间：ibd文件，off时系统表空间ibdataX文件</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>是事务性存储引擎，完全支持事务的acid特性<br>支持行级锁<br>锁的类型是读锁和写锁，粒度是表级锁、行级锁<br>后面版本已经支持全文索引和空间函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lock table table_name write;//表级锁</div><div class="line">unlock tables;</div><div class="line">show engine innodb status;//innodb</div></pre></td></tr></table></figure></p>
<h2 id="mysql服务器参数设置"><a href="#mysql服务器参数设置" class="headerlink" title="mysql服务器参数设置"></a>mysql服务器参数设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> global 参数名=参数值</div><div class="line"><span class="built_in">set</span> @@global.参数名 :=参数值</div><div class="line"><span class="built_in">set</span> session 参数名=参数值</div><div class="line"><span class="built_in">set</span> @@session.参数名 :=参数值</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么影响了mysql的性能&quot;&gt;&lt;a href=&quot;#什么影响了mysql的性能&quot; class=&quot;headerlink&quot; title=&quot;什么影响了mysql的性能&quot;&gt;&lt;/a&gt;什么影响了mysql的性能&lt;/h1&gt;&lt;h2 id=&quot;影响性能的几个方面&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程4~5</title>
    <link href="http://yoursite.com/2017/12/31/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-6/"/>
    <id>http://yoursite.com/2017/12/31/java并发编程4-6/</id>
    <published>2017-12-31T07:25:57.000Z</published>
    <updated>2018-01-05T13:34:18.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java并发编程基础"><a href="#java并发编程基础" class="headerlink" title="java并发编程基础"></a>java并发编程基础</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程时间片用完了就会发生线程调度，等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。<br>Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。<br>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>java线程在运行的生命周期可能处于6中不同的状态，在给定的一个时刻线程只能处于其中一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用start方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，java线程将操作系统中的就绪和运行两种状态笼统地称作运行中</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITTING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（如通知或者中断）</td>
</tr>
<tr>
<td>TIME_WAITTING</td>
<td>超时等待状态，该状态不同于WAITTING，它是可以在指定的时间返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jps <span class="_">-l</span></div><div class="line">jstack pid//查看线程情况</div></pre></td></tr></table></figure>
<p><img src="/2017/12/31/java并发编程4-6/java线程状态变迁.png" alt=""><br>注意　Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个java虚拟机不存在非Daemon线程时，java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个标记位，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了招呼，其他线程调用了该线程的interrupt方法对其进行了中断。<br>线程通过检查自身是否被中断进行响应，通过调用isInterrupted来判断是否被中断，也可以调用静态方法Thread.interrupted对当前线程进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。<br>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<h3 id="过期的suspend、resume、stop"><a href="#过期的suspend、resume、stop" class="headerlink" title="过期的suspend、resume、stop"></a>过期的suspend、resume、stop</h3><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。<br>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="volatile和synchronize关键字"><a href="#volatile和synchronize关键字" class="headerlink" title="volatile和synchronize关键字"></a>volatile和synchronize关键字</h3><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。<br>简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(value != desire) &#123;</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125;</div><div class="line"><span class="keyword">do</span>Something();</div></pre></td></tr></table></figure></p>
<p>1）难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时<br>发现条件已经变化，也就是及时性难以保证。<br>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现<br>条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。<br>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br><img src="/2017/12/31/java并发编程4-6/通知机制.png" alt=""><br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>wait、notify和notifyAll注意细节：</p>
<ul>
<li>使用wait、notify、notifyAll时需要先对对象加锁</li>
<li>调用wait后，线程状态由RUNNING变为WAITING，并将当前线程放到等待队列中</li>
<li>notify和notifyAll调用后，等待线程不会从wait返回，需要等待notify和notifyAll释放锁后，等待线程才有机会从wait中返回。</li>
<li>notify方法将等待队列中的一个线程从等待队列中移出到同步队列，notifyAll是将等待队列中的所有线程移到同步队列中，被移动的线程从waiting变为blocked。</li>
<li>从wait方法中返回前提是获得调用对象锁</li>
</ul>
<p><img src="/2017/12/31/java并发编程4-6/wait_notify.png" alt=""></p>
<h3 id="等待通知的经典范式"><a href="#等待通知的经典范式" class="headerlink" title="等待通知的经典范式"></a>等待通知的经典范式</h3><p>该范式分为两个部分：分别针对等待方和通知方</p>
<h4 id="等待方"><a href="#等待方" class="headerlink" title="等待方"></a>等待方</h4><p>等待方遵守如下规则：</p>
<ol>
<li>获取对象的锁</li>
<li>如果不满足条件，那么调用对象的wait方法，被通知后仍然检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  <span class="keyword">while</span>(条件不满足)&#123;</div><div class="line">    对象.wait();</div><div class="line">  &#125;</div><div class="line">  对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通知方"><a href="#通知方" class="headerlink" title="通知方"></a>通知方</h4><ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  改变条件</div><div class="line">  对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。<br>管道输入输出流包括了如下四种具体实现：PipedOutputStream、PipedInputStream、PipedReader、PipedWriter，前两种面向字节，后两种面向字符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Piped &#123;</div><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">PipedWriter out = new PipedWriter();</div><div class="line">PipedReader <span class="keyword">in</span> = new PipedReader();</div><div class="line">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</div><div class="line">out.connect(<span class="keyword">in</span>);</div><div class="line">Thread <span class="built_in">print</span>Thread = new Thread(new Print(<span class="keyword">in</span>), <span class="string">"PrintThread"</span>);</div><div class="line"><span class="built_in">print</span>Thread.start();</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = System.in.read()) != -1) &#123;</div><div class="line">out.write(receive);</div><div class="line">&#125;</div><div class="line">&#125; finally &#123;</div><div class="line">out.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">static class Print implements Runnable &#123;</div><div class="line">private PipedReader <span class="keyword">in</span>;</div><div class="line">public Print(PipedReader <span class="keyword">in</span>) &#123;</div><div class="line">this.in =<span class="keyword">in</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = in.read()) != -1) &#123;</div><div class="line">System.out.print((char) receive);</div><div class="line">&#125;</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><p>如果一个线程执行了thread.join语句，其含义是当前线程A等待thread线程终止后才从thread.join返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 加锁当前线程对象</div><div class="line">public final synchronized void join() throws InterruptedException &#123;</div><div class="line">// 条件不满足，继续等待</div><div class="line"><span class="keyword">while</span>(isAlive()) &#123;</div><div class="line"> <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div><div class="line">// 条件符合，方法返回</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal是线程变量，是一个以ThreadLocal为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程的值。<br>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p>开发人员经常遇到：调用一个方法等待一段时间后，如果该方法能够在给定时间段内得到结果，那么将结果返回，反之超时返回默认结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 对当前对象加锁</div><div class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line">// 当超时大于0并且result返回值不满足要求</div><div class="line"><span class="keyword">while</span>((result == null) &amp;&amp; remaining &gt; 0) &#123;</div><div class="line"><span class="built_in">wait</span>(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ConnectionPool &#123;</div><div class="line">private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</div><div class="line">public ConnectionPool(int initialSize) &#123;</div><div class="line"><span class="keyword">if</span>(initialSize &gt; 0) &#123;</div><div class="line"><span class="keyword">for</span>(int i = 0; i &lt; initialSize; i++) &#123;</div><div class="line">pool.addLast(ConnectionDriver.createConnection());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void releaseConnection(Connection connection) &#123;</div><div class="line"><span class="keyword">if</span>(connection != null) &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</div><div class="line">pool.addLast(connection);</div><div class="line">pool.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 在mills内无法获取到连接，将会返回null</div><div class="line">public Connection fetchConnection(long mills) throws InterruptedException &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 完全超时</div><div class="line"><span class="keyword">if</span>(mills &lt;= 0) &#123;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty()) &#123;</div><div class="line">pool.wait();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> pool.removeFirst();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</div><div class="line">pool.wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">Connection result = null;</div><div class="line"><span class="keyword">if</span>(!pool.isEmpty()) &#123;</div><div class="line">result = pool.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h1><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock=new ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。<br><img src="/2017/12/31/java并发编程4-6/lock特性.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/lock-api.png" alt=""></p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer是用来构建锁或者其他组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程排队工作。<br>同步器的主要使用方式是继承，子类通过继承父类同步器并实现他的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这就需要对同步器提供的三个方法（getState、setState、compareAndSetState）来进行操作，因为它能保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。<br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方<br>法，而这些模板方法将会调用使用者重写的方法。<br>·getState()：获取当前同步状态。<br>·setState(int newState)：设置当前同步状态。<br>·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。<br><img src="/2017/12/31/java并发编程4-6/同步器重写.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/模板方法.png" alt=""><br>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><p>同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，同步器将当前线程以及等待状态等信息构造称为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。<br><img src="/2017/12/31/java并发编程4-6/节点属性.png" alt=""><br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部<br><img src="/2017/12/31/java并发编程4-6/同步队列结构.png" alt=""><br>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="/2017/12/31/java并发编程4-6/cas设置尾节点.png" alt=""><br>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点<br><img src="/2017/12/31/java并发编程4-6/首节点设置.png" alt=""><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line"><span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">    selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">  Node node = new Node(Thread.currentThread(), mode);</div><div class="line">  // 快速尝试在尾部添加</div><div class="line">  Node pred = tail;</div><div class="line">  <span class="keyword">if</span>(pred != null) &#123;</div><div class="line">    node.prev = pred;</div><div class="line">    <span class="keyword">if</span>(compareAndSetTail(pred, node)) &#123;</div><div class="line">      pred.next = node;</div><div class="line">      <span class="built_in">return</span> node;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  enq(node);</div><div class="line">  <span class="built_in">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">  <span class="keyword">for</span>(;;)&#123;</div><div class="line">    Node t = tail;</div><div class="line">    <span class="keyword">if</span>(t==null)&#123;</div><div class="line">      Node temp=new Node();</div><div class="line">      <span class="keyword">if</span>(compareAndSetHead(temp))</div><div class="line">        tail = head;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      node.prev = t;</div><div class="line">      <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</div><div class="line">        t.next = node;</div><div class="line">        <span class="built_in">return</span> t;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码通过使用compareAndSetTail(Node expect,Node update)方法来确保节点能够被线程安全添加。试想一下：如果使用一个普通的LinkedList来维护节点之间的关系，那么当一个线程获取了同步状态，而其他多个线程由于调用tryAcquire(int arg)方法获取同步状态失败而并发地被添加到LinkedList时，LinkedList将难以保证Node的正确添加，最终的结果可能是节点的数量有偏差，而且顺序也是混乱的。<br>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变得“串行化”了。<br>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">    boolean failed=<span class="literal">true</span>;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(;;)&#123;</div><div class="line">          final Node p = node.predecessor();</div><div class="line">          <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">              <span class="built_in">set</span>Head(node);</div><div class="line">              p.next = null;</div><div class="line">              failed=<span class="literal">false</span>;</div><div class="line">              <span class="built_in">return</span> interrupted;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt)</div><div class="line">              interrupted = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        <span class="keyword">if</span>(failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。<br>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为<br>适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</div><div class="line">      Node h = head;</div><div class="line">      <span class="keyword">if</span>(h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">       unparkSuccessor(h);</div><div class="line">       <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">     <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="共享同步状态获取与释放"><a href="#共享同步状态获取与释放" class="headerlink" title="共享同步状态获取与释放"></a>共享同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况<br><img src="/2017/12/31/java并发编程4-6/共享与独占.png" alt=""><br>左半部分，共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞，右半部分是独占式访问资源时，同一时刻其他访问均被阻塞。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; 0)</div><div class="line">           <span class="keyword">do</span>AcquireShared(arg);</div><div class="line">   &#125;</div><div class="line">private void <span class="keyword">do</span>AcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                final Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= 0) &#123;</div><div class="line">                        <span class="built_in">set</span>HeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        <span class="built_in">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            <span class="keyword">if</span>(failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。<br>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line"><span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">      <span class="keyword">do</span>ReleaseShared();</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。在分析该方法的实现前，先介绍一下响应中断的同步状态获取过程。在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private boolean <span class="keyword">do</span>AcquireNanos(int arg, long nanosTimeout)</div><div class="line">     throws InterruptedException &#123;</div><div class="line">     long lastTime = System.nanoTime();</div><div class="line">     final Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">     boolean failed = <span class="literal">true</span>;</div><div class="line">     try &#123;</div><div class="line">         <span class="keyword">for</span> (;;) &#123;</div><div class="line">             final Node p = node.predecessor();</div><div class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                 <span class="built_in">set</span>Head(node);</div><div class="line">                 p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                 failed = <span class="literal">false</span>;</div><div class="line">                 <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= 0)</div><div class="line">                 <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                 nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                 LockSupport.parkNanos(this, nanosTimeout);</div><div class="line">             long now = System.nanoTime();</div><div class="line">             nanosTimeout -= now - lastTime;</div><div class="line">             lastTime = now;</div><div class="line">             <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                 throw new InterruptedException();</div><div class="line">         &#125;</div><div class="line">     &#125; finally &#123;</div><div class="line">         <span class="keyword">if</span> (failed)</div><div class="line">             cancelAcquire(node);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object blocker,long nanos)方法返回）。如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，同步器会进入无条件的快速自旋。<br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑。acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态，而doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。<br><img src="/2017/12/31/java并发编程4-6/独占超时.png" alt=""></p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，支持重新进入的锁，表示该锁能够支持一个线程对一个资源的重复加锁。该锁还支持获取锁的公平性和非公平性的选择。<br>当一个线程调用Mutex的lock方法获取锁之后，如果再次调用lock方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。简单地说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。<br>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。<br>如果在决定时间下，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之则是不公平的。公平锁也就是等待时间最长的线程最优先获取到锁.ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。公平锁往往没有不公平锁效率高，但是并非任何场景下都是以TPS作为唯一指标，公平锁能够减少饥饿发生的概率，等待越久的线程越是能够得到优先满足。<br>1.实现重进入<br>重进入是是指任意线程获取到锁后再次获取到该锁不会被该锁所阻塞，该特性需要解决两个问题：<br>1）线程再次获取到锁，锁需要去识别获取锁的线程是否是当前占据锁的线程，如果是，再次成功获取<br>2）锁的最终释放，线程重复n次获取到锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。<br>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">int c = getState() - releases;</div><div class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">boolean free = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line">free = <span class="literal">true</span>;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">&#125;</div><div class="line"><span class="built_in">set</span>State(c);</div><div class="line"><span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。<br>2.公平锁与非公平锁的区别<br>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>回顾nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>为什么会出现线程连续获取锁的情况呢？回顾nonfairTryAcquire(int acquires)方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待.<br>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>之前提到的锁基本都是排他锁，这些锁同一时刻只能由一个线程进行访问，而读写锁在同一时刻只允许一个线程进行访问，而读写锁同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了提升。<br>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务、（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。<br>一般情况下，读写锁的性能都会比排它锁性能好，因为大多数场景读是多于写。读写锁比排它锁有更好的并发量和吞吐量。java并发包提供读写锁ReentrantReadWriteLock</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平和公平，吞吐量非公平优于公平</td>
</tr>
<tr>
<td>重进入</td>
<td>该锁支持重进入，以读写线程为例，读线程获取读锁后，能够再次获取读锁，写线程获取写锁后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级称为读锁</td>
</tr>
</tbody>
</table>
<h3 id="读写锁接口与示例"><a href="#读写锁接口与示例" class="headerlink" title="读写锁接口与示例"></a>读写锁接口与示例</h3><p>仅定义了获取读锁和写锁两个方法，即readLock和writeLock<br><img src="/2017/12/31/java并发编程4-6/读写锁监控.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">	static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">	static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">	static Lock r = rwl.readLock();</div><div class="line">	static Lock w = rwl.writeLock();</div><div class="line"></div><div class="line">	// 获取一个key对应的value</div><div class="line">	public static final Object get(String key) &#123;</div><div class="line">		r.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.get(key);</div><div class="line">		&#125; finally &#123;</div><div class="line">			r.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置key对应的value，并返回旧的value</div><div class="line">	public static final Object put(String key, Object value) &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.put(key, value);</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清空所有的内容</div><div class="line">	public static final void <span class="function"><span class="title">clear</span></span>() &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			map.clear();</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性</p>
<h3 id="读写锁实现设计"><a href="#读写锁实现设计" class="headerlink" title="读写锁实现设计"></a>读写锁实现设计</h3><p>主要包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级</p>
<h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果一个整形变量维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量分为两个部分，前十六位表示读，低十六位表示写。<br>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。<br>当S等于零时说明没有锁，当S不等于零时，当写状态(S&amp;0x0000FFFF)等于0时，则读状态不等于0，即读锁已被获取。</p>
<h4 id="写状态的获取与释放"><a href="#写状态的获取与释放" class="headerlink" title="写状态的获取与释放"></a>写状态的获取与释放</h4><p>写锁是一个支持可重入的排它锁，如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">           Thread current = Thread.currentThread();</div><div class="line">           int c = getState();</div><div class="line">           int w = exclusiveCount(c);</div><div class="line">           <span class="keyword">if</span> (c != 0) &#123;</div><div class="line">               // (Note: <span class="keyword">if</span> c != 0 and w == 0 <span class="keyword">then</span> shared count != 0)</div><div class="line">               <span class="keyword">if</span> (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                   <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                   throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">               // Reentrant acquire</div><div class="line">               <span class="built_in">set</span>State(c + acquires);</div><div class="line">               <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">               !compareAndSetState(c, c + acquires))</div><div class="line">               <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">           <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。<br>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount()方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">int c = getState();</div><div class="line">int nextc = c + (1 &lt;&lt; 16);</div><div class="line"><span class="keyword">if</span> (nextc &lt; c)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</div><div class="line"><span class="built_in">return</span> -1;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line"><span class="built_in">return</span> 1;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。<br>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。<br>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">processData</span></span>() &#123;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 必须先释放读锁</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">// 锁降级从写锁获取到开始</div><div class="line">writeLock.lock();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 准备数据的流程（略）</div><div class="line">update = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line">&#125; finally &#123;</div><div class="line">writeLock.unlock();</div><div class="line">&#125;</div><div class="line">// 锁降级完成，写锁降级为读锁</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">// 使用数据的流程（略）</div><div class="line">&#125; finally &#123;</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。<br>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类完成相应工作。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程<br><img src="/2017/12/31/java并发编程4-6/locksupport.png" alt=""><br>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<h2 id="condition接口"><a href="#condition接口" class="headerlink" title="condition接口"></a>condition接口</h2><p>任意一个java对象，都拥有一组监视器方法，主要包括wait、notify、notifyAll方法，这些方法与synchronize同步关键字配合，可以实现等待、通知模式。Condition接口也提供了类似Object监视器方法，与lock配合实现等待通知模式。<br><img src="/2017/12/31/java并发编程4-6/对比.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Lock lock=new ReentrantLock();</div><div class="line">	static Condition condition=lock.newCondition();</div><div class="line">	public static void <span class="function"><span class="title">wait_1</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.await();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void <span class="function"><span class="title">singal</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/31/java并发编程4-6/condition.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BoundedQueue&lt;T&gt; &#123;</div><div class="line">    T[] itemsObjects;</div><div class="line">	int addindex,removeIndex,count;</div><div class="line">	Lock lock=new ReentrantLock();</div><div class="line">	Condition notFull=lock.newCondition();</div><div class="line">	Condition notEmpty=lock.newCondition();</div><div class="line">	public void add(T t)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==itemsObjects.length)&#123;</div><div class="line">				notFull.await();</div><div class="line">			&#125;</div><div class="line">			itemsObjects[addindex]=t;</div><div class="line">			addindex++;</div><div class="line">			<span class="keyword">if</span>(addindex==itemsObjects.length)&#123;</div><div class="line">				addindex=0;</div><div class="line">			&#125;</div><div class="line">			count++;</div><div class="line">			notEmpty.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public T <span class="function"><span class="title">remove</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==0)&#123;</div><div class="line">				notEmpty.await();</div><div class="line">			&#125;</div><div class="line">			T t=itemsObjects[removeIndex];</div><div class="line">			<span class="keyword">if</span>(++removeIndex==itemsObjects.length)</div><div class="line">				removeIndex=0;</div><div class="line">			count--;</div><div class="line">			notFull.signal();</div><div class="line">			<span class="built_in">return</span> t;</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="condition的实现分析"><a href="#condition的实现分析" class="headerlink" title="condition的实现分析"></a>condition的实现分析</h3><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是FIFO的操作，在队列中的每个节点都包含一个线程的引用，该线程就是在Condition对象等待的线程，如果一个对象调用Condition.await，那么线程会释放锁，构造成节点加入等待队列并进入等待状态。点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node<br>一个Condition包含一个等待队列，Condition拥有首节点和尾节点，当前线程调用Condition.await，将会以当前线程构造节点，并将节点从尾部加入等待队列。<br><img src="/2017/12/31/java并发编程4-6/等待队列基本结构.png" alt=""><br>Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向他，并且更新尾节点。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br>在Object的监视器模型上，一个对象拥有一个同步队列和同步队列，而并发包中的Lock拥有一个同步队列和多个等待队列。<br><img src="/2017/12/31/java并发编程4-6/同步与等待.png" alt=""></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await方法中返回时，当前线程一定获取了Condition的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        throw new InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    long savedState = fullyRelease(node);</div><div class="line">    int interruptMode = 0;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步状态中的后继节点，然后当前线程会进入等待</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal方法，将会唤醒等待队列中等待最长的节点，在唤醒节点前，会将节点移到同步队列中。<br><img src="/2017/12/31/java并发编程4-6/唤醒.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void <span class="function"><span class="title">signal</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">Node first = firstWaiter;</div><div class="line"><span class="keyword">if</span> (first != null)</div><div class="line"><span class="keyword">do</span>Signal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。<br>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。<br>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java并发编程基础&quot;&gt;&lt;a href=&quot;#java并发编程基础&quot; class=&quot;headerlink&quot; title=&quot;java并发编程基础&quot;&gt;&lt;/a&gt;java并发编程基础&lt;/h1&gt;&lt;h2 id=&quot;线程简介&quot;&gt;&lt;a href=&quot;#线程简介&quot; class=&quot;head
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程前三章</title>
    <link href="http://yoursite.com/2017/12/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%89%8D%E4%B8%89%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/12/26/java并发编程前三章/</id>
    <published>2017-12-26T09:08:19.000Z</published>
    <updated>2017-12-31T07:08:16.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>即使是单核也支持多线程执行代码，cpu通过给每个线程分配cpu时间片来实现这个机制。时间片是cpu分配给每个线程的时间，因为时间片非常短，所以cpu通过不停地切换线程执行，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。<br>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="多线程一定快吗"><a href="#多线程一定快吗" class="headerlink" title="多线程一定快吗"></a>多线程一定快吗</h3><p>当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<h3 id="测试上下文切换的次数"><a href="#测试上下文切换的次数" class="headerlink" title="测试上下文切换的次数"></a>测试上下文切换的次数</h3><p>使用Lmbench3可以测量上下文切换的时长，使用vmstat可以测量上下文切换的次数。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。<br>·无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。<br>·CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<br>·使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。<br>·协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h3 id="减少上下文切换实战"><a href="#减少上下文切换实战" class="headerlink" title="减少上下文切换实战"></a>减少上下文切换实战</h3><p>第一步用jstack命令dump线程信息<br>第二步统计所有线程分别处于什么状态<br>第三步打开dump文件查看处于waiting的线程在做什么<br>第四步根据查看发现很多线程都在waiting，调整线程池配置<br>第五步重启服务器再统计</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>避免死锁的方法：<br>避免一个线程同时获得多个锁；<br>避免一个锁内同时占用多个资源，尽量保证一个锁只占用一个资源<br>尝试使用定时锁来代替内部锁机制,lock.tryLock(timeout)<br>对于数据库操作，加锁和解锁必须在一个数据库的连接里，否则会出现解锁失败的现象</p>
<h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><h3 id="什么是资源限制"><a href="#什么是资源限制" class="headerlink" title="什么是资源限制"></a>什么是资源限制</h3><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。例如带宽的上传下载速度、硬盘读写速度和cpu的处理速度。软件资源限制有数据库连接数和socket的连接数</p>
<h3 id="资源限制带来的问题"><a href="#资源限制带来的问题" class="headerlink" title="资源限制带来的问题"></a>资源限制带来的问题</h3><p>资源限制引发的问题导致并发可能不会加快，反而变慢，原因在于增加了上下文的切换和资源调度的时间</p>
<h3 id="如何解决资源限制问题"><a href="#如何解决资源限制问题" class="headerlink" title="如何解决资源限制问题"></a>如何解决资源限制问题</h3><p>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制可以使用线程池将socket和数据库连接复用，或者在调用对方webservice接口获取数据时</p>
<h3 id="在资源限制情况下进行并发编程"><a href="#在资源限制情况下进行并发编程" class="headerlink" title="在资源限制情况下进行并发编程"></a>在资源限制情况下进行并发编程</h3><p>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接</p>
<h1 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h1><h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="定义及其实现原理"><a href="#定义及其实现原理" class="headerlink" title="定义及其实现原理"></a>定义及其实现原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">instance = new Singleton();//instance是volatile变量</div><div class="line">//汇编</div><div class="line">0x01a3de1d: movb \<span class="variable">$0</span>×0,0×1104800(%esi);0x01a3de24: lock addl \<span class="variable">$0</span>×0,(%esp);</div></pre></td></tr></table></figure>
<p>lock指令会在多核处理器引发两件事情：</p>
<ol>
<li>将当前的缓存处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使其他cpu缓存该地内存址的数据无效</li>
</ol>
<p><em>缓存一致性协议：在多处理器中，为了保证各个处理器的缓存是一致的，就会实现缓存一致性，每个处理器会通过嗅探在总线传播过来的数据来检查自己缓存的数据是否过期，当处理器发现自己缓存行对应的内存地址被修改时，就会将自己的缓存状态设为失效状态，当处理器对这个数据进行访问时，就会重新从系统内存中把数据读到处理器缓存中。</em></p>
<h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>Linked-TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能<br>一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。<br>为什么追加64字节能够提高并发编程的效率呢？因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。那么是不是在使用volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。<br>·缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。<br>·共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>java中每一个对象都可以成为锁，具体表现形式如下：<br>对于普通的同步方法，锁是当前实例对象<br>对于静态的同步方法，锁是当前类的class对象<br>对于同步方法快，锁是Sychronized括号里配置的对象。<br>JVM基于进入和退出monitor对象实现方法同步和代码块同步，但两个实现细节不一样，代码块同步是通过monitorenter和monitorexit指令实现，方法同步使用另一种方式。<br>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>synchronized用的锁是存在java对象头里。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果非数组，用2字宽存储对象头。<br><img src="/2017/12/26/java并发编程前三章/java对象头.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/锁状态.png" alt=""></p>
<h3 id="锁升级与对比"><a href="#锁升级与对比" class="headerlink" title="锁升级与对比"></a>锁升级与对比</h3><p>java SE1.6中锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量锁状态、重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h5 id="关闭锁"><a href="#关闭锁" class="headerlink" title="关闭锁"></a>关闭锁</h5><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果进程间存在着锁竞争会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋消耗cpu</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程使用不使用自旋，不用消耗cpu</td>
<td>线程阻塞，响应速度非常慢</td>
<td>追求吞吐量。同步块执行时间较长</td>
</tr>
</tbody>
</table>
<h2 id="原子操作实现原理"><a href="#原子操作实现原理" class="headerlink" title="原子操作实现原理"></a>原子操作实现原理</h2><p>原子操作意为不可被中断的一个或一系列操作</p>
<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><p>缓存行、比较并交换、cpu流水线、内存顺序冲突</p>
<h3 id="处理器实现原子操作"><a href="#处理器实现原子操作" class="headerlink" title="处理器实现原子操作"></a>处理器实现原子操作</h3><p>处理器通过总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性</p>
<h4 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h4><p>总线锁就是使用处理器提供的一个lock信号，当一个总线输出此信号时，其他处理器的请求将会被阻塞住，那么该处理器就可以独占共享内存。</p>
<h4 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h4><p>缓存锁定是内存区域如果被缓存在处理器的缓存行中，并且在lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言lock信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性会阻止同时修改由两个以上的处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。<br>但是有两种情况下处理器不会使用缓存锁定。<br>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。<br>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<h4 id="java如何实现原子操作"><a href="#java如何实现原子操作" class="headerlink" title="java如何实现原子操作"></a>java如何实现原子操作</h4><p>java中可以通过使用锁和cas实现原子操作<br>1.使用循环cas操作<br>2.cas实现原子操作的三大问题</p>
<ul>
<li>A-&gt;B-&gt;A问题<br>解决思路是使用版本号，在变量前面追加版本号，每次变量改变版本号加一。这个<br>类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
</ul>
<p>3.使用锁机制实现原子操作<br>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><h2 id="java内存查询的基础"><a href="#java内存查询的基础" class="headerlink" title="java内存查询的基础"></a>java内存查询的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><p>两个关键问题：线程之间如何通信以及线程之间如何同步。线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐性通信。在消息传递的并发模型中，线程没有公共状态，线程必须通过发送信息来显性通信。<br>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h3 id="java内存模型的抽象结构"><a href="#java内存模型的抽象结构" class="headerlink" title="java内存模型的抽象结构"></a>java内存模型的抽象结构</h3><p>在java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程间共享。局部变量、方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题。也不受内存模型的影响。<br>java线程的通信由java内存模型(JMM)控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写的共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br><img src="/2017/12/26/java并发编程前三章/java内存模型.png" alt=""><br>如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。<br>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>2）线程B到主内存中去读取线程A之前已更新过的共享变量。<br><img src="/2017/12/26/java并发编程前三章/线程通信.png" alt=""><br>本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p>重排序分为三类：<br>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="/2017/12/26/java并发编程前三章/重排序.png" alt=""><br>1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>现代处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>在JMM中，如果一个操作执行结果需要对另一个操作可见，那么这两个操作必须存在happens-before关系。这里提到的两个操作可以是一个线程内，也可以是不同线程间。<br>·程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问一个变量，且这两个操作有一个是写操作，那么这两个操作就存在数据依赖性。<br>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<br>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as if serial语义"></a>as if serial语义</h3><p>不管怎么重排序，程序的执行结果不能被改变。</p>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.这时B不一定能观察到线程A的写入。因为两个线程之间没有数据依赖性。</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>数据竞争：在一个线程中写一个变量、在另一个线程中读一个变量、而且写和读之间没有通过同步来排序。<br>如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>两大特性：1.一个线程内的所有操作必须按照程序的顺序来执行。2.所有线程只能看到单一的操作执行顺序。在顺序一致性模型中，每个操作都必须原子执行且立刻对所有线程可见。<br>顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摇摆的开关可以连接到任意一个线程，同时每个线程都按照程序的顺序执行内存的读写操作。<br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性模型"><a href="#同步程序的顺序一致性模型" class="headerlink" title="同步程序的顺序一致性模型"></a>同步程序的顺序一致性模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">boolean flag=<span class="literal">false</span>;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">  a=1;</div><div class="line">  flag=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  <span class="keyword">if</span>(flag)&#123;</div><div class="line">    int i=a*a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。<br>JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。为了实现最小安全性，JVM在堆上分配对象，域会默认初始化。<br>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。<br>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。<br>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的<br>操作会按程序的顺序执行<br>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程<br>能看到一致的操作执行顺序。<br>3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><p>理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。<br>锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>volatile变量自身具有下列特性：<br>可见性。对一个volatile变量的读，总能看到任意线程对这个volatile变量的写入。<br>原子性。对任意单个volatile变量的读/写具有原子性。但类似volatile++这种复合操作不具有原子性。</p>
<h3 id="volatile写-读建立的happens-before"><a href="#volatile写-读建立的happens-before" class="headerlink" title="volatile写-读建立的happens-before"></a>volatile写-读建立的happens-before</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class VolatileExample &#123;</div><div class="line"> int a = 0;</div><div class="line"> volatile boolean flag = <span class="literal">false</span>;</div><div class="line"> public void <span class="function"><span class="title">writer</span></span>() &#123;</div><div class="line">    a = 1;　　　　　// 1</div><div class="line">    flag = <span class="literal">true</span>;　　　// 2</div><div class="line"> &#125;</div><div class="line"> public void <span class="function"><span class="title">reader</span></span>() &#123;</div><div class="line">    <span class="keyword">if</span>(flag)&#123;  //3</div><div class="line">      int i=a; //4</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据程序次序规则，1 happens-before 2;3 happens-before 4<br>根据volatile规则，2 happens-before 3<br>根据happens-before的传递性规则，1 happens-before 4</p>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。<br>volatile的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置<br>为无效，线程接下来从主内存中读取共享变量。</p>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p><img src="/2017/12/26/java并发编程前三章/重排序规则.png" alt=""><br>·当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>·当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>·当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。<br>·在每个volatile写操作的前面插入一个StoreStore屏障。<br>·在每个volatile写操作的后面插入一个StoreLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadLoad屏障。<br>·在每个volatile读操作的后面插入一个LoadStore屏障。<br><img src="/2017/12/26/java并发编程前三章/volatile写指令.png" alt=""></p>
<p><img src="/2017/12/26/java并发编程前三章/volatile读指令.png" alt=""></p>
<h3 id="jsr-133为什么要增强volatile语句"><a href="#jsr-133为什么要增强volatile语句" class="headerlink" title="jsr-133为什么要增强volatile语句"></a>jsr-133为什么要增强volatile语句</h3><p>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><h3 id="锁的释放获取"><a href="#锁的释放获取" class="headerlink" title="锁的释放获取"></a>锁的释放获取</h3><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MonitorExample &#123;</div><div class="line">int a = 0;</div><div class="line">public synchronized void <span class="function"><span class="title">writer</span></span>() &#123;　　　　// 1</div><div class="line">a++;　　　　　　　　　　// 2</div><div class="line">&#125;　　　　　　　　　　　　// 3</div><div class="line">public synchronized void <span class="function"><span class="title">reader</span></span>() &#123;　　　// 4</div><div class="line">int i = a;　　　　　　　　// 5</div><div class="line">……</div><div class="line">&#125;　　　　　　　　　　　　// 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。<br>1）根据程序次序规则，1 happens-before 2,2 happens-before 3;4 happens-before 5,5 happens-before 6。<br>2）根据监视器锁规则，3 happens-before 4。<br>3）根据happens-before的传递性，2 happens-before 5。</p>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取到锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>总结：线程A释放一个锁，实质是线程A向接下来将要获取这个锁的某个线程发出了对共享变量所做修改的消息。线程B获取一个锁，实质是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。<br>线程A释放锁，随后线程B获取这个锁，这个过程实质是线程A通过主内存向线程B发送消息。</p>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int a=0;</div><div class="line">ReentrantLock lock=new ReentrantLock();</div><div class="line">public void <span class="function"><span class="title">writer</span></span>()&#123;</div><div class="line">    lock.lock();</div><div class="line">    try&#123;</div><div class="line">       a++;</div><div class="line">    &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">    &#125;finally&#123;</div><div class="line">      lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">reader</span></span>()&#123;</div><div class="line">  lock.lock();</div><div class="line">  try&#123;</div><div class="line">    int i=a;</div><div class="line">  &#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">  &#125;finally&#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer(AQS)，AQS使用一个整形的volatile(state)变量来维护同步状态。<br><img src="/2017/12/26/java并发编程前三章/ReentrantLock类图.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，使用公平锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ReentrantLock:lock();</div><div class="line">FairSync:lock();</div><div class="line">AbstractQueuedSynchronizer:acquire(int arg);</div><div class="line">ReentrantLock:tryAcquire(int acquire);</div><div class="line">FairSync:</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    final Thread current = Thread.currentThread();</div><div class="line">    int c = getState();</div><div class="line">    <span class="keyword">if</span>(c == 0)&#123;</div><div class="line">        <span class="keyword">if</span>(!hasQueuedPredecessors() &amp;&amp;compareAndSetState(0, acquires))&#123;</div><div class="line">            <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</div><div class="line">      int nextc = c + acquires;</div><div class="line">      <span class="keyword">if</span>(nextc &lt; 0)</div><div class="line">          throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">      <span class="built_in">set</span>State(nextc);</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加锁方法首先读volatile变量state<br>在使用公平锁时，解锁方法unlock()调用轨迹如下。<br>1）ReentrantLock:unlock()。<br>2）AbstractQueuedSynchronizer:release(int arg)。<br>3）Sync:tryRelease(int releases)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    int c =getState()- releases;</div><div class="line">    <span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line">    boolean free = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(c == 0) &#123;</div><div class="line">        free = <span class="literal">true</span>;</div><div class="line">        <span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span>State(c);</div><div class="line">    <span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在释放锁的最后写volatile变量state。<br>公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。<br>这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。<br>1）ReentrantLock:lock()。<br>2）NonfairSync:lock()。<br>3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。<br>现在对公平锁和非公平锁的内存语义做个总结。<br>·公平锁和非公平锁释放时，最后都要写一个volatile变量state。<br>·公平锁获取时，首先会去读volatile变量。<br>·非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</p>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>java的CAS同时具有volatile读和volatile写的内存语义，因此java线程之间的通信有了下面四种方式：<br>1）A线程写volatile变量，随后B线程读这个volatile变量。<br>2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。<br>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。<br>首先，声明共享变量为volatile。<br>然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。<br>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
<h2 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h2><p>对final域的读和写更像是普通的变量访问。</p>
<h3 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h3><p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用<br>变量，这两个操作之间不能重排序。<br>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能<br>重排序。</p>
<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><p>1）JMM禁止编译器把final域的写重排序到构造函数之外；<br>2）编译器会在final域写之后，构造函数return之前，插入一个storestore。这个屏障会禁止处理器把final域的写重排序到构造函数之外。<br>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><p>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。<br>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h3 id="final为引用类型"><a href="#final为引用类型" class="headerlink" title="final为引用类型"></a>final为引用类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FinalReferenceExample &#123;</div><div class="line">final int[] intArray; // final是引用类型</div><div class="line">static FinalReferenceExample obj;</div><div class="line">public <span class="function"><span class="title">FinalReferenceExample</span></span> () &#123; // 构造函数</div><div class="line">intArray = new int[1]; // 1</div><div class="line">intArray[0] = 1; // 2</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerOne</span></span> () &#123; // 写线程A执行</div><div class="line">obj = new FinalReferenceExample (); // 3</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">writerTwo</span></span> () &#123; // 写线程B执行</div><div class="line">obj.intArray[0] = 2; // 4</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">reader</span></span> () &#123; // 读线程C执行</div><div class="line"><span class="keyword">if</span>(obj != null) &#123; // 5</div><div class="line">int temp1 = obj.intArray[0]; // 6</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader()方法.JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<h3 id="为什么final引用不能从构造函数内“溢出”"><a href="#为什么final引用不能从构造函数内“溢出”" class="headerlink" title="为什么final引用不能从构造函数内“溢出”"></a>为什么final引用不能从构造函数内“溢出”</h3><p>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程#都能看到这个final域在构造函数中被初始化之后的值。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><p>JMM目标：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。<br>JMM保证两点：</p>
<ol>
<li>JMM向程序员提供的happens-before能够保证程序员的需求。JMM的happens-before规则不但简单且易懂，而且向程序员提供了足够强的内存可见性保证。</li>
<li>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实在遵循一个基本原则：只要不改变程序的执行结果，编译器和处理器怎么优化都可以。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ol>
<h3 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h3><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作执行顺序排在第二个操作之前。<br>2）两个操作之间存在着happens-before关系，并不意味着java平台具体实现按照happens-before关系指定的顺序来执行。如果重排序的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法。<br>上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。<br>上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。<br>·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。<br>·as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><ol>
<li>程序顺序规则：一个程序的每个操作，happens-before与该线程的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before与后续对这个volatile的读</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执行操作ThreadB.start,那么A线程的start操作happens-before线程B的任何操作。</li>
<li>join规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ol>
<h2 id="双重检查锁和延迟初始化"><a href="#双重检查锁和延迟初始化" class="headerlink" title="双重检查锁和延迟初始化"></a>双重检查锁和延迟初始化</h2><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<h3 id="双重锁检查锁定的由来"><a href="#双重锁检查锁定的由来" class="headerlink" title="双重锁检查锁定的由来"></a>双重锁检查锁定的由来</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public synchronized static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;</div><div class="line">        single=new Singleton();</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美。<br>·多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。<br>·在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h3 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h3><p>single=new Singleton();创建了一个对象。这一行代码可以分解为如下的3行伪代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div><div class="line">single = memory;　　// 3：设置instance指向刚分配的内存地址</div></pre></td></tr></table></figure></p>
<p>上面3行伪代码中的2和3之间，可能会被重排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">memory = allocate();　　// 1：分配对象的内存空间</div><div class="line">instance = memory;　　// 3：设置instance指向刚分配的内存地址</div><div class="line">// 注意，此时对象还没有被初始化！</div><div class="line">ctorInstance(memory);　// 2：初始化对象</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/26/java并发编程前三章/多线程执行时序.png" alt=""></p>
<h3 id="基于volatile解决"><a href="#基于volatile解决" class="headerlink" title="基于volatile解决"></a>基于volatile解决</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static Singleton single;</div><div class="line">    public  static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(single==null)&#123;   //4</div><div class="line">        synchronized(Singleton.class)&#123;</div><div class="line">          <span class="keyword">if</span>(single==null)&#123;</div><div class="line">            single=new Singleton();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当声明对象的引用为volatile后,伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><p>VM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class InstanceFactory&#123;</div><div class="line"></div><div class="line">  private static class InstanceHolder&#123;</div><div class="line">    public static Instance instance=new Instance();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> public static Instance <span class="function"><span class="title">getInstance</span></span>()&#123;</div><div class="line">         <span class="built_in">return</span> InstanceHoleder.instance;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了<br>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。<br>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。<br>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。<br>第4阶段：线程B结束类的初始化处理。<br>第5阶段：线程C执行类的初始化的处理。<br>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。</p>
<h2 id="java内存模型综述"><a href="#java内存模型综述" class="headerlink" title="java内存模型综述"></a>java内存模型综述</h2><h3 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h3><p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。<br>·放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。<br>·在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>·在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了RelaxedMemory Order内存模型（简称为RMO）和PowerPC内存模型。<br>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的<br>JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h3 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h3><p>JMM是一种语言参考模型，处理器内存模型是硬件级的内存模型，顺序一致性模型是一个理论参考模型。<br>常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按照程序类型，java程序的内存可见性保证可以分为3类：</p>
<ul>
<li>单线程程序<br>单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果跟该程序在顺序一致性模型中执行的结果一样。</li>
<li>正确同步的多线程程序<br>正确同步的多线程程序的执行将具有顺序一致性。这是JMM关注的重点。JMM通过限制编译器和处理器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>对于未同步或未正确同步的多线程程序<br>JMM提供了最小安全保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，false，null）</li>
</ul>
<p>最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们“发生”的时间点也不同。最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会无中生<br>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h3 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h3><ul>
<li>增强volatile变量的内存语义。旧内存模型允许volatile变量和普通变量进行重排序。JSR-133严格限制volatile变量与普通变量的重排序，使得volatile的写和读和和锁的释放-获取有相同的语义</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量可能有所不同。为此jsr-133增加两个重排规则，在保证final引用不会从构造函数内溢出的情况，final具有了初始化的安全。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="java并发编程艺术读书笔记" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统基础设施</title>
    <link href="http://yoursite.com/2017/12/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://yoursite.com/2017/12/21/分布式系统基础设施/</id>
    <published>2017-12-21T15:01:53.000Z</published>
    <updated>2017-12-25T08:23:39.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>在高并发环境下，大量的读、写请求涌向数据库，磁盘的读写速度与内存显然不在一个量级，从减轻数据库的压力和提高系统响应两个角度来考虑，一般都会在数据库层加一层缓存。由于单台机器的内存资源和承载有限，并且如果大量使用本地缓存，也会使相同数据被不同的节点存储多份，对内存资源造成较大的浪费，因此催生出分布式缓存。分布式缓存的经典代表是memcache，最经典的场景是分布式session。</p>
<h3 id="memchache简介及安装"><a href="#memchache简介及安装" class="headerlink" title="memchache简介及安装"></a>memchache简介及安装</h3><p>memcache使用key-value的形式存储和访问数据，在内存中维护一张巨大的hashtable，使得数据查询的时间复杂度降低到O(1),保证高性能的访问。内存的空间是有限的，当内存没有足够空间存储新的数据，memcache就会使用LRU算法，将最近步长访问的数据淘汰掉，以腾出新的空间存放。memcache支持的数据格式多样化，通过对象序列化转成二进制数据，又可以通过反序列化还原原有对象。<br>windows安装：[<a href="http://kimi.it/258.html" target="_blank" rel="external">http://kimi.it/258.html</a>]<br>linux安装：[<a href="http://kimi.it/257.html" target="_blank" rel="external">http://kimi.it/257.html</a>]<br>备注：windows安装要在管理员命令行安装</p>
<h3 id="memcache-java-api与分布式"><a href="#memcache-java-api与分布式" class="headerlink" title="memcache java api与分布式"></a>memcache java api与分布式</h3><p>java api：<br>[<a href="http://blog.csdn.net/seelye/article/details/8511073" target="_blank" rel="external">http://blog.csdn.net/seelye/article/details/8511073</a>], [<a href="http://acooly.iteye.com/blog/1120347" target="_blank" rel="external">http://acooly.iteye.com/blog/1120347</a>]<br>memcache本身不是分布式缓存系统，它的分布式是由访问的客户端来实现，一种比较简单的方式是通过缓存的key来进行哈希，当后端有N台缓存服务器时，访问的服务器为hash(key)%N,这样请求就均衡地映射到后端缓存服务器，但是需要新增时服务器时，大部分的key将会重新分布，会导致请求访问不到缓存进而访问数据库，导致雪崩。<br>一致性哈希算法可以改善这个问题：将哈希函数的值域空间组织成一个圆环，整个空间按照瞬时间方向组织，然后对应的服务器节点进行哈希，将他们映射在哈希环上。<br><img src="/2017/12/21/分布式系统基础设施/一致性哈希.png" alt=""><br>这样子当新增一个节点后，只影响局部的节点，避免大量key重新映射。当节点数量很少时，可能导致分布不均匀，引入虚拟节点机制，key的映射不变，只是多了虚拟节点映射到真实节点的过程。<br>java中一致性哈希的实现：<br>[<a href="http://blog.csdn.net/kinger0/article/details/49760751" target="_blank" rel="external">http://blog.csdn.net/kinger0/article/details/49760751</a>]</p>
<h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>传统的应用服务器，如tomcat、jboss，其自身实现的session管理大部分是基于单机的。对于大型分布式网站来说，支撑其业务的远远不止一台服务器，而是分布式集群，请求在不同服务器之间跳转。传统的做法是通过cookie进行session同步，但是cooie有安全性问题，还有存储的数据大小是有限制的，加上需要兼容移动端的session。<br>对于系统可靠性要求较高的用户，可以将session持久化到DB中，这样可以保证宕机时不易丢失，但是系统整体吞吐量会受到影响。另一种方式是session统一存储到缓存集群里，如memcache，这样可以保证有较高的读、写性能，从安全性角度看，session是有有效期的，使用缓存存储便于利用缓存失效机制。<br><img src="/2017/12/21/分布式系统基础设施/分布式session.png" alt=""><br>tomcat的web server举例，通过memcached-session-manager实现分布式session。<br>[<a href="http://chenzhou123520.iteye.com/blog/1650212" target="_blank" rel="external">http://chenzhou123520.iteye.com/blog/1650212</a>]</p>
<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="mysql扩展"><a href="#mysql扩展" class="headerlink" title="mysql扩展"></a>mysql扩展</h3><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><p><img src="/2017/12/21/分布式系统基础设施/业务拆分.png" alt=""></p>
<h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>通过数据库的复制策略，可以将一台mysql数据库服务器中的数据复制到其他mysql数据库服务器，通过读写分离。前端服务器通过master执行数据写入，数据的更新通过binary log同步到slave集群，对于数据读取请求，交由slave处理。master-slave架构能减轻单库读的压力。<br><img src="/2017/12/21/分布式系统基础设施/master-slave.png" alt=""><br>master-slaves架构存在着单点故障的问题。最佳的方式是采用dual-master架构。<br>这种架构下，两台服务器互相将对方视为自己的master，这样就可以互相同步消息，并且通过server-id，就不会出现循环复制。通常情况下，我们仅开启一台master的写入，另一台master作为standby或者读库开放，这样可以避免数据写入冲突，防止数据不一致。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>对于访问频繁且数据量巨大的单表来说，首先要做的是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐量。<br><img src="/2017/12/21/分布式系统基础设施/分表.png" alt=""><br>分表能解决单表数据量过大带来的查询效率下降的问题。却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库Master服务器无法承载写操作压力时，不管怎么扩展slave服务器，此时都没有意义。所以我们可以采用分库。<br><img src="/2017/12/21/分布式系统基础设施/分库.png" alt=""></p>
<h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><p><img src="/2017/12/21/分布式系统基础设施/hbase.png" alt=""></p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h4><p>[<a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="external">http://www.runoob.com/redis/redis-install.html</a>]</p>
<h4 id="redis-java-api"><a href="#redis-java-api" class="headerlink" title="redis java api"></a>redis java api</h4><p>[<a href="https://www.cnblogs.com/libaoting/p/4418007.html" target="_blank" rel="external">https://www.cnblogs.com/libaoting/p/4418007.html</a>]</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="/2017/12/21/分布式系统基础设施/jms和amqp.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/mq对比2.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/mq对比.png" alt=""></p>
<h2 id="垂直化搜索引擎"><a href="#垂直化搜索引擎" class="headerlink" title="垂直化搜索引擎"></a>垂直化搜索引擎</h2><p>垂直搜索引擎既能满足用户对于全文检索、模糊匹配的需求，解决数据库like查询效率低下问题。又能解决分布式分库分表后或者使用nosql无法进行多表关联和复杂查询。<br><img src="/2017/12/21/分布式系统基础设施/luecene.png" alt=""></p>
<h3 id="搜索引擎的重要概念"><a href="#搜索引擎的重要概念" class="headerlink" title="搜索引擎的重要概念"></a>搜索引擎的重要概念</h3><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>将文档的词作为关键字，建立词与文档的映射关系，通过对倒排索引的检索，可以根据词可以迅速获取包含这个词的文档列表。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>分词就是将句子或者段落进行切割，从中提取出包含固定语义的词。对于英语来说，语言的基本单位是单词。但对于中文来说，多个中文字组合一起才能表达一个具体含义的词。这里推荐使用ik-analyer分词库。</p>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><p>对于没有具体含义、区分度低的词，搜索引擎对这些词进行检索没有意义，因此停用词可以忽略。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>最经典的是tf-idf算法。</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是一切域的组合</p>
<h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>每个文档包含了域的名称和域的对应值，域可以是不同值，如整数，浮点数，字符串</p>
<h4 id="词"><a href="#词" class="headerlink" title="词"></a>词</h4><p>term是搜索的基本单元</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>TermQuery、phraseQuery、BoolQuery、TermRangeQuery、NumericRangeQuery、PrefixQuery</p>
<h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><p>文档在被索引之前，需要经过分词器处理建立索引<br><img src="/2017/12/21/分布式系统基础设施/建立索引.png" alt=""><br><img src="/2017/12/21/分布式系统基础设施/search.png" alt=""></p>
<h3 id="lucene的使用"><a href="#lucene的使用" class="headerlink" title="lucene的使用"></a>lucene的使用</h3><ol>
<li>建立索引</li>
<li>索引更新与删除<br>lucene还不支持单个阈的更新，而是先删除，后添加</li>
<li>条件查询</li>
<li>结果排序</li>
<li>高亮</li>
<li>中文分词（推荐ik-analyer）</li>
<li>索引优化<br>Lucene索引是由段组成，每个段可能有多个索引文件，即每个段包含一个或者多个document；段结构可以使lucene很好的支持增量索引，新增的document将被添加到新的索引段当中。但是越来越多的段被添加到索引当中，索引文件也越来越多。但是操作系统打开文件的句柄数是有限的。lucene在执行搜索时，分别搜索每一段，然后将结果合并，这样查询的性能会降低。<br>为了提高查询性能，当索引段到达一个上限后，Lucene会自动进行索引段的优化，将索引段合并成一个，以提高查询性能，并减少打开文件句柄数量。但是索引段合并需要大量的io操作，使得查询性能受损。我们可以每隔一段时间对索引进行一次全量的重建操作，以将增量更新所生成的索引段合并。</li>
<li>分布式扩展<br>搜索应用的大部分场景都能接受一定的时间延迟，可以采用最终一致性。<br>索引读写分离架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene读写分离.png" alt=""><br>每份query server保存一份完整的索引，该索引由dump server周期性生成，并进行索引段的合并，索引生成好后推送到每台query server进行替换，这样避免集群索引dump对后端存储造成的压力。当然对于增量索引的更新，dump server可以异步更新推送到每台query server。对于前端应用中，通过对请求进行哈希，将请求均衡地分布到集群的每台服务器。<br>索引切分架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene切分.png" alt=""><br>单机对索引的存储能力有限，随着索引数量的增加，索引的速度也会下降，此时索引本身已经成为系统的瓶颈，这时需要对索引进行切分，将索引分布到各个集群机器上，提高查询性能，降低存储压力。<br>merge server将索引分发给index server，最后将查询结果合并，返回给client应用。但是这有时候会导致排序和真实的结果会存在不一样。<br>综合两种架构：<br><img src="/2017/12/21/分布式系统基础设施/lucene综合.png" alt=""><h3 id="solr"><a href="#solr" class="headerlink" title="solr"></a>solr</h3>安装配置：[<a href="http://blog.csdn.net/jack__ming/article/details/72615162" target="_blank" rel="external">http://blog.csdn.net/jack__ming/article/details/72615162</a>]<h3 id="es和solr的优缺点"><a href="#es和solr的优缺点" class="headerlink" title="es和solr的优缺点"></a>es和solr的优缺点</h3>[<a href="http://www.cnblogs.com/chowmin/articles/4629220.html" target="_blank" rel="external">http://www.cnblogs.com/chowmin/articles/4629220.html</a>]<h2 id="其他设施"><a href="#其他设施" class="headerlink" title="其他设施"></a>其他设施</h2></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式缓存&quot;&gt;&lt;a href=&quot;#分布式缓存&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存&quot;&gt;&lt;/a&gt;分布式缓存&lt;/h2&gt;&lt;p&gt;在高并发环境下，大量的读、写请求涌向数据库，磁盘的读写速度与内存显然不在一个量级，从减轻数据库的压力和提高系统响应两
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向服务的体系架构-SOA(第一章)</title>
    <link href="http://yoursite.com/2017/12/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-SOA/"/>
    <id>http://yoursite.com/2017/12/21/面向服务的体系架构-SOA/</id>
    <published>2017-12-21T02:57:29.000Z</published>
    <updated>2017-12-21T14:48:02.696Z</updated>
    
    <content type="html"><![CDATA[<p>伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提供服务，达成业务之间相互复用，系统也因此演变为分布式应用架构体系。<br>基于http协议之间的系统间的RPC，具有使用灵活、实现便捷、开放且天生支持异构平台间的调用等多个优点。与之对应的是tcp协议的实现版本，效率更高，实现更复杂，但由于协议和标准不同，很难跨平台和企业间的通信。</p>
<h2 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h2><h3 id="RPC名词解释"><a href="#RPC名词解释" class="headerlink" title="RPC名词解释"></a>RPC名词解释</h3><p>remote process call，远程过程调用，拥有着RMI、webservice等诸多成熟的方案。RPC将原来的本地调用转变为调用远端的服务器上的方法。<br>RPC的实现包括客户端和服务器端，即服务的调用方和服务提供方。服务调用方发送RPC请求到服务提供方，服务提供方根据调用方提供的参数执行请求方法，将执行结果返回给调用方。其中参数和返回结果序列化。</p>
<h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>将对象转成二进制流的过程称为对象的序列化<br>将二进制流转成对象的过程称为对象的反序列化<br>对象的序列化和反序列化有很多成熟的方案：Google protocol Buffers协议、java内置的序列化方式、Hessian、json以及xml。</p>
<h3 id="基于TCP实现的RPC"><a href="#基于TCP实现的RPC" class="headerlink" title="基于TCP实现的RPC"></a>基于TCP实现的RPC</h3><p>基于java socket的api，能够实现简单的RPC调用。</p>
<h2 id="基于http协议的RPC"><a href="#基于http协议的RPC" class="headerlink" title="基于http协议的RPC"></a>基于http协议的RPC</h2><h3 id="http协议栈"><a href="#http协议栈" class="headerlink" title="http协议栈"></a>http协议栈</h3><p>Http是Hypertext Transfer Protocol（超文本传输协议）的缩写，当今采用的版本主要是http1.1。<br>http属于应用层，构建在tcp和ip协议之上，处于tcp/ip协议的最顶层，它不需要处理下层协议间诸如丢包补发、握手及数据分段和重新组装的细节。<br><img src="/2017/12/21/面向服务的体系架构-SOA/协议.png" alt=""></p>
<h3 id="http请求与响应"><a href="#http请求与响应" class="headerlink" title="http请求与响应"></a>http请求与响应</h3><p><img src="面向服务的体系架构-SOA/http请求.png" alt=""></p>
<h3 id="通过HttpClient发送http请求"><a href="#通过HttpClient发送http请求" class="headerlink" title="通过HttpClient发送http请求"></a>通过HttpClient发送http请求</h3><h3 id="使用Http协议的优势"><a href="#使用Http协议的优势" class="headerlink" title="使用Http协议的优势"></a>使用Http协议的优势</h3><p>基于http协议的，很多成熟的开源web容器已经帮助解决了很多问题，如tomcat、jboss、Apache，这使得开发人员将更多的精力集中在业务的实现而非处理底层细节。<br>但http也有其劣势的一面，相同内容信息，http协议传输用的字节数肯定比tcp用的字节数更多，同等网络下，效率也比较低，信息传输用的时间更长。</p>
<h3 id="Json和xml"><a href="#Json和xml" class="headerlink" title="Json和xml"></a>Json和xml</h3><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>json是一种轻量级的数据交换语言，以文字为基础，易于阅读。将对象序列化为json格式，可以在网络上很方便的传输，且各个平台几乎都拥有成熟的工具，能很快地将json反序列化为其对应语言的所需要的格式。<br>使用jackson包</p>
<h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><p>xml的全称是可扩展标记语言（extensible markup language），可以标记数据、定义数据类型，是允许用户对自己的标记语言进行定义，用于标记电子文件使其具有结构性的源语言。xml提供统一的方法来描述和交换独立于应用程序和供应商的结构化数据，非常适合web传输。<br>可以使用xstream包</p>
<h3 id="restful和RPC"><a href="#restful和RPC" class="headerlink" title="restful和RPC"></a>restful和RPC</h3><p>主流url链接风格主要有两种：一种是RPC风格，另一种是Rest风格。</p>
<h4 id="RPC风格"><a href="#RPC风格" class="headerlink" title="RPC风格"></a>RPC风格</h4><p>RPC的风格是直接在http请求参数标明需要远程调用的服务接口名称、服务参数即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://hostname/provider.do?service=xxx.sayHello&amp;arg1=xxx</div></pre></td></tr></table></figure></p>
<h4 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h4><p>Rest是Representation state transform，表现层状态转移。<br>在表现层状态转移过程中，表现层指的是资源的表现层，资源是网络的实体，是一张图片、一首歌曲、一段文本，你可以用url进行访问。资源通过表现层呈现出来，比如图片通过png表现，文本通过html表现。访问一个资源，需要客户端和服务器端进行一定的交互，势必涉及数据和状态的变化，http是无状态协议，因此所有的状态都保存在服务器端。如果客户端想要操作服务端，必须通过某种手段，这种手段就是http协议的集中操作方式，如GET、PUT、POST、DELETE。这便是rest原则的思想，符合rest原则设计的就是restful风格。<br>restful风格就是通过http请求对应的GET、POST、PUT、DELETE方法，完成对应的CRUD操作。<br><img src="/2017/12/21/面向服务的体系架构-SOA/restful.png" alt=""></p>
<h3 id="基于http协议的RPC实现"><a href="#基于http协议的RPC实现" class="headerlink" title="基于http协议的RPC实现"></a>基于http协议的RPC实现</h3><p>类似我开发的数据交换平台的http接口</p>
<h2 id="服务的路由和负载均衡"><a href="#服务的路由和负载均衡" class="headerlink" title="服务的路由和负载均衡"></a>服务的路由和负载均衡</h2><h3 id="服务化的演变"><a href="#服务化的演变" class="headerlink" title="服务化的演变"></a>服务化的演变</h3><p>分布式应用架构体系对于业务逻辑复用的需求十分强烈，上层应用都想借用已有的底层服务，来搭建更多、更丰富的应用。公共的业务被拆分出来，形成可共用的服务，最大程度的保障了代码和逻辑的复用，避免重复建设，这种设计也称SOA。<br>SOA架构中，服务消费者通过服务名称，在众多服务中找到要调用的服务的地址列表，称为服务的路由。<br><img src="/2017/12/21/面向服务的体系架构-SOA/服务路由.png" alt=""><br>对于负载比较高的服务来说，往往对应着多台服务器的集群，在请求到来时，为了将请求均衡地分配到后端服务器，负载均衡服务器将从服务对应的地址列表中，通过相应的负载均衡算法和规则，选择一台服务器进行访问，这个过程称为服务的负载均衡。<br>当服务的规模比较小时，可以采用硬编码的方式将服务地址和配置写在代码中，通过编码的方式来解决服务的路由和负载均衡问题，也可以通过传统的硬件负载均衡设备如F5或者采用LVS或者Nginx等软件解决方案，通过相关配置来解决服务的路由和负载均衡问题。<br>当服务越来越多，规模越来越大时，对应的机器数量也越来越大，单靠人工来管理和维护服务和地址的配置信息也越来越困难，依赖单点设备或者使用LVS、Nginx等软件方案进行路由和负载均衡调度，单点问题也开始出现，一旦服务路由和负载均衡服务器宕机，依赖它的所有服务均将失效。<br>此时需要一个能够动态注册和获取服务信息的地方，来统一管理服务名称和其对应的服务器列表信息，称之为服务配置中心。服务在启动时将其服务名、服务器地址注册到配置中心，服务消费者通过服务配置中心获取需要获取服务的机器列表，通过相应的负载均衡列表，选取其中一台服务器进行调用。当服务器进行宕机或者下线时，相应的机器需要能够动态地从服务配置中心里面移除，并通知相应的服务消费者。在这个过程中，服务消费者只有第一次调用需要查询服务配置中心，然后将查询的信息缓存到本地，后面的调用直接使用本地缓存的服务地址信息列表，知道服务的地址列表更新，这种无中心化的结构解决了之前负载均衡的设备导致的单点问题。<br>基于zookeeper的的持久节点和非持久节点，我们能够近乎实时地感觉到后端服务器的状态。通过集群间的zab协议，使得服务配置信息能够保持一致，zookeeper本身的容错和leader选举机制，保障了扩容性。<br><img src="/2017/12/21/面向服务的体系架构-SOA/zookeeper负载均衡.png" alt=""></p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h4><p>将请求按顺序轮流的分配到后端服务器，它均衡地对待后端每一台服务器，而不关心服务器实际的连接数和当前的系统负载</p>
<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>通过系统函数，根据后端服务器列表大小值来随机选取一台访问</p>
<h4 id="源地址哈希表"><a href="#源地址哈希表" class="headerlink" title="源地址哈希表"></a>源地址哈希表</h4><p>获取客户端访问的ip地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表大小进行取模运算，得到的结果就是要访问的服务器序号。同一ip地址的客户端当服务器的列表不变时，它每次都会映射到同一台后端服务器访问。</p>
<h4 id="加权轮询法"><a href="#加权轮询法" class="headerlink" title="加权轮询法"></a>加权轮询法</h4><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此他们的抗压能力也不尽相同。给配置高负载低的机器配置更高的权重，让其处理更多的请求，给配置低负载高的配置更低的权重，降低其系统的负载，</p>
<h4 id="加权随机法"><a href="#加权随机法" class="headerlink" title="加权随机法"></a>加权随机法</h4><h4 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h4><p>最小连接数算法比较灵活和智能，由于后端的服务器不尽相同，对于请求的处理有快有慢，它根据后端服务器当前连接的情况，动态的选取当前积压连接数最小的服务器来处理当前请求，尽可能提高后端服务器的利用效率，将负载合理地分流给每一台机器。</p>
<h3 id="动态配置规则"><a href="#动态配置规则" class="headerlink" title="动态配置规则"></a>动态配置规则</h3><p>把这部分代码剥离出来，采用动态配置规则，使用groovy脚本语言直接编译成java的class字节码，运行在java虚拟机上。</p>
<h3 id="zookeeper介绍和环境搭建"><a href="#zookeeper介绍和环境搭建" class="headerlink" title="zookeeper介绍和环境搭建"></a>zookeeper介绍和环境搭建</h3><h3 id="zk的api使用"><a href="#zk的api使用" class="headerlink" title="zk的api使用"></a>zk的api使用</h3><h3 id="zkclient的使用"><a href="#zkclient的使用" class="headerlink" title="zkclient的使用"></a>zkclient的使用</h3><p>github源码：<a href="https://github.com/sgroschupf/zkclient.git" target="_blank" rel="external">https://github.com/sgroschupf/zkclient.git</a></p>
<h3 id="路由和负载均衡的实现"><a href="#路由和负载均衡的实现" class="headerlink" title="路由和负载均衡的实现"></a>路由和负载均衡的实现</h3><p>通过注册相应的watcher，服务消费者能够第一时间获知服务提供者机器信息的变更。利用其znode的特点和watcher机制，将其作为动态注册和获取服务信息的配置中心。<br><img src="/2017/12/21/面向服务的体系架构-SOA/服务配置节点树.png" alt=""><br>配置中心分三层，根节点为用来聚集服务的节点，通过它可以查询到所有服务，而节点名称挂载的是服务提供者提供的服务地址，服务消费者通过负载均衡算法选择其中一个地址发起远程调用。根节点和服务名称采用的是zk的持久化节点，服务提供者的地址节点是zk的非持久化节点，一旦服务器宕机或者下线，节点就会消失。<br><img src="/2017/12/21/面向服务的体系架构-SOA/zk节点.png" alt=""><br>增加一层，用来表示节点类型，每个服务包含两种节点类型，即consumer和provider，当服务消费者启动时，即在服务配置中心里，在其调用的所有服务的consumer节点下增加自己的机器地址，只需要后台监控程序解析出对应服务的consumer节点的子节点，便能清楚的知道某一服务被哪些机器消费了。</p>
<h2 id="http服务网关"><a href="#http服务网关" class="headerlink" title="http服务网关"></a>http服务网关</h2><p><img src="/2017/12/21/面向服务的体系架构-SOA/网关1.png" alt=""><br>gateway外部各种app的http请求，完成相应的权限和安全验证，当验证通过，根据传过的服务名称，到服务配置中心找到相应的服务名称节点，并加载对应服务提供者提供的地址列表，通过前面的负载均衡算法选取机器发起远程调用，将客户端参数传到服务端。服务提供方根据传入的参数，给出响应，当gateway收到响应后，再将响应返回给App<br>一方面通过网关可以很好解决安全问题，在恶意请求或者非授权请求到达后端会进行拦截。另一方面网关可以通过服务的路由进行负载均衡<br><img src="/2017/12/21/面向服务的体系架构-SOA/网关集群.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化ActiveMQ性能</title>
    <link href="http://yoursite.com/2017/12/20/%E4%BC%98%E5%8C%96ActiveMQ%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2017/12/20/优化ActiveMQ性能/</id>
    <published>2017-12-20T14:25:04.000Z</published>
    <updated>2017-12-20T14:55:09.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化和非持久化传递"><a href="#持久化和非持久化传递" class="headerlink" title="持久化和非持久化传递"></a>持久化和非持久化传递</h2><h3 id="持久化消息"><a href="#持久化消息" class="headerlink" title="持久化消息"></a>持久化消息</h3><p>这是 ActiveMQ 的默认传送模式，此模式保证这些消息只被传送一次和成功使用一次。对于这些消息，可靠性是优先考虑的因素。可靠性的另一个重要方面是确保持久性消息传送至目标后，消息服务在向消费者传送它们之前不会丢失这些消息。这意味着在持久性消息传送至目标时，消息服务将其放入持久性数据存储。如果消息服务由于某种原因导致失败，它可以恢复此消息并将此消息传送至相应的消费者。虽然这样增加了消息传送的开销，但却增加了可靠性。</p>
<h3 id="非持久化消息"><a href="#非持久化消息" class="headerlink" title="非持久化消息"></a>非持久化消息</h3><p>保证这些消息最多被传送一次。对于这些消息，可靠性并非主要的考虑因素。此模式并不要求持久性的数据存储，也不保证消息服务由于某种原因导致失败后消息不会丢失。<br>Non-persistent 传递消息比 Persistents 传递消息速度更快，原因如下：<br>Non-persistent 发送消息是异步的， Producer 不需要等待 Consumer 的 receipt消息。<br>Persisting 传递消息是需要把消息存储起来。然后在传递，这样很慢 。</p>
<h2 id="超快回应消息"><a href="#超快回应消息" class="headerlink" title="超快回应消息"></a>超快回应消息</h2><p>内嵌 broker</p>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>Transaction 比 Non-transaction 的性能高</p>
<h2 id="Tuning-the-OpenWire-protocol"><a href="#Tuning-the-OpenWire-protocol" class="headerlink" title="Tuning the OpenWire protocol"></a>Tuning the OpenWire protocol</h2><p>跨语言协议</p>
<h2 id="uning-the-TCP-Transport"><a href="#uning-the-TCP-Transport" class="headerlink" title="uning the TCP Transport"></a>uning the TCP Transport</h2><p>TCP 协议是 ActiveMQ 使用最常见的协议。<br>有以下两点影响 TCP 协议性能：<br>1) socketBufferSize=缓存，默认是 65536。<br>2) tcpNoDelay=默认是 false，</p>
<h2 id="优化消息消费者"><a href="#优化消息消费者" class="headerlink" title="优化消息消费者"></a>优化消息消费者</h2><h3 id="Prefetch-Limit"><a href="#Prefetch-Limit" class="headerlink" title="Prefetch Limit"></a>Prefetch Limit</h3><p>ActiveMQ 默认的 prefetch 大小不同的：<br>Queue Consumer 默认大小=1000<br>Queue Browser Consumer 默认大小=500<br>Persistent Topic Consumer 默认大小=100<br>Non-persistent Topic Consumer 默认大小=32766</p>
<h3 id="Delivery-and-Acknowledgement-of-messages"><a href="#Delivery-and-Acknowledgement-of-messages" class="headerlink" title="Delivery and Acknowledgement of messages"></a>Delivery and Acknowledgement of messages</h3><p>建议使用 Session.DUPS_ACKNOWLEDGE。<br>JMS 消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中， 消息何时被确认取决于创建会话时的应答模式 （acknowledgement mode） 。<br>该参数有以下三个可选值：<br>Session.AUTO_ACKNOWLEDGE。当客户成功的从 receive 方法返回的时候，或者从MessageListener.onMessage 方法成功返回的时候，会话自动确认客户收到的消息<br>Sessiion.TRANSACTION。用 session.commit()回执确认。<br>Session.CLIENT_ACKNOWLEDGE。客户通过消息的 acknowledge 方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了 10 个消息，然后确认第 5 个消息，那么所有 10 个消息都被确认。<br>Session.DUPS_ACKNOWLEDGE。该选择只是会话迟钝第确认消息的提交。当消息到达一定数量后，才开始消费该消息。如果 JMS provider 失败，那么可能会导致一些重复的消息。如果是重复的消息，那么 JMS provider 必须把消息头的 JMSRedelivered 字段设置为 true。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;持久化和非持久化传递&quot;&gt;&lt;a href=&quot;#持久化和非持久化传递&quot; class=&quot;headerlink&quot; title=&quot;持久化和非持久化传递&quot;&gt;&lt;/a&gt;持久化和非持久化传递&lt;/h2&gt;&lt;h3 id=&quot;持久化消息&quot;&gt;&lt;a href=&quot;#持久化消息&quot; class=&quot;he
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>activemq先进特性和优化性能</title>
    <link href="http://yoursite.com/2017/12/19/activemq%E5%85%88%E8%BF%9B%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/12/19/activemq先进特性/</id>
    <published>2017-12-19T15:07:38.000Z</published>
    <updated>2017-12-20T14:24:32.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先进特性"><a href="#先进特性" class="headerlink" title="先进特性"></a>先进特性</h1><h2 id="Destination-Features"><a href="#Destination-Features" class="headerlink" title="Destination Features"></a>Destination Features</h2><h3 id="Composite-Destinations"><a href="#Composite-Destinations" class="headerlink" title="Composite Destinations"></a>Composite Destinations</h3><p>ActiveMQ 支持 composite destinations。它允许用一个虚拟的destination 代表多个 destinations。例如你可以通过 composite destinations 在一个操作中同时向 12 个 queue 发送消息。在 composite destinations 中，多个 destination之间采用”,”分割。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Queue queue =  new ActiveMQQueue(<span class="string">"FOO.A,FOO.B,FOO.C"</span>)</div><div class="line">&lt;destinationInterceptors&gt;</div><div class="line"> &lt;virtualDestinat ionInterceptor&gt;</div><div class="line"> &lt;virtualDestinations&gt;</div><div class="line"> &lt;compositeQueue name=<span class="string">"MY.QUEUE"</span>&gt;</div><div class="line"> &lt;forwardTo&gt;</div><div class="line"> &lt;queue physicalName=<span class="string">"FOO"</span>  /&gt;</div><div class="line"> &lt;topic physicalName=<span class="string">"BAR"</span>  /&gt;</div><div class="line"> &lt;/forwardTo&gt;</div><div class="line"> &lt;/compositeQueue&gt;</div><div class="line"> &lt;/virtualDestinations&gt;</div><div class="line"> &lt;/virtualDestinationInterceptor&gt;</div><div class="line">&lt;/destinationInterceptors&gt;</div></pre></td></tr></table></figure></p>
<h3 id="mirrored-Queues"><a href="#mirrored-Queues" class="headerlink" title="mirrored Queues"></a>mirrored Queues</h3><p>每个queue中的消息只能被一个 consumer 消费。然而，有时候你可能希望能够监视生产者和消费者之间的消息流。你可以通过使用 Virtual Destinations 来建立一个 virtual queue 来把消息转发到多个 queues 中。但是 为系统中每个queue 都进行如此的配置可能会很麻烦。<br>ActiveMQ支持 Mirrored Queues。Broker 会把发送到某个 queue 的所有消息转发到一个名称类似的 topic，因此监控程序可以订阅这个 mirrored queue topic。为了启用Mirrored Queues，首先要将 BrokerService 的useMirroredQueues属性设置成  true ，然后可以通过destinationInterceptors设置其它属性，如mirror topic的前缀，缺省是”VirtualTopic.Mirror.” 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.org/config/1.0"</span> brokerName=<span class="string">"MirroredQueuesBroker1"</span> useMirroredQueues=<span class="string">"true"</span>&gt; &gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line"> &lt;destinationInterceptors&gt;</div><div class="line"> &lt;mirroredQueue copyMessage = <span class="string">"true"</span> prefix=<span class="string">"Mirror.Topic"</span> /&gt;</div><div class="line"> &lt;/destinationInterceptors&gt;</div><div class="line">&lt;/broker&gt;</div><div class="line">BrokerService answer = new BrokerService();</div><div class="line">answer.setUseMirroredQueues(<span class="literal">true</span>);</div><div class="line">answer.setPersistent(isPersistent());</div><div class="line">answer.addConnector(<span class="built_in">bind</span>Address);</div><div class="line"><span class="built_in">return</span> answer;</div></pre></td></tr></table></figure></p>
<h3 id="Wildcards-Desitination"><a href="#Wildcards-Desitination" class="headerlink" title="Wildcards Desitination"></a>Wildcards Desitination</h3><p>Wildcards 用来支持联合的名字分层体系（federated name hierarchies）。它不是 JMS 规范的一部分， 而是 ActiveMQ 的扩展。 ActiveMQ 支持以下三种 wildcards：<br>“.” 用于作为路径上名字间的分隔符。<br>“*“ 用于匹配路径上的任何名字。<br>“&gt;” 用于递归地匹配任何以这个名字开始的 destination。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PRICE.STOCK.NASDAQ.IBM （IBM 在 NASDAQ 的股价）</div><div class="line">PRICE.STOCK.NYSE.SUNW （SUN 在纽约证券交易所的股价）</div><div class="line">PRICE.&gt; :Any price <span class="keyword">for</span> any product on any exchange</div><div class="line">PRICE.STOCK.NASDAQ.* :Any stock price on NASDAQ</div><div class="line">PRICE.STOCK.*.IBM :Any IBM stock price on any exchange</div></pre></td></tr></table></figure></p>
<h3 id="virtual-Topic"><a href="#virtual-Topic" class="headerlink" title="virtual Topic"></a>virtual Topic</h3><p>虚拟主题，它创建一个逻辑地址并且使用户在客户端可以使用生产者和消费者消息在多个物理地址上关联起来，提高更解耦的消息配置。<br>最好的场景就是应用在发布/订阅上，允许生产者根本无需知道订阅该消息的消费者的数量。<br>ActiveMQ中，topic只有在持久订阅（durablesubscription）下是持久化的。存在持久订阅时，每个持久订阅者，都相当于一个持久化的queue的客户端，它会收取所有消息。这种情况下存在两个问题：<br>1.同一应用内consumer端负载均衡的问题：同一个应用上的一个持久订阅不能使用多个consumer来共同承担消息处理功能。因为每个都会获取所有消息。queue模式可以解决这个问题，broker端又不能将消息发送到多个应用端。所以，既要发布订阅，又要让消费者分组，这个功能jms规范本身是没有的。<br>2.同一应用内consumer端failover的问题：由于只能使用单个的持久订阅者，如果这个订阅者出错，则应用就无法处理消息了，系统的健壮性不高。<br>为了解决这两个问题，ActiveMQ中实现了虚拟Topic的功能。使用起来非常简单。对于消息发布者来说，就是一个正常的Topic，名称以VirtualTopic.开头。例如VirtualTopic.TEST。<br>对于消息接收端来说，是个队列，不同应用里使用不同的前缀作为队列的名称，即可表明自己的身份即可实现消费端应用分组。例如Consumer.A.VirtualTopic.TEST，说明它是名称为A的消费端，同理Consumer.B.VirtualTopic.TEST说明是一个名称为B的客户端。可以在同一个应用里使用多个consumer消费此queue，则可以实现上面两个功能。又因为不同应用使用的queue名称不同（前缀不同），所以不同的应用中都可以接收到全部的消息。每个客户端相当于一个持久订阅者，而且这个客户端可以使用多个消费者共同来承担消费任务。<br>使用同样queue名称的消费者会平分所有消息。<br><a href="http://blog.csdn.net/paul_wei2008/article/details/51252255" target="_blank" rel="external">http://blog.csdn.net/paul_wei2008/article/details/51252255</a></p>
<h3 id="队列选项"><a href="#队列选项" class="headerlink" title="队列选项"></a>队列选项</h3><p>consumer.prefetchSize    不定    consumer持有的未确认最大消息数量<br>consumer.maximumPendingMessageLimit    0    控制非持久主题在慢消费（slow consumer）情况下丢弃消息的最大数量。<br>consumer.noLocal    false<br>consumer.dispatchAsync    true    是否异步分发，参见 dispatch messages asynchronously。<br>consumer.retroactive    false    是否为回溯消费者 Retroactive Consumer.<br>consumer.selector    null    JMS Selector.<br>consumer.exclusive    false    是否为独占消费者 Exclusive Consumer.<br>consumer.priority    0    配置消费者优先级 Consumer Priority.</p>
<h2 id="Message-dispatching-Features"><a href="#Message-dispatching-Features" class="headerlink" title="Message dispatching Features"></a>Message dispatching Features</h2><h3 id="Message-cursor（消息游标）"><a href="#Message-cursor（消息游标）" class="headerlink" title="Message cursor（消息游标）"></a>Message cursor（消息游标）</h3><p>当 producer 发送的持久化消息到达 broker 之后， broker 首先会把它保存在持久存储中。接下来，如果发现当前有活跃的 consumer，而且这个 consumer 消费消息的速度能跟上 producer 生产消息的速度，那么 ActiveMQ 会直接把消息传递给broker 内部跟这个 consumer 关联的 dispatch queue；如果当前没有活跃的consumer 或者 consumer 消费消息的速度跟不上 producer 生产消息的速度，那么ActiveMQ 会使用 Pending Message Cursors 保存对消息的引用。在需要的时候，Pending Message Cursors 把消息引用传递给 broker 内部跟这个 consumer 关联的dispatch queue。<br>总共分为三种消息游标：<br>Store-based cursors<br>broker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。<br>VM cursors<br>若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。<br>File-based cursors<br>对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到临时文件中。<br>Activemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。.</p>
<h3 id="严格调度策略"><a href="#严格调度策略" class="headerlink" title="严格调度策略"></a>严格调度策略</h3><p>有时候需要保证不同的 topic consumer 以相同的顺序接收消息。通常ActiveMQ 会保证 topic consumer 以相同的顺序接收来自同一个 producer 的消息。然而，由于多线程和异步处理，不同的 topic consumer 可能会以不同的顺序接收来自不同 producer 的消息。例如有两个 producer，分别是 P 和 Q。差不多是同一时间内，P 发送了 P1、P2 和 P3 三个消息；Q 发送了 Q1 和 Q2 两个消息。两个不同的 consumer 可能会以以下顺序接收到消息：<br>consumer1: P1 P2 Q1 P3 Q2<br>consumer2: P1 Q1 Q2 P2 P3<br>Strict order dispatch policy 会保证每个 topic consumer 会以相同的顺序接收消息， 代价是性能上的损失。 以下是采用了strict order dispatch policy后，两个不同的 consumer 可能以以下的顺序接收消息：<br>consumer1: P1 P2 Q1 P3 Q2<br>consumer2: P1 P2 Q1 P3 Q2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;destinationPolicy&gt;</div><div class="line"> &lt;policyMap&gt;</div><div class="line"> &lt;policyEntries&gt;</div><div class="line"> &lt;policyEntry topic=<span class="string">"FOO"</span>&gt;</div><div class="line"> &lt;dispatchPolicy&gt;</div><div class="line"> &lt;strictOrderDispatchPolicy  /&gt;</div><div class="line"> &lt;/dispatchPolicy&gt;</div><div class="line"> &lt;/policyEntry&gt;</div><div class="line"> &lt;/policyEntries&gt;</div><div class="line"> &lt;/policyMap&gt;</div><div class="line"> &lt; /destinationPolicy&gt;</div></pre></td></tr></table></figure></p>
<h3 id="轮询分发策略"><a href="#轮询分发策略" class="headerlink" title="轮询分发策略"></a>轮询分发策略</h3><p>ActiveMQ 的缺省参数是针对处理大量消息时的高性能和高吞吐量而设置的。所以缺省的 prefetch 参数比较大，而且缺省的 dispatch policies 会尝试尽可能快的填满 prefetch 缓冲。 然而在有些情况下，例如只有少量的消息而且单个消息的处理时间比较长，那么在缺省的 prefetch 和dispatch policies 下，这些少量的消息总是倾向于被分发到个别的 consumer 上。这样就会因为负载的不均衡分配而导致处理时间的增加。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dispatchPolicy&gt;</div><div class="line">&lt;roundRobinDispatchPolicy  /&gt;</div><div class="line">&lt;/dispatchPolicy&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Configure-Startup-Destinations"><a href="#Configure-Startup-Destinations" class="headerlink" title="Configure Startup Destinations"></a>Configure Startup Destinations</h3><p>启动时 JMS 地址配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;destinations&gt;</div><div class="line">&lt;queue physicalName=<span class="string">"FOO.BAR"</span> /&gt;</div><div class="line">&lt;topic physicalName=<span class="string">"SOME.TOPIC"</span> /&gt;</div><div class="line">&lt;/destinations&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Async-sends"><a href="#Async-sends" class="headerlink" title="Async sends"></a>Async sends</h3><p>Acivemq 支持异步和同步发送消息。在 ActiveMQ4.0 以上，所有的异步或同步对于 Consumer 来说是变得可配置了。默认是在 ConnectionFactory、Connection、Connection URI 等方面配置对于一个基于 Destination 的 Consumer 来说。<br>ActiveMQ 默认设置 dispatcheAsync=true 是最好的性能设置。如果你处理的是Slow Consumer 则使用 dispatcheAsync=true，反之，那你使用的是 Fast Consumer则使用 dispatcheAsync=false<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cf = new ActiveMQConnectionFactory( <span class="string">"tcp://locahost:61616?jms.useAsyncSend= true "</span> );</div></pre></td></tr></table></figure></p>
<h3 id="Optimized-Acknowledgement"><a href="#Optimized-Acknowledgement" class="headerlink" title="Optimized Acknowledgement"></a>Optimized Acknowledgement</h3><p>ActiveMQ缺省支持批量确认消息。由于批量确认会提高性能，因此这是缺省的确认方式。如果希望在应用程序中禁止经过优化的确认方式，那么可以采用如下方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cf = new ActiveMQConnectionFactory(<span class="string">"tcp://locahost:61616?jms.optimizeAcknowledge=false"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Producer-Flow-Control"><a href="#Producer-Flow-Control" class="headerlink" title="Producer Flow Control"></a>Producer Flow Control</h3><p>同步发送消息的producer会自动使用producer flow control ；对于异步发送消息的producer，要使用producer flow control，你先要为connection配置一个ProducerWindowSize参数.ProducerWindowSize 是 producer 在发送消息的过程中， 收到 broker 对于之前发送消息的确认之前， 能够发送消息的最大字节数</p>
<h2 id="Message-Feature"><a href="#Message-Feature" class="headerlink" title="Message Feature"></a>Message Feature</h2><h3 id="Blob-Message"><a href="#Blob-Message" class="headerlink" title="Blob Message"></a>Blob Message</h3><p>配置其地址：包括其上传的 url 的地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tcp://localhost:61616?jms.blobTransferPolicy.uploadUrl=http://foo.com</div><div class="line">方式一：</div><div class="line">BlobMessage message = session.createBlobMessage(new URL(<span class="string">"http://some.shared.site.com"</span>);</div><div class="line">producer.send(message);</div><div class="line">// lets use a <span class="built_in">local</span> file</div><div class="line">方式二：</div><div class="line">BlobMessage message = session.createBlobMessage(new File(<span class="string">"/foo/bar"</span>);</div><div class="line">producer.send(message);</div><div class="line">// lets use a stream</div><div class="line">InputStream <span class="keyword">in</span> = ...;</div><div class="line">BlobMessage message = session.createBlobMessage(<span class="keyword">in</span>);</div><div class="line">producer.send(message);</div><div class="line"></div><div class="line">BlobMessage blobMessage = (BlobMessage) message;</div><div class="line">InputStream <span class="keyword">in</span> = blobMessage.getInputStream();</div></pre></td></tr></table></figure></p>
<h3 id="Advisory-Message"><a href="#Advisory-Message" class="headerlink" title="Advisory Message"></a>Advisory Message</h3><p>ActiveMQ 自身的系统消息地址.我们可以监听该地址来获取 activemq 的系统信息.</p>
<h3 id="ActiveMQ-Stream"><a href="#ActiveMQ-Stream" class="headerlink" title="ActiveMQ Stream"></a>ActiveMQ Stream</h3><p><img src="/2017/12/19/activemq先进特性/stream1.png" alt=""><br><img src="/2017/12/19/activemq先进特性/stream2.png" alt=""></p>
<h3 id="Transformer-message"><a href="#Transformer-message" class="headerlink" title="Transformer message"></a>Transformer message</h3><p>有时候需要在JMS provider内部进行message 的转换</p>
<h2 id="Consumer-Features"><a href="#Consumer-Features" class="headerlink" title="Consumer Features"></a>Consumer Features</h2><h3 id="exclusive-consumer"><a href="#exclusive-consumer" class="headerlink" title="exclusive consumer"></a>exclusive consumer</h3><p>Queue 中的消息是按照顺序被分发到 consumers 的。然而，当你有多个consumers 同时从相同的 queue 中提取消息时，你将失去这个保证。因为这些消息是被多个线程并发的处理。有的时候，保证消息按照顺序处理是很重要的。例如，你可能不希望在插入订单操作结束之前执行更新这个订单的操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue = new ActiveMQQueue(<span class="string">"TEST.QUEUE?consumer.exclusive=true"</span>);</div><div class="line">consumer = session.createConsumer(queue);</div></pre></td></tr></table></figure></p>
<p>如果存在 Exclusive Consumer 和普通的 Consumer，那么 Broker 会首先把消息发送给 Exclusive Consumer。除非该独有消费者死亡。</p>
<h3 id="Message-Group"><a href="#Message-Group" class="headerlink" title="Message Group"></a>Message Group</h3><p>它是 Exclusive Consumer功能的增强。逻辑上，Message Groups 可以看成是一种并发的 Exclusive Consumer。跟所有的消息都由唯一的 consumer 处理不同，JMS 消息属性JMSXGroupID 被用来区分 message group。Message Groups 特性保证所有具有相同 JMSXGroupID 的消息会被分发到相同的 consumer（只要这个consumer保持active）。另外一方面，Message Groups 特性也是一种负载均衡的机制。在一个消息被分发到 consumer 之前，broker 首先检查消息 JMSXGroupID属性。如果存在，那么 broker 会检查是否有某个consumer 拥有这个 message group。如果没有，那么 broker 会选择一个consumer，并将它关联到这个message group。此后，这个 consumer 会接收这个 message group 的所有消息，直到：<br>1.Consumer 被关闭。<br>2.Message group被关闭。通过发送一个消息，并设置这个消息的JMSXGroupSeq为-1</p>
<h4 id="创建一个message-groups"><a href="#创建一个message-groups" class="headerlink" title="创建一个message groups"></a>创建一个message groups</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div></pre></td></tr></table></figure>
<h4 id="关闭一个message-groups"><a href="#关闭一个message-groups" class="headerlink" title="关闭一个message groups"></a>关闭一个message groups</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div><div class="line">message.setIntProperty(<span class="string">"JMSXGroupSeq"</span>, -1);</div></pre></td></tr></table></figure>
<h3 id="JMS-Selectors"><a href="#JMS-Selectors" class="headerlink" title="JMS Selectors"></a>JMS Selectors</h3><p>JMS Selectors 用于在订阅中，基于消息属性和 Xpath 语法对进行消息的过滤</p>
<h3 id="消息重发与死信管理"><a href="#消息重发与死信管理" class="headerlink" title="消息重发与死信管理"></a>消息重发与死信管理</h3><p>出现以下情况时，消息会被redelivered（重发）:</p>
<ul>
<li>使用一个事务session，并且调用了rollback方法.</li>
<li>一个事务session，关闭之前调用了commit.</li>
<li>在session中使用CLIENT_ACKNOWLEDGE签收模式，并且调用了Session.recover方法.<br>当消息试图被传递的次数是配置中 maximumRedeliveries 属性的值时，那么，broker 会任何该消息是一个死消息，并被把该消息发送到死队列中。默认，aciaveMQ 中死队列被声明为“ActivemMQ.DLQ” ，所有不能消费的消息被传递到该死队列中。<br>有时需要直接删除过期的消息而不需要发送到死队列中,xml可以使用属性processExpired=false来设置。<br>存放非持久消息到死队列中;默认情况下，Activemq 不会把非持久的死消息发送到死队列中。如果你想把非持久的消息发送到死队列中，需要设置属性processNonPersistent=“true”<h3 id="consumer-priority"><a href="#consumer-priority" class="headerlink" title="consumer priority"></a>consumer priority</h3>JMS JMSPriority 定义了十个消息优先级值， 0 是最低的优先级， 9 是最高的优先级。另外，客户端应当将0‐4 看作普通优先级，5‐9 看作加急优先级。<br>Consumer 的 Priority 的划分为 0~127 个级别，127 是最高的级别，0 是最低<br>的也是 ActiveMQ 默认的。<br>这种配置可以是 Broker 根据 Consumer 的优先级来发送消息先到较高的优先级的 Consumer 上，如果某个较高的 Consumer 的缓存预先被消息装载慢，则Broker 会把消息发送到仅次于它优先级的 Consumer 上.<h3 id="slow-consumer-handling"><a href="#slow-consumer-handling" class="headerlink" title="slow consumer handling"></a>slow consumer handling</h3>ActiveMQ通过prefetch机制来提高性能，这意味这客户端的内存里可能会缓存一定数量的消息。缓存消息的数量由prefetch limit来控制。当某个consumer的prefetch buffer已经达到上限，那么broker不会再向consumer分发消息，直到consumer向broker发送消息的确认。<h3 id="consumer-dispatcher-Async"><a href="#consumer-dispatcher-Async" class="headerlink" title="consumer dispatcher Async"></a>consumer dispatcher Async</h3>在 activemq4.0 以后， 你肯能选择 broker 执行同步或异步的方法消息给消费者。<br>默认是 true<h3 id="Retroactive-Consumer"><a href="#Retroactive-Consumer" class="headerlink" title="Retroactive Consumer"></a>Retroactive Consumer</h3>消费者回溯消息</li>
</ul>
<ol>
<li>这种策略限制在基于一个静态的计数中对于主题 （Topic） 消息缓存的数量。</li>
<li>这种策略限制在内存使用量中对于主题（Topic）消息缓存的数量</li>
<li>仅仅保持发送到主题（Topic）的最后一个消息。</li>
<li>不保存主题消息，不需要任何配置</li>
<li>基于一个 JMS 属性选择器应用到所有的消息来设置其消息缓存的大小</li>
<li>基于应用到每个消息的过期时间来限制其消息缓存数量。提示这种消息的生命周期时间来源于消息发送者设置其 timeToLive 参数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;先进特性&quot;&gt;&lt;a href=&quot;#先进特性&quot; class=&quot;headerlink&quot; title=&quot;先进特性&quot;&gt;&lt;/a&gt;先进特性&lt;/h1&gt;&lt;h2 id=&quot;Destination-Features&quot;&gt;&lt;a href=&quot;#Destination-Features&quot; cla
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>为大量并发应用程序部署ActiveMQ</title>
    <link href="http://yoursite.com/2017/12/19/%E4%B8%BA%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2ActiveMQ/"/>
    <id>http://yoursite.com/2017/12/19/为大量并发应用程序部署ActiveMQ/</id>
    <published>2017-12-19T13:49:38.000Z</published>
    <updated>2017-12-19T14:57:15.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h2><p>垂直扩展是一种用于增加单个ActiveMQ broker可以处理的连接数（因此增加负载）的技术。默认情况下，ActiveMQ broker设计为尽可能高效地移动消息，以确保低延迟和良好的性能。但是我们可以做一些配置调整，以确保ActiveMQ broker可以处理大量的并发连接和大量的队列。<br>默认情况下，ActiveMQ将使用阻塞I/O来处理传输连接。 这导致每个连接使用一个线程。 我们可以在ActiveMQ broker上使用非阻塞I/O（而客户端上仍然使用默认传输）来减少使用的线程数。broker的非阻塞I/O配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker&gt;</div><div class="line">    &lt;transportConnectors&gt;</div><div class="line">        &lt;transportConnector name=<span class="string">"nio"</span> uri=<span class="string">"nio://localhost:61616"</span>/&gt;</div><div class="line">    &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>除了每个连接使用一个线程来阻塞I/O外，ActiveMQ broker可以使用线程为每个客户端连接分派消息。可以通过将名为org.apache.activemq.UseDedicatedTaskRunner的系统属性设置为false，让ActiveMQ使用线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACTIVEMQ_OPTS=<span class="string">"-Dorg.apache.activemq.UseDedicatedTaskRunner=false"</span></div></pre></td></tr></table></figure></p>
<p>确保ActiveMQ broker具有足够的内存来处理大量并发连接有两步过程。<br>首先，需要确保启动ActiveMQ broker的JVM配置了足够的内存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACTIVEMQ_OPTS=<span class="string">"-Xmx1024M \-Dorg.apache.activemq.UseDedicatedTaskRunner=false"</span></div></pre></td></tr></table></figure></p>
<p>确保专门为ActiveMQ broker在JVM配置适当的内存量。此调整通过&lt; system-Usage &gt;元素的limit属性进行。（最好从512MB开始，如果测试不够再往上加）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;systemUsage&gt;</div><div class="line">    &lt;systemUsage&gt;</div><div class="line">        &lt;memoryUsage&gt;</div><div class="line">            &lt;memoryUsage <span class="built_in">limit</span>=<span class="string">"512 mb"</span>/&gt;</div><div class="line">        &lt;/memoryUsage&gt;</div><div class="line">        &lt;storeUsage&gt;</div><div class="line">            &lt;storeUsage <span class="built_in">limit</span>=<span class="string">"10 gb"</span> name=<span class="string">"foo"</span>/&gt;</div><div class="line">        &lt;/storeUsage&gt;</div><div class="line">        &lt;tempUsage&gt;</div><div class="line">            &lt;tempUsage <span class="built_in">limit</span>=<span class="string">"1 gb"</span>/&gt;</div><div class="line">        &lt;/tempUsage&gt;</div><div class="line">    &lt;/systemUsage&gt;</div><div class="line">&lt;/systemUsage&gt;</div></pre></td></tr></table></figure></p>
<p>还应该降低每一个连接的CPU负载，如果使用的OpenWire连接方式，禁用紧密编码，否则会使得CPU过度紧张。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String uri = <span class="string">"failover://(tcp://localhost:61616?"</span> + <span class="string">" wireFormat.tightEncodingEnabled=false)"</span>;</div><div class="line">ConnectionFactory cf = new ActiveMQConnectionFactory(uri);</div></pre></td></tr></table></figure></p>
<p>前面研究的是broker怎么调整去处理数千个连接，下面开始研究的是怎么调整broker去处理数千个队列。<br>默认队列配置使用单独的线程来将消息从消息存储区分页到队列中，以便分发给感兴趣的消息消费者。 对于大量队列，建议通过为所有队列启用optimize-Dispatch属性来禁用此功能，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;destinationPolicy&gt;</div><div class="line">    &lt;policyMap&gt;</div><div class="line">        &lt;policyEntries&gt;</div><div class="line">            &lt;policyEntry queue=<span class="string">"&gt;"</span> optimizedDispatch=<span class="string">"true"</span>/&gt;</div><div class="line">        &lt;/policyEntries&gt;</div><div class="line">    &lt;/policyMap&gt;</div><div class="line">&lt;/destinationPolicy&gt;</div></pre></td></tr></table></figure></p>
<p>为了确保不仅可以扩展到数千个连接，而且还可以扩展到数万个队列，使用JDBC消息存储库或更新和更快的KahaDB消息存储库。 KahaDB默认情况下在ActiveMQ中启用。</p>
<p>到目前为止，我们已经考虑了扩展连接，减少线程使用，并选择正确的消息存储。 调整用于扩展的ActiveMQ的示例配置如以下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"amq-broker"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span>&gt;</div><div class="line">    &lt;persistenceAdapter&gt;</div><div class="line">        &lt;kahaDB directory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span> journalMaxFileLength=<span class="string">"32mb"</span>/&gt;</div><div class="line">    &lt;/persistenceAdapter&gt;</div><div class="line">    &lt;destinationPolicy&gt;</div><div class="line">        &lt;policyMap&gt;</div><div class="line">            &lt;policyEntries&gt;</div><div class="line">                &lt;policyEntry queue=<span class="string">"&amp;gt;"</span> optimizedDispatch=<span class="string">"true"</span>/&gt;</div><div class="line">            &lt;/policyEntries&gt;</div><div class="line">        &lt;/policyMap&gt;</div><div class="line">    &lt;/destinationPolicy&gt;</div><div class="line">    &lt;systemUsage&gt;</div><div class="line">        &lt;systemUsage&gt;</div><div class="line">            &lt;memoryUsage&gt;</div><div class="line">                &lt;memoryUsage <span class="built_in">limit</span>=<span class="string">"512 mb"</span>/&gt;</div><div class="line">            &lt;/memoryUsage&gt;</div><div class="line">            &lt;storeUsage&gt;</div><div class="line">                &lt;storeUsage <span class="built_in">limit</span>=<span class="string">"10 gb"</span> name=<span class="string">"foo"</span>/&gt;</div><div class="line">            &lt;/storeUsage&gt;</div><div class="line">            &lt;tempUsage&gt;</div><div class="line">                &lt;tempUsage <span class="built_in">limit</span>=<span class="string">"1 gb"</span>/&gt;</div><div class="line">            &lt;/tempUsage&gt;</div><div class="line">        &lt;/systemUsage&gt;</div><div class="line">    &lt;/systemUsage&gt;</div><div class="line">    &lt;transportConnectors&gt;</div><div class="line">        &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"nio://localhost:61616"</span>/&gt;</div><div class="line">    &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h2><p>除了扩展单个broker之外，还可以使用networks来增加可用于应用程序的ActiveMQ broker的数量。 由于networks会自动将消息传递给具有感兴趣的消费者的连接broker，因此可以将客户端配置为连接到一个broker集群，随机选择一个来连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover://(tcp://broker1:61616,tcp://broker2:61616)?randomize=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>为了确保队列或持久主题订阅者的消息不会在broker上孤立，需要将network配置为使用dynamicOnly和低网络prefetchSize<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnector uri=<span class="string">"static://(tcp://remotehost:61617)"</span></div><div class="line">    name=<span class="string">"bridge"</span></div><div class="line">    dynamicOnly=<span class="string">"true"</span></div><div class="line">    prefetchSize=<span class="string">"1"</span>&gt;</div><div class="line">&lt;/networkConnector&gt;</div></pre></td></tr></table></figure></p>
<p>使用network进行水平扩展会带来更多的延迟，因为潜在的消息必须在分发给消费者之前通过多个broker。</p>
<h2 id="流量分区"><a href="#流量分区" class="headerlink" title="流量分区"></a>流量分区</h2><p>客户端流量分割是垂直和水平分割的混合。 通常不使用network，因为客户端应用程序决定什么流量应该到哪个broker上。 客户端应用程序必须维护多个JMS连接，并决定哪些JMS连接应用于哪些目标。<br>不直接使用network connection的优点是，减少在brokers之间转发消息的开销。 需要平衡这与导致典型应用程序的额外复杂性<br><img src="/2017/12/19/为大量并发应用程序部署ActiveMQ/流量分区.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;垂直扩展&quot;&gt;&lt;a href=&quot;#垂直扩展&quot; class=&quot;headerlink&quot; title=&quot;垂直扩展&quot;&gt;&lt;/a&gt;垂直扩展&lt;/h2&gt;&lt;p&gt;垂直扩展是一种用于增加单个ActiveMQ broker可以处理的连接数（因此增加负载）的技术。默认情况下，ActiveMQ
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 笔记一</title>
    <link href="http://yoursite.com/2017/12/15/Apache-ActiveMQ-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/15/Apache-ActiveMQ-笔记/</id>
    <published>2017-12-15T01:52:52.000Z</published>
    <updated>2018-03-08T07:51:28.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>面向消息的中间件：Message-oriented Middleware, MOM<br>基本功能：将信息以消息的形式，从一个应用程序传送到另一个或多个应用程序。<br>主要特点：</p>
<ul>
<li>消息异步接受，类似手机短信的行为，消息发送者不需要等待消息接受者的响应，减少软件多系统集成的耦合度。</li>
<li>消息可靠接收，确保消息在中间件可靠保存，只有接收方收到后才删除消息，多个消息也可以组成原子事务。</li>
</ul>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>java message service</p>
<h3 id="JMS规范"><a href="#JMS规范" class="headerlink" title="JMS规范"></a>JMS规范</h3><p>java消息服务定义了java中访问消息中间件的接口。JMS只是接口，并没有实现，实现JMS的接口的消息中间件称为JMS Provider，例如ActiveMQ。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>JMS Provider：实现JMS接口的消息中间件<br>PTP：point to point，即点对点模型<br>pub/sub：publish/subscribe，即发布/订阅消息模型<br>Queue：队列目标<br>Topic：主题目标<br>ConnectionFactory：连接工厂，JMS用它来创建连接<br>Connection：JMS客户端到JMS provider的连接<br>Destination：消息的目的地<br>Session：会话，一个发送或接收消息的线程<br>MessageProducer：由session对象创建用来发送消息的对象<br>MessageConsumer：由session对象创建用来接收消息的对象<br>Acknowledge：签收<br>Transaction：事务</p>
<h3 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h3><p>在 JMS 编程模型中，JMS 客户端（组件或应用程序）通过 JMS 消息服务交换消息。消息生产者将消息发送至消息服务，消息消费者则从消息服务接收这些消息。这些消息传送操作是使用一组实现 JMS 应用编程接口 (API) 的对象 （由 JMS Provide 提供）来执行的。<br>在 JMS 编程模型中，JMS 客户端使用 ConnectionFactory 对象创建一个连接，向消息服务发送消息以及从消息服务接收消息均是通过此连接来进行。Connection是客户端与消息服务的活动连接。创建连接时，将分配通信资源以及验证客户端。这是一个相当重要的对象，大多数客户端均使用一个连接来进行所有的消息传送。连接用于创建会话。Session 是一个用于生成和使用消息的单线程上下文。它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。客户端使用 MessageProducer 向指定的物理目标 （在 API 中表示为目标身份对象）发送消息。<br>生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息。同样，客户端使用 MessageConsumer 对象从指定的物理目标（在 API 中表示为目标对象）接收消息。消费者可使用消息选择器，借助它，消息服务可以只向消费者发送与选择标准匹配的那些消息。消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 MessageListener 来实现。当会话线程调用 MessageListener 对象的 onMessage 方法时，客户端将使用消息。</p>
<h3 id="JMS编程域"><a href="#JMS编程域" class="headerlink" title="JMS编程域"></a>JMS编程域</h3><p>JMS接收两种截然不同的消息传送模型PTP和Pub/Sub</p>
<ul>
<li>PTP<br>消息从一个生产者传送给一个消费者。在此传送模型中，目标是一个队列。消息首先传送到队列目标，然后根据队列传送策略，从该队列将消息传送到这队列进行注册的某一个消费者，一次只传送一条消息。可以向队列目标发送消息的生产者的数量没有限制，但每条消息只能发送至、并由一个消费者成功使用。如果没有已经向队列目标注册的消费者，队列将保留它收到的消息，并在某个消费者向该队列进行注册时将消息传送给该消费者。</li>
<li>Pub/Sub<br>消息从一个生产者传送至任意数量的消费者。在此传送模型中，目标是一个主题。消息首先被传送至主题目标，然后传送至所有已订阅此主题的活动消费者。可以向主题目标发送消息的生产者的数量没有限制，并且每个消息可以发送至任意数量的订阅消费者。主题目标也支持持久订阅的概念。持久订阅表示消费者已向主题目标进行注册，但在消息传送时此消费者可以处于非活动状态。当此消费者再次处于活动状态时，它将接收此信息。如果没有已经向主题目标注册的消费者，主题不保留其接收到的消息，除非有非活动消费者注册了持久订阅</li>
</ul>
<h2 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h2><p>JMS消息由消息头、属性和消息体组成</p>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>消息头包含消息的识别信息和路由信息，消息头包含一些标准的属性如JMSDestination、JMSMessageID<br>JMSDestination<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/jms消息结构.png" alt=""><br>JMSDestination(自动)：消息发送的目的地主要指Queue和Topic<br>JMSDeliveryMode（自动）：传送模式有两种模式：持久模式和非持久模式，一条持久性消息应该被传递一次仅仅一次，这就意味着如果JMS提供者出现故障，该消息不会丢失，它会在服务器恢复之后再次传递。<br>JMSExpiration（自动）：消息过期时间，等于Destination 的send 方法的timeToLive值加上发送时刻的GMT 时间值。如果timeToLive值等于零则JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除<br>JMSPriority(自动):消息优先级， 从 0-9 十个级别，0-4 是普通消息，5-9 是加急消息。JMS 不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达。默认是4级。<br>JMSMessageID（自动）：唯一识别每个消息的标识，由JMS Provider 产生。<br>JMSTimestamp（自动）：一个JMS Provider在调用send()方法时自动设置的。它是消息被发送和消费者实际接收的时间差。自动分配。<br>JMSCorrelationID（开发者设置）：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对 JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。<br>JMSReplyTo（开发者设置）：提供本消息回复消息的目的地址。<br>JMSType（开发者设置）：消息类型的识别符。由开发者设置<br>JMSRedelivered(自动)：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收 (acknowledged)。如果该消息被重新传送，JMSRedelivered=true反之，JMSRedelivered =false。</p>
<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>TextMessage:java.lang.String 对象，如xml 文件内容<br>MapMessage:名/值对的集合，名是String 对象，值类型可以是Java 任何基本类型。<br>ByteMessage:字节流<br>StreamMessage：java输入输出流<br>ObjectMessage：java中可序列化对象</p>
<h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><h4 id="应用程序特定的属性"><a href="#应用程序特定的属性" class="headerlink" title="应用程序特定的属性"></a>应用程序特定的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextMessage message=session.createTextMessage();</div><div class="line">message.setStringProperty(<span class="string">"username"</span>,username);</div></pre></td></tr></table></figure>
<h4 id="JMS定义的属性"><a href="#JMS定义的属性" class="headerlink" title="JMS定义的属性"></a>JMS定义的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div><div class="line">message.setIntProperty(<span class="string">"JMSXGroupSeq"</span>, -1);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名字</th>
<th>类型</th>
<th>设置者</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>JMSXUserID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送时的用户标识</td>
</tr>
<tr>
<td>JMSXAppID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送消息的应用标识</td>
</tr>
<tr>
<td>JMSXDeliveryCount</td>
<td>int</td>
<td>发送时提供商设置</td>
<td>转发消息重试次数，第一次是1，第二次是2</td>
</tr>
<tr>
<td>JMSXGroupID</td>
<td>String</td>
<td>客户端</td>
<td>消息所在消息组的标识</td>
</tr>
<tr>
<td>JMSXGroupSeq</td>
<td>int</td>
<td>客户端</td>
<td>组内消息的序号第一个消息是1，第二个是2</td>
</tr>
<tr>
<td>JMSXProducerTXID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>产生消息时的事务的事务标识</td>
</tr>
<tr>
<td>JMSXConsumerTXID</td>
<td>String</td>
<td>接收时提供商设置</td>
<td>接收消息的事务的事务标识</td>
</tr>
<tr>
<td>JMSXRcvTimestamp</td>
<td>long</td>
<td>接收时提供商设置</td>
<td>JMS转发到消费者的消息</td>
</tr>
<tr>
<td>JMSXState</td>
<td>int</td>
<td>提供商</td>
<td>假定存在一个消息仓库，它存储了每个消息的拷贝，且这些消息从原始消息被发送开始，每个的拷贝的状态有1(等待),2（准备），3（到期）或者4（保留）。由于状态与生产者和消费者无关，所以它不是由它们来提供。它只和在仓库中查找消息相关，因此JMS没有提供这种API。</td>
</tr>
</tbody>
</table>
<h3 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h3><p>如果会话是事务性的，那么消息确认自动由commit 处理，且恢复自动由rollback 处理。如果会话不是事务性的，有三个确认选择，且手工处理恢复。</p>
<ul>
<li><p>DUPS_OK_ACKNOWLEDGE:这个选项告诉会话懒惰确认消息的传递。如果JMS失败，这很可能造成传递重复消息，因此这个选项只用于可以忍受重复消息的消费者。它的好处是减少了会话为防止重复所要做的工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.DUPS_OK_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>AUTO_ACKNOWLEDGE:使用这个选项，当消息被成功地从调用接收返回或处理消息的MessageListener 成功返回时，会话自动确认客户端的消息接收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>CLIENT_ ACKNOWLEDGE:使用这个选项，客户端通过调用消息的acknowledge方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。当使用 CLIENT_ACKNOWLEDGE 模式时，客户端可以在处理它们时产生大量未确认消息。JMS 提供商应当为管理员提供限制客户端超量运行的途径，以便客户端不会造成资源耗尽并保证当它们使用的资源被临时阻塞时造成失败。 会话的recover 方法用于停止一个会话然后使用第一个未确认消息来重新启动它。事实上，会话的被转发消息序列被重新设置到最后一个确认消息之后。现在转发的消息序列可以与起初转发的消息序列不同， 因为消息到期和收到更高优先级的消息。会话必须设置消息的redelivered 标记，表示它是由于恢复而被重新转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">conn.createTopicSession(<span class="literal">false</span>, Session.CLIENT_ACKNOWLEDGE);</div><div class="line">message.acknowledge();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="PTP模型"><a href="#PTP模型" class="headerlink" title="PTP模型"></a>PTP模型</h2><p>PTP(Point-to-Point)模型是基于队列的，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的异步传输成为可能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConnectionFactory</td>
<td>客户端用ConnectionFactory创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用session创建Message、Producer、Consumer。如果在session关闭有一些消息已经收到但还未被签收，当消费者下次再连接到相同队列时，会被再次接收。</td>
</tr>
<tr>
<td>Destination(Queue或TemporaryQueue)</td>
<td>此处的目标为队列，队列由队列名识别。临时队列只能由创建它的Connection 所创建的消费者消费，但是任何生产者都可向临时队列发送消息。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到队列中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收队列中的消息，如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>可靠性</td>
<td>队列可以长久地保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的连接状态，充分体现了异步传输模式的优势。</td>
</tr>
</tbody>
</table>
<h2 id="PUB-SUB模型"><a href="#PUB-SUB模型" class="headerlink" title="PUB/SUB模型"></a>PUB/SUB模型</h2><p>JMS Pub/Sub 模型定义了如何向一个内容节点发布和订阅消息，这些节点被称作主题。主题可以被认为是消息的传输中介，发布者(publisher)发布消息到主题，订阅者(subscribe) 从主题订阅消息。主题使得消息订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>订阅(subscription)</td>
<td>消息订阅分为非持久订阅和持久订阅，非持久订阅只有当客户端处于激活状态，也就是和JMSProvider 保持连接状态才能收到发送到某个主题的消息，而当客户端处于离线状态，这个时间段发到主题的消息将会丢失，永远不会收到。持久订阅时，客户端向JMS 注册一个识别自己身份的ID，当这个客户端处于离线时，JMS Provider 会为这个ID 保存所有发送到主题的消息，当客户再次连接到JMS Provider 时， 会根据自己的ID 得到所有当自己处于离线时发送到主题的消息</td>
</tr>
<tr>
<td>ConnectionFactory</td>
<td>客户端用 ConnectionFactory 创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用Session 创建MessageProducer 和MessageConsumer 对象。它还提供持久订阅主题，或使用unsubscribe 方法取消消息的持久订阅。</td>
</tr>
<tr>
<td>Destination(Topic和TemporaryTopic)</td>
<td>客户端用 Session 创建Destination 对象。此处的目标为主题，主题由主题名识别。临时主题只能由创建它的Connection 所创建的消费者消费。临时主题不能提供持久订阅功能。JMS 没有给出主题的组织和层次结构的定义，由JMS Provider 自己定义。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到主题中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收主题中的消息， 如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>恢复和重新派送</td>
<td>非持久订阅状态下，不能恢复或重新派送一个未签收的消息。只有持久订阅才能恢复或重新派送一个未签收的消息。</td>
</tr>
<tr>
<td>可靠性</td>
<td>当所有的消息必须被接收，则用持久订阅模式。当丢失消息能够被容忍，则用非持久订阅模式。</td>
</tr>
</tbody>
</table>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>支持并发的对象：Destination、ConnectionFactory、Connection<br>不支持并发的对象：Session、MessageProducer、MessageConsumer</p>
<h1 id="如何配置ActiveMQ"><a href="#如何配置ActiveMQ" class="headerlink" title="如何配置ActiveMQ"></a>如何配置ActiveMQ</h1><blockquote>
<blockquote>
<blockquote>
<p>Master-Slave集群：<br>由至少3个节点组成，一个Master节点，其他为Slave节点。只有Master节点对外提供服务，Slave节点处于等待状态。当主节点宕机后，从节点会推举出一个节点出来成为新的Master节点，继续提供服务。<br>优点是可以解决多服务热备的高可用问题，缺点是无法解决负载均衡和分布式的问题。<br>Broker Cluster集群：<br>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue.当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。<br>优点是可以解决负载均衡和分布式的问题。但不支持高可用。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="如何配置传输连接"><a href="#如何配置传输连接" class="headerlink" title="如何配置传输连接"></a>如何配置传输连接</h2><h3 id="格式配置如下"><a href="#格式配置如下" class="headerlink" title="格式配置如下"></a>格式配置如下</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/配置.png" alt=""></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>activeMQ 的 Broker 和 Client 之间需要一个高稳定性的通信，不难发现，TCP是一个理想的实现。所以我们并不惊讶在 ActiveMQ 频繁的使用 TCP 协议。<br>在做数据交互之前，我们需要知道必须序列化数据，消息是如何通过一个叫wire protocol 的来序列化成字节流。默认情况下，ActiveMQ 把 wire protocol 叫做OpenWire。它的目的是促使网络上的效率和数据快速交互等。默认的 Broker 配置，TCP 的 Client 监听端口是 61616。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://host:port?key=value</div></pre></td></tr></table></figure></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO 协议和 TCP 协议类似，nio 更侧重于底层的访问操作。它不同与传统的I/O 流操作。允许开发人员对同一资源可有更多的 client 调用和服务端有更多的负载。<br>以下场景使用NIO：</p>
<ul>
<li>你可能有大量的 Client 去链接到 Broker 上；<br>般情况下，大量的 Client 去链接 Broker 是被操作系统的线程数所限制的。因此，NIO 的实现比 TCP 需要更少的线程去运行，所以，建议你使用 NIO 协议。</li>
<li>你可能对于 Broker 有一个很迟钝的网络传输。<br>NIO 比 TCP 提供更好的性能。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nio://host:port?key=value</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"tcp"</span> uri=<span class="string">"tcp://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"nio"</span> uri=<span class="string">"nio://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>运行原理如下：Producer 通过 NIO 协议发送数据到 broker，Consumer 通过 TCP 协议接收数据<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/broker.png" alt=""></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP是被用在稳定可靠的场景中使用的，然而，UDP 通常用在快速数据传递和不怕数据丢失的场景中使用的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udp://hostname:port?key=value</div></pre></td></tr></table></figure></p>
<p>TCP 是一个原始的流协议，意味者数据包的传递是有保证的。UDP 则没有保证。<br>TCP 同样也是一个可靠性高的传递协议。意味者数据包不会丢失，反之，UDP 则不能保证</p>
<h3 id="Secure-Sockets-Layer-Protocol-SSL"><a href="#Secure-Sockets-Layer-Protocol-SSL" class="headerlink" title="Secure Sockets Layer Protocol(SSL)"></a>Secure Sockets Layer Protocol(SSL)</h3><p>基于 TCP 之上的安全协议</p>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://hostname:port?key=value</div></pre></td></tr></table></figure>
<h3 id="vm-protocol"><a href="#vm-protocol" class="headerlink" title="vm protocol"></a>vm protocol</h3><p>VM transport 允许在 VM 内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。第一个创建 VM 连接的客户会启动一个 embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个 broker。当这个 broker上所有的连接都关闭的时候，这个broker也会自动关闭</p>
<h2 id="如何配置网络"><a href="#如何配置网络" class="headerlink" title="如何配置网络"></a>如何配置网络</h2><p>一个ActiveMQ Broker对于你的所有的应用来说是非常实用的。但是，某些场景需要一些高级的特性。例如：高稳定性和大传输量。典型的就是用在网络中。Broker集群在多个ActiveMQ的实例中大大优化了消息的传递。这章主要是解释网络链接在 ActiveMQ 的应用，Broker 到 Broker 的通信。网络链接是以通道的形式将一个Broker 和其他的 Broker 链接起来通信。 网络链接默认是单向的， 然而， 一个 Broker在一端发送消息， 在另一 Broker 在另一端接收消息。 这就是所谓的 “桥接” 。 然而，你可能想创建一个双向的通道对于两个 Broker。他将不仅发送消息而且也能从相同的通道来接收消息。ActiveMQ 支持这种双向链接，通常作为 duplex connector来映射。如下图<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/brokers.png" alt=""></p>
<h3 id="如何配置Dynamic-Networks"><a href="#如何配置Dynamic-Networks" class="headerlink" title="如何配置Dynamic Networks"></a>如何配置Dynamic Networks</h3><h4 id="multicast协议"><a href="#multicast协议" class="headerlink" title="multicast协议"></a>multicast协议</h4><p>ActiveMQ 使用 Multicast 协议将一个 Service 和其他的 Broker 的 Service 连接起来。IP multicast是一个被用于网络中传输数据到其它一组接收者的技术。Ip multic 传统的概念称为组地址。组地址是 ip 地址在 224.0.0.0 到 239.255.255.255 之间的 ip 地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">multicast://address:port?transportOptions</div><div class="line">multicast://default</div><div class="line">multicast://224.1.2.3:6255</div><div class="line">multicast://224.1.2.3:6255?group=mygroupname</div><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"localhost"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector name=<span class="string">"default-nc"</span> uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;!-- DOS protection, <span class="built_in">limit</span> concurrent connections to 1000 and frame size to 100MB --&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"</span> discoveryUri=<span class="string">"multicast://default"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>“default”=是 activemq 默认的 ip，默认动态的寻找地址<br>“discoveryUri”=是指在 transport 中用 multicast 的 default 的地址传递。<br>“uri”=指动态寻找可利用的地址<br><em>防止自动寻找地址</em><br>1.名称为 openwire 的 transport，移除discoveryUri=”multicast://default”即可。传输链接用默认的名称 openwire 来配置 broker 的 tcp 多点链接，这将允许其它 broker 能够自动发现和链接到可用的 broker 中<br>2.名称为“default-nc”的 networkConnector，注释掉或者删除即可<br>3.使 brokerName 的名字唯一。默认是 localhost。是为了唯一识别 Broker的实例</p>
<h4 id="discovery协议"><a href="#discovery协议" class="headerlink" title="discovery协议"></a>discovery协议</h4><p>Discovery 是在 multicast 协议的功能上定义的。功能类似与 failover 功能。它将动态的发现 multicast 协议的 broker 的链接并且随机的链接其中一个 broker。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions</div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<h4 id="peer协议"><a href="#peer协议" class="headerlink" title="peer协议"></a>peer协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">peer://peergroup/brokerName?key=value</div></pre></td></tr></table></figure>
<h4 id="fanout协议"><a href="#fanout协议" class="headerlink" title="fanout协议"></a>fanout协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fanout://(fanoutUri)?key=value</div></pre></td></tr></table></figure>
<h3 id="如何配置Static-Networks"><a href="#如何配置Static-Networks" class="headerlink" title="如何配置Static Networks"></a>如何配置Static Networks</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static://(uri1,uri2)</div></pre></td></tr></table></figure>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/static.png" alt=""><br>关于以上视图，两个 Brokers 是网络链接的。Brokers 通过一个 static 的协议来创建一个链接。一个 Consumer 链接到 brokerB 的一个地址上 ，当 Producer 在brokerA 上以相同的地址发送消息时， 此时它将被转移到 brokerB 上。 这种情况下，BrokerA 转发消息到 BrokerB 上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"brokerA"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector uri=<span class="string">"static:(tcp://localhost:61617)"</span>  /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"localhost:61616"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>以上配置broker监听端口在 61617上，它定义了一个 networks 链接到 BrokerB上。以上例子，消息在 BrokerA 上被发送，消息被转发到 BrokerB 上，此时通过Consumer 来消费该消息。</p>
<h4 id="failover-protocol"><a href="#failover-protocol" class="headerlink" title="failover protocol"></a>failover protocol</h4><p>Failover 协议实现了自动重新链接的逻辑。这里有两种方式提供了稳定的brokers 列表对于 Client 链接。 第一种方式：提供一个 static 的可用的 Brokers 列表。第二种方式：提供一个 dynamic 发现的可用 Brokers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp://localhost:61616)</div></pre></td></tr></table></figure></p>
<p>对于 broker 失败 client 不需要重新去启动，而是自动的去连接其它可用的broker</p>
<h1 id="消息存储的持久化"><a href="#消息存储的持久化" class="headerlink" title="消息存储的持久化"></a>消息存储的持久化</h1><p>消息的持久化不仅支持persistence和non-persistence，还支持recovery。</p>
<h2 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/PTP.png" alt=""></p>
<h2 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/pub-sub.png" alt=""></p>
<h2 id="有效存储"><a href="#有效存储" class="headerlink" title="有效存储"></a>有效存储</h2><ul>
<li>AMQ 消息存储-默认的消息存储</li>
<li>KahaDB 消息存储-提供了容量的提升和恢复能力（5.3 以上采用）</li>
<li>JDBC 消息存储-消息基于 JDBC 存储的。</li>
<li>Memory 消息存储-基于内存的消息存储。</li>
</ul>
<h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store 是 ActiveMQ 5.0 缺省的持久化存储。它是一个基于文件、事务存储设计为快速消息存储的一个结构。AMQ 消息存储的初衷是尽可能简单的应用。它用了一个基于文件存储的消息数据库并且不依赖与第三方数据库。ActiveMQ 不会下载数据和不会运行很长时间。反之，AMQ 存储结构是以流的形式来进行消息交互的。如果 AMQ 消息存储没有配置，那么它会使用默认的配置参数。选择性的使用消息存储或者改变 AMQ 消息存储的默认行为。当然了，一个<persistenceadapter>元素必须被配置。<br>Message commands 被保存到 transactional journal（由 rolling data logs 组成）。Messages 被保存到 data logs 中，同时被 reference store 进行索引以提高存取速度。Date logs 由一些单独的 data log 文件组成， 缺省的文件大小是 32M， 如果某个消息的大小超过了 data log 文件的大小， 那么可以修改配置以增加data log 文件的大小。如果某个 data log 文件中所有的消息都被成功消费了，那么这个data log 文件将会被标记，以便在下一轮的清理中被删除或者归档。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook =<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;amqPersistenceAdapter directory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span> maxFileLength=<span class="string">"32mb"</span> /&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">&lt;/boker&gt;</div></pre></td></tr></table></figure></persistenceadapter></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/amq.png" alt=""></p>
<ol>
<li>Journal=包括一些基于消息和命令存储的回滚日志文件。 当数据文件到达最大值时，新的数据文件将会被创建。数据文件中的消息都会被映射， 如果一些消息如果不长时间使用的话， 他将会被移除或者被存档。Journal 仅仅是把当前的最新消息链接到该数据文件上即可， 所以存储相当的快.</li>
<li>Cache:能够快速的是存储在journal目录中的数据恢复到内存中。 Cache还更新当前消息 id 和定位消息在journal中存储的最新映射。映射存储被更新后，消息才被安全的从缓存中移除。在缓存更新到映射存储这个范围段内我们需要配置属性checkpoinInterval。如果ActiveMQ消息 broker 在内存达到上限时 checkpoint将会起作用。</li>
<li>Refernce：在journal中通过消息的id来映射消息。 它能够准确的从FIFO中映射其队列的数据结构和通过指针指向持久化订阅的主题消息。索引指数指的是 hash 索引。它也可以用一个内存 HashMap 类型的。</li>
</ol>
<p>使用场景：<br>AMQ 是 ActiveMQ 的默认消息存储，它提供了在执行中的负载平衡，事实上这种存储是已经在嵌入 broker 和配置 xml 的 broker 中是最理想的存储方式对于用户。<br>它对于独立的和嵌入式的 ActiveMQ 来说是由可靠的持久性依赖于持久的事务处理和高效的索引来存储使其最优化程度高。AMQ 存储的这用易操作性意味这它将被大部分应用所使用， 从高输出应用到存储大数据量的消息。</p>
<h3 id="KahaDB-Message-Store"><a href="#KahaDB-Message-Store" class="headerlink" title="KahaDB Message Store"></a>KahaDB Message Store</h3><p>KahaDB 是一种新的消息消息存储，而且解决了 AMQ 的一些不足，提高了性能。 AMQ 消息存储用两个分离的文件对于每一个索引和如果 broker 没有彻底关闭则恢复很麻烦， 所有的索引文件需要重新构建， broker 需要遍历所有的消息日志文件。<br>为了克服以上限制， KahaDB 消息存储对于它的索引用一个事务日志和仅仅用一个索引文件来存储它所有的地址。不同于 AMQ。而且在生成环境测试链接数到10000，而且每一个链接对应一个队列。<br>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在 Kaha 中，数据被追加到 data logs 中。当不再需要 log 文件中的数据的时候，log 文件会被丢弃。以下是其配置的一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;kahaPersistenceAdapter directory=<span class="string">"activemq-data"</span> maxDataFileLength=<span class="string">"33554432"</span></div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">   &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/kaha.png" alt=""><br>所有的索引文件更新的记录存在 Redo Log 中，这样就不用更新没有变化的索引数据了，仅仅更新变化的数据。额外的，KahaDB 消息存储用了一个 B-Tree 布局恰恰和 AMQ 消息存储相反，KahaBD 消息存储保持所有的索引在一个持久的 hash 表中，然而 hash 索引在时刻的变化，KahaBD 在这方面已经有了很好的性能特征<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;kahaDB directory=<span class="string">"activemq-data"</span> journalMaxFileLength=<span class="string">"32mb"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Message-Store"><a href="#JDBC-Message-Store" class="headerlink" title="JDBC Message Store"></a>JDBC Message Store</h3><p>当我们使用 JDBC 消息存储默认的驱动使用 Apache Derby 数据库。同时也支持其它关系数据库：MySQL、Oracle、SQLServer、Sybase、Informix、MaxDB.<br>JDBC 消息存储提供了三张表， 其中两种表是用于存储消息和第三张表是用于类似与排他锁似的，这样确保 ActiveMQ 仅仅由一个用户进入数据库.<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/msgs.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack1.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;persistence&gt;</div><div class="line">&lt;jdbcPersistence dataSourceRef=<span class="string">"mysql-ds"</span>/&gt;</div><div class="line">&lt;/persistence&gt;</div><div class="line">&lt;bean id=<span class="string">"mysql-ds"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"driverClassName"</span>value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost/activemq?relaxAutoCommit=true"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"username"</span> value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"password"</span>value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h3 id="jdbc-with-journal"><a href="#jdbc-with-journal" class="headerlink" title="jdbc with journal"></a>jdbc with journal</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;persistenceFactory&gt; &lt;journalPersistenceAdapterFactory journalLogFiles=<span class="string">"4"</span> journalLogFileSize=<span class="string">"32768"</span> useJournal=<span class="string">"true"</span> useQuickJournal=<span class="string">"true"</span> dataSource=<span class="string">"#derby-ds"</span> dataDirectory=<span class="string">"activemq-data"</span> /&gt;</div><div class="line">&lt;/persistenceFactory&gt;</div><div class="line">&lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>JDBC Store和JDBC Message Store with ActiveMQ Journal的区别<br>1:Jdbc with journal的性能优于jdbc<br>2:Jdbc用于master/slave模式的数据库分享<br>3:Jdbc with journal不能用于master/slave模式<br>4:一般情况下,推荐使用jdbc with journal</p>
<h3 id="memory-message-Store"><a href="#memory-message-Store" class="headerlink" title="memory message Store"></a>memory message Store</h3><p>内存消息存储主要是存储所有的持久化的消息在内存中。这里没有动态的缓存存在，所以你必须注意设置你的 broker 在 JVM 和内存限制。<br>消息存储基于 Memory，所有的消息都存储在内存里。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> persistent=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61635"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt; &lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h3 id="KahaDB、-AMQ-区别"><a href="#KahaDB、-AMQ-区别" class="headerlink" title="KahaDB、  AMQ 区别"></a>KahaDB、  AMQ 区别</h3><ol>
<li>KahaDB 克服了 AMQ 的一些不足。</li>
<li>kahaDB 性能上优于 AMQ。</li>
<li>KahaDB 用于大量的 broker【500 个以上】 。</li>
<li>AMQ 用于独立和嵌入式的 broker 比较好。</li>
<li>AMQ 在执行的性能和索引方面都比较不错。</li>
<li>kahaDB 和 AMQ 两者是独立的，谁也不包括谁。</li>
</ol>
<h3 id="使用内存消息存储"><a href="#使用内存消息存储" class="headerlink" title="使用内存消息存储"></a>使用内存消息存储</h3><p>如果你的 broker 仅仅对于一组消息的消费是很快的，那么可以使用内存消息存储，但是他通常用于内部简单的消息测试，而不花费很多时间。或者能够在测试消息后清除消息</p>
<h1 id="如何用ActiveMQ构建应用"><a href="#如何用ActiveMQ构建应用" class="headerlink" title="如何用ActiveMQ构建应用"></a>如何用ActiveMQ构建应用</h1><h2 id="用ActiveMQ构建java应用"><a href="#用ActiveMQ构建java应用" class="headerlink" title="用ActiveMQ构建java应用"></a>用ActiveMQ构建java应用</h2><h3 id="嵌入式broker启动"><a href="#嵌入式broker启动" class="headerlink" title="嵌入式broker启动"></a>嵌入式broker启动</h3><h4 id="broker-service启动broker"><a href="#broker-service启动broker" class="headerlink" title="broker service启动broker"></a>broker service启动broker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService();</div><div class="line">broker.setUseJmx(<span class="literal">true</span>);</div><div class="line">broker.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<h4 id="broker-factory启动"><a href="#broker-factory启动" class="headerlink" title="broker factory启动"></a>broker factory启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String Uri = <span class="string">"properties:resources/broker.properties"</span>;</div><div class="line">//默认不自动启动。</div><div class="line">// BrokerService broker1 = BrokerFactory.createBroker(Uri);</div><div class="line">BrokerService broker1 = BrokerFactory.createBroker(new URI(Uri));</div><div class="line">//<span class="string">"true"</span>表示自动启动。反之，不启动。</div><div class="line">// BrokerService broker2 = BrokerFactory.createBroker(Uri,<span class="literal">true</span>);</div><div class="line">broker1.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker1.start();</div></pre></td></tr></table></figure>
<h4 id="利用spring集成broker"><a href="#利用spring集成broker" class="headerlink" title="利用spring集成broker"></a>利用spring集成broker</h4><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/spring-broker.png" alt=""></p>
<h4 id="activeMQ嵌入到其他应用服务器中"><a href="#activeMQ嵌入到其他应用服务器中" class="headerlink" title="activeMQ嵌入到其他应用服务器中"></a>activeMQ嵌入到其他应用服务器中</h4><h1 id="ActiveMq的安全"><a href="#ActiveMq的安全" class="headerlink" title="ActiveMq的安全"></a>ActiveMq的安全</h1><h2 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h2><p>适用于简单的认证需求，或者用于建立测试环境。它允许在 XML 配置文件中指定用户、用户组和密码等信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"true"</span> persistent=<span class="string">"false"</span></div><div class="line">xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span></div><div class="line">populateJMSXUserID=<span class="string">"true"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;destinations&gt;</div><div class="line">&lt;queue physicalName=<span class="string">"TEST.Q"</span> /&gt;</div><div class="line">&lt;/destinations&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">&lt;simpleAuthenticationPlugin&gt;</div><div class="line">&lt;users&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"system"</span> password=<span class="string">"manager"</span></div><div class="line">groups=<span class="string">"users,admins"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"users"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"guest"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"guests"</span>/&gt;</div><div class="line">&lt;/users&gt;</div><div class="line">&lt;/simpleAuthenticationPlugin&gt;</div><div class="line">&lt;authorizationPlugin&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;authorizationMap&gt;</div><div class="line">&lt;authorizationEntries&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory.&gt;"</span></div><div class="line"><span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">&lt;/authorizationEntries&gt;</div><div class="line">&lt;/authorizationMap&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="JAAS授权插件"><a href="#JAAS授权插件" class="headerlink" title="JAAS授权插件"></a>JAAS授权插件</h2><p>JAAS Authentication Plugin依赖标准的 JAAS 机制来实现认证。通常情况下，你需要通过设置java.security.auth.login.config 系统属性来配置 loginmodules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin 会缺省使用 login.config 作为文件名</p>
<h3 id="在activeMQ-xml中配置"><a href="#在activeMQ-xml中配置" class="headerlink" title="在activeMQ.xml中配置"></a>在activeMQ.xml中配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt;</div><div class="line">    &lt;jaasAuthenticationPlugin configuration=<span class="string">"activemq-domain"</span> /&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="创建login-config"><a href="#创建login-config" class="headerlink" title="创建login.config"></a>创建login.config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123;</div><div class="line">  org.apache.activemq.jaas.PropertiesLoginModule required</div><div class="line">    debug=<span class="literal">true</span></div><div class="line">    org.apache.activemq.jaas.properties.user=<span class="string">"users.properties"</span></div><div class="line">    org.apache.activemq.jaas.properties.group=<span class="string">"groups.properties"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="创建users-properties和groups-properties文件，包含用户和用户组信息"><a href="#创建users-properties和groups-properties文件，包含用户和用户组信息" class="headerlink" title="创建users.properties和groups.properties文件，包含用户和用户组信息"></a>创建users.properties和groups.properties文件，包含用户和用户组信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">users.properties：</div><div class="line">system=password</div><div class="line">user=password</div><div class="line">guest=password</div><div class="line">groups.properties：</div><div class="line">admins=system</div><div class="line">users=system,user</div><div class="line">guests=guest</div></pre></td></tr></table></figure>
<h3 id="Authorization-plugin-in的使用"><a href="#Authorization-plugin-in的使用" class="headerlink" title="Authorization plugin-in的使用"></a>Authorization plugin-in的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">在activemq.xml中如下配置：</div><div class="line">&lt;plugins&gt;</div><div class="line">  &lt;authorizationPlugin&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">      &lt;authorizationMap&gt;</div><div class="line">        &lt;authorizationEntries&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory."</span>&gt; <span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">        &lt;/authorizationEntries&gt;</div><div class="line">      &lt;/authorizationMap&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">  &lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h1 id="ActiveMQ特点"><a href="#ActiveMQ特点" class="headerlink" title="ActiveMQ特点"></a>ActiveMQ特点</h1><h2 id="使用activeMQ进行集群"><a href="#使用activeMQ进行集群" class="headerlink" title="使用activeMQ进行集群"></a>使用activeMQ进行集群</h2><h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>我们支持 Consumer对消息高可靠性的负载平衡消费，如果一个 Consumer 死掉，该消息会转发到其它的Consumer消费的Queue上。如果一个 Consumer 获得消息比其它Consumer快，那么他将获得更多的消息。如果一个 Conseumer消费缓慢，则其它 Consumer会替换它。</p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>大部情况下是使用一系列的 Broker 和 Client 链接到一起。如果一个 Broker死掉了，Client 可以自动链接到其它Broker上。实现以上行为我门需要用failover：//协议作为 Client，如果启动了多个Broker，Client 可以使用static discover 或者Dynamic discovery 容易的从一个 broker 到另一个 broker 直接链接。这样的当一个broker上没有 Consumer 的话， 那么它的消息不会被消费的， 然而该 broker会通过存储和转发的策略来把该消息发到其它 broker 上。这里的 brokers 没有网络链接各个 brokers。</p>
<h3 id="discovery-of-brokers"><a href="#discovery-of-brokers" class="headerlink" title="discovery of brokers"></a>discovery of brokers</h3><p>ActiveMQ 支持使用 static discovery 或者 dynamic discovery 来动态发现brokers，以至于 Client 能够链接到其它发现的 broker，从而形成网络。</p>
<h3 id="networks-of-brokers"><a href="#networks-of-brokers" class="headerlink" title="networks of brokers"></a>networks of brokers</h3><p>如果你正在使用client/server或者hub/spoke类型的拓扑结构并且你有很多的client很多的broker。这就有可能其中一个broker只有生产者没有消费者，这样的话消息会在这个broker上堆积，并且得不到处理。为了避免这种情况，ActiveMQ提供了网络连接模式（Network of brokers），该模式可以提供存储和转发消息的功能，具体就是broker之间可以互相传送消息，这样也允许我们在网络连接模式中提供重分发TOPIC和QUEUES的功能（参见：<a href="http://activemq.apache.org/how-do-distributed-queues-work.html）。" target="_blank" rel="external">http://activemq.apache.org/how-do-distributed-queues-work.html）。</a><br>这允许一个client去连接任意一个broker， 并且当有错误发生的时候可以failover到其他的broker，它提供了从client的角度来观察一个broker集群<br>网络连接模式允许我们放大client群到一个很大的数量级，因为我们可以运行我们需要的任意多个broker.<br>你可以把该模式想象成一个client集群去连接一个broker集群同时拥有failover和discovery功能去做成的一个简单的易用的消息结构。<br>（注：此处的网络连接模式，仅仅只是为了避免集群中的broker只有producer而没有consumer的情况，它会在不同的broker中间传送消息，以便让所有的消息都能有消费者来处理，但是<br>该模式下不会有消费的备份，在任何时刻，对客户端来说同一个消息都只存在一份，若需要消息备份机制则需要Master Slave的支持，这我们下面会说到）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"static:(nio://192.168.9.102:61616)"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;  </div><div class="line">&lt;!-- dynamic discovery config--&gt;  </div><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>  discoveryUri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master Slave"></a>Master Slave</h3><p>运行独立应用部署的 Brokers 由一个问题，它在任何时候其 broker 在物理上都是独有的。 如果一个 broker 断掉， 那么你必须等待重新复制消息才能启动 broker。必须是 persistent=true 的情况下成立。例如：这里指的是 Shared Nonthing Master/Slave模式，就是说如果 master断掉了，消息的备份会存储在slave中。重新拷贝 slave目录下的数据到 master 的目录下即可，重启 master 了。还有一种就是启动 slave 来替换 master。</p>
<h3 id="Replicated-Message-Stores"><a href="#Replicated-Message-Stores" class="headerlink" title="Replicated Message Stores"></a>Replicated Message Stores</h3><p>Master/Slave 模式的另一种方式就是基于Shared File和 DataBase 的共享模式。当master断掉以后，消息应经存储到硬盘上了，此时 slave 获得锁替换了 Master</p>
<h2 id="Master-Slave集群"><a href="#Master-Slave集群" class="headerlink" title="Master/Slave集群"></a>Master/Slave集群</h2><h3 id="纯Master-Slave"><a href="#纯Master-Slave" class="headerlink" title="纯Master/Slave"></a>纯Master/Slave</h3><ul>
<li>Slave broker 消费 master broker 上所有的消息状态，例如消息、确认和事务状态等。只要 slave broker 连接到了 master broker，它不会（也不被允许）启动任何 network connectors 或者 transport connectors，所以唯一的目的就是复制 master broker 的状态。</li>
<li>Master broker 只有在消息成功被复制到 slave broker 之后才会响应客户。例如，客户的 commit 请求只有在 master broker 和 slave broker 都处理完毕 commit 请求之后才会结束。</li>
<li>当 master broker 失效的时候，slave broker 有两种选择，一种是 slave broker 启动所有的 network connectors 和 transport connectors，这允许客户端切换到 slave broker；另外一种是 slave broker 停止。这种情况下，slave broker 只是复制了 master broker 的状态。</li>
<li>客户应该使用 failover transport 并且应该首先尝试连接 master broker。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover://(tcp://masterhost:61616,tcp://slavehost:61615)?random</div><div class="line">ize=<span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>设置randomize为false就可以让客户总是首先尝试连接master broker（slave broker 并不会接受任何连接，直到它成为了 master broker）。<br>限制：</p>
<ul>
<li>只能有一个 slave broker 连接到 master broker。</li>
<li>在因 master broker 失效而导致 slave broker 成为 master 之后，之前的master broker 只有在当前的 master broker（原 slave broker）停止后才能重新生效。</li>
<li>Master broker 失效后而切换到 slave broker 后，最安全的恢复 master broker 的方式是人工处理。首先要停止 slave broker（这意味着所有的客户也要停止） 。 然后把 slave broker 的数据目录中所有的数据拷贝到 master broker 的数据目录中。然后重启 master broker 和 slave broker。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Master broker 不需要特殊的配置。Slave broker 需要进行以下配置</div><div class="line">&lt;broker masterConnectorURI=<span class="string">"tcp://masterhost:62001"</span> shutdownOn MasterFailure=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://slavehost:61616"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h3 id="JDBC-DataBase-master-slave集群"><a href="#JDBC-DataBase-master-slave集群" class="headerlink" title="JDBC DataBase master/slave集群"></a>JDBC DataBase master/slave集群</h3><p>如果你用单纯的 JDBC 而没有用高性能的持久此时你将依赖于你的数据库作为单独的持久存储引擎。如果你没有高性能的要求，类似这种数据库作为存储引擎可以应用很多场景。<br>启动利用数据库作为数据源，采用Master/Slave模式，其中在启动的时候Master首先获得独有锁，其它 Slaves Broker 则等待获取独有锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp: //broker1:61616,tcp://broker2:61616,tcp://broker3:61616)</div></pre></td></tr></table></figure></p>
<p>如果 Master 失败，则它释放独有锁，其他 Slaver 则获取独有锁.其它 Slaver 立即获得独有锁后此时它将变成 Master，并且启动所有的传输链接。同时，Client 将停止链接之前的 Master 和将会轮询链接到其他可以利用的 Broker 即新 Master。</p>
<h3 id="share-file-master-slave集群"><a href="#share-file-master-slave集群" class="headerlink" title="share file master/slave集群"></a>share file master/slave集群</h3><p>希望基于相同的存储目录下运行多个 Broker，首先，该 Broker Master 会首先获得排它锁。如果该 Master Broker 死掉了会释放掉排它锁，则其它的 Slave Broker会替换它。Slave 是一个轮询的从 Master 那里获得排它锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.org/config/1.0"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;journaledJDBC dataDirectory=<span class="string">"/sharedFileSystem/broker"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>如果你使用 SAN 或者共享文件系统，那么你可以使用 Shared File System Master Slave。基本上，你可以运行多个 broker，这些 broker 共享数据目录。当第一个 broker 得到文件上的排他锁之后，其它的 broker 便会在循环中等待获得这把锁。客户端使用 failover transport 来连接到可用的 broker。当 master broker 失效的时候会释放这把锁，这时候其中一个 slave broker 会得到这把锁从而成为master broker。</p>
<h2 id="network-of-brokers-存储和转发集群"><a href="#network-of-brokers-存储和转发集群" class="headerlink" title="network of brokers (存储和转发集群)"></a>network of brokers (存储和转发集群)</h2><h3 id="单向传递"><a href="#单向传递" class="headerlink" title="单向传递"></a>单向传递</h3><p>ActiveMQ默认的两个broker链接是单方向的，brokerA可以消费brokerB的消息<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/单向broker.png" alt=""></p>
<h3 id="双向传递"><a href="#双向传递" class="headerlink" title="双向传递"></a>双向传递</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/双向broker.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/扩展broker.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static://(tcp://backoffice:61617)"</span> name=<span class="string">"brdge"</span> duplex=<span class="string">"true"</span> ConduitSubscriptions=<span class="string">"true"</span>&gt;</div><div class="line">&lt;/networkConnector&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>Duplex=”true”表示双发可以通信.<br>ConduitSubscriptions=“false”表示每个 Consumer 上都会收到所有的发送的消息。<br>Name=“bridge”默认的。</p>
<h3 id="Broker连接集群"><a href="#Broker连接集群" class="headerlink" title="Broker连接集群"></a>Broker连接集群</h3><p>一个常见的场景是有多个 JMS broker，有一个客户连接到其中一个 broker。如果这个 broker 失效，那么客户会自动重新连接到其它的 broker。在 ActiveMQ中使用 failover:// 协议来实现这个功能。ActiveMQ3.x 版本的 reliable://协议已经变更为 failover://。如果某个网络上有多个 brokers 而且客户使用静态发现（使用 Static Transport 或 Failover Transport）或动态发现（使用 Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的 brokers。然而，stand alone brokers并不了解其它brokers上的consumer，也就是说如果某个broker 上没有 consumers，那么这个 broker 上的消息可能会因得不到处理而积压起来。目前的解决方案是使用 Network of brokers，以便在 broker 之间存储转发消息。ActiveMQ 在未来会有更好的特性，用来在客户端处理这个问题。从 ActiveMQ1.1 版本起，ActiveMQ 支持 networks of brokers。它支持分布式的 queues 和 topics。一个 broker 会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程 broker，它都会递送有关的消息拷贝到每个订阅。远程 broker 得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。 有两种方式配置 Network of brokers， 一种是使用 static transport，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"receiver"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:62002"</span> /&gt;</div><div class="line">&lt; /transportConnectors&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static:( tcp://localhost:61616, tcp://remotehost:61616)"</span> /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>或者使用dynamic transport<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=<span class="string">"sender"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt; &gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://localhost:0"</span> discoveryUri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line"> &lt;networkConnectors&gt;</div><div class="line"> &lt;networkConnector uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/networkConnectors&gt;</div><div class="line">  &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Queue-consumer集群"><a href="#Queue-consumer集群" class="headerlink" title="Queue consumer集群"></a>Queue consumer集群</h2><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认的消息都会被发送到这个 queue 上其它的 consumers。如果某个 consumer 的处理速度比其它 consumers 更快，那么这个 consumer 就会消费更多的消息</p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="dynamicOnly"><a href="#dynamicOnly" class="headerlink" title="dynamicOnly"></a>dynamicOnly</h3><p>默认是 false，如果是 true，消息将被动态的转接的在其他 broker 的 consumer上</p>
<h3 id="prefetchSize"><a href="#prefetchSize" class="headerlink" title="prefetchSize"></a>prefetchSize</h3><p>ActiveMQ使用了　消息”预取限制“(prefetch limit)：表示在某个时间段内，可能向消费者传输的最大消息量，如果达到该上限，那么停止发送，直到ActiveMQ收到消费者的acknowledgements(确认，表示已经处理了该消息。prefetch limit可以针对每个不同的consumer来设置。<br>为了获取更高的性能，prefetch limit当然是越大越好，只要consumer有足够大的消息缓冲区(messagevolume)。如果消息的总量非常少，而且每个消息的处理时间非常的长，那么，可以将prefetch设置为1，这样，每次向consumer发送一个消息，等其确认已经处理完毕后，再发送第二个。<br>特别地，如果prefetch设置为0，表示consumer每次　主动向activeMQ要求传输最大的数据量，而不是被动地接收消息</p>
<h3 id="conduitSubscriptons"><a href="#conduitSubscriptons" class="headerlink" title="conduitSubscriptons"></a>conduitSubscriptons</h3><p>关于 conduitSubscriptions 属性，这里稍稍说明一下。设想有两个 brokers，分别是brokerA和brokerB， 它们之间用forwarding bridge连接。 有一个consumer连接到brokerA并订阅 queue： Q.TEST。 有两个 consumers 连接到 brokerB， 也是订阅 queue： Q.TEST。这三个 consumers 有相同的优先级。然后启动一个 producer，它发送了 30 条消息到brokerA。如果 conduitSubscriptions=true，那么 brokerA 上的 consumer 会得到 15 条消息， 另外15条消息会发送给brokerB。 此时负载并不均衡， 因为此时brokerA将brokerB上的两个 consumers 视为一个；如果 conduitSubscriptions=false，那么每个 consumer上都会收到 10 条消息。</p>
<h3 id="decreaseNetwordConsumerPriority"><a href="#decreaseNetwordConsumerPriority" class="headerlink" title="decreaseNetwordConsumerPriority"></a>decreaseNetwordConsumerPriority</h3><p>默认是 false。设定消费者优先权</p>
<h3 id="networkTTL"><a href="#networkTTL" class="headerlink" title="networkTTL"></a>networkTTL</h3><p>默认是 1</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;面向消息的中间件：Message-oriented Middleware, MOM&lt;br&gt;基本功能：将信息以消息的形
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
</feed>
