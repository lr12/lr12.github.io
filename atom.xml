<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-19T13:50:22.406Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为大量并发应用程序部署ActiveMQ</title>
    <link href="http://yoursite.com/2017/12/19/%E4%B8%BA%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2ActiveMQ/"/>
    <id>http://yoursite.com/2017/12/19/为大量并发应用程序部署ActiveMQ/</id>
    <published>2017-12-19T13:49:38.000Z</published>
    <updated>2017-12-19T13:50:22.406Z</updated>
    
    <content type="html"><![CDATA[<p>##</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##&lt;/p&gt;

    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 笔记一</title>
    <link href="http://yoursite.com/2017/12/15/Apache-ActiveMQ-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/15/Apache-ActiveMQ-笔记/</id>
    <published>2017-12-15T01:52:52.000Z</published>
    <updated>2017-12-19T13:45:59.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>面向消息的中间件：Message-oriented Middleware, MOM<br>基本功能：将信息以消息的形式，从一个应用程序传送到另一个或多个应用程序。<br>主要特点：</p>
<ul>
<li>消息异步接受，类似手机短信的行为，消息发送者不需要等待消息接受者的响应，减少软件多系统集成的耦合度。</li>
<li>消息可靠接收，确保消息在中间件可靠保存，只有接收方收到后才删除消息，多个消息也可以组成原子事务。</li>
</ul>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>java message service</p>
<h3 id="JMS规范"><a href="#JMS规范" class="headerlink" title="JMS规范"></a>JMS规范</h3><p>java消息服务定义了java中访问消息中间件的接口。JMS只是接口，并没有实现，实现JMS的接口的消息中间件称为JMS Provider，例如ActiveMQ。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>JMS Provider：实现JMS接口的消息中间件<br>PTP：point to point，即点对点模型<br>pub/sub：publish/subscribe，即发布/订阅消息模型<br>Queue：队列目标<br>Topic：主题目标<br>ConnectionFactory：连接工厂，JMS用它来创建连接<br>Connection：JMS客户端到JMS provider的连接<br>Destination：消息的目的地<br>Session：会话，一个发送或接收消息的线程<br>MessageProducer：由session对象创建用来发送消息的对象<br>MessageConsumer：由session对象创建用来接收消息的对象<br>Acknowledge：签收<br>Transaction：事务</p>
<h3 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h3><p>在 JMS 编程模型中，JMS 客户端（组件或应用程序）通过 JMS 消息服务交换消息。消息生产者将消息发送至消息服务，消息消费者则从消息服务接收这些消息。这些消息传送操作是使用一组实现 JMS 应用编程接口 (API) 的对象 （由 JMS Provide 提供）来执行的。<br>在 JMS 编程模型中，JMS 客户端使用 ConnectionFactory 对象创建一个连接，向消息服务发送消息以及从消息服务接收消息均是通过此连接来进行。Connection是客户端与消息服务的活动连接。创建连接时，将分配通信资源以及验证客户端。这是一个相当重要的对象，大多数客户端均使用一个连接来进行所有的消息传送。连接用于创建会话。Session 是一个用于生成和使用消息的单线程上下文。它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。客户端使用 MessageProducer 向指定的物理目标 （在 API 中表示为目标身份对象）发送消息。<br>生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息。同样，客户端使用 MessageConsumer 对象从指定的物理目标（在 API 中表示为目标对象）接收消息。消费者可使用消息选择器，借助它，消息服务可以只向消费者发送与选择标准匹配的那些消息。消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 MessageListener 来实现。当会话线程调用 MessageListener 对象的 onMessage 方法时，客户端将使用消息。</p>
<h3 id="JMS编程域"><a href="#JMS编程域" class="headerlink" title="JMS编程域"></a>JMS编程域</h3><p>JMS接收两种截然不同的消息传送模型PTP和Pub/Sub</p>
<ul>
<li>PTP<br>消息从一个生产者传送给一个消费者。在此传送模型中，目标是一个队列。消息首先传送到队列目标，然后根据队列传送策略，从该队列将消息传送到这队列进行注册的某一个消费者，一次只传送一条消息。可以向队列目标发送消息的生产者的数量没有限制，但每条消息只能发送至、并由一个消费者成功使用。如果没有已经向队列目标注册的消费者，队列将保留它收到的消息，并在某个消费者向该队列进行注册时将消息传送给该消费者。</li>
<li>Pub/Sub<br>消息从一个生产者传送至任意数量的消费者。在此传送模型中，目标是一个主题。消息首先被传送至主题目标，然后传送至所有已订阅此主题的活动消费者。可以向主题目标发送消息的生产者的数量没有限制，并且每个消息可以发送至任意数量的订阅消费者。主题目标也支持持久订阅的概念。持久订阅表示消费者已向主题目标进行注册，但在消息传送时此消费者可以处于非活动状态。当此消费者再次处于活动状态时，它将接收此信息。如果没有已经向主题目标注册的消费者，主题不保留其接收到的消息，除非有非活动消费者注册了持久订阅</li>
</ul>
<h2 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h2><p>JMS消息由消息头、属性和消息体组成</p>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>消息头包含消息的识别信息和路由信息，消息头包含一些标准的属性如JMSDestination、JMSMessageID<br>JMSDestination<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/jms消息结构.png" alt=""><br>JMSDestination(自动)：消息发送的目的地主要指Queue和Topic<br>JMSDeliveryMode（自动）：传送模式有两种模式：持久模式和非持久模式，一条持久性消息应该被传递一次仅仅一次，这就意味着如果JMS提供者出现故障，该消息不会丢失，它会在服务器恢复之后再次传递。<br>JMSExpiration（自动）：消息过期时间，等于Destination 的send 方法的timeToLive值加上发送时刻的GMT 时间值。如果timeToLive值等于零则JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除<br>JMSPriority(自动):消息优先级， 从 0-9 十个级别，0-4 是普通消息，5-9 是加急消息。JMS 不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达。默认是4级。<br>JMSMessageID（自动）：唯一识别每个消息的标识，由JMS Provider 产生。<br>JMSTimestamp（自动）：一个JMS Provider在调用send()方法时自动设置的。它是消息被发送和消费者实际接收的时间差。自动分配。<br>JMSCorrelationID（开发者设置）：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对 JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。<br>JMSReplyTo（开发者设置）：提供本消息回复消息的目的地址。<br>JMSType（开发者设置）：消息类型的识别符。由开发者设置<br>JMSRedelivered(自动)：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收 (acknowledged)。如果该消息被重新传送，JMSRedelivered=true反之，JMSRedelivered =false。</p>
<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>TextMessage:java.lang.String 对象，如xml 文件内容<br>MapMessage:名/值对的集合，名是String 对象，值类型可以是Java 任何基本类型。<br>ByteMessage:字节流<br>StreamMessage：java输入输出流<br>ObjectMessage：java中可序列化对象</p>
<h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><h4 id="应用程序特定的属性"><a href="#应用程序特定的属性" class="headerlink" title="应用程序特定的属性"></a>应用程序特定的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextMessage message=session.createTextMessage();</div><div class="line">message.setStringProperty(<span class="string">"username"</span>,username);</div></pre></td></tr></table></figure>
<h4 id="JMS定义的属性"><a href="#JMS定义的属性" class="headerlink" title="JMS定义的属性"></a>JMS定义的属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message.setStringProperty(<span class="string">"JMSXGroupID"</span>,<span class="string">"GroupA"</span>);</div><div class="line">message.setIntProperty(<span class="string">"JMSXGroupSeq"</span>, -1);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名字</th>
<th>类型</th>
<th>设置者</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>JMSXUserID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送时的用户标识</td>
</tr>
<tr>
<td>JMSXAppID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>发送消息的应用标识</td>
</tr>
<tr>
<td>JMSXDeliveryCount</td>
<td>int</td>
<td>发送时提供商设置</td>
<td>转发消息重试次数，第一次是1，第二次是2</td>
</tr>
<tr>
<td>JMSXGroupID</td>
<td>String</td>
<td>客户端</td>
<td>消息所在消息组的标识</td>
</tr>
<tr>
<td>JMSXGroupSeq</td>
<td>int</td>
<td>客户端</td>
<td>组内消息的序号第一个消息是1，第二个是2</td>
</tr>
<tr>
<td>JMSXProducerTXID</td>
<td>String</td>
<td>发送时提供商设置</td>
<td>产生消息时的事务的事务标识</td>
</tr>
<tr>
<td>JMSXConsumerTXID</td>
<td>String</td>
<td>接收时提供商设置</td>
<td>接收消息的事务的事务标识</td>
</tr>
<tr>
<td>JMSXRcvTimestamp</td>
<td>long</td>
<td>接收时提供商设置</td>
<td>JMS转发到消费者的消息</td>
</tr>
<tr>
<td>JMSXState</td>
<td>int</td>
<td>提供商</td>
<td>假定存在一个消息仓库，它存储了每个消息的拷贝，且这些消息从原始消息被发送开始，每个的拷贝的状态有1(等待),2（准备），3（到期）或者4（保留）。由于状态与生产者和消费者无关，所以它不是由它们来提供。它只和在仓库中查找消息相关，因此JMS没有提供这种API。</td>
</tr>
</tbody>
</table>
<h3 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h3><p>如果会话是事务性的，那么消息确认自动由commit 处理，且恢复自动由rollback 处理。如果会话不是事务性的，有三个确认选择，且手工处理恢复。</p>
<ul>
<li><p>DUPS_OK_ACKNOWLEDGE:这个选项告诉会话懒惰确认消息的传递。如果JMS失败，这很可能造成传递重复消息，因此这个选项只用于可以忍受重复消息的消费者。它的好处是减少了会话为防止重复所要做的工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.DUPS_OK_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>AUTO_ACKNOWLEDGE:使用这个选项，当消息被成功地从调用接收返回或处理消息的MessageListener 成功返回时，会话自动确认客户端的消息接收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session = conn.createTopicSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
</li>
<li><p>CLIENT_ ACKNOWLEDGE:使用这个选项，客户端通过调用消息的acknowledge方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。当使用 CLIENT_ACKNOWLEDGE 模式时，客户端可以在处理它们时产生大量未确认消息。JMS 提供商应当为管理员提供限制客户端超量运行的途径，以便客户端不会造成资源耗尽并保证当它们使用的资源被临时阻塞时造成失败。 会话的recover 方法用于停止一个会话然后使用第一个未确认消息来重新启动它。事实上，会话的被转发消息序列被重新设置到最后一个确认消息之后。现在转发的消息序列可以与起初转发的消息序列不同， 因为消息到期和收到更高优先级的消息。会话必须设置消息的redelivered 标记，表示它是由于恢复而被重新转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">conn.createTopicSession(<span class="literal">false</span>, Session.CLIENT_ACKNOWLEDGE);</div><div class="line">message.acknowledge();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="PTP模型"><a href="#PTP模型" class="headerlink" title="PTP模型"></a>PTP模型</h2><p>PTP(Point-to-Point)模型是基于队列的，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的异步传输成为可能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConnectionFactory</td>
<td>客户端用ConnectionFactory创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用session创建Message、Producer、Consumer。如果在session关闭有一些消息已经收到但还未被签收，当消费者下次再连接到相同队列时，会被再次接收。</td>
</tr>
<tr>
<td>Destination(Queue或TemporaryQueue)</td>
<td>此处的目标为队列，队列由队列名识别。临时队列只能由创建它的Connection 所创建的消费者消费，但是任何生产者都可向临时队列发送消息。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到队列中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收队列中的消息，如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>可靠性</td>
<td>队列可以长久地保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的连接状态，充分体现了异步传输模式的优势。</td>
</tr>
</tbody>
</table>
<h2 id="PUB-SUB模型"><a href="#PUB-SUB模型" class="headerlink" title="PUB/SUB模型"></a>PUB/SUB模型</h2><p>JMS Pub/Sub 模型定义了如何向一个内容节点发布和订阅消息，这些节点被称作主题。主题可以被认为是消息的传输中介，发布者(publisher)发布消息到主题，订阅者(subscribe) 从主题订阅消息。主题使得消息订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>订阅(subscription)</td>
<td>消息订阅分为非持久订阅和持久订阅，非持久订阅只有当客户端处于激活状态，也就是和JMSProvider 保持连接状态才能收到发送到某个主题的消息，而当客户端处于离线状态，这个时间段发到主题的消息将会丢失，永远不会收到。持久订阅时，客户端向JMS 注册一个识别自己身份的ID，当这个客户端处于离线时，JMS Provider 会为这个ID 保存所有发送到主题的消息，当客户再次连接到JMS Provider 时， 会根据自己的ID 得到所有当自己处于离线时发送到主题的消息</td>
</tr>
<tr>
<td>ConnectionFactory</td>
<td>客户端用 ConnectionFactory 创建Connection对象</td>
</tr>
<tr>
<td>Connection</td>
<td>一个到JMS provider的连接</td>
</tr>
<tr>
<td>Session</td>
<td>客户端用Session 创建MessageProducer 和MessageConsumer 对象。它还提供持久订阅主题，或使用unsubscribe 方法取消消息的持久订阅。</td>
</tr>
<tr>
<td>Destination(Topic和TemporaryTopic)</td>
<td>客户端用 Session 创建Destination 对象。此处的目标为主题，主题由主题名识别。临时主题只能由创建它的Connection 所创建的消费者消费。临时主题不能提供持久订阅功能。JMS 没有给出主题的组织和层次结构的定义，由JMS Provider 自己定义。</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>客户端用MessageProducer发送消息到主题中</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>客户端用MessageConsumer 接收主题中的消息， 如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到。</td>
</tr>
<tr>
<td>恢复和重新派送</td>
<td>非持久订阅状态下，不能恢复或重新派送一个未签收的消息。只有持久订阅才能恢复或重新派送一个未签收的消息。</td>
</tr>
<tr>
<td>可靠性</td>
<td>当所有的消息必须被接收，则用持久订阅模式。当丢失消息能够被容忍，则用非持久订阅模式。</td>
</tr>
</tbody>
</table>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>支持并发的对象：Destination、ConnectionFactory、Connection<br>不支持并发的对象：Session、MessageProducer、MessageConsumer</p>
<h1 id="如何配置ActiveMQ"><a href="#如何配置ActiveMQ" class="headerlink" title="如何配置ActiveMQ"></a>如何配置ActiveMQ</h1><blockquote>
<blockquote>
<blockquote>
<p>Master-Slave集群：<br>由至少3个节点组成，一个Master节点，其他为Slave节点。只有Master节点对外提供服务，Slave节点处于等待状态。当主节点宕机后，从节点会推举出一个节点出来成为新的Master节点，继续提供服务。<br>优点是可以解决多服务热备的高可用问题，缺点是无法解决负载均衡和分布式的问题。<br>Broker Cluster集群：<br>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue.当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。<br>优点是可以解决负载均衡和分布式的问题。但不支持高可用。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="如何配置传输连接"><a href="#如何配置传输连接" class="headerlink" title="如何配置传输连接"></a>如何配置传输连接</h2><h3 id="格式配置如下"><a href="#格式配置如下" class="headerlink" title="格式配置如下"></a>格式配置如下</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/配置.png" alt=""></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>activeMQ 的 Broker 和 Client 之间需要一个高稳定性的通信，不难发现，TCP是一个理想的实现。所以我们并不惊讶在 ActiveMQ 频繁的使用 TCP 协议。<br>在做数据交互之前，我们需要知道必须序列化数据，消息是如何通过一个叫wire protocol 的来序列化成字节流。默认情况下，ActiveMQ 把 wire protocol 叫做OpenWire。它的目的是促使网络上的效率和数据快速交互等。默认的 Broker 配置，TCP 的 Client 监听端口是 61616。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://host:port?key=value</div></pre></td></tr></table></figure></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO 协议和 TCP 协议类似，nio 更侧重于底层的访问操作。它不同与传统的I/O 流操作。允许开发人员对同一资源可有更多的 client 调用和服务端有更多的负载。<br>以下场景使用NIO：</p>
<ul>
<li>你可能有大量的 Client 去链接到 Broker 上；<br>般情况下，大量的 Client 去链接 Broker 是被操作系统的线程数所限制的。因此，NIO 的实现比 TCP 需要更少的线程去运行，所以，建议你使用 NIO 协议。</li>
<li>你可能对于 Broker 有一个很迟钝的网络传输。<br>NIO 比 TCP 提供更好的性能。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nio://host:port?key=value</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"tcp"</span> uri=<span class="string">"tcp://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;transportConnector name=<span class="string">"nio"</span> uri=<span class="string">"nio://localhost:61616?trade=true"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>运行原理如下：Producer 通过 NIO 协议发送数据到 broker，Consumer 通过 TCP 协议接收数据<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/broker.png" alt=""></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP是被用在稳定可靠的场景中使用的，然而，UDP 通常用在快速数据传递和不怕数据丢失的场景中使用的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udp://hostname:port?key=value</div></pre></td></tr></table></figure></p>
<p>TCP 是一个原始的流协议，意味者数据包的传递是有保证的。UDP 则没有保证。<br>TCP 同样也是一个可靠性高的传递协议。意味者数据包不会丢失，反之，UDP 则不能保证</p>
<h3 id="Secure-Sockets-Layer-Protocol-SSL"><a href="#Secure-Sockets-Layer-Protocol-SSL" class="headerlink" title="Secure Sockets Layer Protocol(SSL)"></a>Secure Sockets Layer Protocol(SSL)</h3><p>基于 TCP 之上的安全协议</p>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://hostname:port?key=value</div></pre></td></tr></table></figure>
<h3 id="vm-protocol"><a href="#vm-protocol" class="headerlink" title="vm protocol"></a>vm protocol</h3><p>VM transport 允许在 VM 内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。第一个创建 VM 连接的客户会启动一个 embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个 broker。当这个 broker上所有的连接都关闭的时候，这个broker也会自动关闭</p>
<h2 id="如何配置网络"><a href="#如何配置网络" class="headerlink" title="如何配置网络"></a>如何配置网络</h2><p>一个ActiveMQ Broker对于你的所有的应用来说是非常实用的。但是，某些场景需要一些高级的特性。例如：高稳定性和大传输量。典型的就是用在网络中。Broker集群在多个ActiveMQ的实例中大大优化了消息的传递。这章主要是解释网络链接在 ActiveMQ 的应用，Broker 到 Broker 的通信。网络链接是以通道的形式将一个Broker 和其他的 Broker 链接起来通信。 网络链接默认是单向的， 然而， 一个 Broker在一端发送消息， 在另一 Broker 在另一端接收消息。 这就是所谓的 “桥接” 。 然而，你可能想创建一个双向的通道对于两个 Broker。他将不仅发送消息而且也能从相同的通道来接收消息。ActiveMQ 支持这种双向链接，通常作为 duplex connector来映射。如下图<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/brokers.png" alt=""></p>
<h3 id="如何配置Dynamic-Networks"><a href="#如何配置Dynamic-Networks" class="headerlink" title="如何配置Dynamic Networks"></a>如何配置Dynamic Networks</h3><h4 id="multicast协议"><a href="#multicast协议" class="headerlink" title="multicast协议"></a>multicast协议</h4><p>ActiveMQ 使用 Multicast 协议将一个 Service 和其他的 Broker 的 Service 连接起来。IP multicast是一个被用于网络中传输数据到其它一组接收者的技术。Ip multic 传统的概念称为组地址。组地址是 ip 地址在 224.0.0.0 到 239.255.255.255 之间的 ip 地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">multicast://address:port?transportOptions</div><div class="line">multicast://default</div><div class="line">multicast://224.1.2.3:6255</div><div class="line">multicast://224.1.2.3:6255?group=mygroupname</div><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"localhost"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector name=<span class="string">"default-nc"</span> uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;!-- DOS protection, <span class="built_in">limit</span> concurrent connections to 1000 and frame size to 100MB --&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"</span> discoveryUri=<span class="string">"multicast://default"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>“default”=是 activemq 默认的 ip，默认动态的寻找地址<br>“discoveryUri”=是指在 transport 中用 multicast 的 default 的地址传递。<br>“uri”=指动态寻找可利用的地址<br><em>防止自动寻找地址</em><br>1.名称为 openwire 的 transport，移除discoveryUri=”multicast://default”即可。传输链接用默认的名称 openwire 来配置 broker 的 tcp 多点链接，这将允许其它 broker 能够自动发现和链接到可用的 broker 中<br>2.名称为“default-nc”的 networkConnector，注释掉或者删除即可<br>3.使 brokerName 的名字唯一。默认是 localhost。是为了唯一识别 Broker的实例</p>
<h4 id="discovery协议"><a href="#discovery协议" class="headerlink" title="discovery协议"></a>discovery协议</h4><p>Discovery 是在 multicast 协议的功能上定义的。功能类似与 failover 功能。它将动态的发现 multicast 协议的 broker 的链接并且随机的链接其中一个 broker。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions</div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<h4 id="peer协议"><a href="#peer协议" class="headerlink" title="peer协议"></a>peer协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">peer://peergroup/brokerName?key=value</div></pre></td></tr></table></figure>
<h4 id="fanout协议"><a href="#fanout协议" class="headerlink" title="fanout协议"></a>fanout协议</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fanout://(fanoutUri)?key=value</div></pre></td></tr></table></figure>
<h3 id="如何配置Static-Networks"><a href="#如何配置Static-Networks" class="headerlink" title="如何配置Static Networks"></a>如何配置Static Networks</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static://(uri1,uri2)</div></pre></td></tr></table></figure>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/static.png" alt=""><br>关于以上视图，两个 Brokers 是网络链接的。Brokers 通过一个 static 的协议来创建一个链接。一个 Consumer 链接到 brokerB 的一个地址上 ，当 Producer 在brokerA 上以相同的地址发送消息时， 此时它将被转移到 brokerB 上。 这种情况下，BrokerA 转发消息到 BrokerB 上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"brokerA"</span> dataDirectory=<span class="string">"<span class="variable">$&#123;activemq.data&#125;</span>"</span>&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">  &lt;networkConnector uri=<span class="string">"static:(tcp://localhost:61617)"</span>  /&gt;</div><div class="line">  &lt;/networkConnectors&gt;</div><div class="line">  &lt;transportConnectors&gt;</div><div class="line">            &lt;transportConnector name=<span class="string">"openwire"</span> uri=<span class="string">"localhost:61616"</span>/&gt;</div><div class="line">        &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>以上配置broker监听端口在 61617上，它定义了一个 networks 链接到 BrokerB上。以上例子，消息在 BrokerA 上被发送，消息被转发到 BrokerB 上，此时通过Consumer 来消费该消息。</p>
<h4 id="failover-protocol"><a href="#failover-protocol" class="headerlink" title="failover protocol"></a>failover protocol</h4><p>Failover 协议实现了自动重新链接的逻辑。这里有两种方式提供了稳定的brokers 列表对于 Client 链接。 第一种方式：提供一个 static 的可用的 Brokers 列表。第二种方式：提供一个 dynamic 发现的可用 Brokers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp://localhost:61616)</div></pre></td></tr></table></figure></p>
<p>对于 broker 失败 client 不需要重新去启动，而是自动的去连接其它可用的broker</p>
<h1 id="消息存储的持久化"><a href="#消息存储的持久化" class="headerlink" title="消息存储的持久化"></a>消息存储的持久化</h1><p>消息的持久化不仅支持persistence和non-persistence，还支持recovery。</p>
<h2 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/PTP.png" alt=""></p>
<h2 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h2><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/pub-sub.png" alt=""></p>
<h2 id="有效存储"><a href="#有效存储" class="headerlink" title="有效存储"></a>有效存储</h2><ul>
<li>AMQ 消息存储-默认的消息存储</li>
<li>KahaDB 消息存储-提供了容量的提升和恢复能力（5.3 以上采用）</li>
<li>JDBC 消息存储-消息基于 JDBC 存储的。</li>
<li>Memory 消息存储-基于内存的消息存储。</li>
</ul>
<h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store 是 ActiveMQ 5.0 缺省的持久化存储。它是一个基于文件、事务存储设计为快速消息存储的一个结构。AMQ 消息存储的初衷是尽可能简单的应用。它用了一个基于文件存储的消息数据库并且不依赖与第三方数据库。ActiveMQ 不会下载数据和不会运行很长时间。反之，AMQ 存储结构是以流的形式来进行消息交互的。如果 AMQ 消息存储没有配置，那么它会使用默认的配置参数。选择性的使用消息存储或者改变 AMQ 消息存储的默认行为。当然了，一个<persistenceadapter>元素必须被配置。<br>Message commands 被保存到 transactional journal（由 rolling data logs 组成）。Messages 被保存到 data logs 中，同时被 reference store 进行索引以提高存取速度。Date logs 由一些单独的 data log 文件组成， 缺省的文件大小是 32M， 如果某个消息的大小超过了 data log 文件的大小， 那么可以修改配置以增加data log 文件的大小。如果某个 data log 文件中所有的消息都被成功消费了，那么这个data log 文件将会被标记，以便在下一轮的清理中被删除或者归档。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook =<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;amqPersistenceAdapter directory=<span class="string">"<span class="variable">$&#123;activemq.base&#125;</span>/data"</span> maxFileLength=<span class="string">"32mb"</span> /&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">&lt;/boker&gt;</div></pre></td></tr></table></figure></persistenceadapter></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/amq.png" alt=""></p>
<ol>
<li>Journal=包括一些基于消息和命令存储的回滚日志文件。 当数据文件到达最大值时，新的数据文件将会被创建。数据文件中的消息都会被映射， 如果一些消息如果不长时间使用的话， 他将会被移除或者被存档。Journal 仅仅是把当前的最新消息链接到该数据文件上即可， 所以存储相当的快.</li>
<li>Cache:能够快速的是存储在journal目录中的数据恢复到内存中。 Cache还更新当前消息 id 和定位消息在journal中存储的最新映射。映射存储被更新后，消息才被安全的从缓存中移除。在缓存更新到映射存储这个范围段内我们需要配置属性checkpoinInterval。如果ActiveMQ消息 broker 在内存达到上限时 checkpoint将会起作用。</li>
<li>Refernce：在journal中通过消息的id来映射消息。 它能够准确的从FIFO中映射其队列的数据结构和通过指针指向持久化订阅的主题消息。索引指数指的是 hash 索引。它也可以用一个内存 HashMap 类型的。</li>
</ol>
<p>使用场景：<br>AMQ 是 ActiveMQ 的默认消息存储，它提供了在执行中的负载平衡，事实上这种存储是已经在嵌入 broker 和配置 xml 的 broker 中是最理想的存储方式对于用户。<br>它对于独立的和嵌入式的 ActiveMQ 来说是由可靠的持久性依赖于持久的事务处理和高效的索引来存储使其最优化程度高。AMQ 存储的这用易操作性意味这它将被大部分应用所使用， 从高输出应用到存储大数据量的消息。</p>
<h3 id="KahaDB-Message-Store"><a href="#KahaDB-Message-Store" class="headerlink" title="KahaDB Message Store"></a>KahaDB Message Store</h3><p>KahaDB 是一种新的消息消息存储，而且解决了 AMQ 的一些不足，提高了性能。 AMQ 消息存储用两个分离的文件对于每一个索引和如果 broker 没有彻底关闭则恢复很麻烦， 所有的索引文件需要重新构建， broker 需要遍历所有的消息日志文件。<br>为了克服以上限制， KahaDB 消息存储对于它的索引用一个事务日志和仅仅用一个索引文件来存储它所有的地址。不同于 AMQ。而且在生成环境测试链接数到10000，而且每一个链接对应一个队列。<br>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在 Kaha 中，数据被追加到 data logs 中。当不再需要 log 文件中的数据的时候，log 文件会被丢弃。以下是其配置的一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;persistenceAdapter&gt;</div><div class="line"> &lt;kahaPersistenceAdapter directory=<span class="string">"activemq-data"</span> maxDataFileLength=<span class="string">"33554432"</span></div><div class="line"> &lt;/persistenceAdapter&gt;</div><div class="line">   &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/15/Apache-ActiveMQ-笔记/kaha.png" alt=""><br>所有的索引文件更新的记录存在 Redo Log 中，这样就不用更新没有变化的索引数据了，仅仅更新变化的数据。额外的，KahaDB 消息存储用了一个 B-Tree 布局恰恰和 AMQ 消息存储相反，KahaBD 消息存储保持所有的索引在一个持久的 hash 表中，然而 hash 索引在时刻的变化，KahaBD 在这方面已经有了很好的性能特征<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;kahaDB directory=<span class="string">"activemq-data"</span> journalMaxFileLength=<span class="string">"32mb"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Message-Store"><a href="#JDBC-Message-Store" class="headerlink" title="JDBC Message Store"></a>JDBC Message Store</h3><p>当我们使用 JDBC 消息存储默认的驱动使用 Apache Derby 数据库。同时也支持其它关系数据库：MySQL、Oracle、SQLServer、Sybase、Informix、MaxDB.<br>JDBC 消息存储提供了三张表， 其中两种表是用于存储消息和第三张表是用于类似与排他锁似的，这样确保 ActiveMQ 仅仅由一个用户进入数据库.<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/msgs.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack1.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/ack2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;persistence&gt;</div><div class="line">&lt;jdbcPersistence dataSourceRef=<span class="string">"mysql-ds"</span>/&gt;</div><div class="line">&lt;/persistence&gt;</div><div class="line">&lt;bean id=<span class="string">"mysql-ds"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"driverClassName"</span>value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost/activemq?relaxAutoCommit=true"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"username"</span> value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;property name=<span class="string">"password"</span>value=<span class="string">"activemq"</span>/&gt;</div><div class="line">&lt;propertyname=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h3 id="jdbc-with-journal"><a href="#jdbc-with-journal" class="headerlink" title="jdbc with journal"></a>jdbc with journal</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;persistenceFactory&gt; &lt;journalPersistenceAdapterFactory journalLogFiles=<span class="string">"4"</span> journalLogFileSize=<span class="string">"32768"</span> useJournal=<span class="string">"true"</span> useQuickJournal=<span class="string">"true"</span> dataSource=<span class="string">"#derby-ds"</span> dataDirectory=<span class="string">"activemq-data"</span> /&gt;</div><div class="line">&lt;/persistenceFactory&gt;</div><div class="line">&lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>JDBC Store和JDBC Message Store with ActiveMQ Journal的区别<br>1:Jdbc with journal的性能优于jdbc<br>2:Jdbc用于master/slave模式的数据库分享<br>3:Jdbc with journal不能用于master/slave模式<br>4:一般情况下,推荐使用jdbc with journal</p>
<h3 id="memory-message-Store"><a href="#memory-message-Store" class="headerlink" title="memory message Store"></a>memory message Store</h3><p>内存消息存储主要是存储所有的持久化的消息在内存中。这里没有动态的缓存存在，所以你必须注意设置你的 broker 在 JVM 和内存限制。<br>消息存储基于 Memory，所有的消息都存储在内存里。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">&lt;broker brokerName=<span class="string">"test-broker"</span> persistent=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61635"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt; &lt;/broker&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h3 id="KahaDB、-AMQ-区别"><a href="#KahaDB、-AMQ-区别" class="headerlink" title="KahaDB、  AMQ 区别"></a>KahaDB、  AMQ 区别</h3><ol>
<li>KahaDB 克服了 AMQ 的一些不足。</li>
<li>kahaDB 性能上优于 AMQ。</li>
<li>KahaDB 用于大量的 broker【500 个以上】 。</li>
<li>AMQ 用于独立和嵌入式的 broker 比较好。</li>
<li>AMQ 在执行的性能和索引方面都比较不错。</li>
<li>kahaDB 和 AMQ 两者是独立的，谁也不包括谁。<h3 id="使用内存消息存储"><a href="#使用内存消息存储" class="headerlink" title="使用内存消息存储"></a>使用内存消息存储</h3>如果你的 broker 仅仅对于一组消息的消费是很快的，那么可以使用内存消息存储，但是他通常用于内部简单的消息测试，而不花费很多时间。或者能够在测试消息后清除消息<h1 id="如何用ActiveMQ构建应用"><a href="#如何用ActiveMQ构建应用" class="headerlink" title="如何用ActiveMQ构建应用"></a>如何用ActiveMQ构建应用</h1><h2 id="用ActiveMQ构建java应用"><a href="#用ActiveMQ构建java应用" class="headerlink" title="用ActiveMQ构建java应用"></a>用ActiveMQ构建java应用</h2><h3 id="嵌入式broker启动"><a href="#嵌入式broker启动" class="headerlink" title="嵌入式broker启动"></a>嵌入式broker启动</h3><h4 id="broker-service启动broker"><a href="#broker-service启动broker" class="headerlink" title="broker service启动broker"></a>broker service启动broker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService();</div><div class="line">broker.setUseJmx(<span class="literal">true</span>);</div><div class="line">broker.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker.start();</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="broker-factory启动"><a href="#broker-factory启动" class="headerlink" title="broker factory启动"></a>broker factory启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String Uri = <span class="string">"properties:resources/broker.properties"</span>;</div><div class="line">//默认不自动启动。</div><div class="line">// BrokerService broker1 = BrokerFactory.createBroker(Uri);</div><div class="line">BrokerService broker1 = BrokerFactory.createBroker(new URI(Uri));</div><div class="line">//<span class="string">"true"</span>表示自动启动。反之，不启动。</div><div class="line">// BrokerService broker2 = BrokerFactory.createBroker(Uri,<span class="literal">true</span>);</div><div class="line">broker1.addConnector(<span class="string">"tcp://localhost:61616"</span>);</div><div class="line">broker1.start();</div></pre></td></tr></table></figure>
<h4 id="利用spring集成broker"><a href="#利用spring集成broker" class="headerlink" title="利用spring集成broker"></a>利用spring集成broker</h4><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/spring-broker.png" alt=""></p>
<h4 id="activeMQ嵌入到其他应用服务器中"><a href="#activeMQ嵌入到其他应用服务器中" class="headerlink" title="activeMQ嵌入到其他应用服务器中"></a>activeMQ嵌入到其他应用服务器中</h4><h1 id="ActiveMq的安全"><a href="#ActiveMq的安全" class="headerlink" title="ActiveMq的安全"></a>ActiveMq的安全</h1><h2 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h2><p>适用于简单的认证需求，或者用于建立测试环境。它允许在 XML 配置文件中指定用户、用户组和密码等信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"true"</span> persistent=<span class="string">"false"</span></div><div class="line">xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span></div><div class="line">populateJMSXUserID=<span class="string">"true"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:61616"</span>/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div><div class="line">&lt;destinations&gt;</div><div class="line">&lt;queue physicalName=<span class="string">"TEST.Q"</span> /&gt;</div><div class="line">&lt;/destinations&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">&lt;simpleAuthenticationPlugin&gt;</div><div class="line">&lt;users&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"system"</span> password=<span class="string">"manager"</span></div><div class="line">groups=<span class="string">"users,admins"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"users"</span>/&gt;</div><div class="line">&lt;authenticationUser username=<span class="string">"guest"</span> password=<span class="string">"password"</span></div><div class="line">groups=<span class="string">"guests"</span>/&gt;</div><div class="line">&lt;/users&gt;</div><div class="line">&lt;/simpleAuthenticationPlugin&gt;</div><div class="line">&lt;authorizationPlugin&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;authorizationMap&gt;</div><div class="line">&lt;authorizationEntries&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span></div><div class="line">admin=<span class="string">"admins"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span></div><div class="line">write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span></div><div class="line">write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">&lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory.&gt;"</span></div><div class="line"><span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">&lt;/authorizationEntries&gt;</div><div class="line">&lt;/authorizationMap&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="JAAS授权插件"><a href="#JAAS授权插件" class="headerlink" title="JAAS授权插件"></a>JAAS授权插件</h2><p>JAAS Authentication Plugin依赖标准的 JAAS 机制来实现认证。通常情况下，你需要通过设置java.security.auth.login.config 系统属性来配置 loginmodules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin 会缺省使用 login.config 作为文件名</p>
<h3 id="在activeMQ-xml中配置"><a href="#在activeMQ-xml中配置" class="headerlink" title="在activeMQ.xml中配置"></a>在activeMQ.xml中配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt;</div><div class="line">    &lt;jaasAuthenticationPlugin configuration=<span class="string">"activemq-domain"</span> /&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="创建login-config"><a href="#创建login-config" class="headerlink" title="创建login.config"></a>创建login.config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123;</div><div class="line">  org.apache.activemq.jaas.PropertiesLoginModule required</div><div class="line">    debug=<span class="literal">true</span></div><div class="line">    org.apache.activemq.jaas.properties.user=<span class="string">"users.properties"</span></div><div class="line">    org.apache.activemq.jaas.properties.group=<span class="string">"groups.properties"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="创建users-properties和groups-properties文件，包含用户和用户组信息"><a href="#创建users-properties和groups-properties文件，包含用户和用户组信息" class="headerlink" title="创建users.properties和groups.properties文件，包含用户和用户组信息"></a>创建users.properties和groups.properties文件，包含用户和用户组信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">users.properties：</div><div class="line">system=password</div><div class="line">user=password</div><div class="line">guest=password</div><div class="line">groups.properties：</div><div class="line">admins=system</div><div class="line">users=system,user</div><div class="line">guests=guest</div></pre></td></tr></table></figure>
<h3 id="Authorization-plugin-in的使用"><a href="#Authorization-plugin-in的使用" class="headerlink" title="Authorization plugin-in的使用"></a>Authorization plugin-in的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">在activemq.xml中如下配置：</div><div class="line">&lt;plugins&gt;</div><div class="line">  &lt;authorizationPlugin&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">      &lt;authorizationMap&gt;</div><div class="line">        &lt;authorizationEntries&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry queue=<span class="string">"TEST.Q"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"&gt;"</span> <span class="built_in">read</span>=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> <span class="built_in">read</span>=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> <span class="built_in">read</span>=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</div><div class="line">          &lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory."</span>&gt; <span class="built_in">read</span>=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</div><div class="line">        &lt;/authorizationEntries&gt;</div><div class="line">      &lt;/authorizationMap&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">  &lt;/authorizationPlugin&gt;</div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h1 id="ActiveMQ特点"><a href="#ActiveMQ特点" class="headerlink" title="ActiveMQ特点"></a>ActiveMQ特点</h1><h2 id="使用activeMQ进行集群"><a href="#使用activeMQ进行集群" class="headerlink" title="使用activeMQ进行集群"></a>使用activeMQ进行集群</h2><h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>我们支持 Consumer对消息高可靠性的负载平衡消费，如果一个 Consumer 死掉，该消息会转发到其它的Consumer消费的Queue上。如果一个 Consumer 获得消息比其它Consumer快，那么他将获得更多的消息。如果一个 Conseumer消费缓慢，则其它 Consumer会替换它。</p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>大部情况下是使用一系列的 Broker 和 Client 链接到一起。如果一个 Broker死掉了，Client 可以自动链接到其它Broker上。实现以上行为我门需要用failover：//协议作为 Client，如果启动了多个Broker，Client 可以使用static discover 或者Dynamic discovery 容易的从一个 broker 到另一个 broker 直接链接。这样的当一个broker上没有 Consumer 的话， 那么它的消息不会被消费的， 然而该 broker会通过存储和转发的策略来把该消息发到其它 broker 上。这里的 brokers 没有网络链接各个 brokers。</p>
<h3 id="discovery-of-brokers"><a href="#discovery-of-brokers" class="headerlink" title="discovery of brokers"></a>discovery of brokers</h3><p>ActiveMQ 支持使用 static discovery 或者 dynamic discovery 来动态发现brokers，以至于 Client 能够链接到其它发现的 broker，从而形成网络。</p>
<h3 id="networks-of-brokers"><a href="#networks-of-brokers" class="headerlink" title="networks of brokers"></a>networks of brokers</h3><p>如果你正在使用client/server或者hub/spoke类型的拓扑结构并且你有很多的client很多的broker。这就有可能其中一个broker只有生产者没有消费者，这样的话消息会在这个broker上堆积，并且得不到处理。为了避免这种情况，ActiveMQ提供了网络连接模式（Network of brokers），该模式可以提供存储和转发消息的功能，具体就是broker之间可以互相传送消息，这样也允许我们在网络连接模式中提供重分发TOPIC和QUEUES的功能（参见：<a href="http://activemq.apache.org/how-do-distributed-queues-work.html）。" target="_blank" rel="external">http://activemq.apache.org/how-do-distributed-queues-work.html）。</a><br>这允许一个client去连接任意一个broker， 并且当有错误发生的时候可以failover到其他的broker，它提供了从client的角度来观察一个broker集群<br>网络连接模式允许我们放大client群到一个很大的数量级，因为我们可以运行我们需要的任意多个broker.<br>你可以把该模式想象成一个client集群去连接一个broker集群同时拥有failover和discovery功能去做成的一个简单的易用的消息结构。<br>（注：此处的网络连接模式，仅仅只是为了避免集群中的broker只有producer而没有consumer的情况，它会在不同的broker中间传送消息，以便让所有的消息都能有消费者来处理，但是<br>该模式下不会有消费的备份，在任何时刻，对客户端来说同一个消息都只存在一份，若需要消息备份机制则需要Master Slave的支持，这我们下面会说到）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"static:(nio://192.168.9.102:61616)"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;  </div><div class="line">&lt;!-- dynamic discovery config--&gt;  </div><div class="line">&lt;networkConnectors&gt;  </div><div class="line">    &lt;networkConnector uri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/networkConnectors&gt;   </div><div class="line">&lt;transportConnectors&gt;  </div><div class="line">    &lt;transportConnector uri=<span class="string">"nio://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"</span>  discoveryUri=<span class="string">"multicast://default"</span>/&gt;  </div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master Slave"></a>Master Slave</h3><p>运行独立应用部署的 Brokers 由一个问题，它在任何时候其 broker 在物理上都是独有的。 如果一个 broker 断掉， 那么你必须等待重新复制消息才能启动 broker。必须是 persistent=true 的情况下成立。例如：这里指的是 Shared Nonthing Master/Slave模式，就是说如果 master断掉了，消息的备份会存储在slave中。重新拷贝 slave目录下的数据到 master 的目录下即可，重启 master 了。还有一种就是启动 slave 来替换 master。</p>
<h3 id="Replicated-Message-Stores"><a href="#Replicated-Message-Stores" class="headerlink" title="Replicated Message Stores"></a>Replicated Message Stores</h3><p>Master/Slave 模式的另一种方式就是基于Shared File和 DataBase 的共享模式。当master断掉以后，消息应经存储到硬盘上了，此时 slave 获得锁替换了 Master</p>
<h2 id="Master-Slave集群"><a href="#Master-Slave集群" class="headerlink" title="Master/Slave集群"></a>Master/Slave集群</h2><h3 id="纯Master-Slave"><a href="#纯Master-Slave" class="headerlink" title="纯Master/Slave"></a>纯Master/Slave</h3><ul>
<li>Slave broker 消费 master broker 上所有的消息状态，例如消息、确认和事务状态等。只要 slave broker 连接到了 master broker，它不会（也不被允许）启动任何 network connectors 或者 transport connectors，所以唯一的目的就是复制 master broker 的状态。</li>
<li>Master broker 只有在消息成功被复制到 slave broker 之后才会响应客户。例如，客户的 commit 请求只有在 master broker 和 slave broker 都处理完毕 commit 请求之后才会结束。</li>
<li>当 master broker 失效的时候，slave broker 有两种选择，一种是 slave broker 启动所有的 network connectors 和 transport connectors，这允许客户端切换到 slave broker；另外一种是 slave broker 停止。这种情况下，slave broker 只是复制了 master broker 的状态。</li>
<li>客户应该使用 failover transport 并且应该首先尝试连接 master broker。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover://(tcp://masterhost:61616,tcp://slavehost:61615)?random</div><div class="line">ize=<span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>设置randomize为false就可以让客户总是首先尝试连接master broker（slave broker 并不会接受任何连接，直到它成为了 master broker）。<br>限制：</p>
<ul>
<li>只能有一个 slave broker 连接到 master broker。</li>
<li>在因 master broker 失效而导致 slave broker 成为 master 之后，之前的master broker 只有在当前的 master broker（原 slave broker）停止后才能重新生效。</li>
<li>Master broker 失效后而切换到 slave broker 后，最安全的恢复 master broker 的方式是人工处理。首先要停止 slave broker（这意味着所有的客户也要停止） 。 然后把 slave broker 的数据目录中所有的数据拷贝到 master broker 的数据目录中。然后重启 master broker 和 slave broker。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Master broker 不需要特殊的配置。Slave broker 需要进行以下配置</div><div class="line">&lt;broker masterConnectorURI=<span class="string">"tcp://masterhost:62001"</span> shutdownOn MasterFailure=<span class="string">"false"</span>&gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://slavehost:61616"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h3 id="JDBC-DataBase-master-slave集群"><a href="#JDBC-DataBase-master-slave集群" class="headerlink" title="JDBC DataBase master/slave集群"></a>JDBC DataBase master/slave集群</h3><p>如果你用单纯的 JDBC 而没有用高性能的持久此时你将依赖于你的数据库作为单独的持久存储引擎。如果你没有高性能的要求，类似这种数据库作为存储引擎可以应用很多场景。<br>启动利用数据库作为数据源，采用Master/Slave模式，其中在启动的时候Master首先获得独有锁，其它 Slaves Broker 则等待获取独有锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">failover:(tcp: //broker1:61616,tcp://broker2:61616,tcp://broker3:61616)</div></pre></td></tr></table></figure></p>
<p>如果 Master 失败，则它释放独有锁，其他 Slaver 则获取独有锁.其它 Slaver 立即获得独有锁后此时它将变成 Master，并且启动所有的传输链接。同时，Client 将停止链接之前的 Master 和将会轮询链接到其他可以利用的 Broker 即新 Master。</p>
<h3 id="share-file-master-slave集群"><a href="#share-file-master-slave集群" class="headerlink" title="share file master/slave集群"></a>share file master/slave集群</h3><p>希望基于相同的存储目录下运行多个 Broker，首先，该 Broker Master 会首先获得排它锁。如果该 Master Broker 死掉了会释放掉排它锁，则其它的 Slave Broker会替换它。Slave 是一个轮询的从 Master 那里获得排它锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=<span class="string">"false"</span> xmlns=<span class="string">"http://activemq.org/config/1.0"</span>&gt;</div><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">&lt;journaledJDBC dataDirectory=<span class="string">"/sharedFileSystem/broker"</span>/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>如果你使用 SAN 或者共享文件系统，那么你可以使用 Shared File System Master Slave。基本上，你可以运行多个 broker，这些 broker 共享数据目录。当第一个 broker 得到文件上的排他锁之后，其它的 broker 便会在循环中等待获得这把锁。客户端使用 failover transport 来连接到可用的 broker。当 master broker 失效的时候会释放这把锁，这时候其中一个 slave broker 会得到这把锁从而成为master broker。</p>
<h2 id="network-of-brokers-存储和转发集群"><a href="#network-of-brokers-存储和转发集群" class="headerlink" title="network of brokers (存储和转发集群)"></a>network of brokers (存储和转发集群)</h2><h3 id="单向传递"><a href="#单向传递" class="headerlink" title="单向传递"></a>单向传递</h3><p>ActiveMQ默认的两个broker链接是单方向的，brokerA可以消费brokerB的消息<br><img src="/2017/12/15/Apache-ActiveMQ-笔记/单向broker.png" alt=""></p>
<h3 id="双向传递"><a href="#双向传递" class="headerlink" title="双向传递"></a>双向传递</h3><p><img src="/2017/12/15/Apache-ActiveMQ-笔记/双向broker.png" alt=""><br><img src="/2017/12/15/Apache-ActiveMQ-笔记/扩展broker.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static://(tcp://backoffice:61617)"</span> name=<span class="string">"brdge"</span> duplex=<span class="string">"true"</span> ConduitSubscriptions=<span class="string">"true"</span>&gt;</div><div class="line">&lt;/networkConnector&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>Duplex=”true”表示双发可以通信.<br>ConduitSubscriptions=“false”表示每个 Consumer 上都会收到所有的发送的消息。<br>Name=“bridge”默认的。</p>
<h3 id="Broker连接集群"><a href="#Broker连接集群" class="headerlink" title="Broker连接集群"></a>Broker连接集群</h3><p>一个常见的场景是有多个 JMS broker，有一个客户连接到其中一个 broker。如果这个 broker 失效，那么客户会自动重新连接到其它的 broker。在 ActiveMQ中使用 failover:// 协议来实现这个功能。ActiveMQ3.x 版本的 reliable://协议已经变更为 failover://。如果某个网络上有多个 brokers 而且客户使用静态发现（使用 Static Transport 或 Failover Transport）或动态发现（使用 Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的 brokers。然而，stand alone brokers并不了解其它brokers上的consumer，也就是说如果某个broker 上没有 consumers，那么这个 broker 上的消息可能会因得不到处理而积压起来。目前的解决方案是使用 Network of brokers，以便在 broker 之间存储转发消息。ActiveMQ 在未来会有更好的特性，用来在客户端处理这个问题。从 ActiveMQ1.1 版本起，ActiveMQ 支持 networks of brokers。它支持分布式的 queues 和 topics。一个 broker 会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程 broker，它都会递送有关的消息拷贝到每个订阅。远程 broker 得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。 有两种方式配置 Network of brokers， 一种是使用 static transport，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=<span class="string">"receiver"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt;</div><div class="line">&lt;transportConnectors&gt;</div><div class="line">&lt;transportConnector uri=<span class="string">"tcp://localhost:62002"</span> /&gt;</div><div class="line">&lt; /transportConnectors&gt;</div><div class="line">&lt;networkConnectors&gt;</div><div class="line">&lt;networkConnector uri=<span class="string">"static:( tcp://localhost:61616, tcp://remotehost:61616)"</span> /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>或者使用dynamic transport<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=<span class="string">"sender"</span> persistent=<span class="string">"false"</span> useJmx=<span class="string">"false"</span>&gt; &gt;</div><div class="line"> &lt;transportConnectors&gt;</div><div class="line"> &lt;transportConnector uri=<span class="string">"tcp://localhost:0"</span> discoveryUri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/transportConnectors&gt;</div><div class="line"> &lt;networkConnectors&gt;</div><div class="line"> &lt;networkConnector uri=<span class="string">"multicast://default"</span> /&gt;</div><div class="line"> &lt;/networkConnectors&gt;</div><div class="line">  &lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Queue-consumer集群"><a href="#Queue-consumer集群" class="headerlink" title="Queue consumer集群"></a>Queue consumer集群</h2><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认的消息都会被发送到这个 queue 上其它的 consumers。如果某个 consumer 的处理速度比其它 consumers 更快，那么这个 consumer 就会消费更多的消息</p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="dynamicOnly"><a href="#dynamicOnly" class="headerlink" title="dynamicOnly"></a>dynamicOnly</h3><p>默认是 false，如果是 true，消息将被动态的转接的在其他 broker 的 consumer上</p>
<h3 id="prefetchSize"><a href="#prefetchSize" class="headerlink" title="prefetchSize"></a>prefetchSize</h3><p>ActiveMQ使用了　消息”预取限制“(prefetch limit)：表示在某个时间段内，可能向消费者传输的最大消息量，如果达到该上限，那么停止发送，直到ActiveMQ收到消费者的acknowledgements(确认，表示已经处理了该消息。prefetch limit可以针对每个不同的consumer来设置。<br>为了获取更高的性能，prefetch limit当然是越大越好，只要consumer有足够大的消息缓冲区(messagevolume)。如果消息的总量非常少，而且每个消息的处理时间非常的长，那么，可以将prefetch设置为1，这样，每次向consumer发送一个消息，等其确认已经处理完毕后，再发送第二个。<br>特别地，如果prefetch设置为0，表示consumer每次　主动向activeMQ要求传输最大的数据量，而不是被动地接收消息</p>
<h3 id="conduitSubscriptons"><a href="#conduitSubscriptons" class="headerlink" title="conduitSubscriptons"></a>conduitSubscriptons</h3><p>关于 conduitSubscriptions 属性，这里稍稍说明一下。设想有两个 brokers，分别是brokerA和brokerB， 它们之间用forwarding bridge连接。 有一个consumer连接到brokerA并订阅 queue： Q.TEST。 有两个 consumers 连接到 brokerB， 也是订阅 queue： Q.TEST。这三个 consumers 有相同的优先级。然后启动一个 producer，它发送了 30 条消息到brokerA。如果 conduitSubscriptions=true，那么 brokerA 上的 consumer 会得到 15 条消息， 另外15条消息会发送给brokerB。 此时负载并不均衡， 因为此时brokerA将brokerB上的两个 consumers 视为一个；如果 conduitSubscriptions=false，那么每个 consumer上都会收到 10 条消息。</p>
<h3 id="decreaseNetwordConsumerPriority"><a href="#decreaseNetwordConsumerPriority" class="headerlink" title="decreaseNetwordConsumerPriority"></a>decreaseNetwordConsumerPriority</h3><p>默认是 false。设定消费者优先权</p>
<h3 id="networkTTL"><a href="#networkTTL" class="headerlink" title="networkTTL"></a>networkTTL</h3><p>默认是 1</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;面向消息的中间件：Message-oriented Middleware, MOM&lt;br&gt;基本功能：将信息以消息的形
    
    </summary>
    
      <category term="消息中间件" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅</title>
    <link href="http://yoursite.com/2017/12/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"/>
    <id>http://yoursite.com/2017/12/06/设计模式之禅/</id>
    <published>2017-12-06T15:21:46.000Z</published>
    <updated>2017-12-11T08:02:44.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一职责-SRP"><a href="#单一职责-SRP" class="headerlink" title="单一职责(SRP)"></a>单一职责(SRP)</h2><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更.<br><img src="/2017/12/06/设计模式之禅/单一职责1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.2.png" alt=""><br>单一职责的优点：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义</li>
<li>可读性提高</li>
<li>可维护性提高</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>继承的优点：</p>
<ul>
<li>代码共享，减少创建类的工作量</li>
<li>提高代码的重用性</li>
<li>提高代码的扩展性</li>
<li>提高产品和项目的开放性<br>缺点：</li>
<li>继承是侵入性的，拥有父类的所有方法和属性</li>
<li>降低代码的灵活性</li>
<li>增强了耦合性</li>
</ul>
<p>里氏替换定义<br>定义一：如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。<br>定义二：所有引用基类的地方都必须能透明的引用其子类对象。第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。<br>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义:</p>
<ol>
<li>子类必须完全实现父类的方法<br><img src="/2017/12/06/设计模式之禅/里氏替换1.1.png" alt=""><br>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
<li>子类可以有自己个性<br>子类当然可以有自己的行为和外观了，也就是方法和属性。但是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</li>
<li>覆盖或实现父类的方法时输入参数可以被放大<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">public Collection <span class="keyword">do</span>Something(HashMap map)&#123;</div><div class="line">System.out.println(<span class="string">"父类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Son extends Father &#123;</div><div class="line">//放大输入参数类型</div><div class="line">public Collection <span class="keyword">do</span>Something(Map map)&#123;</div><div class="line">System.out.println(<span class="string">"子类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Father f = new Father();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div><div class="line">Son f =new Son();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>与父类的方法名相同，但又不是覆写（Override）父类的方法。是重载（Overload）。用子类替换父类，子类代替父类传递到调用者中，子类的方法永远都不会被执行。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。<br>如果你把父类参数放宽变为map，子类的参数变为Hashmap，根据里氏替换子类替换父类，子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</p>
<ol>
<li>覆盖或实现父类方法输出结果可以被缩小<br>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的</li>
</ol>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。依赖倒置原则在Java语言中的表现就是：<br>● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过<br>接口或抽象类产生的；<br>● 接口或抽象类不依赖于实现类；<br>● 实现类依赖接口或抽象类<br>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设<br>计）的精髓之一<br><img src="/2017/12/06/设计模式之禅/依赖倒置1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.3.png" alt=""><br>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，<br>不互相影响，实现模块间的松耦合。只要遵循以下几个规则</p>
<ul>
<li>每个类都尽量有抽象类或者接口</li>
<li>表面类型尽量是接口或者抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆盖父类的方法</li>
<li>结合里氏替换原则使用</li>
</ul>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><p><img src="/2017/12/06/设计模式之禅/接口隔离原则1.1.png" alt=""><br>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探<br>AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。<br>接口隔离原则包含四层含义：</p>
<ul>
<li>接口要尽量小<br>是接口隔离原则的核心定义，不出现臃肿的接口。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</li>
<li>接口要高内聚<br>具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li>
<li>定制服务<br>定制服务就是单独为一个个体提供优良的服务。<br><img src="/2017/12/06/设计模式之禅/接口隔离原则1.2.png" alt=""></li>
<li>接口设计时有粒度的<br>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构<br>的复杂化，开发难度增加，可维护性降低。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多的public方法，我就调用这么多，其他的我一概不关心。</p>
<ol>
<li>只和朋友类交流<br>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类<br><img src="/2017/12/06/设计模式之禅/迪米特1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特1.2.png" alt=""><br>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象</li>
<li>朋友间也是有距离的<br><img src="/2017/12/06/设计模式之禅/迪米特2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特2.2.png" alt=""></li>
<li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ol>
<h2 id="开闭原则-DIP"><a href="#开闭原则-DIP" class="headerlink" title="开闭原则(DIP)"></a>开闭原则(DIP)</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br><img src="/2017/12/06/设计模式之禅/开闭1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/开闭1.2.png" alt=""><br>开闭的好处:</p>
<ol>
<li>开闭对测试有影响</li>
<li>提高复用性</li>
<li>可以提高可维护性</li>
<li>面向对象开发要求</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下：<br>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。<br>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。<br>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。<br>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）<br>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。<br>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h3><ul>
<li>由于单例模式在内存只有一个实例，减少了内存的开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁的性能又无法优化时，单例模式的优势非常明显</li>
<li>由于单例只生成一个实例，较少了系统性能开销，当一个对象产生需要比较多的资源时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>单例模式一般没有接口，扩展很困难</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li>
<li>单例模式与单一职责原则有冲突。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">	private static  volatile Singleton singleton;</div><div class="line"></div><div class="line">	private <span class="function"><span class="title">Singleton</span></span>()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">		<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">			synchronized (this) &#123;</div><div class="line">				<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">					singleton=new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Human &#123;</div><div class="line"></div><div class="line">	public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123;</div><div class="line">		Human human=(Human) Class.forName(c.getName()).newInstance();</div><div class="line">		<span class="built_in">return</span> (T) human;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/06/设计模式之禅/工厂模式1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/工厂模式通用类图.png" alt=""></p>
<h3 id="工厂方法模式优点："><a href="#工厂方法模式优点：" class="headerlink" title="工厂方法模式优点："></a>工厂方法模式优点：</h3><ul>
<li>良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。</li>
<li>屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li>
<li>工厂方法模式是典型的解耦框架。</li>
</ul>
<h3 id="工厂方法的扩展"><a href="#工厂方法的扩展" class="headerlink" title="工厂方法的扩展"></a>工厂方法的扩展</h3><ol>
<li>缩小为简单工厂模式一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了</li>
<li>多个工厂类<br><img src="/2017/12/06/设计模式之禅/多个工厂类.png" alt=""></li>
<li><p>替代单例模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SingletonFactory &#123;</div><div class="line">private static Singleton singleton;</div><div class="line"> static&#123;</div><div class="line">  try &#123;</div><div class="line">    Class cl= Class.forName(Singleton.class.getName());</div><div class="line">    //获得无参构造</div><div class="line">    Constructor constructor=cl.getDeclaredConstructor();</div><div class="line">    //设置无参构造是可访问的</div><div class="line">    constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">    //产生一个实例对象</div><div class="line">    singleton = (Singleton)constructor.newInstance();</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">    //异常处理</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> public static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> singleton;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>延迟初始化<br>一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ProductFactory &#123;</div><div class="line">private static final Map&lt;String,Product&gt; prMap = new HashMap();</div><div class="line">public static synchronized Product createProduct(String <span class="built_in">type</span>) throws Exception&#123;</div><div class="line">Product product =null;</div><div class="line">//如果Map中已经有这个对象</div><div class="line"><span class="keyword">if</span>(prMap.containsKey(<span class="built_in">type</span>))&#123;</div><div class="line">product = prMap.get(<span class="built_in">type</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(type.equals(<span class="string">"Product1"</span>))&#123;</div><div class="line">product = new ConcreteProduct1();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">product = new ConcreteProduct2();</div><div class="line">&#125;</div><div class="line">//同时把对象放到缓存容器中</div><div class="line">prMap.put(<span class="built_in">type</span>,product);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> product;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/2017/12/06/设计模式之禅/抽象1.png" alt=""><br>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：<br>（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）<br><img src="/2017/12/06/设计模式之禅/抽象工厂模式类图.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public abstract class AbstractCreator &#123;</div><div class="line">//创建A产品家族</div><div class="line">public abstract AbstractProductA createProductA();</div><div class="line">//创建B产品家族</div><div class="line">public abstract AbstractProductB createProductB();</div><div class="line">&#125;</div><div class="line">public class Creator1 extends AbstractCreator &#123;</div><div class="line">//只生产产品等级为1的A产品</div><div class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductA1();</div><div class="line">&#125;</div><div class="line">//只生产产品等级为1的B产品</div><div class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductB1();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务</p>
<h3 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h3><p>1.封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。<br>2.产品族内的约束为非公开状态。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码<br>为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序<br>有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><img src="/2017/12/06/设计模式之禅/模板1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/模板2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public abstract class HummerModel &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * 首先，这个模型要能发动起来，别管是手摇发动，还是电力发动，反正 是要能够发动起来，那这个实现要在实现类里了</div><div class="line">	 */</div><div class="line">	public abstract void start();</div><div class="line"></div><div class="line">	// 能发动，还要能停下来，那才是真本事</div><div class="line">	public abstract void stop();</div><div class="line"></div><div class="line">	// 喇叭会出声音，是滴滴叫，还是哔哔叫</div><div class="line">	public abstract void alarm();</div><div class="line"></div><div class="line">	// 引擎会轰隆隆地响，不响那是假的</div><div class="line">	public abstract void engineBoom();</div><div class="line"></div><div class="line">	// 那模型应该会跑吧，别管是人推的，还是电力驱动，总之要会跑</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		// 先发动汽车</div><div class="line">		this.start();</div><div class="line">		// 引擎开始轰鸣</div><div class="line">		this.engineBoom();</div><div class="line">		// 然后就开始跑了，跑的过程中遇到一条狗挡路，就按喇叭</div><div class="line">		this.alarm();</div><div class="line">		// 到达目的地就停车</div><div class="line">		this.stop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class HummerH1Model extends HummerModel&#123;</div><div class="line"></div><div class="line">	//H1型号的悍马车鸣笛</div><div class="line">	public void <span class="function"><span class="title">alarm</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1鸣笛..."</span>);</div><div class="line">	&#125;</div><div class="line">	//引擎轰鸣声</div><div class="line">	public void <span class="function"><span class="title">engineBoom</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1引擎声音是这样的..."</span>);</div><div class="line">	&#125;</div><div class="line">	//汽车发动</div><div class="line">	public void <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1发动..."</span>);</div><div class="line">	&#125;</div><div class="line">	//停车</div><div class="line">	public void <span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1停车..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/2017/12/06/设计模式之禅/模板4.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.封装不变的部分，扩展可变部分<br>2.提取公共部分代码，便于维护<br>3.行为由父类控制，子类实现</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h3 id="模板方法模式使用场景"><a href="#模板方法模式使用场景" class="headerlink" title="模板方法模式使用场景"></a>模板方法模式使用场景</h3><p>● 多个子类有公有的方法，并且逻辑基本相同时。<br>● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。<br>● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/2017/12/06/设计模式之禅/建造0.png" alt=""><br>建造者模式（Builder Pattern）也叫做生成器模式，其定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示<br><img src="/2017/12/06/设计模式之禅/建造1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/建造2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">		//独立业务处理</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Builder &#123;</div><div class="line">	// 设置产品的不同部分，以获得不同的产品</div><div class="line">	public abstract void <span class="built_in">set</span>Part();</div><div class="line"></div><div class="line">	// 建造产品</div><div class="line">	public abstract Product buildProduct();</div><div class="line">&#125;</div><div class="line">public class ConcreteProduct extends Builder &#123;</div><div class="line">	private Product product = new Product();</div><div class="line"></div><div class="line">	// 设置产品零件</div><div class="line">	public void <span class="function"><span class="title">setPart</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 产品类内的逻辑处理</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 组建一个产品</div><div class="line">	public Product <span class="function"><span class="title">buildProduct</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> product;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Director &#123;</div><div class="line">	private Builder builder = new ConcreteProduct();</div><div class="line"></div><div class="line">	// 构建不同的产品</div><div class="line">	public Product <span class="function"><span class="title">getAProduct</span></span>() &#123;</div><div class="line">		builder.setPart();</div><div class="line">		/*</div><div class="line">		 * 设置不同的零件，产生不同的产品</div><div class="line">		 */</div><div class="line">		<span class="built_in">return</span> builder.buildProduct();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>● 封装性<br>使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。<br>● 建造者独立，容易扩展<br>BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。<br>● 便于控制细节风险<br>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。<br>● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。<br>● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。<br>● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</p>
<p><em>建造者模式关注的是零件类型和装配工艺（顺序）</em>。建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义为：为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/2017/12/06/设计模式之禅/代理1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	public void request();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	//实现方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">	//业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Proxy implements Subject &#123;</div><div class="line"></div><div class="line">	// 要代理哪个实现类</div><div class="line">	private Subject subject = null;</div><div class="line"></div><div class="line">	// 默认被代理者</div><div class="line">	public <span class="function"><span class="title">Proxy</span></span>() &#123;</div><div class="line">		this.subject = new RealSubject();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过构造函数传递代理者</div><div class="line">	public Proxy(Object... objects) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 实现接口中定义的方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.before();</div><div class="line">		this.subject.request();</div><div class="line">		this.after();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 预处理</div><div class="line">	private void <span class="function"><span class="title">before</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 善后处理</div><div class="line">	private void <span class="function"><span class="title">after</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><img src="/2017/12/06/设计模式之禅/代理2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/代理3.png" alt=""><br>要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下前面的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/2017/12/06/设计模式之禅/原型1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PrototypeClass implements Cloneable&#123;</div><div class="line">//覆写父类Object方法</div><div class="line">@Override</div><div class="line">public PrototypeClass <span class="function"><span class="title">clone</span></span>()&#123;</div><div class="line">PrototypeClass prototypeClass = null;</div><div class="line">try &#123;</div><div class="line">prototypeClass = (PrototypeClass)super.clone();</div><div class="line">&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">//异常处理</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> prototypeClass;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>● 性能优良<br>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。<br>● 逃避构造函数的约束<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 资源优化场景<br>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>● 性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>● 一个对象多个修改者的场景<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable &#123;</div><div class="line">	// 定义一个私有变量</div><div class="line">	private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Thing <span class="function"><span class="title">clone</span></span>() &#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			thing.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用clone方法，类的成员变量上不要增加final关键字</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p><img src="/2017/12/06/设计模式之禅/中介者1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者3.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractMediator &#123;</div><div class="line">	protected Purchase purchase;</div><div class="line">	protected Sale sale;</div><div class="line">	protected Stock stock;</div><div class="line"></div><div class="line">	// 构造函数</div><div class="line">	public <span class="function"><span class="title">AbstractMediator</span></span>() &#123;</div><div class="line">		purchase = new Purchase(this);</div><div class="line">		sale = new Sale(this);</div><div class="line">		stock = new Stock(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中介者最重要的方法叫做事件方法，处理多个对象之间的关系</div><div class="line">	public abstract void execute(String str, Object... objects);</div><div class="line">&#125;</div><div class="line">public class Mediator extends AbstractMediator &#123;</div><div class="line">	// 中介者最重要的方法</div><div class="line">	public void execute(String str, Object... objects) &#123;</div><div class="line">		<span class="keyword">if</span> (str.equals(<span class="string">"purchase.buy"</span>)) &#123; // 采购电脑</div><div class="line">			this.buyComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.sell"</span>)) &#123; // 销售电脑</div><div class="line">			this.sellComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.offsell"</span>)) &#123; // 折价销售</div><div class="line">			this.offSell();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"stock.clear"</span>)) &#123; // 清仓处理</div><div class="line">			this.clearStock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购电脑</div><div class="line">	private void buyComputer(int number) &#123;</div><div class="line">		int saleStatus = super.sale.getSaleStatus();</div><div class="line">		<span class="keyword">if</span> (saleStatus &gt; 80) &#123; // 销售情况良好</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑:"</span> + number + <span class="string">"台"</span>);</div><div class="line">			super.stock.increase(number);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 销售情况不好</div><div class="line">			int buyNumber = number / 2; // 折半采购</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑："</span> + buyNumber + <span class="string">"台"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售电脑</div><div class="line">	private void sellComputer(int number) &#123;</div><div class="line">		<span class="keyword">if</span> (super.stock.getStockNumber() &lt; number) &#123; // 库存数量不够销售</div><div class="line">			super.purchase.buyIBMcomputer(number);</div><div class="line">		&#125;</div><div class="line">		super.stock.decrease(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价销售电脑</div><div class="line">	private void <span class="function"><span class="title">offSell</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"折价销售IBM电脑"</span> + stock.getStockNumber() + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清仓处理</div><div class="line">	private void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		// 要求清仓销售</div><div class="line">		super.sale.offSale();</div><div class="line">		// 要求采购人员不要采购</div><div class="line">		super.purchase.refuseBuyIBM();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class AbstractColleague &#123;</div><div class="line">	protected AbstractMediator mediator;</div><div class="line"></div><div class="line">	public AbstractColleague(AbstractMediator _mediator) &#123;</div><div class="line">		this.mediator = _mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Purchase extends AbstractColleague &#123;</div><div class="line">	public Purchase(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购IBM电脑</div><div class="line">	public void buyIBMcomputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"purchase.buy"</span>, number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 不再采购IBM电脑</div><div class="line">	public void <span class="function"><span class="title">refuseBuyIBM</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"不再采购IBM电脑"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Sale extends AbstractColleague &#123;</div><div class="line">	public Sale(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售IBM电脑</div><div class="line">	public void sellIBMComputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.sell"</span>, number);</div><div class="line">		System.out.println(<span class="string">"销售IBM电脑"</span> + number + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 反馈销售情况，0～100变化，0代表根本就没人买，100代表非常畅销，出一个卖一个</div><div class="line">	public int <span class="function"><span class="title">getSaleStatus</span></span>() &#123;</div><div class="line">		Random rand = new Random(System.currentTimeMillis());</div><div class="line">		int saleStatus = rand.nextInt(100);</div><div class="line">		System.out.println(<span class="string">"IBM电脑的销售情况为："</span> + saleStatus);</div><div class="line">		<span class="built_in">return</span> saleStatus;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价处理</div><div class="line">	public void <span class="function"><span class="title">offSale</span></span>() &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.offsell"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Stock extends AbstractColleague &#123;</div><div class="line">	public Stock(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 刚开始有100台电脑</div><div class="line">	private static int COMPUTER_NUMBER = 100;</div><div class="line"></div><div class="line">	// 库存增加</div><div class="line">	public void increase(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER + number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 库存降低</div><div class="line">	public void decrease(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER - number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得库存数量</div><div class="line">	public int <span class="function"><span class="title">getStockNumber</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> COMPUTER_NUMBER;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售</div><div class="line">	public void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"清理存货数量为："</span> + COMPUTER_NUMBER);</div><div class="line">		super.mediator.execute(<span class="string">"stock.clear"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/2017/12/06/设计模式之禅/中介者4.png" alt=""><br>● Mediator 抽象中介者角色<br>抽象中介者角色定义统一的接口，用于各同事角色之间的通信。<br>● Concrete Mediator 具体中介者角色<br>具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。<br>● Colleague 同事角色<br>每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br><img src="/2017/12/06/设计模式之禅/命令1.png" alt=""><br>Receive接收者角色<br>该角色就是干活的角色，命令传递到这里是应该被执行的。<br>● Command命令角色<br>需要执行的所有命令都在这里声明。<br>● Invoker调用者角色<br>接收到命令，并执行命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public abstract class Receiver &#123;</div><div class="line">	// 抽象接收者，定义每个接收者都必须完成的业务</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteReciver1 extends Receiver &#123;</div><div class="line">	// 每个接收者都必须处理一定的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"ConcreteReciver1:dosomething"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Command &#123;</div><div class="line">	// 每个命令类都必须有一个执行命令的方法</div><div class="line">	public abstract void execute();</div><div class="line">&#125;</div><div class="line">public class ConcreteCommand1 extends Command &#123;</div><div class="line">	// 对哪个Receiver类进行命令处理</div><div class="line">	private Receiver receiver;</div><div class="line"></div><div class="line">	// 构造函数传递接收者</div><div class="line">	public ConcreteCommand1(Receiver _receiver) &#123;</div><div class="line">		this.receiver = _receiver;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 必须实现一个命令</div><div class="line">	public void <span class="function"><span class="title">execute</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">		this.receiver.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Invoker &#123;</div><div class="line">	private Command <span class="built_in">command</span>;</div><div class="line"></div><div class="line">	// 受气包，接受命令</div><div class="line">	public void <span class="built_in">set</span>Command(Command _command) &#123;</div><div class="line">		this.command = _command;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 执行命令</div><div class="line">	public void <span class="function"><span class="title">action</span></span>() &#123;</div><div class="line">		this.command.execute();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 首先声明调用者Invoker</div><div class="line">		Invoker invoker = new Invoker();</div><div class="line">		// 定义接收者</div><div class="line">		Receiver receiver = new ConcreteReciver1();</div><div class="line">		// 定义一个发送给接收者的命令</div><div class="line">		Command <span class="built_in">command</span> = new ConcreteCommand1(receiver);</div><div class="line">		// 把命令交给调用者去执行</div><div class="line">		invoker.setCommand(<span class="built_in">command</span>);</div><div class="line">		invoker.action();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>● 类间解耦<br>调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。<br>● 可扩展性<br>Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。<br>● 命令模式结合其他模式会更优秀<br>命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。<br><img src="/2017/12/06/设计模式之禅/责任.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Level &#123;</div><div class="line">	// 定义一个请求和处理等级</div><div class="line">&#125;</div><div class="line">public class Request &#123;</div><div class="line">	// 请求的等级</div><div class="line">	public Level <span class="function"><span class="title">getRequestLevel</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Response &#123;</div><div class="line">	// 处理者返回的数据</div><div class="line">&#125;</div><div class="line">public abstract class Handler &#123;</div><div class="line">	private Handler nextHandler;</div><div class="line"></div><div class="line">	// 每个处理者都必须对请求做出处理</div><div class="line">	public final Response handleMessage(Request request) &#123;</div><div class="line">		Response response = null;</div><div class="line">		// 判断是否是自己的处理级别</div><div class="line">		<span class="keyword">if</span> (this.getHandlerLevel().equals(request.getRequestLevel())) &#123;</div><div class="line">			response = this.echo(request);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 不属于自己的处理级别</div><div class="line">		// 判断是否有下一个处理者</div><div class="line">			<span class="keyword">if</span> (this.nextHandler != null) &#123;</div><div class="line">				response = this.nextHandler.handleMessage(request);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				// 没有适当的处理者，业务自行处理</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> response;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置下一个处理者是谁</div><div class="line">	public void <span class="built_in">set</span>Next(Handler _handler) &#123;</div><div class="line">		this.nextHandler = _handler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 每个处理者都有一个处理级别</div><div class="line">	protected abstract Level getHandlerLevel();</div><div class="line"></div><div class="line">	// 每个处理者都必须实现处理任务</div><div class="line">	protected abstract Response <span class="built_in">echo</span>(Request request);</div><div class="line">&#125;</div><div class="line">public class ConcreteHandler1 extends Handler &#123;</div><div class="line">	// 定义自己的处理逻辑</div><div class="line">	protected Response <span class="built_in">echo</span>(Request request) &#123;</div><div class="line">		// 完成处理逻辑</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置自己的处理级别</div><div class="line">	protected Level <span class="function"><span class="title">getHandlerLevel</span></span>() &#123;</div><div class="line">		// 设置自己的处理级别</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><p>责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活<br><img src="/2017/12/06/设计模式之禅/装饰1.png" alt=""><br>● Component抽象构件<br>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当<br>Component抽象构件。<br>● ConcreteComponent 具体构件<br>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。<br>● Decorator装饰角色<br>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。<br>● 具体装饰角色<br>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 抽象的方法</div><div class="line">	public abstract void operate();</div><div class="line">&#125;</div><div class="line">public class ConcreteComponent extends Component &#123;</div><div class="line">	// 具体实现</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"do Something"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Decorator extends Component &#123;</div><div class="line">	private Component component = null;</div><div class="line"></div><div class="line">	// 通过构造函数传递被修饰者</div><div class="line">	public Decorator(Component _component) &#123;</div><div class="line">		this.component = _component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 委托给被修饰者执行</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.component.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteDecorator1 extends Decorator &#123;</div><div class="line">	// 定义被修饰者</div><div class="line">	public ConcreteDecorator1(Component _component) &#123;</div><div class="line">		super(_component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义自己的修饰方法</div><div class="line">	private void <span class="function"><span class="title">method1</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"method1 修饰"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 重写父类的Operation方法</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.method1();</div><div class="line">		super.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Component component = new ConcreteComponent();</div><div class="line">		//第一次修饰</div><div class="line">		component = new ConcreteDecorator1(component);</div><div class="line">		component.operate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><p>● 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道 Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。<br>● 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。<br>● 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如<br>此。</p>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>多层的装饰是比较复杂的</p>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>● 需要扩展一个类的功能，或给一个类增加附加功能。<br>● 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。<br>● 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。<br><img src="/2017/12/06/设计模式之禅/策略1.png" alt=""><br>● Context封装角色<br>它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。<br>● Strategy抽象策略角色<br>策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。<br>● ConcreteStrategy具体策略角色<br>实现抽象策略中的操作，该类含有具体的算法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">	// 策略模式的运算法则</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"具体策略1的运算法则"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 抽象策略</div><div class="line">	private Strategy strategy = null;</div><div class="line"></div><div class="line">	// 构造函数设置具体策略</div><div class="line">	public Context(Strategy _strategy) &#123;</div><div class="line">		this.strategy = _strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 封装后的策略方法</div><div class="line">	public void <span class="function"><span class="title">doAnythinig</span></span>() &#123;</div><div class="line">		this.strategy.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 声明一个具体的策略</div><div class="line">		Strategy strategy = new ConcreteStrategy1();</div><div class="line">		// 声明上下文对象</div><div class="line">		Context context = new Context(strategy);</div><div class="line">		// 执行封装后的方法</div><div class="line">		context.doAnythinig();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><p>● 算法可以自由切换<br>这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。<br>● 避免使用多重条件判断<br>如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</p>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><p>● 策略类数量增多<br>每一个策略都是一个类，复用的可能性很小，类数量增多。<br>● 所有的策略类都需要对外暴露<br>上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式</p>
<h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>● 多个类只有在算法或行为上稍有不同的场景。<br>● 算法需要自由切换的场景。<br>● 需要屏蔽算法规则的场景。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。<br><img src="/2017/12/06/设计模式之禅/适配器1.png" alt=""><br>● Target目标角色<br>该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口就是目标角色。<br>● Adaptee源角色<br>你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。<br>● Adapter适配器角色<br>适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Target &#123;</div><div class="line">	// 目标角色有自己的方法</div><div class="line">	public void request();</div><div class="line">&#125;</div><div class="line">public class ConcreteTarget implements Target &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"if you need any help,pls call me!"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Adaptee &#123;</div><div class="line">	// 原有的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"I'm kind of busy,leave me alone,pls!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Adapter extends Adaptee implements Target &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		super.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 原有的业务逻辑</div><div class="line">		Target target = new ConcreteTarget();</div><div class="line">		target.request();</div><div class="line">		// 现在增加了适配器角色后的业务逻辑</div><div class="line">		Target target2 = new Adapter();</div><div class="line">		target2.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><p>● 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。<br>● 增加了类的透明性<br>想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。<br>● 提高了类的复用度<br>当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员<br>● 灵活性非常好<br>某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</p>
<h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>适配器应用的场景只要记住一点就足够了：比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节<br><img src="/2017/12/06/设计模式之禅/迭代器1.png" alt=""><br>● Iterator抽象迭代器<br>抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法：first获得第一个元素，next访问下一个元素，isDone是否已经访问到底部。<br>● ConcreteIterator具体迭代器<br>具体迭代器角色要实现迭代器接口，完成容器元素的遍历。<br>● Aggregate抽象容器<br>容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator这样的方法，在Java中一般是iterator方法。<br>● Concrete Aggregate具体容器<br>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">	// 遍历到下一个元素</div><div class="line">	public Object next();</div><div class="line"></div><div class="line">	// 是否已经遍历到尾部</div><div class="line">	public boolean hasNext();</div><div class="line"></div><div class="line">	// 删除当前指向的元素</div><div class="line">	public boolean remove();</div><div class="line">&#125;</div><div class="line">public class ConcreteIterator implements Iterator &#123;</div><div class="line"></div><div class="line">	private Vector vector = new Vector();</div><div class="line">	// 定义当前游标</div><div class="line">	public int cursor = 0;</div><div class="line"></div><div class="line">	@SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">	public ConcreteIterator(Vector _vector) &#123;</div><div class="line">		this.vector = _vector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否到达尾部</div><div class="line">	public boolean <span class="function"><span class="title">hasNext</span></span>() &#123;</div><div class="line">		<span class="keyword">if</span> (this.cursor == this.vector.size()) &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回下一个元素</div><div class="line">	public Object <span class="function"><span class="title">next</span></span>() &#123;</div><div class="line">		Object result = null;</div><div class="line">		<span class="keyword">if</span> (this.hasNext()) &#123;</div><div class="line">			result = this.vector.get(this.cursor++);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			result = null;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除当前元素</div><div class="line">	public boolean <span class="function"><span class="title">remove</span></span>() &#123;</div><div class="line">		this.vector.remove(this.cursor);</div><div class="line">		<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public interface Aggregate &#123;</div><div class="line"></div><div class="line">	// 是容器必然有元素的增加</div><div class="line">	public void add(Object object);</div><div class="line"></div><div class="line">	// 减少元素</div><div class="line">	public void remove(Object object);</div><div class="line"></div><div class="line">	// 由迭代器来遍历所有的元素</div><div class="line">	public Iterator iterator();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class ConcreteAggregate implements Aggregate &#123;</div><div class="line"></div><div class="line">	// 容纳对象的容器</div><div class="line">	private Vector vector = new Vector();</div><div class="line"></div><div class="line">	// 增加一个元素</div><div class="line">	public void add(Object object) &#123;</div><div class="line">		this.vector.add(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回迭代器对象</div><div class="line">	public Iterator <span class="function"><span class="title">iterator</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new ConcreteIterator(this.vector);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个元素</div><div class="line">	public void remove(Object object) &#123;</div><div class="line">		this.remove(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性<br><img src="/2017/12/06/设计模式之禅/组合模式.png" alt=""><br>● Component抽象构件角色<br>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>● Leaf叶子构件<br>叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>● Composite树枝构件<br>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 个体和整体都具有的共享</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 编写业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Composite extends Component &#123;</div><div class="line">	// 构件容器</div><div class="line">	private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</div><div class="line"></div><div class="line">	// 增加一个叶子构件或树枝构件</div><div class="line">	public void add(Component component) &#123;</div><div class="line">		this.componentArrayList.add(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个叶子构件或树枝构件</div><div class="line">	public void remove(Component component) &#123;</div><div class="line">		this.componentArrayList.remove(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得分支下的所有叶子构件和树枝构件</div><div class="line">	public ArrayList&lt;Component&gt; <span class="function"><span class="title">getChildren</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> this.componentArrayList;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Leaf extends Component &#123;</div><div class="line">	/*</div><div class="line">	 * 可以覆写父类方法 public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">	 *</div><div class="line">	 * &#125;</div><div class="line">	 */</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个根节点</div><div class="line">		Composite root = new Composite();</div><div class="line">		root.doSomething();</div><div class="line">		// 创建一个树枝构件</div><div class="line">		Composite branch = new Composite();</div><div class="line">		// 创建一个叶子节点</div><div class="line">		Leaf leaf = new Leaf();</div><div class="line">		// 建立整体</div><div class="line">		root.add(branch);</div><div class="line">		branch.add(leaf);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过递归遍历树</div><div class="line">	public static void display(Composite root) &#123;</div><div class="line">		<span class="keyword">for</span> (Component c : root.getChildren()) &#123;</div><div class="line">			<span class="keyword">if</span> (c instanceof Leaf) &#123; // 叶子节点</div><div class="line">				c.doSomething();</div><div class="line">			&#125; <span class="keyword">else</span> &#123; // 树枝节点</div><div class="line">				display((Composite) c);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><p>● 高层模块调用简单<br>一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br>● 节点自由增加<br>使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</p>
<h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>● 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。<br>● 从一个整体中能够独立出部分模块或功能的场景。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。<br><img src="/2017/12/06/设计模式之禅/观察者模式.png" alt=""><br>● Subject被观察者<br>定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。<br>● Observer观察者<br>观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。<br>● ConcreteSubject具体的被观察者<br>定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。<br>● ConcreteObserver具体的观察者<br>每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public abstract class Subject &#123;</div><div class="line">	// 定义一个观察者数组</div><div class="line">	private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</div><div class="line"></div><div class="line">	// 增加一个观察者</div><div class="line">	public void addObserver(Observer o) &#123;</div><div class="line">		this.obsVector.add(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个观察者</div><div class="line">	public void delObserver(Observer o) &#123;</div><div class="line">		this.obsVector.remove(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通知所有观察者</div><div class="line">	public void <span class="function"><span class="title">notifyObservers</span></span>() &#123;</div><div class="line">		<span class="keyword">for</span> (Observer o : this.obsVector) &#123;</div><div class="line">			o.update();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteSubject extends Subject &#123;</div><div class="line">	// 具体的业务</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * <span class="keyword">do</span> something</div><div class="line">		 */</div><div class="line">		super.notifyObservers();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface Observer &#123;</div><div class="line">	// 更新方法</div><div class="line">	public void update();</div><div class="line">&#125;</div><div class="line">public class ConcreteObserver implements Observer &#123;</div><div class="line">	// 实现更新方法</div><div class="line">	public void <span class="function"><span class="title">update</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"接收到信息，并进行处理！"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个被观察者</div><div class="line">		Subject subject = new ConcreteSubject();</div><div class="line">		// 定义一个观察者</div><div class="line">		Observer obs = new ConcreteObserver();</div><div class="line">		// 观察者观察被观察者</div><div class="line">		subject.addObserver(obs);</div><div class="line">		// 观察者开始活动了</div><div class="line">		subject.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><p>● 观察者和被观察者之间是抽象耦合<br>如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实现的抽象层级的定义，在系统扩展方面更是得心应手。<br>● 建立一套触发机制</p>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。多级触发时的效率更是让人担忧，大家在设计时注意考虑</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>● 广播链的问题<br>如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表A上写了一个触发器，内容是一个字段更新后更新表B的一条数据，而表B上也有个触发器，要更新表C，表C也有触发器……完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，既是观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次）这还是比较好控制的。注意它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。<br>● 异步处理问题<br>这个EJB是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。</p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。<br>● Facade门面角色<br>客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。<br>● subsystem子系统角色<br>可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。<br><img src="/2017/12/06/设计模式之禅/门面.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ClassA &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingA</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ClassB &#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomethingB</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassC &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingC</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Facade &#123;</div><div class="line">	// 被委托的对象</div><div class="line">	private ClassA a = new ClassA();</div><div class="line">	private ClassB b = new ClassB();</div><div class="line">	private ClassC c = new ClassC();</div><div class="line"></div><div class="line">	// 提供给外部访问的方法</div><div class="line">	public void <span class="function"><span class="title">methodA</span></span>() &#123;</div><div class="line">		this.a.doSomethingA();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodB</span></span>() &#123;</div><div class="line">		this.b.doSomethingB();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodC</span></span>() &#123;</div><div class="line">		this.c.doSomethingC();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><p>● 减少系统的相互依赖<br>想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模<br>式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。<br>● 提高了灵活性<br>依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。<br>● 提高安全性<br>想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到</p>
<h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><p>门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。</p>
<h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><p>● 为一个复杂的模块或子系统提供一个供外界访问的接口<br>● 子系统相对独立——外界对子系统的访问只要黑箱操作即可<br>比如利息的计算问题，没有深厚的业务知识和扎实的技术水平是不可能开发出该子系统的，但是对于使用该系统的开发人员来说，他需要做的就是输入金额以及存期，其他的都不用关心，返回的结果就是利息，这时候，门面模式是非使用不可了。<br>● 预防低水平人员带来的风险扩散</p>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br><img src="/2017/12/06/设计模式之禅/备忘录.png" alt=""><br>● Originator发起人角色<br>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。<br>● Memento备忘录角色<br>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。<br>● Caretaker备忘录管理员角色<br>对备忘录进行管理、保存和提供备忘录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 创建一个备忘录</div><div class="line">	public Memento <span class="function"><span class="title">createMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new Memento(this.state);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 恢复一个备忘录</div><div class="line">	public void restoreMemento(Memento _memento) &#123;</div><div class="line">		this.setState(_memento.getState());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Memento &#123;</div><div class="line">	// 发起人的内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	// 构造函数传递参数</div><div class="line">	public Memento(String _state) &#123;</div><div class="line">		this.state = _state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Caretaker &#123;</div><div class="line">	// 备忘录对象</div><div class="line">	private Memento memento;</div><div class="line"></div><div class="line">	public Memento <span class="function"><span class="title">getMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> memento;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Memento(Memento memento) &#123;</div><div class="line">		this.memento = memento;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义出发起人</div><div class="line">		Originator originator = new Originator();</div><div class="line">		// 定义出备忘录管理员</div><div class="line">		Caretaker caretaker = new Caretaker();</div><div class="line">		// 创建一个备忘录</div><div class="line">		caretaker.setMemento(originator.createMemento());</div><div class="line">		// 恢复一个备忘录</div><div class="line">		originator.restoreMemento(caretaker.getMemento());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 需要保存和恢复数据的相关状态场景。<br>● 提供一个可回滚（rollback）的操作；比如Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。<br>● 需要监控的副本场景中。例如要监控一个对象的属性，但是监控又不应该作为系统=的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。<br>● 数据库连接的事务管理就是用的备忘录模式</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br><img src="/2017/12/06/设计模式之禅/访问.png" alt=""><br>● Visitor——抽象访问者<br>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。<br>● ConcreteVisitor——具体访问者<br>它影响访问者访问到一个类后该怎么干，要做什么事情。<br>● Element——抽象元素<br>接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。<br>● ConcreteElement——具体元素<br>实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了。<br>● ObjectStruture——结构对象<br>元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目中，一般很少抽象出这个角色。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public abstract class Element &#123;</div><div class="line">	// 定义业务逻辑</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	// 允许谁来访问</div><div class="line">	public abstract void accept(IVisitor visitor);</div><div class="line">&#125;</div><div class="line">public class ConcreteElement1 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteElement2 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface IVisitor &#123;</div><div class="line">	// 可以访问哪些对象</div><div class="line">	public void visit(ConcreteElement1 el1);</div><div class="line"></div><div class="line">	public void visit(ConcreteElement2 el2);</div><div class="line">&#125;</div><div class="line">public class Visitor implements IVisitor &#123;</div><div class="line">	// 访问el1元素</div><div class="line">	public void visit(ConcreteElement1 el1) &#123;</div><div class="line">		el1.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 访问el2元素</div><div class="line">	public void visit(ConcreteElement2 el2) &#123;</div><div class="line">		el2.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ObjectStruture &#123;</div><div class="line">	// 对象生成器，这里通过一个工厂方法模式模拟</div><div class="line">	public static Element <span class="function"><span class="title">createElement</span></span>() &#123;</div><div class="line">		Random rand = new Random();</div><div class="line">		<span class="keyword">if</span> (rand.nextInt(100) &gt; 50) &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement1();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement2();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			// 获得元素对象</div><div class="line">			Element el = ObjectStruture.createElement();</div><div class="line">			// 接受访问者访问</div><div class="line">			el.accept(new Visitor());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><p>● 符合单一职责原则<br>具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。<br>● 优秀的扩展性<br>由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。<br>● 灵活性非常高<br>例如，数据汇总，就以刚刚我们说的Employee的例子，如果我现在要统计所有员工的工资之和，怎么计算？把所有人的工资for循环加一遍？是个办法，那我再提个问题，员工工资×1.2，部门经理×1.4，总经理×1.8，然后把这些工资加起来，你怎么处理？1.2，1.4，1.8是什么？不是吧？！你没看到领导不论什么时候都比你拿得多，工资奖金就不说了，就是过节发个慰问券也比你多，就是这个系数在作祟。我们继续说你想怎么统计？使用for循环，然后使用instanceof来判断是员工还是经理？这可以解决，但不是个好办法，好办法是通过访问者模式来实现，把数据扔给访问者，由访问者来进行统计计算。</p>
<h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><p>● 具体元素对访问者公布细节<br>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。<br>● 具体元素变更比较困难<br>具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？<br>● 违背了依赖倒置转原则<br>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖=于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。<br>● 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。<br>总结一下，在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。访问者模式还有一个用途，就是充当拦截器（Interceptor）角色。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。<br>● State——抽象状态角色<br>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。<br>● ConcreteState——具体状态角色<br>每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。<br>● Context——环境角色<br>定义客户端需要的接口，并且负责具体状态的切换。<br>环境角色有两个不成文的约束：<br>● 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。<br>● 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public abstract class State &#123;</div><div class="line">	// 定义一个环境角色，提供子类访问</div><div class="line">	protected Context context;</div><div class="line"></div><div class="line">	// 设置环境角色</div><div class="line">	public void <span class="built_in">set</span>Context(Context _context) &#123;</div><div class="line">		this.context = _context;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为1</div><div class="line">	public abstract void handle1();</div><div class="line"></div><div class="line">	// 行为2</div><div class="line">	public abstract void handle2();</div><div class="line">&#125;</div><div class="line">public class ConcreteState1 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 设置当前状态为<span class="built_in">stat</span>2</div><div class="line">		super.context.setCurrentState(Context.STATE2);</div><div class="line">		// 过渡到state2状态，由Context实现</div><div class="line">		super.context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteState2 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 设置当前状态为state1</div><div class="line">		super.context.setCurrentState(Context.STATE1);</div><div class="line">		// 过渡到state1状态，由Context实现</div><div class="line">		super.context.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 定义状态</div><div class="line">	public final static State STATE1 = new ConcreteState1();</div><div class="line">	public final static State STATE2 = new ConcreteState2();</div><div class="line">	// 当前状态</div><div class="line">	private State CurrentState;</div><div class="line"></div><div class="line">	// 获得当前状态</div><div class="line">	public State <span class="function"><span class="title">getCurrentState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> CurrentState;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置当前状态</div><div class="line">	public void <span class="built_in">set</span>CurrentState(State currentState) &#123;</div><div class="line">		this.CurrentState = currentState;</div><div class="line">		// 切换状态</div><div class="line">		this.CurrentState.setContext(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为委托</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		this.CurrentState.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		this.CurrentState.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义环境角色</div><div class="line">		Context context = new Context();</div><div class="line">		// 初始化状态</div><div class="line">		context.setCurrentState(new ConcreteState1());</div><div class="line">		// 行为执行</div><div class="line">		context.handle1();</div><div class="line">		context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><p>● 结构清晰<br>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性,提高系统的可维护性。<br>● 遵循设计原则<br>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。<br>● 封装性非常好<br>这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</p>
<h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><p>子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。</p>
<h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><p>● 行为随状态改变而改变的场景<br>这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。<br>● 条件、分支判断语句的替代者<br>在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变<br>化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）是一种按照规定语法进行解析的方案，在现在项目中使用较少。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br><img src="/2017/12/06/设计模式之禅/解释器.png" alt=""><br>● AbstractExpression——抽象解释器<br>具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和 Non-terminalExpression完成。<br>● TerminalExpression——终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达<br>式，但有多个实例，对应不同的终结符。具体到我们例子就是VarExpression类，表达式中的每个终结符都在栈中产生了一个VarExpression对象。<br>● NonterminalExpression——非终结符表达式<br>文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。<br>● Context——环境角色<br>具体到我们的例子中是采用HashMap代替。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public abstract class Expression &#123;</div><div class="line">	// 每个表达式必须有一个解析任务</div><div class="line">	public abstract Object interpreter(Context ctx);</div><div class="line">&#125;</div><div class="line">public class NonterminalExpression extends Expression &#123;</div><div class="line">	// 每个非终结符表达式都会对其他表达式产生依赖</div><div class="line">	public NonterminalExpression(Expression... expression) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		// 进行文法处理</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class TerminalExpression extends Expression &#123;</div><div class="line">	// 通常终结符表达式只有一个，但是有多个对象</div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p>
<h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><p>● 解释器模式会引起类膨胀<br>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。<br>● 解释器模式采用递归调用方法<br>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下使用的，它导致调试非常复杂。想想看，如果要排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。<br>● 效率问题<br>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。</p>
<h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><p>● 重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。<br>● 一个简单语法需要解释的场景</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）是池技术的重要实现方式。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>使用共享对象可有效地支持大量的细粒度的对象。<br><img src="/2017/12/06/设计模式之禅/享元模式.png" alt=""><br>● Flyweight——抽象享元角色<br>它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。<br>● ConcreteFlyweight——具体享元角色<br>具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。<br>● unsharedConcreteFlyweight——不可共享的享元角色<br>不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。<br>● FlyweightFactory——享元工厂<br>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public abstract class Flyweight &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String intrinsic;</div><div class="line">	// 外部状态</div><div class="line">	protected final String Extrinsic;</div><div class="line"></div><div class="line">	// 要求享元角色必须接受外部状态</div><div class="line">	public Flyweight(String _Extrinsic) &#123;</div><div class="line">		this.Extrinsic = _Extrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义业务操作</div><div class="line">	public abstract void operate();</div><div class="line"></div><div class="line">	// 内部状态的getter/setter</div><div class="line">	public String <span class="function"><span class="title">getIntrinsic</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> intrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Intrinsic(String intrinsic) &#123;</div><div class="line">		this.intrinsic = intrinsic;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight1(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight2(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class FlyweightFactory &#123;</div><div class="line">	// 定义一个池容器</div><div class="line">	private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;String, Flyweight&gt;();</div><div class="line"></div><div class="line">	// 享元工厂</div><div class="line">	public static Flyweight getFlyweight(String Extrinsic) &#123;</div><div class="line">		// 需要返回的对象</div><div class="line">		Flyweight flyweight = null;</div><div class="line">		// 在池中没有该对象</div><div class="line">		<span class="keyword">if</span> (pool.containsKey(Extrinsic)) &#123;</div><div class="line">			flyweight = pool.get(Extrinsic);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 根据外部状态创建享元对象</div><div class="line">			flyweight = new ConcreteFlyweight1(Extrinsic);</div><div class="line">			// 放置到池中</div><div class="line">			pool.put(Extrinsic, flyweight);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> flyweight;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><p>元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存<br>的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h3 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h3><p>● 系统中存在大量的相似对象。<br>● 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>● 需要缓冲池的场景。</p>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><p>桥梁模式（Bridge Pattern）也叫做桥接模式，是一个比较简单的模式</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>将抽象和实现解耦，使得两者可以独立地变化。<br><img src="/2017/12/06/设计模式之禅/桥梁.png" alt=""><br>● Abstraction——抽象化角色<br>它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。<br>● Implementor——实现化角色<br>它是接口或者抽象类，定义角色必需的行为和属性。<br>● RefinedAbstraction——修正抽象化角色<br>它引用实现化角色对抽象化角色进行修正。<br>● ConcreteImplementor——具体实现化角色<br>它实现接口或抽象类定义的方法和属性。<br>桥梁模式中的几个名词比较拗口，大家只要记住一句话就成：抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public interface Implementor &#123;</div><div class="line">	// 基本方法</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	public void <span class="keyword">do</span>Anything();</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor1 implements Implementor &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor2 implements Implementor&#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public abstract class Abstraction &#123;</div><div class="line">	// 定义对实现化角色的引用</div><div class="line">	private Implementor imp;</div><div class="line"></div><div class="line">	// 约束子类必须实现该构造函数</div><div class="line">	public Abstraction(Implementor _imp) &#123;</div><div class="line">		this.imp = _imp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 自身的行为和属性</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.imp.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得实现化角色</div><div class="line">	public Implementor <span class="function"><span class="title">getImp</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> imp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class RefinedAbstraction extends Abstraction &#123;</div><div class="line">	// 覆写构造函数</div><div class="line">	public RefinedAbstraction(Implementor _imp) &#123;</div><div class="line">		super(_imp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 修正父类的行为</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 业务处理...</div><div class="line">		 */</div><div class="line">		super.request();</div><div class="line">		super.getImp().doAnything();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义一个实现化角色</div><div class="line">		Implementor imp = new ConcreteImplementor1();</div><div class="line">		// 定义一个抽象化角色</div><div class="line">		Abstraction abs = new RefinedAbstraction(imp);</div><div class="line">		// 执行行文</div><div class="line">		abs.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h3><p>● 抽象和实现分离<br>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。<br>● 优秀的扩充能力<br>看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。<br>● 实现细节对客户透明<br>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p>
<h3 id="场景-8"><a href="#场景-8" class="headerlink" title="场景"></a>场景</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;h2 id=&quot;单一职责-SRP&quot;&gt;&lt;a href=&quot;#单一职责-SRP&quot; class=&quot;headerlink&quot; title=&quot;单
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java8</title>
    <link href="http://yoursite.com/2017/12/02/java8/"/>
    <id>http://yoursite.com/2017/12/02/java8/</id>
    <published>2017-12-02T07:22:38.000Z</published>
    <updated>2017-12-07T13:48:13.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>java8新特性：Lambda（匿名函数）、流、默认方法</p>
<h2 id="java中的函数"><a href="#java中的函数" class="headerlink" title="java中的函数"></a>java中的函数</h2><p>java8新增函数作为值的一种新形式。</p>
<h3 id="方法和-Lambda-作为一等公民"><a href="#方法和-Lambda-作为一等公民" class="headerlink" title="方法和 Lambda 作为一等公民"></a>方法和 Lambda 作为一等公民</h3><p>Java 8的第一个新功能是方法引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> File[] hiddenFiles= new File(<span class="string">"."</span>).listFiles(new <span class="function"><span class="title">FileFilter</span></span>()&#123;</div><div class="line">     public boolean accept(File file)&#123;</div><div class="line">         <span class="built_in">return</span> file.isHidden();</div><div class="line">     &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">File[] hiddenFiles1 = new File(<span class="string">"."</span>).listFiles(File::isHidden);</div></pre></td></tr></table></figure></p>
<h3 id="传递代码"><a href="#传递代码" class="headerlink" title="传递代码"></a>传递代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static boolean isGreenApple(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.color.equals(<span class="string">"green"</span>);</div><div class="line">	&#125;</div><div class="line">	public static boolean isHeavy(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.weight&gt;150;</div><div class="line">	&#125;</div><div class="line">	public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list,Predicate&lt;Apple&gt; p)&#123;</div><div class="line">		List&lt;Apple&gt; result=new ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(Apple apple:list)&#123;</div><div class="line">			<span class="keyword">if</span>(p.test(apple))</div><div class="line">			result.add(apple);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		List&lt;Apple&gt; list=new ArrayList&lt;Apple&gt;();</div><div class="line">		list.add(new Apple(150, <span class="string">"red"</span>));</div><div class="line">		filterApple(list, AppleExample::isHeavy);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从传递方法到Lambda"><a href="#从传递方法到Lambda" class="headerlink" title="从传递方法到Lambda"></a>从传递方法到Lambda</h3><p>不过Java 8也解决了这个问题，它引入了一套新记法（匿名函数或Lambda）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">filterApple(inventory, (Apple a) -&gt; <span class="string">"green"</span>.equals(a.getColor()) );</div><div class="line">filterApple(inventory, (Apple a) -&gt; a.weight &gt; 150 );</div></pre></td></tr></table></figure></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =</div><div class="line">transactions.stream()</div><div class="line">.filter((Transaction t) -&gt; t.getPrice() &gt; 1000)</div><div class="line">.collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<p>Stream允许并提倡并行处理一个 Stream 中的元素。虽然可能乍看上去有点儿怪，但筛选一个 Collection （filterApples 应用在一个List 上）的最快方法常常是将其转换为 Stream ，进行并行处理，然后再转换回 List<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//顺序处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.stream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div><div class="line">//并行处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div></pre></td></tr></table></figure></p>
<p>库会负责分块，即把大的流分成几个小的流，以便并行处理。其次，流提供的这个几乎免费的并行，只有在传递给 filter 之类的库方法的方法不会互动（比方说有可变的共享对象）时才能工作。</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8的解决方法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名<br>了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现） ，而不是由实现类提供。<br>这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明<br>中使用新的 default 关键字来表示这一点。例如，在Java 8里，你现在可以直接对 List 调用 sort 方法。它是用Java 8  List 接口中如下所示的默认方法实现的，它会调用 Collections.sort 静态方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">Collections.sort(this, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这意味着 List 的任何实体类都不需要显式实现 sort ，而在以前的Java版本中，除非提供了sort 的实现，否则这些实体类在重新编译时都会失败。</p>
<h1 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h1><h2 id="应对不断变化的需求"><a href="#应对不断变化的需求" class="headerlink" title="应对不断变化的需求"></a>应对不断变化的需求</h2><h3 id="初试牛刀：筛选绿苹果"><a href="#初试牛刀：筛选绿苹果" class="headerlink" title="初试牛刀：筛选绿苹果"></a>初试牛刀：筛选绿苹果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把颜色作为参数"><a href="#把颜色作为参数" class="headerlink" title="把颜色作为参数"></a>把颜色作为参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory,String color) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(color.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三次尝试对属性做筛选"><a href="#第三次尝试对属性做筛选" class="headerlink" title="第三次尝试对属性做筛选"></a>第三次尝试对属性做筛选</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span> (Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>((flag&amp;&amp;apple.getColor().equals(color))||(!flag&amp;&amp;apple.getWeight()&gt;150))&#123;</div><div class="line">      result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h2><p>1.传递代码/行为，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt;inventory, ApplePredicate p)&#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">   <span class="keyword">if</span>(p.test(apple))&#123;</div><div class="line">      result.add(apple);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">  ApplePredicate p=new AppleRedAndHeavyPredicate();</div><div class="line">  List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.多种行为，一种参数<br>行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应用的行为区分开来。这样你可以重复使用同一个方法，给它不同的行为来达到不同的目的。<br><img src="/2017/12/02/java8/行为参数化.PNG" alt=""></p>
<h2 id="对付啰嗦"><a href="#对付啰嗦" class="headerlink" title="对付啰嗦"></a>对付啰嗦</h2><p>当要把新的行为传递给filterApples方法的时候，你不得不声明好几个实现 ApplePredicate接口的类，然后实例化好几个只会提到一次的ApplePredicate对象.</p>
<h3 id="使用匿名类"><a href="#使用匿名类" class="headerlink" title="使用匿名类"></a>使用匿名类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new <span class="function"><span class="title">ApplePredicate</span></span>() &#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>匿名类在GUI经常用到，但是有缺点：1.很笨重；2.用起来费解。</p>
<h3 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; result=filterApples(list,(Apple a)-&gt;<span class="string">"red"</span>.equals(a.color));</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/参数化和值参数化.PNG" alt=""></p>
<h3 id="List抽象化"><a href="#List抽象化" class="headerlink" title="List抽象化"></a>List抽象化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">   boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list,Predicate&lt;T&gt; p)&#123;</div><div class="line">   List&lt;T&gt; result=new ArrayList&lt;T&gt;();</div><div class="line">   <span class="keyword">for</span>(T t:list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(t))&#123;</div><div class="line">       result.add(t);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="真实的例子"><a href="#真实的例子" class="headerlink" title="真实的例子"></a>真实的例子</h2><h3 id="使用Comparator排序"><a href="#使用Comparator排序" class="headerlink" title="使用Comparator排序"></a>使用Comparator排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a,Apple b)-&gt; a.getWeight().compareTo(b.getWeight()));</div></pre></td></tr></table></figure>
<h3 id="用runnable执行代码块"><a href="#用runnable执行代码块" class="headerlink" title="用runnable执行代码块"></a>用runnable执行代码块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=new Thread(()-&gt;System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure>
<h3 id="GUI例子"><a href="#GUI例子" class="headerlink" title="GUI例子"></a>GUI例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnAction((ActionEvent event)-&gt;lable.setText(<span class="string">"hello"</span>));</div></pre></td></tr></table></figure>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h2><p>Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：没有名称、有参数列表函数主体、返回类型、可能还会有可抛出的异常列表。<br>特点：<br>匿名：不像普通方法有明确的名称：写得少而想得多<br>函数：Lambda函数不像方法那样属于某个特定的类。但和方法一样，有参数列表，函数主体，返回类型，还可能有可抛出的异常列表。<br>传递：Lambda表达式可作为参数传递给方法或者存储在变量中<br>简洁：无需像匿名类写很多模板代码<br><img src="/2017/12/02/java8/Lambda表达式.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//有效Lambda表达式</div><div class="line">(String s)-&gt; s.length()</div><div class="line">(Apple a)-&gt; a.weigth&gt;150</div><div class="line">(int x,int y)-&gt;&#123;</div><div class="line">   System.out.println(<span class="string">"result:"</span>);</div><div class="line">   System.out.println(x+y);</div><div class="line">&#125;</div><div class="line">()-&gt;42</div><div class="line">(Apple a1,Apple a2)-&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<p>Lambda语法：(parameters)-&gt;expression或者(parameters)-&gt;{statements;}</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>布尔表达式：(List<string> list)-&gt; list.isEmpty()<br>创建一个对象:()-&gt;new Apple(10):<br>消费一个对象:(Apple a)-&gt;{System.out.println(a.getWeight());}<br>从一个对象中选择或选取:(String s)-&gt; s.length()<br>组合两个值:(int a,int b)-&gt;a*b<br>三比较两个对象:(Apple a1,Apple a2)-&gt; a1.getWeight.compareTo(12.getWeight())</string></p>
<h2 id="在哪里以及如何使用Lambda"><a href="#在哪里以及如何使用Lambda" class="headerlink" title="在哪里以及如何使用Lambda"></a>在哪里以及如何使用Lambda</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只定义一个抽象方法的接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface Runnable&#123;</div><div class="line">  public void run();</div><div class="line">&#125;</div><div class="line">public interface Comparator&lt;T&gt;&#123;</div><div class="line">  public int compare(T o1,T o2);</div><div class="line">&#125;</div><div class="line">public interface Callable&lt;T&gt;&#123;</div><div class="line">  public T call();</div><div class="line">&#125;</div><div class="line">public interface PrivilegedAction&lt;V&gt;&#123;</div><div class="line">  V run();</div><div class="line">&#125;</div><div class="line">public interface ActionListener extends EventListener&#123;</div><div class="line">  void actionPerformed(ActionEvent e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化。</p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫做函数描述符。例如runnable接口是()-&gt;void.<br>如果你用@FunctionalInterface 定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。@FunctionalInter-face不是必需的，但对于为此设计的接口而言,使用它是比较好的做法。它就像是@Override标注表示方法被重写了.</p>
<h2 id="环绕执行模式"><a href="#环绕执行模式" class="headerlink" title="环绕执行模式"></a>环绕执行模式</h2><p>通过一个例子，看看在实践中如何利用Lambda和行为参数化来让代码更为灵活。资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static String processFile() throws IOException &#123;</div><div class="line">  try (BufferedReader br =new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">    <span class="built_in">return</span> br.readLine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="行为参数化-1"><a href="#行为参数化-1" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>你只能读文件的第一行。如果你想要返回头两行？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String result = processFile((BufferedReader br) -&gt;br.readLine() + br.readLine());</div></pre></td></tr></table></figure></p>
<h3 id="使用函数式接口传递行为"><a href="#使用函数式接口传递行为" class="headerlink" title="使用函数式接口传递行为"></a>使用函数式接口传递行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public class BufferedReaderProcessor&#123;</div><div class="line">  String process(BufferedReader reader) throws IOException;</div><div class="line">&#125;</div><div class="line">public static String processFile(BufferedReaderProcessor p) throws IOException&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="执行一个行为"><a href="#执行一个行为" class="headerlink" title="执行一个行为"></a>执行一个行为</h3><p>任何 BufferedReader -&gt; String 形式的Lambda都可以作为参数来传递，因为它们符合BufferedReaderProcessor 接口中定义的 process 方法的签名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static String processFile(BufferedReaderProcessor p) throws</div><div class="line">IOException &#123;</div><div class="line">  try (BufferedReader br =</div><div class="line">      new BufferedReader(new FileReader(<span class="string">"data.txt"</span>))) &#123;</div><div class="line">      <span class="built_in">return</span> p.process(br);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="传递Lambda"><a href="#传递Lambda" class="headerlink" title="传递Lambda"></a>传递Lambda</h3><p>现在你就可以通过传递不同的Lambda重用processFile方法，并以不同的方式处理文件了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String oneLine=processFile((BufferedReader br)-&gt; br.readLine());</div><div class="line">String twoLine= processFile((BufferedReader br)-&gt; br.readLine()+br.readLine());</div></pre></td></tr></table></figure></p>
<h2 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h2><p>java Api已经有几个函数式接口，比如Comparable、Runnable和Callable。</p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>java.util.function.Predicate<t> 接口定义了一个名叫test的抽象方法，它接受泛型T对象并返回一个boolean这恰恰和你先前创建的一样，现在就可以直接使用了。在你需要表示一个涉及类型T的布尔表达式时，就可以使用这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">    boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</div><div class="line"> List&lt;T&gt; results = new ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(s))&#123;</div><div class="line">       results.add(s);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> <span class="built_in">return</span> results;</div><div class="line">&#125;</div><div class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt;!s.isEmpty();</div><div class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings,nonEmptyStringPredicate);</div></pre></td></tr></table></figure></t></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>java.util.Consumer<t>定义了一个名为accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用<br>这个接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Consumer&lt;T&gt;&#123;</div><div class="line">   void accept(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; void <span class="keyword">for</span>Each(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123;</div><div class="line">   <span class="keyword">for</span>(T i: list)&#123;</div><div class="line">       c.accept(i);</div><div class="line">   &#125;</div><div class="line">&#125;  </div><div class="line"><span class="keyword">for</span>Each(Arrays.asList(1,2,3,4,5),(Integer i)-&gt;System.out.println(i));</div></pre></td></tr></table></figure></t></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>java.util.function.Function<t, r=""> 接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Function&lt;T,R&gt;&#123;</div><div class="line">  R apply(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list,Function&lt;T,R&gt; f)&#123;</div><div class="line">  List&lt;R&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(T s: list)&#123;</div><div class="line">    result.add(f.apply(s));</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">List&lt;Integer&gt; l = map(</div><div class="line">Arrays.asList(<span class="string">"lambdas"</span>,<span class="string">"in"</span>,<span class="string">"action"</span>),</div><div class="line">(String s) -&gt; s.length()</div><div class="line">);</div></pre></td></tr></table></figure></t,></p>
<p>Java类型要么是引用类型（比如Byte、Integer、Object、List），要么是原始类型（比如int、double、byte、char）。但是泛型（比如Consumer<t> 中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的.因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing）。相反的是拆箱操作。</t></p>
<h2 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h2><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>Lambda的类型是从使用Lambda的上下文推断。上下文中Lambda表达式的需要的类型称为目标类型。<br><img src="/2017/12/02/java8/Lambda类型检查.png" alt=""><br>首先，你要找出filter方法的声明。<br>第二，要求它是Predicate<apple>（目标类型）对象的第二个正式参数。<br>第三，Predicate<apple>是一个函数式接口，定义了一个叫作test的抽象方法<br>第四，test 方法描述了一个函数描述符，它可以接受一个 Apple ，并返回一个 boolean 。<br>最后，filter 的任何实际参数都必须匹配这个要求</apple></apple></p>
<h3 id="同样的Lambda，不同的接口"><a href="#同样的Lambda，不同的接口" class="headerlink" title="同样的Lambda，不同的接口"></a>同样的Lambda，不同的接口</h3><p>有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Callable&lt;Integer&gt; c = () -&gt; 42;</div><div class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; 42;</div></pre></td></tr></table></figure></p>
<p>类型检查<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为什么下面的代码不能编译</div><div class="line">Object o = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div><div class="line">答案：Lambda表达式的上下文是 Object （目标类型） 。但 Object 不是一个函数式接口。</div><div class="line">为了解决这个问题，你可以把目标类型改成 Runnable ，它的函数描述符是 () -&gt; void ：</div><div class="line">Runnable r = () -&gt; &#123;System.out.println(<span class="string">"Tricky example"</span>); &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。显示类型可读性更高<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div><div class="line">Comparator&lt;Apple&gt; c =</div><div class="line">(a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div></pre></td></tr></table></figure></p>
<p>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，或事实上是final 。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量 this） 例如，下面的代码无法编译，因为 portNumber变量被赋值两次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int portNumber = 1337;</div><div class="line">Runnable r = () -&gt; System.out.println(portNumber);</div><div class="line">portNumber = 31337</div></pre></td></tr></table></figure></p>
<p>为什么局部变量有这些限制。<br>第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。<br>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式.<br>闭包<br>你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。 这些变量必须是隐式最终的。 可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的） 。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
<h3 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h3><p>如果一个Lambda代表的只是直接调用这个方法，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。<br>当你需要使用方法引用时，目标引用放在分隔符 :: 前，方法的名称放在后面。例如，Apple::getWeight 就是引用了 Apple 类中定义的方法 getWeight，，不需要括号，因为你没有实际调用这个方法。<br>构建方法引用的方式：</p>
<ol>
<li>指向静态方法的引用(Integer.parseInt方法，写做Integer::parseInt)</li>
<li>指向任意实例化类型方法的方法引用，(String的length写做String::length)</li>
<li>指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放 Transaction 类型的对象，它支持实例方法getValue ，那么你就可以写 expensive-Transaction::getValue ）</li>
</ol>
<p>二种和第三种方法引用可能乍看起来有点儿晕。类似于 String::length 的第二种方法引用的思想就是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数。例如，Lambda表达式 (String s) -&gt; s.toUppeCase() 可以写作 String::toUpperCase。但第三种方法引用指的是，你在Lambda中调用一个已经存在的外部对象中的方法。例如，Lambda表达式()-&gt; expensiveTransaction.getValue() 可以写作expensiveTransaction::getValue。<br><img src="/2017/12/02/java8/lambda方法引用.png" alt=""></p>
<h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>你可以利用它的名称和关键字new来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。假设有一个构造函数没有参数，它适合Supplier的签名() -&gt; Apple。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//无参数的构造函数</div><div class="line">Supplier&lt;Apple&gt; c1=Apple::new;</div><div class="line">Apple a=c1.get();</div><div class="line">或者</div><div class="line">Supplier&lt;Apple&gt; c1=()-&gt;new Apple();</div><div class="line">//带参数的构造函数</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=Apple::new;</div><div class="line">等价于</div><div class="line">Function&lt;Integer,Apple&gt; <span class="keyword">function</span>=(weight)-&gt;new Apple(weight);</div><div class="line">Apple a=function.apply(110);</div><div class="line">//两个参数的构造函数</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=Apple::new;</div><div class="line">BiFunction&lt;String,Integer,Apple&gt; biFunction=(color,weight)-&gt;new Apple(color,weight);</div><div class="line">Apple a=biFunction.apply(<span class="string">"red"</span>,100);</div></pre></td></tr></table></figure></p>
<h2 id="Lambda和方法引用实战"><a href="#Lambda和方法引用实战" class="headerlink" title="Lambda和方法引用实战"></a>Lambda和方法引用实战</h2><h2 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h2><p>许多函数式接口，比如用<br>于传递Lambda表达式的 Comparator 、Function 和 Predicate 都提供了允许你进行复合的方法。可以让两个谓词之间做一个 or 操作，组合成一个更大的谓词。而且，你还可以让一个函数的结果成为另一个函数的输入。窍门在于，我们即将介绍的方法都是默认方法。</p>
<h3 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h3><h4 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h4><p>按照重量递减排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed());</div></pre></td></tr></table></figure></p>
<h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><p>按照重量递减排序,相同体重的苹果在根据国家排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry));</div></pre></td></tr></table></figure></p>
<h3 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h3><p>谓词接口包括三个接口:negate、and和or，可以让你重用已有的predicate来创建更复杂的谓词。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//苹果不是红的</div><div class="line">Predicate&lt;Apple&gt; notRedApple=redApple.negate();</div><div class="line">//苹果又红又重</div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApples=redApple.and(a-&gt;a.ggetWeight()&gt;150);</div><div class="line">//又红又重的苹果或者绿苹果,a.and(b).or(c),代表(a&amp;b)||c,从左到右确定优先级</div><div class="line">Predicate&lt;Apple&gt; redAndHeadvyOrGreen=redApple.and(a-&gt;a.getWeight()&gt;150).or(a-&gt;a.getColor().equals(<span class="string">"green"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p>可以把Function接口所代表的Lambda表达式复合，Function提供了andThen和compose两个默认方法，它们都返回一个Function的实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</div><div class="line">       Objects.requireNonNull(before);</div><div class="line">       <span class="built_in">return</span> (V v) -&gt; apply(before.apply(v));</div><div class="line">   &#125;</div><div class="line">default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</div><div class="line">     Objects.requireNonNull(after);</div><div class="line">     <span class="built_in">return</span> (T t) -&gt; after.apply(apply(t));</div><div class="line"> &#125;</div><div class="line">Function&lt;Integer, Integer&gt; f= x -&gt; x + 1;</div><div class="line">Function&lt;Integer, Integer&gt; g= x -&gt; x * 2;</div><div class="line">对于g(f(x))</div><div class="line">Function&lt;Integer,Integer&gt; h=f.andThen(g);</div><div class="line">Function&lt;Integer,Integer&gt; h=g.compose(f);</div><div class="line">int result=h.apply(1);</div></pre></td></tr></table></figure></p>
<p>用String表示一封信的文本转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Letter &#123;</div><div class="line">	public static String addHeader(String text) &#123;</div><div class="line">		<span class="built_in">return</span> <span class="string">"From Raoul, Mario and Alan: "</span> + text;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String addFooter(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text + <span class="string">" Kind regards"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String checkSpelling(String text) &#123;</div><div class="line">		<span class="built_in">return</span> text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</div><div class="line">	&#125;</div><div class="line">  Function&lt;String, String&gt; addHeader =Letter::addHeader;</div><div class="line">  Function&lt;String, String&gt; transformationPipeline=addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h1><h2 id="引入流"><a href="#引入流" class="headerlink" title="引入流"></a>引入流</h2><p>流允许你使用声明性方式处理数据集合，就现在来说，你可以把他们看成遍历数据集的高级迭代器，此外，流可以透明并行处理。下面两段代码都是用来返回低热量的菜肴名称的，并按照卡路里排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//java7</div><div class="line">List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  <span class="keyword">if</span>(d.getCalories() &lt; 400)&#123;</div><div class="line">   lowCaloricDishes.add(d);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() &#123;</div><div class="line">  public int compare(Dish d1, Dish d2)&#123;</div><div class="line">     <span class="built_in">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)&#123;</div><div class="line"> lowCaloricDishesName.add(d.getName());</div><div class="line">&#125;</div><div class="line">//java8</div><div class="line">menu.parallelStream()</div><div class="line">				.filter((Dish d) -&gt; d.getCalories() &lt; 400)</div><div class="line">				.sorted((Dish d1, Dish d2) -&gt; d1.getCalories()</div><div class="line">				- d2.getCalories()).map((Dish d)-&gt;d.name).collect(toList());</div></pre></td></tr></table></figure></p>
<h2 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h2><p>从支持数据处理操作的源生成的元素序列。集合强调的是数据，流强调的是计算</p>
<ul>
<li>元素序列–流提供了一个接口，可以访问特定元素类型的一组有序值。</li>
<li>源–流会使用提供数据的源，如集合、数组或输入输出资源。从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作–流的数据处理功能类似于数据库的操作，如filter、map、reduce、find、match、sort。流操作可以顺序执行，也可以并行执行。<br>流操作的特点</li>
<li>流水线–很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li>
<li>内部迭代–使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.parallelStream()</div><div class="line">				.filter((d) -&gt; d.getCalories() &lt; 500).limit(1)</div><div class="line">				.map((d) -&gt; d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/menu.png" alt=""></p>
<h2 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h2><p>java现有的集合概念和新的流概念都提供了接口，来代表元素型有序值的有序接口。所谓有序，就是我们一般按照顺序取用值，而不是随机取用。<br>集合和流的之间的差异在于什么时候进行计算。集合是内存的数据结构，它包含数据结构目前所有值–集合中每个元素都得算出来才能添加到集合里面。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）流在概念上是固定的数据结构，你不能添加或者删除元素，其元素是按需计算的。类比质数流，尽管质数有无穷多个，但是仅仅从流提取需要的值，这样实现会很简单。这是一种生产者消费者关系，换另外的角度来讲，流就像是个延迟创建的集合：只有在消费者要求的时候才会计算其值。而集合是急切创建的，以质数为例，要想创建一个包含所有质数的集合，那么集合永远创建不完，消费者永远获取不到这个集合。</p>
<h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h3><p>和迭代器类似，流只能遍历一次，遍历完后，这个流就已经被消费掉了，你可以从原始数据源那里在获得一个新的流重新遍历一遍。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; title = Arrays.asList(<span class="string">"Java8"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</div><div class="line">Stream&lt;String&gt; s = title.stream();</div><div class="line">s.forEach(System.out::println);</div><div class="line">//java.lang.IllegalStateException:流已被操作</div><div class="line">或关闭</div><div class="line">s.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h3><h4 id="用for-Each循环外部迭代"><a href="#用for-Each循环外部迭代" class="headerlink" title="用for-Each循环外部迭代"></a>用for-Each循环外部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</div><div class="line">  names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用背后迭代器"><a href="#用背后迭代器" class="headerlink" title="用背后迭代器"></a>用背后迭代器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line">Iterator&lt;String&gt; iterator = menu.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">   Dish d = iterator.next();</div><div class="line">   names.add(d.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="流：内部迭代"><a href="#流：内部迭代" class="headerlink" title="流：内部迭代"></a>流：内部迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names=menu.stream().map(d-&gt;d.getName()).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/迭代.png" alt=""></p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; name=menu.stream().filter(d-&gt;d.getCalories()&lt;300).map(d-&gt;g.getName())<span class="built_in">limit</span>(3).collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>filter、map、limit可以连成一条流水线，collect触发流水线执行并关闭。可以连起来的流操作称为中间操作，关闭流的操作称为终端操作。</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>诸如filter、sorted等中间操作会返回另外一个流，这让多个操作可以连接起来形成一个查询。除非流水线触发一个终端操作，否则中间操作不会执行任何处理。</p>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p>终端操作会从流的流水线生成结果，其结果是任何不是流的值，比如List、Integer甚至是void。</p>
<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>一个数据源来执行一个查询、一个中间操作链形成一条流的流水线、一个终端形成流水线，并能生成结果。<br>中间操作：<br>filter|Stream<t>|Predicate<t>|T-&gt;boolean<br>map|Stream<t>|Function<t,r>|T-&gt;R<br>limit|Stream<t><br>sorted|Stream<t>|Comparator<t>|(T,T)-&gt;int<br>distinct|Stream<t><br>终端操作<br>forEach 消费流中的每个元素并对其使用应用Lambda。这一操作返回void。<br>count 消费流中的元素个数，返回long<br>collect 把流规约成一个集合，比如list、map甚至是Integer。</t></t></t></t></t,r></t></t></t></p>
<h1 id="使用流-1"><a href="#使用流-1" class="headerlink" title="使用流"></a>使用流</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><p>用谓词筛选，筛选出各不相同的元素，忽略流中的头几个元素，或将流截短至指定长度</p>
<h3 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h3><p>streams支持filter方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.stream().filter(i-&gt;i%2==0).distinct().forEach(System.out::println);</div></pre></td></tr></table></figure>
<h3 id="截断流"><a href="#截断流" class="headerlink" title="截断流"></a>截断流</h3><p>limit(n)，会返回不超过n的流。</p>
<h3 id="跳过流"><a href="#跳过流" class="headerlink" title="跳过流"></a>跳过流</h3><p>skip(n),返回一个扔掉前n个元素的流。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p>
<h3 id="对流中每个元素应用函数"><a href="#对流中每个元素应用函数" class="headerlink" title="对流中每个元素应用函数"></a>对流中每个元素应用函数</h3><p>流支持 map 方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; wordLengths = words.stream().map(String::length).collect(toList());</div></pre></td></tr></table></figure></p>
<h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharacters =words.stream().map(w -&gt;w.split(<span class="string">""</span>)).</div><div class="line">flatMap(Arrays::stream).distinct().collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/flatmap.png" alt=""><br>给定两个数字列表，如何返回所有的数对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);</div><div class="line">List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);</div><div class="line">List&lt;int[]&gt; pairs=numbers1.stream().flatMap(i-&gt;number2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(asList);</div></pre></td></tr></table></figure></p>
<h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><h3 id="检查谓词至少符合一个元素"><a href="#检查谓词至少符合一个元素" class="headerlink" title="检查谓词至少符合一个元素"></a>检查谓词至少符合一个元素</h3><p>anyMatch可以回答流中是否有一个元素匹配给定谓词。nyMatch 方法返回一个boolean ，因此是一个终端操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu.stream().anyMatch(Dish::isVegetarian)&#123;</div><div class="line">  System.out.println(<span class="string">"The menu is (somewhat) vegetarian friendly!!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="检查谓词是否都符合所有元素"><a href="#检查谓词是否都符合所有元素" class="headerlink" title="检查谓词是否都符合所有元素"></a>检查谓词是否都符合所有元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean isHealthy = menu.stream().allMatch(d-&gt;d.getCalories() &lt; 1000);</div></pre></td></tr></table></figure>
<h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>确保流中没有任何元素与给定的谓词匹配.anyMatch 、 allMatch 和 noneMatch 这三个操作都用到了我们所谓的短路， 这就是大家熟悉的Java中 &amp;&amp; 和 || 运算符短路在流中的版本。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>isPresent() 将在 Optional 包含值的时候返回 true , 否则返回 false 。<br>ifPresent(Consumer<t> block) 会在值存在的时候执行给定的代码块。Consumer 函数式接口；它让你传递一个接收 T 类型参数，并返回 void 的Lambda<br>表达式。<br>T get() 会在值存在时返回值，否则抛出一个 NoSuchElement 异常。<br>T orElse(T other) 会在值存在时返回值，否则返回一个默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(Dish::isVegetarian).findAny().ifPresent(d-&gt;System.out.println(d.getName());</div></pre></td></tr></table></figure></t></p>
<h3 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h3><p>findFirst.如果你不关心返回的元素是哪个，请使用 findAny ，因为它在使用并行流<br>时限制较少。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree =someNumbers.stream()</div><div class="line">.map(x -&gt; x * x)</div><div class="line">.filter(x -&gt; x % 3 == 0)</div><div class="line">.findFirst();</div></pre></td></tr></table></figure></p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>你将看到如何把一个流中的元素组合起来，使用reduce操作来表达更复杂的查询</p>
<h3 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</div><div class="line">//reduce 还有一个重载的变体，它不接受初始值，但是会返回一个 Optional 对象：</div><div class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</div></pre></td></tr></table></figure>
<p>Integer 类现在有了一个静态的sum方法来对两个数求和，这恰好是我们想要的，用不着反复用Lambda写同一段代码了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int sum = numbers.stream().reduce(0, Integer::sum);</div></pre></td></tr></table></figure></p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; max=numbers.stream().reduce(Integer::max);</div><div class="line">Optional&lt;Integer&gt; min=numbers.stream().reduce(Integer::min);</div></pre></td></tr></table></figure>
<p>诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内部可变状态）。但诸如reduce、sum、max等操作需要内部状态来累积结果。<br><img src="/2017/12/02/java8/stream.png" alt=""></p>
<h2 id="数据值"><a href="#数据值" class="headerlink" title="数据值"></a>数据值</h2><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream 和LongStream ，分别将流中的元素特化为int、long和double ，从而避免了暗含的装箱成本。</p>
<h4 id="映射到数值"><a href="#映射到数值" class="headerlink" title="映射到数值"></a>映射到数值</h4><p>将流转换为特化版本的常用方法是 mapToInt 、mapToDouble和mapToLong.如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如max、min 、 average<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int calories = menu.stream().mapToInt(Dish::getCalories).sum();</div></pre></td></tr></table></figure></p>
<h4 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories)</div><div class="line">.max();</div></pre></td></tr></table></figure>
<h4 id="默认值OptionalInt"><a href="#默认值OptionalInt" class="headerlink" title="默认值OptionalInt"></a>默认值OptionalInt</h4><p>Optional 可以用Integer 、 String 等参考类型来参数化。对于三种原始流特化，也分别有一个 Optional 原始类型特化版本： OptionalInt 、 OptionalDouble 和 OptionalLong 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OptionalInt max=menu.stream().mapToInt(Dish::getCalories).max();</div><div class="line">int m=max.orElse(1);</div></pre></td></tr></table></figure></p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。 range 是不包含结束值的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntStream evenNumbers = IntStream.rangeClosed(1, 100)</div><div class="line">.filter(n -&gt; n % 2 == 0);</div><div class="line">System.out.println(evenNumbers.count());</div></pre></td></tr></table></figure></p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>);</div></pre></td></tr></table></figure>
<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int[] numbers=&#123;1,2,,3&#125;;</div><div class="line">int sum=Arrays.stream(numbers).sum();</div></pre></td></tr></table></figure>
<h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>java.nio.file.Files 中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines ，它会返回一个由指定文件中的各行构成的字符串流。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long uniqueWords=0;</div><div class="line">try&#123;</div><div class="line">  Stream&lt;String&gt; line=Files.lines(Paths.get(<span class="string">"data.txt"</span>),Charset.defaultCharset());</div><div class="line">  uniqueWords=line.flatMap(i-&gt;Arrays.stream(i.split(<span class="string">" "</span>))).distinct().count();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.iterator(0,n-&gt;n+2).limit.forEach(System.out::println);</div></pre></td></tr></table></figure>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</div></pre></td></tr></table></figure>
<h1 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency,List&lt;Transaction&gt;&gt; transactionsByCurrencies=transactions.stream().collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<h2 id="收集器简介"><a href="#收集器简介" class="headerlink" title="收集器简介"></a>收集器简介</h2><p>多级分组里函数式版本只要再加上一个收集器就可以轻松地增强功能了。</p>
<h3 id="收集器用做高级归约"><a href="#收集器用做高级归约" class="headerlink" title="收集器用做高级归约"></a>收集器用做高级归约</h3><p>Collector会对元素应用一个转换函数（很多时候是不体现任何效果的恒等转换例如toList），并将结果累积在一个数据结构中，从而产生这一过程的最终输出。Collectors实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，只要拿来用就可以了。最直接和最常用的收集器是 toList静态方法，它会把流中所有的元素收集到一个 List 中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Transaction&gt; transactions=transactionStream.collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<h3 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h3><p>Collectors提供的工厂方法groupingBy创建的收集器，主要提供三大功能：把流元素归约和汇总为一个值、元素分组、元素分区</p>
<h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long total=menu.stream().collect(counting());</div></pre></td></tr></table></figure>
<h3 id="寻找流中最小值和最大值"><a href="#寻找流中最小值和最大值" class="headerlink" title="寻找流中最小值和最大值"></a>寻找流中最小值和最大值</h3><p>Collectors.maxBy 和Collectors.minBy ，来计算流中的最大或最小值。这两个收集器接收一个Comparator 参数来比较流中的元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</div><div class="line">Comparator.comparingInt(Dish::getCalories);</div><div class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));</div></pre></td></tr></table></figure></p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</div><div class="line">double average=menu.stream().collect(averagingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics menuStatistics =</div><div class="line">menu.stream().collect(summarizingInt(Dish::getCalories));</div><div class="line">IntSummaryStatistics&#123;count=9, sum=4300, min=120,average=477.777778, max=800&#125;</div></pre></td></tr></table></figure></p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>joining 工厂方法返回的收集器会把对流中每一个对象应用 toString 方法得到的所有字符串连接成一个字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String shortMenu = menu.stream().collect(joining(<span class="string">", "</span>));</div></pre></td></tr></table></figure></p>
<h3 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//第一个参数是归约操作的起始值,第二个是转换函数，第三个是BinaryOperator，累积函数</div><div class="line">int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j));</div></pre></td></tr></table></figure>
<p>reduce 方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反， collect 方法的设计就是要改变容器，从而累积要输出的结果。使用 reduce 方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏 List 本身。果你想要线程安全，就需要每次分配一个新的 List ，而对象分配又会影响性能。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type,List&lt;Dish&gt;&gt; map=menu.stream().collect(groupingBy(Dish::getType));</div><div class="line">public enum CaloricLevel &#123;</div><div class="line">   DIET, NORMAL, FAT</div><div class="line">&#125;</div><div class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; caloricLevel = menu.stream().collect(</div><div class="line">groupingBy(</div><div class="line">dish-&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(dish.getCalories() &lt;= 400)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= 700)</div><div class="line">        <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125;));</div><div class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(groupingBy(</div><div class="line">Dish::getCalories,counting()</div><div class="line">));</div></pre></td></tr></table></figure>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</div><div class="line">menu.stream().collect(groupingBy(Dish::getType,groupingBy(dish -&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(dish.getCalories()&lt;=400)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.DIET;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories()&lt;=700)</div><div class="line">    <span class="built_in">return</span> CaloricLevel.NORMAL;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="built_in">return</span> CaloricLevel.FAT;</div><div class="line">&#125; )</div><div class="line">)</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>由一个谓词作为一个返回函数，分区函数返回一个布尔值，意味着分组Map的键值是boolean，最多可以分成两组-true是一组，false是一组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</div><div class="line">menu.stream().collect(partitioningBy(Dish::isVegetarian));</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/分区.png" alt=""></p>
<h2 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Collector&lt;T, A, R&gt; &#123;</div><div class="line">   Supplier&lt;A&gt; supplier();</div><div class="line">   BiConsumer&lt;A, T&gt; accumulator();</div><div class="line">   Function&lt;A, R&gt; finisher();</div><div class="line">   BinaryOperator&lt;A&gt; combiner();</div><div class="line">   Set&lt;Characteristics&gt; characteristics();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>T 是流中要收集的项目的泛型。<br>A 是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。<br>R 是收集操作得到的对象（通常但并不一定是集合）的类型</p>
<h3 id="理解collector接口声明的方法"><a href="#理解collector接口声明的方法" class="headerlink" title="理解collector接口声明的方法"></a>理解collector接口声明的方法</h3><h4 id="建立新的结果容器-supplier方法"><a href="#建立新的结果容器-supplier方法" class="headerlink" title="建立新的结果容器:supplier方法"></a>建立新的结果容器:supplier方法</h4><p>supplier 方法必须返回一个结果为空的 Supplier ，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> ()-&gt;new ArrayList&lt;T&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="把元素添加到结果容器-accumulator"><a href="#把元素添加到结果容器-accumulator" class="headerlink" title="把元素添加到结果容器:accumulator"></a>把元素添加到结果容器:accumulator</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BiConsumer&lt;List&lt;T&gt; ,T&gt;()&#123;</div><div class="line">  <span class="built_in">return</span> (list,item)-&gt;list.add(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="把结果应用最终转换：finisher"><a href="#把结果应用最终转换：finisher" class="headerlink" title="把结果应用最终转换：finisher"></a>把结果应用最终转换：finisher</h4><p>在遍历完流后， finisher 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line">     <span class="built_in">return</span> Function.identity();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/顺序归约.png" alt=""></p>
<h4 id="合并两个结果容器"><a href="#合并两个结果容器" class="headerlink" title="合并两个结果容器"></a>合并两个结果容器</h4><p>四个方法中的最后一个—— combiner 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line">   <span class="built_in">return</span> (list1, list2) -&gt; &#123;list1.addAll(list2);<span class="built_in">return</span> list1; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/02/java8/combine规约.png" alt=""></p>
<h4 id="characteristics方法"><a href="#characteristics方法" class="headerlink" title="characteristics方法"></a>characteristics方法</h4><p>characteristics 会返回一个不可变的 Characteristics 集合， 它定义<br>了收集器的行为:<br>UNORDERED ——归约结果不受流中项目的遍历和累积顺序的影响。<br>CONCURRENT —— accumulator 函数可以从多个线程同时调用，且该收集器可以并行归<br>约流。如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约<br>IDENTITY_FINISH ——这表明完成器方法返回的函数是一个恒等函数，可以跳过。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">import java.util.function.*;</div><div class="line">import java.util.stream.Collector;</div><div class="line">import static java.util.stream.Collector.Characteristics.*;</div><div class="line">public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt; &#123;</div><div class="line">@Override</div><div class="line">public Supplier&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">supplier</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> ArrayList::new;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BiConsumer&lt;List&lt;T&gt;, T&gt; <span class="function"><span class="title">accumulator</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> List::add;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; <span class="function"><span class="title">finisher</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Function.indentity();</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public BinaryOperator&lt;List&lt;T&gt;&gt; <span class="function"><span class="title">combiner</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> (list1, list2) -&gt; &#123;</div><div class="line">list1.addAll(list2);</div><div class="line"><span class="built_in">return</span> list1;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Set&lt;Characteristics&gt; <span class="function"><span class="title">characteristics</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> Collections.unmodifiableSet(EnumSet.of(</div><div class="line">IDENTITY_FINISH, CONCURRENT));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">List&lt;Dish&gt; dishes = menuStream.collect(</div><div class="line">new ToListCollector&lt;Dish&gt;()</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h1 id="并行数据处理与性能"><a href="#并行数据处理与性能" class="headerlink" title="并行数据处理与性能"></a>并行数据处理与性能</h1><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p>
<h2 id="并行流-1"><a href="#并行流-1" class="headerlink" title="并行流"></a>并行流</h2><p>可以通过对收集源调用parallelStream把集合转换成并行流。并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<h3 id="将顺序流转化成并行流"><a href="#将顺序流转化成并行流" class="headerlink" title="将顺序流转化成并行流"></a>将顺序流转化成并行流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static long sequentialSum(long n) &#123;</div><div class="line">		<span class="built_in">return</span> Stream.iterate(1L, i -&gt; i + 1)</div><div class="line">		.limit(n)</div><div class="line">		.reduce(0L, Long::sum);</div><div class="line">&#125;</div><div class="line">public static long parallelSum(long n) &#123;</div><div class="line">  	<span class="built_in">return</span> Stream.iterate(1L, i -&gt; i + 1)</div><div class="line">  	.limit(n)</div><div class="line">  	.parallel()</div><div class="line">  	.reduce(0L, Long::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并行流内部使用了默认的 ForkJoinPool，它默认的线程数量 就是 你 的 处 理器 数 量 ， 这个 值 是 由 Runtime.getRuntime().available-<br>Processors() 得到的。但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.<br>parallelism来改变线程池大小，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>,<span class="string">"12"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="测量流性能"><a href="#测量流性能" class="headerlink" title="测量流性能"></a>测量流性能</h3><p>真实的情况反而并发流反而更慢了，造成的原因有两点</p>
<ol>
<li>iterate生成的是装箱的对象，必须拆箱成数字才能求和.</li>
<li>我们很难把 iterate 分成多个独立块来并行执行;因为每次应用这个函数都要依赖前一次应用的结果.</li>
</ol>
<p>更有效的针对方案：<br>LongStream.rangeClosed 直接产生原始类型的 long 数字，没有装箱拆箱的开销。<br>LongStream.rangeClosed 会生成数字范围,很容易拆分为独立的小块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static long rangedSum(long n)&#123;</div><div class="line">		<span class="built_in">return</span> LongStream.rangeClosed(0, n).reduce(0L,Long::sum );</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="正确使用并行流"><a href="#正确使用并行流" class="headerlink" title="正确使用并行流"></a>正确使用并行流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static long sideEffectSum(long n) &#123;</div><div class="line">Accumulator accumulator = new Accumulator();</div><div class="line">LongStream.rangeClosed(1, n).forEach(accumulator::add);</div><div class="line"><span class="built_in">return</span> accumulator.total;</div><div class="line">&#125;</div><div class="line">public class Accumulator &#123;</div><div class="line">public long total = 0;</div><div class="line">public void add(long value) &#123; total += value; &#125;</div><div class="line">&#125;</div><div class="line">public static long sideEffectParallelSum(long n) &#123;</div><div class="line">Accumulator accumulator = new Accumulator();</div><div class="line">LongStream.rangeClosed(1,n).parallel().forEach(accumulator::add);</div><div class="line"><span class="built_in">return</span> accumulator.total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它在本质上就是顺序的。每次访问 total 都会出现数据竞争。如果你尝试用同步来修复，那就完全失去并行的意义了.这回方法的性能无关紧要了，唯一要紧的是每次执行都会返回不同的结果，都离正确值<br>50000005000000 差很远。这是由于多个线程在同时访问累加器，执行 total += value ，而这一句虽然看似简单，却不是一个原子操作。问题的根源在于，forEach 中调用的方法有副作用，它会改变多个线程共享的对象的可变状态。</p>
<h3 id="高效使用并行流"><a href="#高效使用并行流" class="headerlink" title="高效使用并行流"></a>高效使用并行流</h3><ul>
<li>如果有疑问，测量。</li>
<li>留意装箱。自动装箱和拆箱操作会大大降低性能。java8的原始类型流（IntStream、DoubleStream、LongStream）来避免这些操作。</li>
<li>有些操作本身在并行流上的性能比顺序流的性能要差。特别是findFirst和limit这些依赖于元素顺序。</li>
<li>还要考虑流操作流水线的总计算成本。N是要处理的元素总数，Q是一个元素通过流水线的大致成本，N*Q是对这个成本的粗略估计，Q值比较高时代表使用并行流性能好的可能性比较大。</li>
<li>对于较小的数据量，选择并行流不是个好的选择</li>
<li>要考虑流的数据结构是否容易分解ArrayList的拆分效率比LinkedList拆分效率高，后者需要遍历。</li>
<li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能</li>
<li>还要考虑终端操作中合并步骤的代价是大是小</li>
</ul>
<p><img src="/2017/12/02/java8/流拆分性能.png" alt=""></p>
<h2 id="分支-合并框架"><a href="#分支-合并框架" class="headerlink" title="分支/合并框架"></a>分支/合并框架</h2><h3 id="使用RecursiveTask"><a href="#使用RecursiveTask" class="headerlink" title="使用RecursiveTask"></a>使用RecursiveTask</h3><p><img src="/2017/12/02/java8/使用RecursiveTask.png" alt=""></p>
<h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题。在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool 中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。<br><img src="/2017/12/02/java8/工作窃取.png" alt=""></p>
<h2 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h2><p>Spliterator是Java8中加入的另一个新接口；这个名字代表“可分迭代器”（splitable iterator）。和 Iterator 一样，Spliterator 也用于遍历数据源中的元素，但它是为了并行执行而设计的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Spliterator&lt;T&gt; &#123;</div><div class="line"> boolean tryAdvance(Consumer&lt;? super T&gt; action);</div><div class="line"> Spliterator&lt;T&gt; trySplit();</div><div class="line"> long estimateSize();</div><div class="line"> int characteristics();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>T 是 Spliterator 遍历的元素的类型。tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。但trySplit是专为 Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator（由该方法返回），让它们两个并行处理。Spliterator还可通过estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值,也有助于让拆分均匀一点.<br><img src="/2017/12/02/java8/递归拆分.png" alt=""><br><img src="/2017/12/02/java8/spliterator.png" alt=""></p>
<h1 id="默认方法-1"><a href="#默认方法-1" class="headerlink" title="默认方法"></a>默认方法</h1><p>Java 8中的接口现在支持在声明方法的同时提供实现，这听起来让人惊讶！通过两种方式可以完成这种操作。其一，Java 8允许在接口内声明静态方法。其二，Java 8引入了一个新功能，叫默认方法，通过默认方法你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现。</p>
<h2 id="不断演进Api"><a href="#不断演进Api" class="headerlink" title="不断演进Api"></a>不断演进Api</h2><p>你的库中包含了一个 Resizable接口，它定义了一个简单的可缩放形状必须支持的很多方法， 比如： setHeight 、 setWidth 、getHeight 、 getWidth 以及 setAbsoluteSize 。 此外， 你还提供了几个额外的实现 （out-of-box implementation） ，如正方形、长方形。由于你的库非常流行，你的一些用户使用 Resizable 接口创建了他们自己感兴趣的实现，比如椭圆。<br>发布API几个月之后，你突然意识到 Resizable 接口遗漏了一些功能。比如，如果接口提供一个 setRelativeSize 方法，可以接受参数实现对形状的大小进行调整，那么接口的易用性会更好。你要考虑已经使用了你接口的用户，他们已经按照自身的需求实现了 Resizable 接口。</p>
<h3 id="初始版本的-API"><a href="#初始版本的-API" class="headerlink" title="初始版本的 API"></a>初始版本的 API</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Resizable extends Drawable&#123;</div><div class="line"> int getWidth();</div><div class="line"> int getHeight();</div><div class="line"> void <span class="built_in">set</span>Width(int width);</div><div class="line"> void <span class="built_in">set</span>Height(int height);</div><div class="line"> void <span class="built_in">set</span>AbsoluteSize(int width, int height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>void setRelativeSize(int wFactor, int hFactor);<br>二进制级的兼容性表示现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行。比如，为接口添加一个方法就是二进制级的兼容，这种方式下，如果新添加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。简单地说， 源代码级的兼容性表示引入变化之后， 现有的程序依然能成功编译通过。 比如，向接口添加新的方法就不是源码级的兼容， 因为遗留代码并没有实现新引入的方法， 所以它们无法顺利通过编译。最后，函数行为的兼容性表示变更发生之后，程序接受同样的输入能得到同样的结果。比如，为接口添加新的方法就是函数行为兼容的，因为新添加的方法在程序中并未被调用</p>
<h2 id="概述默认方法"><a href="#概述默认方法" class="headerlink" title="概述默认方法"></a>概述默认方法</h2><p>缺失的方法实现会作为接口的一部分由实现类继承（所以命名为默认实现） ，而无需由实现类提供。默认方法由 default 修饰符修饰，并像类中声明的其他方法一样包含方法体。</p>
<h2 id="默认方法的使用模式"><a href="#默认方法的使用模式" class="headerlink" title="默认方法的使用模式"></a>默认方法的使用模式</h2><h3 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h3><p>Java 8之前，由于用户通常不会使用该方法， remove 方法常被忽略。因此，实现 Interator 接口的类通常会为 remove 方法放置一个空的实现，这些都是些毫无用处的模板代码。 Iterator 接口就为remove方法提供了一个默认实现</p>
<h3 id="行为的多继承"><a href="#行为的多继承" class="headerlink" title="行为的多继承"></a>行为的多继承</h3><h2 id="解决冲突的规则"><a href="#解决冲突的规则" class="headerlink" title="解决冲突的规则"></a>解决冲突的规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface A &#123;</div><div class="line">default void <span class="function"><span class="title">hello</span></span>() &#123;</div><div class="line">  System.out.println(<span class="string">"Hello from A"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public interface B extends A &#123;</div><div class="line">default void <span class="function"><span class="title">hello</span></span>() &#123;</div><div class="line">System.out.println(<span class="string">"Hello from B"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class C implements B, A &#123;</div><div class="line">public static void main(String... args) &#123;</div><div class="line">new C().hello();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解决问题的三条规则"><a href="#解决问题的三条规则" class="headerlink" title="解决问题的三条规则"></a>解决问题的三条规则</h3><p>(1) 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。<br>(2) 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A ，那么 B 就比 A 更加具体。<br>(3) 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法<br>Java 8中引入了一种新的语法 X.super.m(…) ，其中 X 是你希望调用的 m<br>方法所在的父接口。如果你希望 C 使用来自于 B 的默认方法，它的调用方式看起来就如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class C implements B, A &#123;</div><div class="line">void <span class="function"><span class="title">hello</span></span>()&#123;</div><div class="line">B.super.hello();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;java8新特性：Lambda（匿名函数）、流、默认方法&lt;/p&gt;
&lt;h2 id=&quot;java中的函数&quot;&gt;&lt;a href=&quot;#j
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络通讯</title>
    <link href="http://yoursite.com/2017/12/01/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2017/12/01/高性能网络通讯/</id>
    <published>2017-12-01T01:31:02.000Z</published>
    <updated>2017-12-02T07:58:36.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的RPC调用问题"><a href="#简单的RPC调用问题" class="headerlink" title="简单的RPC调用问题"></a>简单的RPC调用问题</h2><h3 id="简单的远程调用"><a href="#简单的远程调用" class="headerlink" title="简单的远程调用"></a>简单的远程调用</h3><h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HelloService helloService=getProxy(HelloService.class,<span class="string">"127.0.0.1"</span>,<span class="string">"2580"</span>);</div><div class="line">System.out.println(helloService.sayHello(<span class="string">"hi, charles"</span>));</div><div class="line">Public &lt;T&gt; T getProxy(Class&lt;T&gt; interfaceClass, String host, int port)&#123;</div><div class="line"><span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new</div><div class="line">Class&lt;?&gt;[] &#123;interfaceClass&#125;,</div><div class="line">new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</div><div class="line">public Object invoke(Object proxy, Method method, Object[]</div><div class="line">arguments) throws Throwable &#123;</div><div class="line">Socket socket = new Socket(host, port);</div><div class="line">ObjectOutputStream output = new</div><div class="line">ObjectOutputStream(socket.getOutputStream());</div><div class="line">output.writeUTF(method.getName());</div><div class="line">output.writeObject(method.getParameterTypes());</div><div class="line">output.writeObject(arguments);</div><div class="line">ObjectInputStream input = new</div><div class="line">ObjectInputStream(socket.getInputStream());</div><div class="line"><span class="built_in">return</span> input.readObject();&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务器端调用"><a href="#服务器端调用" class="headerlink" title="服务器端调用"></a>服务器端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = new ServerSocket(port);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">   final Socket socket= server.accept();</div><div class="line">   new Thread(new Runnable(</div><div class="line">     public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">       ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</div><div class="line">       String methodName=input.readUTF();</div><div class="line">       Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();</div><div class="line">       Object[] arguments = (Object[])input.readObject();</div><div class="line">       ObjectOutputStream output = new</div><div class="line">       ObjectOutputStream(socket.getOutputStream());</div><div class="line">       Method method = service.getClass().getMethod(methodName,</div><div class="line">       parameterTypes);</div><div class="line">       Object result = method.invoke(service, arguments);</div><div class="line">       output.writeObject(result);</div><div class="line">     &#125;</div><div class="line">   )).start();</div><div class="line">&#125;</div><div class="line">Public String sysHello(String input)&#123;</div><div class="line">  <span class="built_in">return</span> input+<span class="string">":wellcome."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>网络传输方式：BIO</li>
<li>序列化方式：java序列化</li>
<li>线程模型：每次连接每线程</li>
<li>jdk代理</li>
</ol>
<h3 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h3><ol>
<li>协议；用什么数据格式进行传输。双方的约定</li>
<li>传输；用什么样的通道将数据发送给对方</li>
<li>线程；当接收到数据时，如何分发数据进行处理</li>
</ol>
<p><img src="/2017/12/01/高性能网络通讯/dataProtocol.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dataFlow.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dubbohead.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/datahead.png" alt=""></p>
<h3 id="data-Header"><a href="#data-Header" class="headerlink" title="data Header"></a>data Header</h3><p>magic code<br>多协议支持<br>Telnet<br>兼容<br>Long id vs id轮转<br>同步转异步<br>过期策略+id轮转<br>扩展header（拥塞控制&amp;response header增加服务器状态）</p>
<h4 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h4><p>并行发起多个请求，但只使用一个线程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxxService.find();</div><div class="line">Future&lt;Xxx&gt; future=RpcContext.getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/01/高性能网络通讯/asy.png" alt=""></p>
<h4 id="body序列化"><a href="#body序列化" class="headerlink" title="body序列化"></a>body序列化</h4><p>数据大小（传输速度）<br>序列化和反序列速度(CPU资源)<br>兼容性和易用性<br><img src="/2017/12/01/高性能网络通讯/序列化.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/size_dfl.png" alt=""></p>
<ul>
<li>远程服务调用时间主要消耗<br>网络开销主要是数据包大小<br>生产环境某应用容量测试</li>
<li>dubbo序列化主要优化目标：<br>减少数据包大小<br>提高序列化反序列化性能</li>
</ul>
<h2 id="IO-model"><a href="#IO-model" class="headerlink" title="IO model"></a>IO model</h2><p>IO Model、NIO、TCP选项、IRQ</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>IO请求分为两个阶段：<br>等待数据就绪；从内存缓存区拷贝数据到进程缓存区<br>Unix5种IO模型：<br>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO<br><img src="/2017/12/01/高性能网络通讯/io.png" alt=""></p>
<h3 id="NIO的好处"><a href="#NIO的好处" class="headerlink" title="NIO的好处"></a>NIO的好处</h3><ul>
<li>事件驱动模型，避免多线程和单线程处理多任务。</li>
<li>IO读写不再阻塞，而是返回0.</li>
<li>基于block的传输，比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了java网络应用的可伸缩性和实用性</li>
</ul>
<h3 id="NIO-reactor模式"><a href="#NIO-reactor模式" class="headerlink" title="NIO reactor模式"></a>NIO reactor模式</h3><ul>
<li>NIO网络框架典型模式</li>
<li>核心组件<br>同步事件多路复用器(event loop 事件分离)<br>分发器（事件派发，可以多线程）<br>请求处理（事件处理，业务代码）</li>
<li>mina netty都是此模式的实现</li>
</ul>
<p><img src="/2017/12/01/高性能网络通讯/reactor.png" alt=""></p>
<h3 id="NIO优化-TCP选项"><a href="#NIO优化-TCP选项" class="headerlink" title="NIO优化-TCP选项"></a>NIO优化-TCP选项</h3><p>合理设置tcp/ip在某些时候可以起到显著的效果</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><ul>
<li>Socket缓冲区至少应该是连接的MSS的四倍，MSS=MTU+40，一般以太网的MTU等于1500字节，MSS：最大分段大小，MTU：最大传输单元</li>
<li>在以太网上4k是不够的，增加到16k，吞吐量增加40%</li>
<li>对于一次性发送大量数据的应用，增加发送缓冲区到48k、64k才是可能唯一有效提高性能的方式。为了最大化性能，发送缓冲区可能至少要跟BDP（带宽延迟乘积）一样大小。</li>
<li>对于大量接收数据的应用，提高接收缓冲区，能减少发送端的阻塞。</li>
<li>如果应用既发送大量数据，也接收大量数据，recvbuffer和send buffer应该同时增加</li>
</ul>
<h3 id="带宽延迟乘积–BDP"><a href="#带宽延迟乘积–BDP" class="headerlink" title="带宽延迟乘积–BDP"></a>带宽延迟乘积–BDP</h3><p>为了优化TCP 吞吐量（假设为合理的无差错传输路径），发送端应该发送足够的数据包以填满发送端和接收端之间的逻辑管道。<br>逻辑管道的容量计算：BDP= 带宽x RTT</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>nagle算法通过将缓冲区的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。<br>实时性要求较高的应用，需要关闭算法，否则响应时间会受影响。</p>
<h3 id="SO-KeepAlive"><a href="#SO-KeepAlive" class="headerlink" title="SO_KeepAlive"></a>SO_KeepAlive</h3><p>Socket.setKeepAlive(boolean)<br>这是TCP层，而非HTTP协议的keep-alive概念,默认一般为false，用于TCP连接保活，默认间<br>隔2个小时.TCP心跳间隔是全局设置，建议在应用层做心跳</p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断此时都是运行在在硬件中断相应的cpu上。<br>如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>
<h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS (Receive Packet Steering) 基本原理<br>– 根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，<br>– 从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="线程模型内容"><a href="#线程模型内容" class="headerlink" title="线程模型内容"></a>线程模型内容</h3><ul>
<li>Reactor线程模型</li>
<li>序列化线程</li>
<li>业务线程派发策略</li>
</ul>
<h3 id="Reator单线程模型"><a href="#Reator单线程模型" class="headerlink" title="Reator单线程模型"></a>Reator单线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor单线程.png" alt=""></p>
<h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor多线程.png" alt=""></p>
<h3 id="线程派发策略"><a href="#线程派发策略" class="headerlink" title="线程派发策略"></a>线程派发策略</h3><p>五个事件：连接建立（Connection）、连接断开（Disconnection）、消息已接受(MessageReceived)、消息已发送（sent）、异常（Exception  caught）<br>派发策略：1.五个事件共享一个线程池；2.Connection和disconnect使用独立的线程池，size为1；3.全部不派发线程池，IO线程处理</p>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p>有这样一个模块<br>cpu 计算时间 18ms （ running ）<br>查询数据库，网络 io 时间 80ms （ waiting ）<br>解析结果 2ms 如果服务器 2CPU ，大家看看这里多少线程合适<br>充分利用cpu资源：<br>线程数量=100/20*2=10<br>从CPU角度而言<br>线程数量=（cpu时间+cpu等待时间）/cpu时间*cpu数量</p>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p>有这样一个模块：<br>线程同步锁 ( 数据库事务锁 )50ms<br>cpu 时间 18ms<br>查询数据库，网络 io 时间 80ms<br>解析结果 2ms  如果服务器有 2 个 CPU ，这个模块线程多少合适？<br>CPU计算为瓶颈，计算线程数量<br>线程数=(18 + 2 + 50 + 80) /20 *2 = 15<br>以线程同步锁为瓶颈，计算线程数<br>线程数=(50 + 18 + 2 + 80) / 50 * 1/1 = 3<br>公式一：<br>线程数量= （线程总时间/ 瓶颈资源时间）*  瓶颈资源的线程并行数<br>准确的讲<br>瓶颈资源的线程并行数= 瓶颈资源的总份数/ 单次请求占用瓶颈资源的份数<br>约束：<br>在计算的时候，对同一类资源的消耗时间进行合并<br>公式二：<br>QPS=1000/线程总时间*线程数<br>注意：如果线程数不够，则QPS减少。线程本身也要消耗资源，如果线程太多，同样QPS会下降。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>• 其他优化<br>– Lock free data structure（无锁数据结构）<br>– Buffer copy (Zero Copy)：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。一个关键的api是java.nio.channel.FileChannel的transferTo()方法。我们可以用transferTo()来把bytes直接从调用它的channel传输到另一个writable byte channel，中间不会使data经过应用程序。<br>– JVM GC tuning<br>– Context Switch 线程上下文切换<br>– 同步转异步<br>– JavassistProxy改进JDK proxy<br>  注意性能的短板效应，避免过度优化<br>– 优化的代价，通常是牺牲未来的可能性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的RPC调用问题&quot;&gt;&lt;a href=&quot;#简单的RPC调用问题&quot; class=&quot;headerlink&quot; title=&quot;简单的RPC调用问题&quot;&gt;&lt;/a&gt;简单的RPC调用问题&lt;/h2&gt;&lt;h3 id=&quot;简单的远程调用&quot;&gt;&lt;a href=&quot;#简单的远程调用&quot; class
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch深入搜索</title>
    <link href="http://yoursite.com/2017/11/27/es%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2017/11/27/es全文搜索/</id>
    <published>2017-11-27T02:55:25.000Z</published>
    <updated>2017-11-28T08:27:07.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><h2 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h2><h3 id="基于词项查询"><a href="#基于词项查询" class="headerlink" title="基于词项查询"></a>基于词项查询</h3><p>如 term 或 fuzzy 这样的底层查询不需要分析阶段，它们对单个词项进行操作。用 term 查询词项 Foo 只要在倒排索引中查找 准确词项 ，并且用 TF/IDF 算法为每个包含该词项的文档计算相关度评分score 。<br>记住 term 查询只对倒排索引的词项精确匹配，这点很重要，它不会对词的多样性进行处理（如， foo 或 FOO ）。这里，无须考虑词项是如何存入索引的。如果是将 [“Foo”,”Bar”] 索引存入一个不分析的（ not_analyzed ）包含精确值的字段，或者将 Foo Bar 索引到一个带有 whitespace 空格分析器的字段，两者的结果都会是在倒排索引中有 Foo 和 Bar 这两个词。</p>
<h3 id="基于全文查询"><a href="#基于全文查询" class="headerlink" title="基于全文查询"></a>基于全文查询</h3><p>像 match 或 query_string 这样的查询是高层查询，它们了解字段映射的信息：<br>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。<br>如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。<br>但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分。<br>当我们想要查询一个具有精确值的 not_analyzed 未分析字段之前， 需要考虑，是否真的采用评分查询，或者非评分查询会更好。<br>单词项查询通常可以用是、非这种二元问题表示，所以更适合用过滤， 而且这样做可以有效利用缓存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"constant_score"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">          <span class="string">"term"</span>:&#123;</div><div class="line">            <span class="string">"sex"</span>:<span class="string">"男"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h2><p>匹配查询match是核心查询，它是一个高级全文查询 ，这表示它既能处理全文字段，又能处理精确字段。</p>
<h3 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:<span class="string">"quick"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询步骤如下：</p>
<ol>
<li>检查字段类型；标题 title 字段是一个 string 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。</li>
<li>分析查询字符串；将查询的字符串quick传入标准分析器中，输出的结果是单个项 quick 。因为只有一个单词项，所以 match 查询执行的是单个底层 term 查询。</li>
<li>查找匹配文档；用 term 查询在倒排索引中查找 quick 然后获取一组包含该项的文档，本例的结果是文档：1、2 和 3 。</li>
<li>为每个文档评分；用 term 查询计算每个文档相关度评分score ，这是种将 词频（term frequency，即词 quick 在相关文档的 title 字段中出现的频率）和反向文档频率（inverse document frequency，即词 quick 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。<h3 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">        <span class="string">"title"</span>:<span class="string">"BROWN DOG"</span></div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//返回结果解释</div><div class="line">文档 4 最相关，因为它包含词 <span class="string">"brown"</span> 两次以及 <span class="string">"dog"</span> 一次。</div><div class="line">文档 2、3 同时包含 brown 和 dog 各一次，而且它们 title 字段的长度相同，所以具有相同的评分。</div><div class="line">文档 1 也能匹配，尽管它只有 brown 没有 dog 。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 match 查询必须查找两个词（ [“brown”,”dog”] ），它在内部实际上先执行两次 term 查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个 term 查询包入一个 bool 查询中。<br>以上示例告诉我们一个重要信息：即任何文档只要 title 字段里包含 指定词项中的至少一个词 就能匹配，被匹配的词项越多，文档就越相关。</p>
<h3 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h3><p>用 任意 查询词项匹配文档可能会导致结果中出现不相关的长尾。 这是种散弹式搜索。可能我们只想搜索包含 所有 词项的文档，也就是说，不去匹配 brown OR dog ，而通过匹配 brown AND dog 找到所有文档。<br>match 查询还可以接受 operator 操作符作为输入参数，默认情况下该操作符是 or 。我们可以将它修改成 and 让所有指定词项都必须匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:&#123;</div><div class="line">           <span class="string">"query"</span>: <span class="string">"brown dog"</span>,</div><div class="line">           <span class="string">"operator"</span>:<span class="string">"and"</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h3><p>在 所有 与 任意 间二选一有点过于非黑即白。 如果用户给定 5 个查询词项，想查找只包含其中 4 个的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。<br>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。<br>match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">        <span class="string">"query"</span>:<span class="string">"a brown dog"</span>,</div><div class="line">        <span class="string">"minimun_should_match"</span>:<span class="string">"75%"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当给定百分比的时候， minimum_should_match 会做合适的事情：在之前三词项的示例中， 75% 会自动被截断成 66.6% ，即三个里面两个词。无论这个值设置成什么，至少包含一个词项的文档才会被认为是匹配的。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>在 组合过滤器 中，我们讨论过如何使用 bool 过滤器通过 and 、 or 和 not 逻辑组合将多个过滤器进行组合。在查询中， bool 查询有类似的功能，只有一个重要的区别。<br>过滤器做二元判断：文档是否应该出现在结果中？但查询更精妙，它除了决定一个文档是否应该被包括在结果中，还会计算文档的 相关程度 。<br>与过滤器一样， bool 查询也可以接受 must 、 must_not 和 should 参数下的多个查询语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"must"</span>:     &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;,</div><div class="line">      <span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"lazy"</span>  &#125;&#125;,</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h3><p>以上的查询结果返回 title 字段包含词项 quick 但不包含 lazy 的任意文档。目前为止，这与 bool 过滤器的工作方式非常相似。<br>区别就在于两个 should 语句，也就是说：一个文档不必包含 brown 或 dog 这两个词项，但如果一旦包含，我们就认为它们更相关。<br>bool查询会为每个文档计算相关度评分，再将所有匹配must和should语句的分数score求和，最后除以must和should语句总数，must_not不会影响评分，只会将不想关的文档排除。</p>
<h3 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h3><p>所有 must 语句必须匹配，所有 must_not 语句都必须不匹配，但有多少 should 语句应该匹配呢？ 默认情况下，没有 should 语句是必须匹配的，只有一个例外：那就是当没有 must 语句的时候，至少有一个 should 语句必须匹配。<br>就像我们能控制 match 查询的精度 一样，我们可以通过 minimum_should_match 参数控制需要匹配的 should 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ],</div><div class="line">      <span class="string">"minimum_should_match"</span>: 2</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个查询结果会将所有满足以下条件的文档返回： title 字段包含 “brown” AND “fox” 、 “brown” AND “dog” 或 “fox” AND “dog” 。如果有文档包含所有三个条件，它会比只包含两个的文档更相关。</p>
<h2 id="bool匹配"><a href="#bool匹配" class="headerlink" title="bool匹配"></a>bool匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">//以下两两是等价的</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown fox"</span>&#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//must</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>:    <span class="string">"brown fox"</span>,</div><div class="line">            <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"must"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>: <span class="string">"quick brown fox"</span>,</div><div class="line">            <span class="string">"minimum_should_match"</span>: <span class="string">"75%"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"minimum_should_match"</span>: 2</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询语句提升比重"><a href="#查询语句提升比重" class="headerlink" title="查询语句提升比重"></a>查询语句提升比重</h2><p>我们可以通过指定 boost 来控制任何查询语句的相对的权重， boost 的默认值为 1 ，大于 1 会提升一个语句的相对权重。<br>boost 参数被用来提升一个语句的相对权重（ boost 值大于 1 ）或降低相对权重（ boost 值处于 0 到 1 之间），但是这种提升或降低并不是线性的，换句话说，如果一个 boost 值为 2 ，并不能获得两倍的评分score 。<br>相反，新的评分score 会在应用权重提升之后被 归一化 ，每种类型的查询都有自己的归一算法，细节超出了本书的范围，所以不作介绍。简单的说，更高的 boost 值为我们带来更高的评分 score 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    <span class="string">"query"</span>: &#123;</div><div class="line">        <span class="string">"bool"</span>: &#123;</div><div class="line">            <span class="string">"must"</span>: &#123;</div><div class="line">                <span class="string">"match"</span>: &#123;  </div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>:    <span class="string">"full text search"</span>,</div><div class="line">                        <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"should"</span>: [</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Elasticsearch"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 3</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;,</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Lucene"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 2</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="控制分析"><a href="#控制分析" class="headerlink" title="控制分析"></a>控制分析</h2><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>在搜索时，顺序有些许不同：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>有时，在索引时和搜索时使用不同的分析器是合理的。 我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。<br>为了区分，Elasticsearch 也支持一个可选的 search_analyzer 映射，它仅会应用于搜索时（ analyzer 还用于索引时）。还有一个等价的 default_search 映射，用以指定索引层的默认配置。<br>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 search_analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default_search 的分析器，默认为索引设置中名为 default 的分析器，默认为standard 标准分析器</p>
<h2 id="被破坏的相关度！"><a href="#被破坏的相关度！" class="headerlink" title="被破坏的相关度！"></a>被破坏的相关度！</h2><p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。<br>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤： 用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。<br>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。<br>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。<br>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。 相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。<br>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。<br>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。<br>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。<br>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF。不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h1 id="多字段搜索"><a href="#多字段搜索" class="headerlink" title="多字段搜索"></a>多字段搜索</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html</a></p>
<h1 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html</a></p>
<h1 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a>控制相关度</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全文搜索&quot;&gt;&lt;a href=&quot;#全文搜索&quot; class=&quot;headerlink&quot; title=&quot;全文搜索&quot;&gt;&lt;/a&gt;全文搜索&lt;/h1&gt;&lt;h2 id=&quot;基于词项与基于全文&quot;&gt;&lt;a href=&quot;#基于词项与基于全文&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>dubbo_framework_extensions</title>
    <link href="http://yoursite.com/2017/11/27/dubbo-framework-extensions/"/>
    <id>http://yoursite.com/2017/11/27/dubbo-framework-extensions/</id>
    <published>2017-11-27T02:41:29.000Z</published>
    <updated>2017-11-30T03:31:12.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/27/dubbo-framework-extensions/do.png" alt="do"></p>
<h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><h3 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h3><p><img src="/2017/11/27/dubbo-framework-extensions/framework1.png" alt="do"><br><img src="/2017/11/27/dubbo-framework-extensions/extension.png" alt="do"></p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p><img src="/2017/11/27/dubbo-framework-extensions/modules.png" alt="do"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="IOC-amp-AOP"><a href="#IOC-amp-AOP" class="headerlink" title="IOC&amp;AOP"></a>IOC&amp;AOP</h3><p>对于扩展实现IOC依赖注入功能：<br>举例来说：接口A，实现者A1、A2。接口B，实现者B1、B2。<br>现在实现者A1含有setB()方法，会自动注入一个接口B的实现者，此时注入B1还是B2呢？都不是，而是注入一个动态生成的接口B的实现者B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能.对扩展采用装饰器模式进行功能增强，类似AOP实现的功能.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//IOC</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private LoadBalance loadbalance;</div><div class="line">   public void <span class="built_in">set</span>LoadBalance(LoadBalance loadbalance) &#123;</div><div class="line">       this.loadbalance = loadbalance;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">//AOP</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private Cluster cluster;</div><div class="line">   public XxxCluster(Cluster cluster) &#123;</div><div class="line">      this.cluster = cluster;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/27/dubbo-framework-extensions/protocol.png" alt="protocol"><br><img src="/2017/11/27/dubbo-framework-extensions/filter.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/proxyFactory.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/javassist.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/cluster.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/remoting.png" alt=""></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//Application shared</div><div class="line">&lt;dubbo:application name=<span class="string">"xxx"</span> /&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"127.0.0.1"</span> /&gt;</div><div class="line">//provider</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"7777"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> /&gt;</div><div class="line">//consumer</div><div class="line">&lt;dubbo:reference interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:consumer timeout /&gt;</div></pre></td></tr></table></figure>
<h3 id="config-type"><a href="#config-type" class="headerlink" title="config type"></a>config type</h3><ul>
<li>Service Identification<br>group<br>version<br>interface</li>
<li>Service Governance<br>deprecated<br>application</li>
<li>performance optimize<br>timeout<br>threads</li>
</ul>
<h3 id="config-Override"><a href="#config-Override" class="headerlink" title="config Override"></a>config Override</h3><p>method 继承 接口 继承缺失，消费者继承服务提供者</p>
<h3 id="编程配置"><a href="#编程配置" class="headerlink" title="编程配置"></a>编程配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServiceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“xxx”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– <span class="built_in">export</span>();</div><div class="line">• ReferenceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“yyy”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– get();</div></pre></td></tr></table></figure>
<h3 id="context-amp-trace"><a href="#context-amp-trace" class="headerlink" title="context&amp;trace"></a>context&amp;trace</h3><p><img src="/2017/11/27/dubbo-framework-extensions/context&amp;trace.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadLocal context</div><div class="line">RpcContext.getContext().getRemoteHost();</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>,<span class="string">"1"</span>);</div><div class="line">RpcContext.getContext().getAttachment(<span class="string">"index"</span>);</div><div class="line">like http cookie</div></pre></td></tr></table></figure></p>
<h3 id="GenericService"><a href="#GenericService" class="headerlink" title="GenericService"></a>GenericService</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// java interface</div><div class="line">MemberService memberService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">memberService.findPeople(memberId);</div><div class="line">//Generic interface POJO需要转化为map</div><div class="line">GenericService genericService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">genericService.invoke(<span class="string">"findPeople"</span>,new String[]&#123;<span class="string">"java.lang.String"</span>&#125;,new Object[]&#123;memberId&#125;);</div><div class="line">//java implement</div><div class="line">public class MemberServiceImpl implements MemberService&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//Generic implement</div><div class="line">public class MemberServiceImpl implement GenericService&#123;</div><div class="line">  public Object invoke(String method,String[] ptypes,Object[] args)&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="local-amp-mock"><a href="#local-amp-mock" class="headerlink" title="local&amp;mock"></a>local&amp;mock</h3><p><img src="/2017/11/27/dubbo-framework-extensions/mock.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dubbo://10.20.153.10?<span class="built_in">local</span>=<span class="literal">true</span>&amp;mock=<span class="literal">true</span></div><div class="line">Constructor:</div><div class="line">public XxxServiceLocal(XxxService xxxService)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public <span class="function"><span class="title">XxxServiceMock</span></span>()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/27/dubbo-framework-extensions/do.png&quot; alt=&quot;do&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;framework&quot;&gt;&lt;a href=&quot;#framework&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>dubbo功能介绍</title>
    <link href="http://yoursite.com/2017/11/24/dubbo%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/11/24/dubbo功能介绍/</id>
    <published>2017-11-24T14:53:33.000Z</published>
    <updated>2017-12-08T02:08:38.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo简要介绍"><a href="#dubbo简要介绍" class="headerlink" title="dubbo简要介绍"></a>dubbo简要介绍</h1><h2 id="dubbo是什么"><a href="#dubbo是什么" class="headerlink" title="dubbo是什么"></a>dubbo是什么</h2><p>它是分布式服务框架，高性能和透明化的RPC远程服务调用方案；SOA服务治理方案</p>
<h2 id="如何使用dubbo"><a href="#如何使用dubbo" class="headerlink" title="如何使用dubbo"></a>如何使用dubbo</h2><p>本地服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>远程服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxInterface"</span> ref=<span class="string">"xxxService"</span>&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span> interface=<span class="string">"xxxInterface"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="dubbo能做什么"><a href="#dubbo能做什么" class="headerlink" title="dubbo能做什么"></a>dubbo能做什么</h2><h3 id="透明化的远程调用"><a href="#透明化的远程调用" class="headerlink" title="透明化的远程调用"></a>透明化的远程调用</h3><p>就像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p>
<h3 id="软负载均衡和容错机制"><a href="#软负载均衡和容错机制" class="headerlink" title="软负载均衡和容错机制"></a>软负载均衡和容错机制</h3><p>可在内网替代F5等硬件负载均衡器</p>
<h3 id="服务自动注册与发现"><a href="#服务自动注册与发现" class="headerlink" title="服务自动注册与发现"></a>服务自动注册与发现</h3><p>不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加和删除服务提供者。</p>
<h2 id="dubbo基本原理"><a href="#dubbo基本原理" class="headerlink" title="dubbo基本原理"></a>dubbo基本原理</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本原理.png" alt="dubbo基本原理"></p>
<h2 id="dubbo-rpc基本功能"><a href="#dubbo-rpc基本功能" class="headerlink" title="dubbo rpc基本功能"></a>dubbo rpc基本功能</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本功能.png" alt="dubbo-rpc 基本功能"></p>
<h3 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h3><p>实际使用中发现服务器比消费者更清楚一个方法的执行时间和是否允许重试等信息，所以增加允许服务提供者为消费者设置缺省值，并采用继承风格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//服务提供者配置</div><div class="line">&lt;dubbo:service timeout=<span class="string">"3000"</span> retries=<span class="string">"0"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=3000&amp;retries=0</div><div class="line">服务提供者提供配置参考值</div><div class="line">//注册中心</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=4000&amp;retries=1</div><div class="line">注册中心可在服务治理过程中修改配置值，如果不修改则使用provider的配置值</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">""</span> interface=<span class="string">""</span> timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=5000&amp;retries=2</div><div class="line">服务消费者如果出现网络慢等因素，可再修改配置值，如果不修改使用前面的配置值</div></pre></td></tr></table></figure></p>
<h3 id="可编程配置"><a href="#可编程配置" class="headerlink" title="可编程配置"></a>可编程配置</h3><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 服务实现</div><div class="line">XxxService xxxService = new XxxServiceImpl();</div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"xxx"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务提供者协议配置</div><div class="line">ProviderConfig provider = new ProviderConfig();</div><div class="line">provider.setProtocol(<span class="string">"dubbo"</span>);</div><div class="line">provider.setPort(12345);</div><div class="line">provider.setThreads(200);</div><div class="line">// 服务提供者暴露服务配置</div><div class="line">ServiceConfig service = new ServiceConfig();</div><div class="line">service.setApplication(application);</div><div class="line">service.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">service.setProvider(provider); // 多个提供者可以用<span class="built_in">set</span>Providers()</div><div class="line">service.setInterfaceClass(XxxService.class);</div><div class="line">service.setRef(xxxService);</div><div class="line">service.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">service.export(); // 触发服务注册</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!--服务实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"com.alibaba.xxx.XxxServiceImpl"</span> /&gt;</div><div class="line">&lt;!--当前应用配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"morgan"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者协议配置 --&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> port=<span class="string">"12345"</span> threads=<span class="string">"200"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者暴露服务配置 --&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> ref=<span class="string">"xxxService"</span> /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"yyy"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务消费者缺省值配置</div><div class="line">ConsumerConfig consumer = new ConsumerConfig();</div><div class="line">consumer.setTimeout(5000);</div><div class="line">consumer.setRetries(2);</div><div class="line">// 引用远程服务</div><div class="line">ReferenceConfig reference = new ReferenceConfig();</div><div class="line">reference.setApplication(application);</div><div class="line">reference.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">reference.setConsumer(consumer);</div><div class="line">reference.setInterfaceClass(XxxService.class);</div><div class="line">reference.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">XxxService xxxService = reference.get(); // 获取远程xxxService代理</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!-- 当前应用信息配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"kylin"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务消费者缺省值配置 --&gt;</div><div class="line">&lt;dubbo:consumer timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">&lt;!-- 引用远程服务 --&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span></div><div class="line">interface=<span class="string">"com.alibaba.xxx.XxxService"</span> version=<span class="string">"1.0.0 /&gt;</span></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h3><p>当一个接口有不同实现，可以用group区分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;dubbo:service group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:service group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"fsService"</span> group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"mservice"</span> group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用<br>一般处理步骤<br>1）在低压力时间段，先升级一半提供者为新版本<br>2）再将所有消费者升级为新版本<br>3）然后将剩下的一半提供者升级为新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">服务提供者</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div><div class="line">服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="指定调用"><a href="#指定调用" class="headerlink" title="指定调用"></a>指定调用</h3><p>点对点直连/指定调用需求（开发/测试环境）。在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表。</p>
<ol>
<li><p>spring配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference interface=<span class="string">"com.alibaba.xxx.XxxService"</span> url=<span class="string">"dubbo://localhost:20890"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>java -D参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>映射文件方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">– java -Ddubbo.resolve.file=xxx.properties</div><div class="line">– com.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>路由方式<br>– 参数匹配 host、clssifier</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//对于所有调用com.foo.BarService接口的消费者，如果消费者的ip是<span class="string">"10.20.153.10"</span>，那么这个消费者将调用ip为<span class="string">"10.20.153.11"</span>的提供者，这样，通过动态配置注册中心的路由规则，就实现了动态指定某个提供者的需求。</div><div class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</div><div class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</div><div class="line">registry.register(URL.valueOf(<span class="string">"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule="</span>+ URL.encode(<span class="string">"http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11"</span>)));</div></pre></td></tr></table></figure>
</li>
<li><p>修改version<br>不推荐</p>
</li>
</ol>
<h3 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h3><p>共用注册中心，开发人员机器上的服务提供者被误调，影响其他开发人员（开发、测试环境）<br>场景：为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p><dubbo:registry register="false"><br><img src="/2017/11/24/dubbo功能介绍/只订阅结构.png" alt="只订阅"></dubbo:registry></p>
<h3 id="集群和容错"><a href="#集群和容错" class="headerlink" title="集群和容错"></a>集群和容错</h3><p><img src="/2017/11/24/dubbo功能介绍/集群容错.png" alt="集群容错"><br>将Directory中的多个Invoker伪装成一个Invoker, 对上层透明，包含集群的容错机制<br>Cluster接口定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SPI(FailoverCluster.NAME)</div><div class="line">public interface Cluster &#123;</div><div class="line">    @Adaptive</div><div class="line">    &lt;T&gt; Invoker&lt;T&gt;join(Directory&lt;T&gt; directory) throws RpcException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cluster可以看做是工厂类， 将目录directory下的invoker合并成一个统一的Invoker，根据不同集群策略的Cluster创建不同的Invoker我们来看下默认的失败转移，当出现失败重试其他服务的策略, 这个Cluster实现很简单就是创建FailoverCluseterInvoker对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FailoverCluster implements Cluster &#123;</div><div class="line">    public final static String NAME =<span class="string">"failover"</span>;</div><div class="line">    public&lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory)throws RpcException&#123;</div><div class="line">        <span class="built_in">return</span> new FailoverClusterInvoker&lt;T&gt;(directory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/集群方案.png" alt="集群方案"><br>1）AvailableCluster: 获取可用的调用。遍历所有Invokers判断Invoker.isAvalible,只要一个有为true直接调用返回，不管成不成功<br>2）BroadcastCluster: 广播调用。遍历所有Invokers, 逐个调用每个调用catch住异常不影响其他invoker调用<br>3）FailbackCluster: 失败自动恢复， 对于invoker调用失败， 后台记录失败请求，任务定时重发, 通常用于通知<br>4）FailfastCluster: 快速失败，只发起一次调用，失败立即保错，通常用于非幂等性操作<br>5）FailoverCluster: 失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟<br>（1）   目录服务directory.list(invocation) 列出方法的所有可调用服务<br>获取重试次数，默认重试两次<br>（2）   根据LoadBalance负载策略选择一个Invoker<br>（3）   执行invoker.invoke(invocation)调用<br>（4）   调用成功返回<br>调用失败小于重试次数，重新执行从3）步骤开始执行<br>       调用次数大于等于重试次数抛出调用失败异常<br>6）FailsafeCluster: 失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。<br>7）ForkingCluster: 并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。<br>8）  MergeableCluster: 分组聚合， 按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。<br>这个还蛮有意思，我们分析下是如何实现的<br>（1）   根据MERGE_KEY从url获取参数值<br>（2）   为空不需要merge， 正常调用<br>（3）   按group分组调用，将返回接口保存到集合中<br>（4）   获取MERGE_KEY如果是默认的话，获取默认merge策略，主要根据返回类型判断<br>（5）   如果不是，获取自定义的merge策略<br>（6）   Merge策略合并调用结果返回<br><img src="/2017/11/24/dubbo功能介绍/merge.png" alt="merge"><br>9）MockClusterWrapper: 具备调用mock功能是其他Cluster包装<br>获取url的MOCK_KEY属性<br>（1）   不存在直接调用其他cluster<br>（2）   存在值startsWith(“force”) 强制mock调用<br>（3）   存在值不是startsWith(“force”) 先正常调用， 出现异常在mock调用<br>集群模式的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:service cluster=<span class="string">"failsafe"</span> /&gt;    服务提供方</div><div class="line">&lt;dubbo:reference cluster=<span class="string">"failsafe"</span> /&gt;  服务消费方</div></pre></td></tr></table></figure></p>
<h3 id="多注册中心引用"><a href="#多注册中心引用" class="headerlink" title="多注册中心引用"></a>多注册中心引用</h3><p>解决CRM需同时调用中文站和国际站PC2相同接口相同版本服务的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">定义多个注册中心：</div><div class="line">&lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"172.29.63.18:9090"</span> /&gt;</div><div class="line">&lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"172.29.61.132:9090"</span> /&gt;</div><div class="line">不同注册中心使用不同引用：</div><div class="line">&lt;dubbo:reference id=<span class="string">"chinaXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"intlXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="graceful-shutdown"><a href="#graceful-shutdown" class="headerlink" title="graceful shutdown"></a>graceful shutdown</h3><p><img src="/2017/11/24/dubbo功能介绍/shutdown.png" alt="shutdown"></p>
<h2 id="dubbo-Rpc高级功能"><a href="#dubbo-Rpc高级功能" class="headerlink" title="dubbo-Rpc高级功能"></a>dubbo-Rpc高级功能</h2><p><img src="/2017/11/24/dubbo功能介绍/高级功能.png" alt="高级功能"></p>
<h3 id="telnet互操作"><a href="#telnet互操作" class="headerlink" title="telnet互操作"></a>telnet互操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\&gt; telnet localhost 20880</div><div class="line">dubbo&gt; <span class="built_in">help</span></div><div class="line">ls <span class="_">-l</span></div><div class="line">ps <span class="_">-l</span></div><div class="line">status <span class="_">-l</span></div><div class="line">trace XxxService 10</div><div class="line">count XxxService</div><div class="line">invoke XxxService.xxxMethod(args)</div><div class="line"><span class="built_in">log</span> 100</div></pre></td></tr></table></figure>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>泛接口调用方式主要用于客户端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过GenericService调用所有服务实现。所谓泛化调用是使用通用服务接口.GenericService来invoke需要调用的服务方法，这种设计无疑是可复用、可扩展之典范。 GenericService只有一个方法Object$invoke(String method,String[] parameterTypes,Object[] args)throwsGenericException;invoke接受三个参数，分别为方法名，参数类型组以及参数值组，其中参数类型和参数值一一对应.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> generic=<span class="string">"true"</span> /&gt;</div><div class="line">GenericService barService = (GenericService) applicationContext.getBean(<span class="string">"barService"</span>);</div><div class="line">Object result = barService.<span class="variable">$invoke</span>(<span class="string">"sayHello"</span>, new String[] &#123; <span class="string">"java.lang.String"</span> &#125;, new Object[] &#123; <span class="string">"World"</span> &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="显示回调"><a href="#显示回调" class="headerlink" title="显示回调"></a>显示回调</h3><p><img src="/2017/11/24/dubbo功能介绍/回调.png" alt="回调"><br>参数回调方式与调用本地callback或listener相同，只需要在Spring的配置文件中声明哪个参数是callback类型即可，Dubbo将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>并行发起多个请求，但只使用一个线程,基于NIO非阻塞实现并行调用，不用开启多线程，开销变小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:method name=<span class="string">"findXxx"</span> async=<span class="string">"true"</span> /&gt;</div><div class="line">xxxService.findXxx();//返回null</div><div class="line">Future&lt;Xxx&gt; future=RpcContext。getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/async.png" alt="async"></p>
<h3 id="框架事件"><a href="#框架事件" class="headerlink" title="框架事件"></a>框架事件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Dubbo:service … ondisconnected= xxx &gt;</div><div class="line">&lt;Dubbo:reference … ondisconnected =xxx&gt;</div></pre></td></tr></table></figure>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>在客户端执行部分代码，比如：<br>– 在客户端缓存已查询过的数据<br>– 当服务器端全部不可用时，伪造容错数据<br><img src="/2017/11/24/dubbo功能介绍/本地执行.png" alt="本地执行"></p>
<h3 id="隐式传参"><a href="#隐式传参" class="headerlink" title="隐式传参"></a>隐式传参</h3><p>隐式传参，比如：<br>– 验权扩展点需要携带一些用户凭证信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">• ThreadLocal Context</div><div class="line">– RpcContext.setAttachment(<span class="string">"password"</span>, <span class="string">"xxx"</span>);</div><div class="line">– RpcContext.getAttachment(<span class="string">"password"</span>);</div><div class="line"></div><div class="line">//Consumer</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"parm"</span>, <span class="string">"test"</span>+i);</div><div class="line">//server</div><div class="line">Map&lt;String, String&gt; attachments = RpcContext.getContext()</div><div class="line">               .getAttachments();</div><div class="line">String parm = attachments.get(<span class="string">"parm"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>注册中心路由<br>注册中心根据路由规则挑选服务提供者列表<br>RPC路由<br>根据类、方法、参数级别的路由规则<br>数据sharding<br>– 开发阶段的服务过滤(classifier)<br>– 可扩展的路由接口&amp;基于ScriptEngine的实现<br>• simpleEL<br>• Groovy ..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(invokers,invocation,context)&#123;</div><div class="line">var result = new java.util.ArrayList();</div><div class="line"><span class="keyword">if</span> (invokers.size()&gt;1 &amp;&amp;</div><div class="line">invocation.getMethodName() .equals(<span class="string">"method1"</span>)) &#123;</div><div class="line">result.add(invokers.get(0)) ;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">result.add(invokers.get(1)) ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;;</div><div class="line">route(invokers,invocation,context);</div></pre></td></tr></table></figure></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>actives:consumer并发数限制<br>executes:provider并发数限制<br>connections：consumer连接数限制<br>accept：provider连接数限制<br>短连接是连接上限，长连接则是启用的连接数<br>LeastActive LoadBalance:<br>调用并发数最少的provider，调节provider的并发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">并发控制</div><div class="line">限制com.foo.BarService的每个方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">限制com.foo.BarService的每个方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了actives，&lt;dubbo:reference&gt;优先，参见：配置的覆盖策略。</div><div class="line">Load Balance均衡：</div><div class="line">配置服务的客户端的loadbalance属性为leastactive，此Loadbalance会调用并发数最小的Provider（Consumer端并发数）。</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">连接控制</div><div class="line">限制服务器端接受的连接不能超过10个：（以连接在Server上，所以配置在Provider上）</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">限制客户端服务使用连接连接数：(如果是长连接，比如Dubbo协议，connections表示该服务对每个提供者建立的长连接数)</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了connections，&lt;dubbo:reference&gt;优先</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dubbo简要介绍&quot;&gt;&lt;a href=&quot;#dubbo简要介绍&quot; class=&quot;headerlink&quot; title=&quot;dubbo简要介绍&quot;&gt;&lt;/a&gt;dubbo简要介绍&lt;/h1&gt;&lt;h2 id=&quot;dubbo是什么&quot;&gt;&lt;a href=&quot;#dubbo是什么&quot; class=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch权威后续</title>
    <link href="http://yoursite.com/2017/11/15/elasticsearch%E6%9D%83%E5%A8%81%E5%90%8E%E7%BB%AD/"/>
    <id>http://yoursite.com/2017/11/15/elasticsearch权威后续/</id>
    <published>2017-11-15T13:44:09.000Z</published>
    <updated>2017-11-27T08:44:31.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式增删改查"><a href="#分布式增删改查" class="headerlink" title="分布式增删改查"></a>分布式增删改查</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard=<span class="built_in">hash</span>(routing)%number_of_primary_shards</div></pre></td></tr></table></figure>
<p>routing是一个字符串，默认是_id；这也就解释了主分片的数量只能在创建索引时定义且不能修改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档也就永远找不到了</p>
<h2 id="分片交互"><a href="#分片交互" class="headerlink" title="分片交互"></a>分片交互</h2><p>我们能够发送请求给集群中任意一个节点。每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。下面的例子中，我们将发送所有请求给 Node 1  ，这个节点我们将会称之为请求节点</p>
<h2 id="新建、索引、删除文档"><a href="#新建、索引、删除文档" class="headerlink" title="新建、索引、删除文档"></a>新建、索引、删除文档</h2><p>新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。<br>罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：</p>
<ul>
<li>客户端给Node1发送新建、索引或删除请求。</li>
<li>节点使用文档的_id  确定文档属于分片0。它转发请求到 Node3，分片0位于这个节点上</li>
<li>Node3在主分片上执行请求，如果成功，它转发请求到相应的位于 Node1和 Node2的复制节点上当所有的复制节点报告成功,Node 3报告成功到请求的节点，请求的节点再报告给客户端。客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</li>
</ul>
<h3 id="replication（注意在ElasticSearch-5-0开始被废弃）"><a href="#replication（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="replication（注意在ElasticSearch 5.0开始被废弃）"></a>replication（注意在ElasticSearch 5.0开始被废弃）</h3><p>复制默认的值是 sync。这将导致主分片得到复制分片的成功响应后才返回。<br>如果你设置 replication为 async，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。</p>
<h3 id="consistency（注意在ElasticSearch-5-0开始被废弃）"><a href="#consistency（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="consistency（注意在ElasticSearch 5.0开始被废弃）"></a>consistency（注意在ElasticSearch 5.0开始被废弃）</h3><p>默认主分片在尝试写入时需要<strong>规定数量(quorum)或过半的分片（可以是主节点或复制节点）可用。这是防止数据被写入到错的网络分区</strong>。规定的数量计算公式如下：<br>int( (primary + number_of_replicas) / 2 ) + 1<br>consistency允许的值为one（只有一个主分片），all（所有主分片和复制分片）或者默认的quorum或过半分片。<br>注意number_of_replicas是在索引中的的设置，用来定义复制分片的数量，而不是现在活动的复制节点的数量。如果你定义了索引有3个复制节点，那规定数量是：int( (primary + 3 replicas) / 2 ) + 1 = 3<br>但如果你只有2个节点，那你的活动分片不够规定数量，也就不能索引或删除任何文档。<br>注意: 新索引默认有1个复制分片，这意味着为了满足quorum的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在number_of_replicas大于一时才生效。</p>
<h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。默认等待一分钟。如果需要，你可以设置 timeout参数让它终止的更早： 100  表示100毫秒， 30s  表示30秒。</p>
<blockquote>
<p>新索引默认有 1  个复制分片，这意味着为了满足 quorum  的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在 number_of_replicas  大于一时才生效</p>
</blockquote>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><ol>
<li>客户端给Node1发送get请求。</li>
<li>节点使用文档的id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。此时，它转发请求到 Node2。</li>
<li>Node2返回endangered给Node1然后返回给客户端。</li>
</ol>
<p>对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本。可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol>
<li>客户端给Node1发送更新请求。</li>
<li>它转发请求到主分片所在节点Node3。</li>
<li>Node3从主分片检索出文档，修改source字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以retry_on_conflict设置的次数重复步骤3，都未成功则放弃。</li>
<li>如果 Node3成功更新文档，它同时转发文档的新版本到Node1和Node2上的复制节点以重建索引。当所有复制节点报告成功,Node3返回成功给请求节点，然后返回给客户端.<blockquote>
<p>当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本。记住这些修改转发到复制节点是异步的，它们并不能保证到达的顺序与发送相同。如果Elasticsearch转发的仅仅是修改请求，修改的顺序可能是错误的，那得到的就是个损坏的文档。</p>
</blockquote>
</li>
</ol>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget请求检索多个文档的顺序步骤：</p>
<ol>
<li>客户端向Node1发送mget请求。</li>
<li>Node1为每个分片构建一个多条数据检索请求，然后转发到这些请求所需的主分片或复制分片上。当所有回复被接收，Node1构建响应并返回给客户端</li>
</ol>
<p>bulk执行多个create、index、delete和update请求的顺序步骤：</p>
<ol>
<li>客户端向Node1发送bulk请求。</li>
<li>Node1为每个分片构建批量请求，然后转发到这些请求所需的主分片上。</li>
<li>主分片一个接一个的按序执行操作。当一个操作执行完，主分片转发新文档（或者删除部分）给对应的复制节点，然后执行下一个操作。复制节点为报告所有操作完成，节点报告给请求节点，请求节点整理响应并返回给客户端。</li>
</ol>
<p>这里我们可以解释bulk的格式，而不是包装成json格式请求：意味着我们需要解析JSON为数组（包括文档数据，可能非常大）、检查每个请求决定应该到哪个分片上、为每个分片创建一个请求的数组、序列化这些数组为内部传输格式、发送请求到每个分片。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><table>
<thead>
<tr>
<th>概念</th>
<th style="text-align:right">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mappings(映射)</td>
<td style="text-align:right">数据在每个字段中的解释说明</td>
</tr>
<tr>
<td>analysis(分析)</td>
<td style="text-align:right">全文是如何处理的可以被搜索的</td>
</tr>
<tr>
<td>领域特定语句查询(query DSL)</td>
<td style="text-align:right">Elasticsearch使用的灵活的、强大的查询语言</td>
</tr>
</tbody>
</table>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>没有指定任何的查询条件，只返回集群索引中的所有文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure></p>
<h2 id="多索引和多类别"><a href="#多索引和多类别" class="headerlink" title="多索引和多类别"></a>多索引和多类别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/_search  //在所有索引的所有类型中搜索</div><div class="line">/gb/_search //在索引gb的所有类型中搜索</div><div class="line">/gb,us/_search //在索引gb us的所有类型中搜索</div><div class="line">/g*,u*/_search //在索引g或u开头的所有类型中搜索</div><div class="line">/gb/user/_search //在索引 gb的类型user中搜索</div><div class="line">/gb,us/user,tweet/_search //在gb、us的user和tweet类型中搜索</div><div class="line">/_all/user,tweet/_search //在user和tweet类型中搜索</div></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>size默认为10 from默认为0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure></p>
<p>注意：现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长</p>
<h1 id="映射分析"><a href="#映射分析" class="headerlink" title="映射分析"></a>映射分析</h1><h2 id="确切值和全文文本"><a href="#确切值和全文文本" class="headerlink" title="确切值和全文文本"></a>确切值和全文文本</h2><p>确切值是确定的，正如它的名字一样。比如一个date或用户ID，也可以包含更多的字符串比如username或email地址。全文文本，从另一个角度来说是文本化的数据(常常以人类的语言书写)，比如一片推文(Twitter的文章)或邮件正文<br>确切值是很容易查询的，因为结果是二进制的 – 要么匹配，要么不匹配。</p>
<h2 id="分析和分析器"><a href="#分析和分析器" class="headerlink" title="分析和分析器"></a>分析和分析器</h2><p>分析(analysis)是这样一个过程：<br>首先，表征化一个文本块为适用于倒排索引单独的词(term)<br>然后标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><table>
<thead>
<tr>
<th>类型</th>
<th>标识的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
</tr>
<tr>
<td>whole number</td>
<td>byte、short、integer、long</td>
</tr>
<tr>
<td>floating point</td>
<td>float、double</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Date</td>
<td>date</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>field type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean:true,false</td>
<td>“boolean”</td>
</tr>
<tr>
<td>whole number:123</td>
<td>“long”</td>
</tr>
<tr>
<td>floating point:123.45</td>
<td>“double”</td>
</tr>
<tr>
<td>String:”123”</td>
<td>“string”</td>
</tr>
<tr>
<td>string valid date:”2016-05-01”</td>
<td>date”</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这意味着，如果你索引一个带引号的数字—— “123”  ，它将被映射为 “string”  类型，而不是 “long”  类型。然而，如果字段已经被映射为 “long”  类型，Elasticsearch将尝试转换字符串为long，并在转换失败时会抛出异常。</p>
</blockquote>
<h3 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get sjjhpt/_mapping/fwjbl</div></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>analyzed</td>
<td>首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。</td>
</tr>
<tr>
<td>not_analyzed</td>
<td>索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段</td>
</tr>
<tr>
<td>no</td>
<td>不索引这个字段。这个字段不能为搜索到</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="string">"userid"</span>:&#123;</div><div class="line">     <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">     <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line"></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其他简单类型——long、double、date等等——也接受index参数，但相应的值只能是 no和not_analyzed,它们的值不能被分析</p>
</blockquote>
<h3 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PUT /gb/_mapping/tweet</div><div class="line">&#123;</div><div class="line"><span class="string">"properties"</span> : &#123;</div><div class="line"><span class="string">"tag"</span> :&#123;</div><div class="line"><span class="string">"type"</span> : <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复合核心字段类型"><a href="#复合核心字段类型" class="headerlink" title="复合核心字段类型"></a>复合核心字段类型</h2><h3 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h3><p>数组：{ “tag”: [ “search”, “nosql” ]}<br>对于数组不需要特殊的映射。任何一个字段可以包含零个、一个或多个值，同样对于全文字段将被分析并产生多个词。这意味着数组中所有值必须为同一类型。你不能把日期和字符窜混合。如果你创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型。</p>
<h3 id="空字段"><a href="#空字段" class="headerlink" title="空字段"></a>空字段</h3><p>Lucene没法存放null值，所以一个null值的字段被认为是空字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"empty_string"</span>: <span class="string">""</span>,</div><div class="line"><span class="string">"null_value"</span>: null,</div><div class="line"><span class="string">"empty_array"</span>: [],</div><div class="line"><span class="string">"array_with_null_value"</span>: [ null ]</div></pre></td></tr></table></figure></p>
<h3 id="多层对象"><a href="#多层对象" class="headerlink" title="多层对象"></a>多层对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="string">"gb"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123;</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"user"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"id"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"gender"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"age"</span>: &#123; <span class="string">"type"</span>: <span class="string">"long"</span> &#125;,</div><div class="line">      <span class="string">"name"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"full"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"first"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"last"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;</div><div class="line">       &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多层对像user的first，我们需要制定他的完整路径，像”user.name.first”或者tweet.user.name.first，而对于lucene，我们不能检索user或者user.name,我们不能检索复杂的结构体.</p>
<h1 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h1><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 30,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结构化查询-1"><a href="#结构化查询-1" class="headerlink" title="结构化查询"></a>结构化查询</h2><p>使用结构化查询，你需要传递query参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: your_query_here</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">       <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询子句"><a href="#查询子句" class="headerlink" title="查询子句"></a>查询子句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> QUERY_NAME: &#123;</div><div class="line"> ARGUMENT: VALUE</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">  <span class="string">"match"</span>: &#123;</div><div class="line">  <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并多字句"><a href="#合并多字句" class="headerlink" title="合并多字句"></a>合并多字句</h3><p>复合子句(compound)用以合并其他的子句。bool子句允许你合并其他的合法子句，无论是must，must_not还是should<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"> <span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"spam"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#125;&#125;</div><div class="line">],</div><div class="line"><span class="string">"minimum_should_match"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>一条查询语句会计算每个文档与查询语句的相关性，会给出一个相关性评分_score并且按照相关性对匹配到的文档进行排序。这种评分方式非常适用于一个没有完全配置结果的全文本搜索。</p>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p>使用过滤语句得到的结果集 – 一个简单的文档列表，快速匹配运算并存入内存是十分方便的，每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。<br>查询语句不仅要查找相匹配的文档，还需要计算每个文档的相关性，所以一般来说查询语句要比过滤语句更耗时，并且查询结果也不可缓存。<br>原则上来说，使用查询语句做全文本搜索或其他需要进行相关性评分的时候，剩下的全部用过滤语句</p>
<h2 id="查询过滤语句"><a href="#查询过滤语句" class="headerlink" title="查询过滤语句"></a>查询过滤语句</h2><h3 id="term过滤"><a href="#term过滤" class="headerlink" title="term过滤"></a>term过滤</h3><p>term用于精确匹配哪些值，比如数字，日期，布尔值或not_analyzed的字符串(未经分析的文本数据类型)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="terms过滤"><a href="#terms过滤" class="headerlink" title="terms过滤"></a>terms过滤</h3><p>terms允许指定多个匹配条件.如果某个字段指定了多个值，那么文档需要一起去做匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"terms"</span>:&#123;</div><div class="line">      <span class="string">"jkbsf"</span>:[<span class="string">"test"</span>,<span class="string">"test1"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="range过滤"><a href="#range过滤" class="headerlink" title="range过滤"></a>range过滤</h3><p>用于查询范围<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"range"</span>:&#123;</div><div class="line">      <span class="string">"age"</span>:&#123;</div><div class="line">          <span class="string">"gte"</span>:10,</div><div class="line">          <span class="string">"lt"</span>:20</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gt：大于、gte:大于等于、lt:小于、lte：小于等于</p>
<h3 id="exists和missing过滤"><a href="#exists和missing过滤" class="headerlink" title="exists和missing过滤"></a>exists和missing过滤</h3><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"exists"</span>:   &#123;</div><div class="line">        <span class="string">"field"</span>:    <span class="string">"title"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="bool过滤"><a href="#bool过滤" class="headerlink" title="bool过滤"></a>bool过滤</h3><p>bool 过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含一下操作符：<br>must :: 多个查询条件的完全匹配,相当于 and。<br>must_not :: 多个查询条件的相反匹配，相当于 not。<br>should :: 至少有一个查询条件匹配, 相当于 or。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">        <span class="string">"must"</span>:     &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line">        <span class="string">"must_not"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>:    <span class="string">"spam"</span>  &#125;&#125;,</div><div class="line">        <span class="string">"should"</span>: [</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span>   &#125;&#125;,</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"unread"</span>:  <span class="literal">true</span>   &#125;&#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">### match查询</span></div><div class="line">match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它</div><div class="line">如果你使用  match  查询一个全文本字段，它会在真正查询之前用分析器先分析 match  一下查询字符</div><div class="line">``` bash</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"About Search"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 match下指定了一个确切值，在遇到数字，日期，布尔值或者 not_analyzed的字符串时，它将为你搜索你给定的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。</p>
</blockquote>
<h3 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"full text search"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询与bool过滤相似，用于合并多个查询子句。不同的是，bool过滤可以直接给出是否匹配成功，而bool查询要计算每一个查询子句的score（相关性分值）。<br>must  :: 查询指定文档一定要被包含。<br>must_not  :: 查询指定文档一定不要被包含。<br>should  :: 查询指定文档，有则可以为文档相关性加分。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"spam"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"range"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 如果bool查询下没有must子句，那至少应该有一个should子句。但是如果有must子句，那么没有should子句也可以进行查询。</p>
</blockquote>
<h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>查询语句和过滤语句可以放在各自的上下文中。在 ElasticSearch API 中我们会看到许多带有query或 filter的语句。这些语句既可以包含单条 query 语句，也可以包含一条 filter子句。换句话说，这些语句需要首先创建一个query或filter的上下文关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"filtered"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /gb/tweet/_validate/query</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span> : &#123;</div><div class="line"><span class="string">"match"</span> : <span class="string">"really powerful"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="字段值排序"><a href="#字段值排序" class="headerlink" title="字段值排序"></a>字段值排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="默认排序"><a href="#默认排序" class="headerlink" title="默认排序"></a>默认排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//默认以顺序排序，_score以倒序排序</div><div class="line"><span class="string">"sort"</span>: <span class="string">"number_of_children"</span></div></pre></td></tr></table></figure>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: [</div><div class="line">&#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</div></pre></td></tr></table></figure>
<h3 id="多值字段字符串排序"><a href="#多值字段字符串排序" class="headerlink" title="多值字段字符串排序"></a>多值字段字符串排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//改变前的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">//改变后的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span>,</div><div class="line"><span class="string">"fields"</span>: &#123;</div><div class="line"><span class="string">"raw"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//现在，在给数据重建索引后，我们既可以使用  tweet  字段进行全文本搜索，也可以用 tweet.raw  字段进行排序</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></div><div class="line">&#125;</div><div class="line">对analyzed字段进行强制排序会消耗大量内存</div></pre></td></tr></table></figure>
<h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><p>每个文档都有相关性评分，用一个相对的浮点数字段_score来表示,_score的评分越高，相关性越高.fuzzy查询会计算与关键词的拼写相似程度,terms查询会计算 找到的内容与关键词组成部分匹配的百分比，但是一般意义上我们说的全文本搜索是指计算内容与关键词的类似程度。<br>es的相似度算法被定义为TF/IDF,即检索词频率和反向文档频率，<br>检索词频率：检索词在该字段出现的频率；也就是出现频率越高，相关性越高。<br>反向文档频率：每个检索词在索引中出现的频率；频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低，即检验一个检索词在文档中的普遍重要性<br>字段长度准则：长度越长，相关度越低。<br>如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<h3 id="理解评分规则"><a href="#理解评分规则" class="headerlink" title="理解评分规则"></a>理解评分规则</h3><p>explain参数可以让返回结果添加一个_score评分的得来依据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /_search?explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Explain-Api"><a href="#Explain-Api" class="headerlink" title="Explain Api"></a>Explain Api</h3><p> explain  选项加到某一文档上时，它会告诉你为何这个文档会被匹配，以及一个文档为何没有被匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /us/tweet/12/_explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;,</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//response</div><div class="line"><span class="string">"failure to match filter: cache(user_id:[2 TO 2])"</span></div></pre></td></tr></table></figure></p>
<h2 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h2><p>为了提高排序效率，ElasticSearch 会将所有字段的值加载到内存中，这就叫做”数据字段”</p>
<blockquote>
<p>es将所有字段数据加载到内存中并不是匹配到的那部分数据,而是索引下所有文档中的值，包括所有类型</p>
</blockquote>
<p>将所有字段数据加载到内存中是因为从硬盘反向倒排索引是非常缓慢的。尽管你这次请求需要的是某些文档中的部分数据，但你下个请求却需要另外的数据，所以将所有字段数据一次性加载到内存中是十分必要的。<br>ElasticSearch中的字段数据常被应用到以下场景：</p>
<ol>
<li>对一个字段进行排序</li>
<li>对一个字段进行聚合</li>
<li>某些过滤，比如地理位置过滤</li>
<li>某些与字段相关的脚本计算<br>这会消耗掉很多内存，尤其是大量的字符串数据 – string字段可能包含很多不同的值，比如邮件内容。 值得庆幸的是，内存不足是可以通过横向扩展解决的，我们可以增加更多的节点到集群。<h1 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h1>一个CRUD操作只处理一个单独的文档。文档的唯一性由 _index  ,  _type  和 routing-value  （通常默认是该文档的 _id  ）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。但如果针对复杂的搜索模型，由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上）。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。搜索的执行过程分两个阶段，称为查询然后取回（query then fetch）<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2>在初始化查询阶段，查询被向索引中的每个分片或者副本广播，每个分片会在本地执行搜索并建立匹配文档的优先队列。<blockquote>
<p>优先队列<br>一个优先队列（priority queue is）只是一个存有前n个（top-n）匹配document的有序列表。这个优先队列的大小由分页参数from和size决定。例如，下面这个例子中的搜索请求要求优先队列要能够容纳100个document</p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 90,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询阶段包含以下三步：<br>1.客户端发送一个search给node3，node3创建一个from+size的空优先队列；<br>2.node3转发请求到索引中每个分片的原本或者副本，每个分片在本地执行这个查询并且将结果放到一个from+size的优先队列里；<br>3.每个分片返回documentid和它优先队列里所有document的排序值给协调节点node3.协调节点node3把这些值合并到自己的优先队列产生全局排列的结果<br>当一个搜索请求被发送到一个节点node时，这个节点就成了协调节点，这个节点工作是向所有相关的分片广播搜索请求并把他们的响应整合成全局的有序结果集。<br>第一步是向索引里的每个节点的分片副本广播请求。就像document的 GET  请求一样，搜索请求可以被每个分片的原本或任意副本处理。对于后续请求，协调节点会轮询所有的分片副本以分摊负载。<br>每一个分片在本地执行查询和建立一个长度为 from+size  的有序优先队列——这个长度意味着它自己的结果数量就足够满足全局的请求要求。分片返回一个轻量级的结果列表给协调节点。只包含documentID值和排序需要用到的值，例如 _score。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>分布式搜索取回阶段如下：<br>1.协调节点需要辨别哪个document需要取回，并且向相关分片发送GET请求。<br>2.每个分片加载document并根据需要丰富他，然后再将document返回给协调节点。<br>3.一旦所有的document都被取回，协调节点会将结果返回给客户端<br>分片加载document主体—— _source  field。如果需要，还会根据元数据丰富结果和高亮搜索片断。一旦协调节点收到所有结果，会将它们汇集到单一的回答响应里，这个响应将会返回给客户端。  </p>
<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>是机器人或者网络爬虫的行为。它们会持续不断地一页接着一页地获取页面直到服务器到底崩溃的边缘<br>查询然后取回过程虽然支持通过使用 from  和 size  参数进行分页，但是要在有限范围内（within limited）。还记得每个分片必须构造一个长度为 from+size  的优先队列吧，所有这些都要传回协调节点。这意味着协调节点要通过对 分片数量 * (from +size)  个document进行排序来找到正确的 size  个document。</p>
<h2 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h2><h3 id="preference（偏爱）"><a href="#preference（偏爱）" class="headerlink" title="preference（偏爱）"></a>preference（偏爱）</h3><p>preference  参数允许你控制使用哪个分片或节点来处理搜索请求。她接受如下一些参数<br>primary：搜索只在主分片执行搜索请求，副本不参与搜索；性能会打折扣，达不到性能的水平扩展。<br>_primary_first：优先在主分片执行，如果主分片挂掉，会在副本执行请求。<br>_local：搜索请求优先于在本地执行。<br>_only_node:xyz：只在xyz节点执行搜索。<br>_prefer_node:xyz：搜索请求优先在节点xyz执行。<br>_shards:2,3：搜索只在分片2、3执行，可以与_primary参数一起使用如：_shards:2,3;_primary<br>随机字符串：指定一个随机字符串，可以保证同样的请求，被分配到同样的副本上面，从而保证同一请求结果的稳定性。<br>结果震荡<br>想像一下，你正在按照 timestamp  字段来对你的结果排序，并且有两个document有相同的timestamp。由于搜索请求是在所有有效的分片副本间轮询的，这两个document可能在原始分片里是一种顺序，在副本分片里是另一种顺序.这就是被称为结果震荡（bouncing results）的问题：用户每次刷新页面，结果顺序会发生变化。避免这个问题方法是对于同一个用户总是使用同一个分片。方法就是使用一个随机字符串例如用户的会话ID（session ID）来设置 preference  参数</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。<br>timeout参数告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回。返回部分结果总比什么都没有好<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"timed_out"</span>: <span class="literal">true</span>, (1)</div><div class="line"><span class="string">"_shards"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: 5,</div><div class="line"><span class="string">"successful"</span>: 4,</div><div class="line"><span class="string">"failed"</span>: 1 (2)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>在搜索时，你可以指定一个或多个 routing  值来限制只搜索那些分片而不是搜索index里的全部分片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?routing=user_1,user2</div></pre></td></tr></table></figure></p>
<h3 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h3><p>默认的搜索类型是query_then_fetch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?search_type=count</div></pre></td></tr></table></figure></p>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>count（计数）搜索类型只有一个 query（查询）  的阶段。当不需要搜索结果只需要知道满足查询的document的数量时，可以使用这个查询类型。</p>
<h4 id="query-then-fetch-查询并且取回"><a href="#query-then-fetch-查询并且取回" class="headerlink" title="query_then_fetch 查询并且取回"></a>query_then_fetch 查询并且取回</h4><p>query_and_fetch（查询并且取回）  搜索类型将查询和取回阶段合并成一个步骤。这是一个内部优化选项，当搜索请求的目标只是一个分片时可以使用，例如指定了 routing（路由选择）  值时。虽然你可以手动选择使用这个搜索类型，但是这么做基本上不会有什么效果</p>
<h4 id="dfs-query-then-fetch-和-dfs-query-and-fetch"><a href="#dfs-query-then-fetch-和-dfs-query-and-fetch" class="headerlink" title="dfs_query_then_fetch 和 dfs_query_and_fetch"></a>dfs_query_then_fetch 和 dfs_query_and_fetch</h4><p>dfs  搜索类型有一个预查询的阶段，它会从全部相关的分片里取回项目频数来计算全局的项目频数。我们将在relevance-is-broken（相关性被破坏）里进一步讨论这个</p>
<h4 id="scan-扫描"><a href="#scan-扫描" class="headerlink" title="scan(扫描)"></a>scan(扫描)</h4><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API连在一起使用的，可以高效地取回巨大数量的结果。它是通过禁用排序来实现的</p>
<h2 id="扫描和滚屏"><a href="#扫描和滚屏" class="headerlink" title="扫描和滚屏"></a>扫描和滚屏</h2><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价。<br>为了使用scan-and-scroll（扫描和滚屏），需要执行一个搜索请求，将 search_type  设置成 scan  ，并且传递一个 scroll  参数来告诉Elasticsearch滚屏应该持续多长时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl -XGET <span class="string">'localhost:9200/twitter/tweet/_search?scroll=1m'</span> <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query": &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "title" : "elasticsearch"</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    size:1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个请求的应答没有包含任何命中的结果，但是包含了一个Base-64编码的 _scroll_id（滚屏id）  字符串。现在我们可以将 _scroll_id  传递给 _search/scroll  末端来获取第一批结果</div><div class="line">curl -XGET  'localhost:9200/_search/scroll<span class="string">'  -d'</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"scroll"</span> : <span class="string">"1m"</span>,</div><div class="line">    <span class="string">"scroll_id"</span> : <span class="string">"c2Nhbjs2OzM0NDg1ODpzRlBLc0FXNlNyNm5JWUc1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(1) 保持滚屏开启另一分钟。<br>(2)  _scroll_id  可以在body或者URL里传递，也可以被当做查询参数传递。注意，要再次指定 ?scroll=1m  。滚屏的终止时间会在我们每次执行滚屏请求时刷新，所以他只需要给我们足够的时间来处理<br>当前批次的结果而不是所有的匹配查询的document。<br>这个滚屏请求的应答包含了第一批次的结果。虽然指定了一个1000的size，但是获得了更多的document。当扫描时,size被应用到每一个分片上，所以我们在每个批次里最多或获得 size <em> number_of_primary_shards（size</em>主分片数）个document。</p>
<blockquote>
<p>滚屏请求也会返回一个新的_scroll_id  。每次做下一个滚屏请求时，必须传递前一次请求返回的_scroll_id  。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /_index</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"mappings"</span>:&#123;</div><div class="line">    <span class="string">"type_one"</span>:&#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>config/elasticsearch.yml,添加下面的配置来防止自动创建索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action.auto_create_index: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">number_of_shards 定义一个索引的主分片个数，默认值是 `5`。这个配置在索引创建后不能修改。</div><div class="line">number_of_replicas 每个主分片的复制分片个数，默认是 `1`。这个配置可以随时在活跃的索引上修改</div><div class="line">PUT /my_temp_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"number_of_shards"</span> : 1,</div><div class="line"><span class="string">"number_of_replicas"</span> : 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//修改</div><div class="line">PUT /my_temp_index/_settings</div><div class="line">&#123;</div><div class="line"><span class="string">"number_of_replicas"</span>: 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置分词器"><a href="#配置分词器" class="headerlink" title="配置分词器"></a>配置分词器</h2><p>standard分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了这几点<br>standard  分词器，在词层级上分割输入的文本。<br>standard  表征过滤器，被设计用来整理分词器触发的所有表征（但是目前什么都没做）。<br>lowercase  表征过滤器，将所有表征转换为小写。<br>stop  表征过滤器，删除所有可能会造成搜索歧义的停用词，如a、the、and、is  。</p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>字符过滤器、分词器、表征过滤器</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>字符过滤器是让字符串在被分词前变得更加“整洁”。例如，如果我们的文本是 HTML 格式，它可能会包含一些我们不想被索引的 HTML 标签，诸如</p><p>或<div>。我们可以使用html_strip字符过滤器 来删除所有的HTML标签，并且将HTML实体转换成对应的 Unicode字符，比如将&Aacute;  转成Á。一个分析器可能包含零到多个字符过滤器</div></p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>一个分析器必须包含一个分词器。分词器将字符串分割成单独的词（terms）或表征（tokens）。standard分析器使用standard分词器将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。</p>
<h3 id="表征过滤器"><a href="#表征过滤器" class="headerlink" title="表征过滤器"></a>表征过滤器</h3><p>表征过滤器可能修改，添加或删除表征。我们已经提过lowercase和stop表征过滤器，但是 Elasticsearch 中有更多的选择。</p>
<h3 id="创建自定义的分词器"><a href="#创建自定义的分词器" class="headerlink" title="创建自定义的分词器"></a>创建自定义的分词器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123; ... custom character filters ... &#125;,</div><div class="line"><span class="string">"tokenizer"</span>: &#123; ... custom tokenizers ... &#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; ... custom token filters ... &#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123; ... custom analyzers ... &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//实例</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123;</div><div class="line"><span class="string">"&amp;_to_and"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"mapping"</span>,</div><div class="line"><span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"my_stopwords"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"stop"</span>,</div><div class="line"><span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123;</div><div class="line"><span class="string">"my_analyzer"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"custom"</span>,</div><div class="line"><span class="string">"char_filter"</span>: [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</div><div class="line"><span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</div><div class="line"><span class="string">"filter"</span>: [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</div><div class="line">&#125;&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>除非我们告诉es在哪里使用，否则分析器不会起作用。我们可以通过下面的映射将它应用在一个string类型的字段上.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">PUT /_index/_mapping/_type</div><div class="line">&#123;</div><div class="line">  <span class="string">"properties"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">          <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">          <span class="string">"analyzer"</span>:<span class="string">"my_analyzer"</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">## 映射</span></div><div class="line">Lucene 中，一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换成多个值。Lucene 不关心这些值是字符串，数字或日期，所有的值都被当成不透明字节</div><div class="line"><span class="comment">### 预防类型陷阱</span></div><div class="line">想象一下我们的索引中有两种类型： blog_en  表示英语版的博客， blog_es  表示西班牙语版的博客。两种类型都有  title字段，但是其中一种类型使用  english  分析器，另一种使用  spanish  分析器。</div><div class="line">``` bash</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"The quick brown fox"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"blog_en.title"</span>, <span class="string">"blog_es.title"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>多个元数据字段，每一个都以下划线开头，例如  _type  ,  _id  和  _source<br>设置项，控制如何动态处理新的字段，例如analyzer,dynamic_date_formats和dynamic_templates  。其他设置，可以同时应用在根对象和其他object类型的字段上，例如enabled,dynamic和 include_in_all<br>属性重要有三个type、index、analyzer</p>
<h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>默认情况下，Elasticsearch 用 JSON 字符串来表示文档主体保存在  _source  字段中。像其他保存的字段一样,_source字段也会在写入硬盘前压缩<br>需要source的理由：</p>
<ol>
<li>搜索结果中能得到完整的文档 —— 不需要额外去别的数据源中查询文档</li>
<li>如果缺少_source字段，部分更新请求不会起作用</li>
<li>当你的映射有变化，而且你需要重新索引数据时，你可以直接在 Elasticsearch 中操作而不需要重新从别的数据源中取回数据</li>
<li>你可以从  _source  中通过  get  或  search  请求取回部分字段，而不是整个文档</li>
<li>这样容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆ID中猜测他们的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//禁用<span class="built_in">source</span></div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_source"</span>: &#123;</div><div class="line"><span class="string">"enabled"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</div><div class="line"><span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="元数据-all字段"><a href="#元数据-all字段" class="headerlink" title="元数据:_all字段"></a>元数据:_all字段</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//当你还不清楚最终文档的结构时，可以将任何查询用于这个字段</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 禁用_all</div><div class="line">PUT /my_index/_mapping/my_type</div><div class="line">&#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过  include_in_all  选项可以控制字段是否要被包含在_all字段中，默认值是true。</p>
<h2 id="文档id"><a href="#文档id" class="headerlink" title="文档id"></a>文档id</h2><p>文档唯一标识由_index、_type、_id、_uid组成</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>它通过动态映射来确定字段的数据类型且自动将该字段加到类型映射中，通过dynamic设置来控制这些行为，它接受下面几个选项true：自动添加字段（默认）、false：忽略字段、strict：当遇到未知字段时抛出异常<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic"</span>: <span class="string">"strict"</span>, &lt;1&gt;</div><div class="line"><span class="string">"properties"</span>: &#123;</div><div class="line"><span class="string">"title"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</div><div class="line"><span class="string">"stash"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line"><span class="string">"dynamic"</span>: <span class="literal">true</span> &lt;2&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断字符串为日期的规则可以通过dynamic_date_formats配置来修改</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用dynamic_templates，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//es  : 字段名以  _es  结尾需要使用spanish分析器 ;en:所有其他字段使用english分析器。</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic_templates"</span>: [</div><div class="line">自定义动态索引</div><div class="line">日期检测</div><div class="line">动态模板</div><div class="line">&#123; <span class="string">"es"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*_es"</span>, &lt;1&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"spanish"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"en"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*"</span>, &lt;2&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="默认映射"><a href="#默认映射" class="headerlink" title="默认映射"></a>默认映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"_default_"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"blog"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><p>_source字段的一个最大的好处是你已经在 Elasticsearch 中有了完整的文档，你不再需要从数据库中重建你的索引。你可以在同一时间执行多个重新索引的任务，但是你显然不愿意它们的结果有重叠。所以，可以将重建大索引的任务通过日期或时间戳字段拆分成较小的任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"range"</span>: &#123;</div><div class="line"><span class="string">"date"</span>: &#123;</div><div class="line"><span class="string">"gte"</span>: <span class="string">"2014-01-01"</span>,</div><div class="line"><span class="string">"lt"</span>: <span class="string">"2014-02-01"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"size"</span>: 1000</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建一个索引  my_index_v1  ，然后将别名  my_index  指向它</div><div class="line">PUT /my_index_v1 &lt;1&gt;</div><div class="line">PUT /my_index_v1/_alias/my_index &lt;2&gt;</div><div class="line">//你可以检测这个别名指向哪个索引</div><div class="line">GET /*/_alias/my_index</div><div class="line">//哪些别名指向这个索引</div><div class="line">GET /my_index_v1/_alias/*</div><div class="line">//别名可以指向多个索引，所以我们需要在新索引中添加别名的同时从旧索引中删除它</div><div class="line">POST /_aliases</div><div class="line">&#123;</div><div class="line"><span class="string">"actions"</span>: [</div><div class="line">&#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="深入分片"><a href="#深入分片" class="headerlink" title="深入分片"></a>深入分片</h1><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。<br>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：<br>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。<br>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h2 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h2><p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件<br>新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存，不时地, 缓存被提交</li>
<li>不时地, 缓存被 提交 ：<br>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。新的段被开启，让它包含的文档可见以被搜索。内存缓存被清空，等待接收新的文档。</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<h2 id="删除更新"><a href="#删除更新" class="headerlink" title="删除更新"></a>删除更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。<br>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。<br>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。<br>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。<br>但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<h3 id="refresh-api"><a href="#refresh-api" class="headerlink" title="refresh api"></a>refresh api</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST /_refresh //刷新所有索引</div><div class="line">POST /blogs/_refresh //刷新blogs索引</div><div class="line">//正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率</div><div class="line">PUT /my_logs</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>: &#123;</div><div class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> //每30秒刷新 my_logs 索引</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//当你在建立一个大索引时，可以关闭自动刷新</div><div class="line">PUT /my_logs/_settings</div><div class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125;</div></pre></td></tr></table></figure></p>
<h2 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h2><p>1.新的文档被添加到内存缓冲区并且被追加到了事务日志<br>2.刷新（refresh）完成后, 缓存被清空但是事务日志不会<br>3.事务日志不断积累文档<br>4.在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST /blogs/_flush //刷新（flush） blogs 索引</div><div class="line">POST /_flush?wait_for_ongoing //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</div></pre></td></tr></table></figure></p>
<h2 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h2><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。启动段合并不需要你做任何事。进行索引和搜索时会自动进行。步骤如下：</p>
<ol>
<li>两个提交了的段和一个未提交的段正在被合并到一个更大的段</li>
<li>一旦合并结束，老的段被删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</div><div class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索是查询包含内部结构的数据。日期、数字、时间都是结构化的，或者是结构化文本，比如蜡笔的颜色或者博客的标签。通过结构化搜索，你的查询结果始终是 是或非；是否应该属于集合。结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档</p>
<h2 id="查找准确的值"><a href="#查找准确的值" class="headerlink" title="查找准确的值"></a>查找准确的值</h2><p>对于准确值，你需要使用过滤器。过滤器的重要性在于它们非常的快。它们不计算相关性（避过所有计分阶段）而且很容易被缓存。<br>在5里filtered被去掉，放在bool里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"query"</span>:&#123;</div><div class="line">			<span class="string">"filter"</span>:&#123;</div><div class="line">				<span class="string">"terms"</span>:&#123;</div><div class="line">					<span class="string">"jkbsf"</span>:[<span class="string">"tyws-AddCaseTrial"</span>,<span class="string">"mrshjbs tyws-AddCaseTrial"</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SELECT document FROM products WHERE price = 20</div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;</div><div class="line"><span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合过滤"><a href="#组合过滤" class="headerlink" title="组合过滤"></a>组合过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">SELECT product</div><div class="line">FROM products</div><div class="line">WHERE (price = 20 OR productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</div><div class="line">AND (price != 30)</div><div class="line"></div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"bool"</span> : &#123;</div><div class="line"><span class="string">"should"</span> : [</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, &lt;2&gt;</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; &lt;2&gt;</div><div class="line">],</div><div class="line"><span class="string">"must_not"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; &lt;3&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嵌套布尔过滤器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT document</div><div class="line">FROM products</div><div class="line">WHERE productID = <span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">OR ( productID = <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">AND price = 30</div><div class="line"></div><div class="line">&#123;</div><div class="line">   <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"filtered"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">           <span class="string">"bool"</span>:&#123;</div><div class="line">             <span class="string">"should"</span>:[</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"term"</span>:&#123;</div><div class="line">                    <span class="string">"productID"</span>:<span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">                  &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"bool"</span>:&#123;</div><div class="line">                    <span class="string">"must"</span>:[</div><div class="line">                    &#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">                      &#125;</div><div class="line">                    &#125;,&#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"price"</span>: 30</div><div class="line">                      &#125;</div><div class="line">                    &#125;</div><div class="line">                    ]</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">             ]</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询多个准确值"><a href="#查询多个准确值" class="headerlink" title="查询多个准确值"></a>查询多个准确值</h2><p>terms过滤器是term过滤器的复数版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"terms"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"price"</span> : [20, 30]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="包含而不是相等"><a href="#包含而不是相等" class="headerlink" title="包含而不是相等"></a>包含而不是相等</h2><p>假如你有一个 term 过滤器  { “term” : { “tags” : “search” } }  ，它将匹配下面两个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>] &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>假如你真的需要完全匹配这种行为，最好是通过添加另一个字段来实现。在这个字段中，你索引原字段包含值的个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>], <span class="string">"tag_count"</span> : 1 &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="string">"tag_count"</span> : 2</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"filtered"</span>:&#123;</div><div class="line">      <span class="string">"filter"</span>:&#123;</div><div class="line">        <span class="string">"bool"</span>:&#123;</div><div class="line">          <span class="string">"must"</span>:[</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tags"</span>:<span class="string">"search"</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tag_count"</span>:1</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="范围过滤"><a href="#范围过滤" class="headerlink" title="范围过滤"></a>范围过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"price"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : 20,</div><div class="line"><span class="string">"lt"</span> : 40</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用于日期字段时,range过滤器支持日期数学操作。例如，我们想找到所有最近一个小时的文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"now-1h"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日期计算也能用于实际的日期，而不是仅仅是一个像 now 一样的占位符。只要在日期后加上双竖线  ||  ，就能使用日期数学表达式了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"2014-01-01 00:00:00"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"2014-01-01 00:00:00||+1M"</span> &lt;1&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>range  过滤器也可以用于字符串。字符串范围根据字典或字母顺序来计算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"title"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : <span class="string">"a"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"b"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字符串范围适用于一个基数较小的字段，一个唯一短语个数较少的字段。你的唯一短语数越多，搜索就越慢</p>
<h2 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h2><p>本质上来说null[]（空数组）和[null]是相等的。它们都不存在于倒排索引中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"exists"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"missing"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>它们的核心是一个字节集来表示哪些文档符合这个过滤器。Elasticsearch 主动缓存了这些字节集留作以后使用。一旦缓存后，当遇到相同的过滤时，这些字节集就可以被重用，而<br>不需要重新运算整个过滤。<br>缓存的字节集很“聪明”：他们会增量更新。你索引中添加了新的文档，只有这些新文档需要被添加到已存的字节集中，而不是一遍遍重新计算整个缓存的过滤器。过滤器和整个系统的其他部分一样是实时的，你不需要关心缓存的过期时间。<br>独立的过滤缓存<br>每个过滤器都被独立计算和缓存，而不管它们在哪里使用。如果两个不同的查询使用相同的过滤器，则会使用相同的字节集。同样，如果一个查询在多处使用同样的过滤器，只有一个字节集会被计算和重用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这两个过滤器相同，而且会使用同一个字节集</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: [</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;, &lt;1&gt;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"read"</span>: <span class="literal">false</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must_not"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125; &lt;1&gt;</div><div class="line">&#125;,</div><div class="line"><span class="string">"must"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"important"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤顺序"><a href="#过滤顺序" class="headerlink" title="过滤顺序"></a>过滤顺序</h2><p>在  bool  条件中过滤器的顺序对性能有很大的影响。更详细的过滤条件应该被放置在其他过滤器之前，以便在更早的排除更多的文档。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式增删改查&quot;&gt;&lt;a href=&quot;#分布式增删改查&quot; class=&quot;headerlink&quot; title=&quot;分布式增删改查&quot;&gt;&lt;/a&gt;分布式增删改查&lt;/h1&gt;&lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch数据</title>
    <link href="http://yoursite.com/2017/11/15/elasticSearch%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2017/11/15/elasticSearch数据/</id>
    <published>2017-11-15T05:41:31.000Z</published>
    <updated>2017-11-15T13:35:52.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档元数据如下<br>_index 文档存储的地方；_type文档代表的对象的类；_id 文档的唯一标识*</p>
<h3 id="index"><a href="#index" class="headerlink" title="_index"></a>_index</h3><p>索引(index)类似于关系型数据库里的”数据库”——它是我们存储和索引关联数据的地方。索引名必须是全部小写，不能以下划线开头，不能包含逗号.</p>
<h3 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h3><p>在Elasticsearch中，我们使用相同类型(type)的文档表示相同的”事物”，类似关系型数据库中的表，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引._type 的名字可以是大写或小写，不能包含下划线或逗号。</p>
<h3 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h3><p>唯一标识一个文档，如果不指定，es自动生成</p>
<h2 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h2><p>自动生成的id一般是22个字节长的uuid<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _index/_type/_id 或者 GET _index/_type/_id?pretty 美化字符串</div></pre></td></tr></table></figure>
<p>pretty:在任意的查询字符串中增加 pretty  参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。_source  字段不会被美化，它的样子与我们输入的一致。</p>
<h3 id="检索文档的一部分"><a href="#检索文档的一部分" class="headerlink" title="检索文档的一部分"></a>检索文档的一部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id?_source=field,filed</div></pre></td></tr></table></figure>
<h3 id="只获取元数据"><a href="#只获取元数据" class="headerlink" title="只获取元数据"></a>只获取元数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id/_source</div></pre></td></tr></table></figure>
<h3 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -i -XHEAD http://localhost:9200/website/blog/123</div></pre></td></tr></table></figure>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id //更新后version要改变</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE /_index/_type/_id</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>数据库在并发冲突时提供了悲观锁和乐观锁的机制，es提供的机制是乐观并发控制。每个文档都有个版本号，当修改时version加一，如果指定的version不是现在的就会失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//插入一行记录</div><div class="line">PUT /website/blog/1/_create</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//获取当前数据,可以知道当前版本是1</div><div class="line">GET /website/blog/1</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : <span class="string">"1"</span>,</div><div class="line"><span class="string">"_version"</span> : 1,</div><div class="line"><span class="string">"found"</span> : <span class="literal">true</span>,</div><div class="line"><span class="string">"_source"</span> : &#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//根据当前版本对数据进行修改</div><div class="line">PUT /website/blog/1?version=1</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//如果当前版本不是1则会失败</div></pre></td></tr></table></figure></p>
<h3 id="使用外部版本控制系统"><a href="#使用外部版本控制系统" class="headerlink" title="使用外部版本控制系统"></a>使用外部版本控制系统</h3><p>一种常见的结构是使用一些其他的数据库做为主数据库，然后使用Elasticsearch搜索数据，这意味着所有主数据库发生变化，就要将其拷贝到Elasticsearch中。如果有多个进程负责这些数据的同步，就会遇到上面提到的并发问题。如果主数据库有版本字段——或一些类似于 timestamp  等可以用于版本控制的字段——是你就可以在Elasticsearch的查询字符串后面添加 version_type=external  来使用这些版本号。版本号必须是整数，大于零小于 9.2e+18  ——Java中的正的 long  。<br>外部版本号与之前说的内部版本号在处理的时候有些不同。它不再检查 _version  是否与请求中指定的一致，而是检查是否小于指定的版本。如果请求成功，外部版本号就会被存储到 _version  中。外部版本号不仅在索引和删除请求中指定，也可以在创建(create)新文档中指定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/2?version=5&amp;version_type=external</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first external blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="更新文档-1"><a href="#更新文档-1" class="headerlink" title="更新文档"></a>更新文档</h2><p>update  请求表单接受一个局部文档参数 doc  ，它会合并到现有文档中——对象合并在一起，存在的标量字段被覆盖，新字段被添加。注：更新文档如果不存在，则会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"doc"</span> : &#123;</div><div class="line"><span class="string">"tags"</span> : [ <span class="string">"testing"</span> ],</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span></div><div class="line">&#125;</div><div class="line">//更新不存在的文档，如果有加一，没有初始化为1</div><div class="line">POST /website/pageviews/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更新和冲突"><a href="#更新和冲突" class="headerlink" title="更新和冲突"></a>更新和冲突</h3><p>这些可以通过 retry_on_conflict  参数设置重试次数来自动完成，这样 update  操作将会在发生错误前重试——这个值默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /website/pageviews/1/_update?retry_on_conflict=5</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h2><p>检索多个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : 2</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"pageviews"</span>,</div><div class="line"><span class="string">"_id"</span> : 1,</div><div class="line"><span class="string">"_source"</span>: <span class="string">"views"</span></div><div class="line">&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果你想检索的文档在同一个 _index  中（甚至在同一个 _type  中），你就可以在URL中定义一个默认的 /_index  或者 /_index/_type  </div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123; <span class="string">"_id"</span> : 2 &#125;,</div><div class="line">&#123; <span class="string">"_type"</span> : <span class="string">"pageviews"</span>, <span class="string">"_id"</span> : 1 &#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果所有文档具有相同 _index  和 _type  ，你可以通过简单的 ids  数组来代替完整的 docs 数组</div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"ids"</span> : [ <span class="string">"2"</span>, <span class="string">"1"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><p>bulk  API允许我们使用单一请求来实现多个文档的 create  、 index  、 update  或 delete  。这对索引类似于日志活动这样的数据流非常有用，它们可以以成百上千的数据为一个批次按序进行索引。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div></pre></td></tr></table></figure></p>
<p>注意：1.每行必须以 “\n”  符号结尾，包括最后一行。这些都是作为每行有效的分离而做的标记；2.每一行的数据不能包含未被转义的换行符，它们会干扰分析——这意味着JSON不能被美化打印<br>action: create（创建、若存在则报错）、index（创建或替换）、update（更新）、delete（删除文档）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /_bulk</div><div class="line">&#123; <span class="string">"delete"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125; &lt;1&gt;</div><div class="line">&#123; <span class="string">"create"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My first blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My second blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"update"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span>, <span class="string">"_retry_on_conflict"</span> : 3&#125; &#125;</div><div class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"title"</span> : <span class="string">"My updated blog post"</span>&#125; &#125;</div></pre></td></tr></table></figure></p>
<p>当然，你可以指定index和type，当下面指定时会覆盖掉<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST /website/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"log"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line"></div><div class="line">POST /website/<span class="built_in">log</span>/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123;&#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"Overriding the default type"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>批量最好的批次在5Mb~15Mb</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h2&gt;&lt;p&gt;文档元数据如下&lt;br&gt;_index 文档存储的地方；_type文档代表的对象的类；_id 文档的唯一标识*&lt;/p&gt;
&lt;h3 id=&quot;inde
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式集群</title>
    <link href="http://yoursite.com/2017/11/14/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2017/11/14/分布式集群/</id>
    <published>2017-11-14T13:22:00.000Z</published>
    <updated>2017-11-14T14:31:21.187Z</updated>
    
    <content type="html"><![CDATA[<p>一个节点就是一个elasticsearch实例，一个集群由一个或者多个节点组成，具有相同的cluster.name，它们协同工作，分享数据和负载。<br>集群中的一个节点选举称为master，将临时管理集群级别的一些变更，<strong>例如新建、删除索引、增加或移除节点。主节点不参与文档级别的变更或搜索，意味着在流量增长时，master不会成为瓶颈。</strong></p>
<h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><p>集群健康分为三种：red、yellow、green,green代表所有的主分片和复制分片都可用，yellow代表所有主要分片可用，但是不是所有复制分片可用，red代表不是所有主分片可用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _cluster/health</div></pre></td></tr></table></figure></p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>索引是用来指向一个或者多个分片的逻辑命名空间，一个分片是一个最小级别工作单元。分片可以是主分片或者复制分片，索引的每一个文档属于一个主分片，主分片的数量决定了索引最终存储的数量。复制分片是主分片的一个副本，可以防止硬件故障导致的数据丢失，同时提供读请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PUT /sjjhpt</div><div class="line">//创建三个主分片，一个副本</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line">     <span class="string">"number_of_shards"</span>:3,</div><div class="line">     <span class="string">"number_of_replicas"</span>: 1.</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="增加故障转移"><a href="#增加故障转移" class="headerlink" title="增加故障转移"></a>增加故障转移</h2><p>在单一节点运行会有单点故障的风险，要防止单点故障，要启动另外一个节点。文档首先会在主分片中存储，然后并发复制到其他复制分片，确保主分片和复制分片都会被检索。</p>
<h2 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h2><p>可以增加节点数，最多节点数为(主分片个数)* (副本数量+1)</p>
<h2 id="更多扩展"><a href="#更多扩展" class="headerlink" title="更多扩展"></a>更多扩展</h2><p>当然，只是有更多的复制分片在同样数量的节点上并不能提高我们的性能，因为每个分片都要访问更小比重的节点资源（译者注：大部分请求都聚集到了分片少的节点，导致一个节点吞吐量太大，反而降低性能）。你需要增加硬件来提高吞吐量。<br>不过这些额外的复制节点意味着我们有更多的冗余：通过以上对接点的设置，我们更够承受两个节点故障而不丢失数据.</p>
<h2 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h2><p>当主节点故障后，会重新选举主节点，如果主分片不能正常工作，重新选举的主节点会提升副本分片为主分片</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个节点就是一个elasticsearch实例，一个集群由一个或者多个节点组成，具有相同的cluster.name，它们协同工作，分享数据和负载。&lt;br&gt;集群中的一个节点选举称为master，将临时管理集群级别的一些变更，&lt;strong&gt;例如新建、删除索引、增加或移除节点。
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch入门</title>
    <link href="http://yoursite.com/2017/11/14/elasticsearch%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/11/14/elasticsearch入门/</id>
    <published>2017-11-14T06:16:48.000Z</published>
    <updated>2017-11-16T12:17:46.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>elasticSearch是基于Lucene的开源搜索引擎。lucene是现在最先进、性能最好、功能最全的搜索引擎库。但是lucene是一个库，你必须使用java语言集成到你的应用。Lucene通过restful api隐藏Lucene的复杂性。es的特性如下：</p>
<ul>
<li>分布式的实时存储</li>
<li>分布式的实时搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="java-API"><a href="#java-API" class="headerlink" title="java API"></a>java API</h2><h3 id="节点客户端"><a href="#节点客户端" class="headerlink" title="节点客户端"></a>节点客户端</h3><p>节点客户端是以无数据节点加入集群，它自己不存储数据，它知道数据在集群里的具体位置，并且能够直接转发请求到对应节点上</p>
<h3 id="传输客户端"><a href="#传输客户端" class="headerlink" title="传输客户端"></a>传输客户端</h3><p>能够发送请求到远程集群，它自己不加入集群，只是简单转发请求到集群的节点</p>
<h3 id="基于http协议，以json为数据交互格式的Restful-ApI"><a href="#基于http协议，以json为数据交互格式的Restful-ApI" class="headerlink" title="基于http协议，以json为数据交互格式的Restful ApI"></a>基于http协议，以json为数据交互格式的Restful ApI</h3><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>es是面向文档的，他可以存储整个对象或者文档。并且文档可以被索引、搜索、排序、过滤。json是文档序列化的格式。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>es的索引一个文档指的是将一个文档存储到索引里，以便检索和查询，类似数据库的insert。但是如果文档已存在，会覆盖文档。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/1 //索引 类型 文档id</div></pre></td></tr></table></figure>
<h3 id="简单检索"><a href="#简单检索" class="headerlink" title="简单检索"></a>简单检索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search //默认返回前十个数据</div></pre></td></tr></table></figure>
<h3 id="查询字符串查询"><a href="#查询字符串查询" class="headerlink" title="查询字符串查询"></a>查询字符串查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search?q=userid:hxdt</div></pre></td></tr></table></figure>
<h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><p>以json请求体出现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"userid"</span>:<span class="string">"hxdt"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更复杂的搜索"><a href="#更复杂的搜索" class="headerlink" title="更复杂的搜索"></a>更复杂的搜索</h3><p>filter重点在区间查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line"></div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"range"</span>:&#123;</div><div class="line">           <span class="string">"dyrq"</span>:&#123;</div><div class="line">           	  <span class="string">"gt"</span>:<span class="string">"2017-05-06"</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //elkname包含aa或包含bb</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h3><p>搜索确切的匹配若干个单词或者短语<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //询同时包含<span class="string">"aa"</span>和<span class="string">"bb"</span>,并且是相邻的</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_phrase"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"highlight"</span>:&#123;</div><div class="line">  	<span class="string">"pre_tags"</span>: [</div><div class="line">          <span class="string">"&lt;em class=\"c_color\"&gt;"</span></div><div class="line">      ],</div><div class="line">      <span class="string">"post_tags"</span>: [</div><div class="line">        <span class="string">"&lt;/em&gt;"</span></div><div class="line">      ],</div><div class="line">  	<span class="string">"fields"</span>:&#123;</div><div class="line">  		<span class="string">"elkname"</span>:&#123;</div><div class="line"></div><div class="line">  		&#125;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>类比数据库的group by<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>聚合允许分级汇总<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST //查询相同接口标识符的平均id</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;,</div><div class="line">			<span class="string">"aggs"</span>:&#123;</div><div class="line">				<span class="string">"avg_id"</span>:&#123;</div><div class="line">					<span class="string">"avg"</span>:&#123;</div><div class="line">						<span class="string">"field"</span>:<span class="string">"id"</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;elasticSearch是基于Lucene的开源搜索引擎。lucene是现在最先进、性能最好、功能最全的搜索引擎库。但是lucene是一个
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>logstash同步数据库</title>
    <link href="http://yoursite.com/2017/11/13/logstash%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/11/13/logstash配置/</id>
    <published>2017-11-13T11:56:34.000Z</published>
    <updated>2017-11-19T09:18:03.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><h2 id="安装logstash"><a href="#安装logstash" class="headerlink" title="安装logstash"></a>安装logstash</h2><p>下载地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.5.1.zip</div></pre></td></tr></table></figure></p>
<h3 id="准备MySQL的驱动"><a href="#准备MySQL的驱动" class="headerlink" title="准备MySQL的驱动"></a>准备MySQL的驱动</h3><p>在lib下新建mysqldriver文件夹，并将mysql-connector-java-5.1.25.jar拷贝到mysqldriver文件夹中。</p>
<h3 id="配置模板"><a href="#配置模板" class="headerlink" title="配置模板"></a>配置模板</h3><h4 id="配置动态模板"><a href="#配置动态模板" class="headerlink" title="配置动态模板"></a>配置动态模板</h4><ol>
<li>切换到根目录</li>
<li>新建template目录</li>
<li>进入template目录</li>
<li>新建文件 logstash-ik.json   </li>
<li>编辑文件内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"template"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"version"</span>: 50001,</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"index.refresh_interval"</span>: <span class="string">"5s"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"mappings"</span>: &#123;</div><div class="line">        <span class="string">"_default_"</span>: &#123;</div><div class="line">            <span class="string">"_all"</span>: &#123;</div><div class="line">                <span class="string">"enabled"</span>: <span class="literal">true</span>,</div><div class="line">                <span class="string">"norms"</span>: <span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"dynamic_templates"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"message_field"</span>: &#123;</div><div class="line">                        <span class="string">"match"</span>: <span class="string">"jkbsf"</span>,</div><div class="line">                        <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line">                        <span class="string">"mapping"</span>: &#123;</div><div class="line">                            <span class="string">"type"</span>: <span class="string">"keyword"</span>,</div><div class="line">                            <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">							              <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"string_fields"</span>: &#123;</div><div class="line">                        <span class="string">"match"</span>: <span class="string">"*"</span>,</div><div class="line">                        <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line">                        <span class="string">"mapping"</span>: &#123;</div><div class="line">                            <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                            <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                            <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                            <span class="string">"fields"</span>: &#123;</div><div class="line">                                <span class="string">"keyword"</span>: &#123;</div><div class="line">                                    <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            ],</div><div class="line">            <span class="string">"properties"</span>: &#123;</div><div class="line">                <span class="string">"@timestamp"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"date"</span>,</div><div class="line">                    <span class="string">"include_in_all"</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"@version"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"keyword"</span>,</div><div class="line">                    <span class="string">"include_in_all"</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="静态模板"><a href="#静态模板" class="headerlink" title="静态模板"></a>静态模板</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"template"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"version"</span>: 50001,</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"index.refresh_interval"</span>: <span class="string">"5s"</span></div><div class="line">     &#125;,</div><div class="line">    <span class="string">"mappings"</span>: &#123;</div><div class="line">        <span class="string">"into_es_type_define"</span> :&#123;</div><div class="line">         <span class="string">"properties"</span>: &#123;</div><div class="line">               <span class="string">"ct"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"@timestamp"</span>: &#123;</div><div class="line">                   <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</div><div class="line">                   <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                &#125;,</div><div class="line">               <span class="string">"@version"</span>: &#123;</div><div class="line">                  <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</div><div class="line">                  <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                &#125;,</div><div class="line">               <span class="string">"name"</span>: &#123;</div><div class="line">                  <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                  <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                  <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                  <span class="string">"fields"</span>: &#123;</div><div class="line">                     <span class="string">"keyword"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"id"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"long"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"type"</span>: &#123;</div><div class="line">                     <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                     <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                     <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                     <span class="string">"fields"</span>: &#123;</div><div class="line">                     <span class="string">"keyword"</span>: &#123;</div><div class="line">                         <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                          &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"age"</span>: &#123;</div><div class="line">                   <span class="string">"type"</span>: <span class="string">"long"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"desc"</span>: &#123;</div><div class="line">                    <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                    <span class="string">"fields"</span>: &#123;</div><div class="line">                    <span class="string">"keyword"</span>: &#123;</div><div class="line">                         <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">                &#125;,</div><div class="line">               <span class="string">"ut"</span>: &#123;</div><div class="line">                      <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                 &#125;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="准备Logstash的配置文件"><a href="#准备Logstash的配置文件" class="headerlink" title="准备Logstash的配置文件"></a>准备Logstash的配置文件</h3><p>在config下新建mysql.conf文件，编辑内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    jdbc &#123;</div><div class="line">        jdbc_driver_library =&gt; <span class="string">"D:/logstash-5.5.1/lib/mysqldriver/mysql-connector-java-5.1.25.jar"</span></div><div class="line">        jdbc_driver_class =&gt; <span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">        jdbc_connection_string =&gt; <span class="string">"jdbc:mysql://localhost:3306/sjjhpt?autoReconnect=true&amp;useSSL=false"</span></div><div class="line">        jdbc_user =&gt; <span class="string">"root"</span></div><div class="line">        jdbc_password =&gt; <span class="string">"123456"</span></div><div class="line">        schedule =&gt; <span class="string">"* * * * *"</span></div><div class="line">        jdbc_default_timezone =&gt; <span class="string">"Asia/Shanghai"</span></div><div class="line">        statement =&gt; <span class="string">"SELECT * FROM pub_sjjhpt_fwjlb;"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        index =&gt; <span class="string">"sjjhpt"</span></div><div class="line">        document_type =&gt; <span class="string">"fwjlb"</span></div><div class="line">        document_id =&gt; <span class="string">"%&#123;id&#125;"</span></div><div class="line">        hosts =&gt; [<span class="string">"localhost:9200"</span>]</div><div class="line">        <span class="comment">## 模板</span></div><div class="line">        template_overwrite =&gt; <span class="literal">true</span></div><div class="line">        template =&gt; <span class="string">"/usr/local/logstash-5.5.2/template/logstash-ik.json"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">参数说明：</div><div class="line">jdbc_driver_library：</div><div class="line">数据库驱动路径，这里我填写的是绝对路径，可自行尝试相对路径；</div><div class="line">jdbc_driver_class：</div><div class="line">驱动名称；</div><div class="line">jdbc_connection_string：</div><div class="line">数据库的连接字符串；</div><div class="line">forelk为数据库名；</div><div class="line">?autoReconnect=<span class="literal">true</span>&amp;useSSL=<span class="literal">false</span>自动重连并禁用SSL；</div><div class="line">jdbc_user：</div><div class="line">数据库用户名；</div><div class="line">jdbc_password：</div><div class="line">数据库密码；</div><div class="line">schedule：</div><div class="line">重复执行导入任务的时间间隔；</div><div class="line">jdbc_default_timezone：</div><div class="line">默认时区设置；</div><div class="line">statement：</div><div class="line">导入的表（查询SQL，可以过滤数据）</div><div class="line">index:</div><div class="line">索引名称（类似数据库名称）；</div><div class="line">document_type：</div><div class="line">类型名称（类似数据库表名）；</div><div class="line">document_id：</div><div class="line">类似主键；</div><div class="line">hosts：</div><div class="line">要导入到的Elasticsearch所在的主机；</div></pre></td></tr></table></figure></p>
<h3 id="执行导入"><a href="#执行导入" class="headerlink" title="执行导入"></a>执行导入</h3><p>首先启动elasticsearch，然后在logstash目录下Shift+鼠标右键，选择在此处打开命令窗口(W),输入命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin\logstash <span class="_">-f</span> config\mysql.conf</div></pre></td></tr></table></figure></p>
<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>可以启动head插件查看也可以通过kibana</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装mysql&quot;&gt;&lt;a href=&quot;#安装mysql&quot; class=&quot;headerlink&quot; title=&quot;安装mysql&quot;&gt;&lt;/a&gt;安装mysql&lt;/h2&gt;&lt;h2 id=&quot;安装logstash&quot;&gt;&lt;a href=&quot;#安装logstash&quot; class=&quot;head
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="logstash" scheme="http://yoursite.com/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>面向服务的体系架构-SOA(第一章)</title>
    <link href="http://yoursite.com/2017/11/10/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-SOA/"/>
    <id>http://yoursite.com/2017/11/10/面向服务的体系架构-SOA/</id>
    <published>2017-11-10T02:57:29.000Z</published>
    <updated>2017-11-12T01:44:03.987Z</updated>
    
    <content type="html"><![CDATA[<p>伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提供服务，达成业务之间相互复用，系统也因此演变为分布式应用架构体系。<br>基于http协议之间的系统间的RPC，具有使用灵活、实现便捷、开放且天生支持异构平台间的调用等多个优点。与之对应的是tcp协议的实现版本，效率更高，实现更复杂，但由于协议和标准不同，很难跨平台和企业间的通信。</p>
<h2 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h2><h3 id="RPC名词解释"><a href="#RPC名词解释" class="headerlink" title="RPC名词解释"></a>RPC名词解释</h3><p>remote process call，远程过程调用，拥有着RMI、webservice等诸多成熟的方案。RPC将原来的本地调用转变为调用远端的服务器上的方法。<br>RPC的实现包括客户端和服务器端，即服务的调用方和服务提供方。服务调用方发送RPC请求到服务提供方，服务提供方根据调用方提供的参数执行请求方法，将执行结果返回给调用方。其中参数和返回结果序列化。</p>
<h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>将对象转成二进制流的过程称为对象的序列化<br>将二进制流转成对象的过程称为对象的反序列化<br>对象的序列化和反序列化有很多成熟的方案：Google protocol Buffers协议、java内置的序列化方式、Hessian、json以及xml。</p>
<h3 id="基于TCP实现的RPC"><a href="#基于TCP实现的RPC" class="headerlink" title="基于TCP实现的RPC"></a>基于TCP实现的RPC</h3><p>基于java socket的api，能够实现简单的RPC调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hbase架构</title>
    <link href="http://yoursite.com/2017/11/07/hbase%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2017/11/07/hbase架构/</id>
    <published>2017-11-07T14:19:10.000Z</published>
    <updated>2017-11-10T01:10:07.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据查找和存储"><a href="#数据查找和存储" class="headerlink" title="数据查找和存储"></a>数据查找和存储</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树的性质使得能够对主键进行高效的插入、查找以及删除，B+树远好于二叉树的数据划分，大大减少查询特定主键所需要的IO。此外，B+树能够提供高效的范围扫描，由于叶节点相互连接且主键有序，扫描时避免了耗时的遍历树的操作。在很多关系型数据库中，都把该数据结构用做索引。<br>当添加新的索引时，可能会使得页表满了拆分成两个页表，若页表不在一块，在进行范围查询时，需要读取不在一块的页表甚至很远的页表，因此我们需要优化该表，使用optimize table，将B+顺序写，使得范围查找时加快。</p>
<h3 id="LSM树-Log-Structured-Merge"><a href="#LSM树-Log-Structured-Merge" class="headerlink" title="LSM树(Log Structured Merge)"></a>LSM树(Log Structured Merge)</h3><p>输入数据首先存储在日志文件中，这些文件的完全有序，当有日志文件被修改时，对应的更新会保存在内存中，来加速查询。在经历数次数据进行修改后，内存逐渐被占满后，LSM树会把有序的键数据对写入磁盘，同时创建一个新的数据存储文件，并且内存中的数据可以丢弃。存储文件组织与B树相似，不过其为磁盘顺序读取做了优化，所有节点都是满的并按页存储，修改数据文件通过滚动合并完成。如果数据量过于庞大，磁盘中的树相应地也会很大，导致的后果是合并的速度会变慢。一个解决方法是建立各个层次的树，低层次的树都比上一层次的树数据集大。假设内存中的树为c0, 磁盘中的树按照层次一次为c1, c2, c3, … ck-1, ck。合并的顺序是(c0, c1), (c1, c2)…(ck-1, ck)。<br>查询时先查找内存中的存储，然后在查找磁盘文件。删除是一种特殊的更改，当删除标记被存储后，查找时会跳过被删除的键。当页被重写时，有删除标记的键会被丢掉。后台运维可以设定一个TTL，在TTL后，检查时间戳，然后重写丢弃过期的记录。<br><strong>B+树与LSM树对比</strong><br>在没有太多修改（插入或者删除）时，B+树表现得很好，因为这些修改要求执行高性能的优化操作以保证查询能在有限的时间内完成。在任意位置添加的数据规模越大，速度越快，这些页成为碎片的速度越快，最后用户写入的速度比优化重写速度更快，导致碎片化。因而只能多次随机io，导致建立索引速度变慢。<br>LSM树使用日志文件内存存储将随机写变为顺序写，因此也能保证稳定的插入速率，由于读写独立，所以不会存在冲突。由于存储数据布局更优，查询一个键需要的磁盘寻道次数在一个可预测的范围，并且读取与改建连续任意数量的记录都不会引发额外的磁盘寻道。一般来说，有几个存储文件，最多几次寻道。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Hbase主要处理两种文件：1.预写文件(write ahead file,WAL);2.实际数据文件，由HRegionServer管理。基本流程是：客户端首先联系Zookeeper子集群（quorum）查找行健，通过Zookeeper获取含有-ROOT-的region服务器名来完成。通过含有-ROOT-的region服务器可以查询到含有.meta表中对应的region服务器名。这两处内容会被缓存。最终通过.meta服务器获取客户端查询的行键所在region服务器名。一旦知道数据所在的位置，Hbase会缓存信息，后面客户端就不需要查询.meta.</p>
<h3 id="写路径"><a href="#写路径" class="headerlink" title="写路径"></a>写路径</h3><p>当用户向HregionServer发起HTable.put(Put)请求时，其会交给对应的region来处理。第一步是要决定数据是否需要写到HLog类实现的预写日志中，一旦数据被写入WAL中，数据就会放到Memstore中，同时还会检查memstore是否已经满了，如果满了，就会将请求刷新到磁盘里。刷新请求由另外一个RegionServer的线程处理，它会把数据写成HDFS中的一个新HFile，同时保存最后写的序号。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>根级文件<br>一个region服务器所有region共享一个对应的子目录，在Hbase根目录下命名为logs的目录</li>
<li>表级文件<br>每张表都有自己的目录，其位于文件系统中的hbase根目录下，每张表包括一个名为.tableinfo的顶层文件</li>
<li>region级文件<br>每张表的目录里面，每个列族都有单独一个目录。</li>
<li>region拆分<br>region存储文件增长超过配置的大小就会一分为二</li>
<li>region合并<br>合并会把磁盘文件合并成数量更少的体积更大的文件<h3 id="HFile格式"><a href="#HFile格式" class="headerlink" title="HFile格式"></a>HFile格式</h3>存储Hbase的数据，分为Trailer、MetaIndex、DataIndex、FileInfo、Data，Data一般存放Magic和keyvalue，keyvalue可以采用压缩算法压缩数据。<h3 id="keyvalue格式"><a href="#keyvalue格式" class="headerlink" title="keyvalue格式"></a>keyvalue格式</h3>keyvalue的格式：KeyLength、ValueLength、(RowLength、Row、ColumnFamilyLength、ColumnFamily、ColumnQualifier、TimeStamp、KeyType)、value,括号部分是key，可以转化为java实例，就可以通过get方法获取属性。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">System.out.println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>region服务器会将数据保存在内存中，直到积攒足够多的数据刷新到磁盘，但是存储在磁盘中的数据是不稳定的，例如断电时候就会数据丢失，比较常见的解决方案是预写日志(WAL):每次更新都会写入日志，只有当写入成功才会通知客户端操作成功。</p>
<h3 id="HLog"><a href="#HLog" class="headerlink" title="HLog"></a>HLog</h3><p>实现WAL类叫做HLog，当region收到更新操作，就直接把数据保存到一个共享的WAL实例中。</p>
<h3 id="HLog-key"><a href="#HLog-key" class="headerlink" title="HLog key"></a>HLog key</h3><p>存储keyvalue的归属，即region和表名，信息存储在HLogKey中。还存储了序列号，每一条的记录都是递增的，还记录了写入到日志的时间戳。</p>
<h3 id="WalEdit"><a href="#WalEdit" class="headerlink" title="WalEdit"></a>WalEdit</h3><p>每一个修改都会被封装为WalEdit实例。</p>
<h3 id="LogSyncer"><a href="#LogSyncer" class="headerlink" title="LogSyncer"></a>LogSyncer</h3><p>延迟日志刷写标记，如果设置为false，每一次编辑发送到服务器，都会调用写日志的sync。</p>
<h3 id="LogRoller"><a href="#LogRoller" class="headerlink" title="LogRoller"></a>LogRoller</h3><p>在特定时间内滚动日志</p>
<h2 id="读路径"><a href="#读路径" class="headerlink" title="读路径"></a>读路径</h2><p>Hbase的每个列族使用多个存储文件进行数据存储。后台合并将小文件写入到大文件减少文件的数目。墓碑标记是可以标记一个单元格，多个单元格，一整行。</p>
<h2 id="region查找"><a href="#region查找" class="headerlink" title="region查找"></a>region查找</h2><p>为了让客户端查找到包含特定主键的region，Hbase提供两张目录表，一张-ROOT-和.META.。-ROOT-用来查询所有.META.表中region的位置。Hbase的设计时只有一个root region，从而保证类似于B+树结构的三层查找：第一层是Zookeeper中包含root region位置信息的节点。第二层是从-ROOT-中查找对应meta region位置。第三层是从.META.表中查找用户表中对应region的位置。</p>
<h2 id="region的生命周期"><a href="#region的生命周期" class="headerlink" title="region的生命周期"></a>region的生命周期</h2><p>offline、pending open、opening、open、pending close、closing、closed、splitting</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>主要功能有跟踪region服务器、保存root region地址。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Hbase最基本的架构师主推送，一个主集群可以将数据复制到任意数目的从集群。所有的WALEdits都会被复制以保证原子性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据查找和存储&quot;&gt;&lt;a href=&quot;#数据查找和存储&quot; class=&quot;headerlink&quot; title=&quot;数据查找和存储&quot;&gt;&lt;/a&gt;数据查找和存储&lt;/h2&gt;&lt;h3 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>慕课网java</title>
    <link href="http://yoursite.com/2017/11/05/%E6%85%95%E8%AF%BE%E7%BD%91java/"/>
    <id>http://yoursite.com/2017/11/05/慕课网java/</id>
    <published>2017-11-05T00:49:22.000Z</published>
    <updated>2017-11-05T09:08:00.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="程序设计语言基础"><a href="#程序设计语言基础" class="headerlink" title="程序设计语言基础"></a>程序设计语言基础</h2><h2 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象不可变性"><a href="#面向对象不可变性" class="headerlink" title="面向对象不可变性"></a>面向对象不可变性</h3><p>final关键字<br>类申明：类不可集成<br>函数申明：函数不可在派生类重写<br>变量申明：变量不可指向其他对象，但是变量指向对象的内容可以改变<br>习惯性常量 static final 一般大写<br>实现不可变性：<br>1.final关键字无法保证不可变性<br>2.从接口的定义上，类的实现上保证不可变性（例如通过暴露部分变量的接口只能获取部分变量，而不能获取整个类的实例，String类的substring方法和replace方法，都不会改变自身的内容，都是new）<br>3.Collections.unmodifiableXXX(例如：list=Collections.unmodifiable(new ArrayList&lt;&gt;(t)))，编译通过，运行add会抛异常</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型。Java 编译器在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。<br>从List到List<t><br>规定类型只能是类型T，但是实现无所谓T是什么类型。<br>从List到List<t>语法<br>List<string> list=new ArrayList&lt;&gt;();//1.7<br>List<integer> list=LinkedList.of(1,2,3);<br>List<string> list=LinkedList.newEmptyList();<br>java Type erasure<br>1.早期java没有泛型；2.为了兼容性，在运行时将所有泛型擦除<br>运行时：List、List<string>、List<integer>没有区别<br>covariance<br>ArrayList<integer>是List<integer>,但是List<integer>不是List<object><br>将List<integer>转化成List<object>:<br>new ArrayList<object>(intList)或者List<object>(List) intList（危险，先要明确目的为什么转）</object></object></object></integer></object></integer></integer></integer></integer></string></string></integer></string></t></t></p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><h2 id="高级知识点"><a href="#高级知识点" class="headerlink" title="高级知识点"></a>高级知识点</h2><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>并行计算的方法：<br>把数据拆分到每个节点<br>每个节点并行的计算结果<br>把结果汇总<br>k路归并排序。把数据切分成k份，每份内部进行排序（可以用快排或者归并），然后进行k路归并，可以用k最小堆，PriorityQueue,从数据源拿数据需要使用缓存，读一段，可以考虑Iterable接口<br>Iterable<t> merge(List<iterable<t> sortedData&gt;)<br>Iterable接口的next方法，如果缓存区空，读取一段数据到缓存，给出缓存区第一个元素，缓存区元素大小（可配置）</iterable<t></t></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>死锁条件：<br>1.互斥等待<br>2.hold and wait<br>3.循环等待<br>4.无法剥夺的等待<br>解决：<br>1.一次性获取所有资源；2.顺序获取资源（根据资源某个标识顺序加锁）；3.加入超时机制</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>创建线程开销大<br>线程池：预先建立好线程，等待任务派发。</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><p>corePoolSize：线程池初始线程的数量<br>maximumPoolSize：线程中最大允许数量<br>KeepAliveTime：超出corePoolSize的线程如果等待时间超过这个时间就会被回收<br>TimeUnit:时间单位，毫秒、秒微秒，描述KeepAliveTime<br>BlockingQueue<runnable>:<br>资源的连接问题：例如数据库的连接，虽然对象被回收但是资源依然不释放。</runnable></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java视频" scheme="http://yoursite.com/tags/java%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>hbase高级特性</title>
    <link href="http://yoursite.com/2017/11/04/hbase%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/11/04/hbase高级特性/</id>
    <published>2017-11-04T02:29:11.000Z</published>
    <updated>2017-11-04T13:50:18.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器简介"><a href="#过滤器简介" class="headerlink" title="过滤器简介"></a>过滤器简介</h3><p>Get和Scan都支持过滤器，过滤器最基本的接口是Filter，所有的过滤器都在服务器生效（谓词下推），可以保证过滤的数据不会传递到客户端。<br>1.过滤器层次结构<br>最底层的过滤器是Filter和FilterBase，定好的过滤器可以传递给get和scan，通过setFilter<br>2.比较运算符<br>CompareFilter多了个compare方法，需要使用传递参数，参数有<br>LESS,LESS_OR_EQUAL,EQUAL,NOT_EQUAL,GREATER_OR_EQUAL,GREATER,NO_OP<br>3.比较器<br>CompareFilter所需要的第二个类型是比较器，比较常用的比较器有：BinaryComparator、NullComparator（判断是否为null）、RegexStringComparator（正则比较）、SubstringComparator（通过contains去操作）、BitComparator（位比较&amp;|^）</p>
<h3 id="比较过滤器"><a href="#比较过滤器" class="headerlink" title="比较过滤器"></a>比较过滤器</h3><p>CompareFilter创建实例需要运算符和比较器，</p>
<h4 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">RowFilter filter = new RowFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-row-1"</span>)));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列族过滤器"><a href="#列族过滤器" class="headerlink" title="列族过滤器"></a>列族过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">FamilyFilter filter = new FamilyFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-family"</span>))); // 列族为 my-family</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列名过滤器-QualifierFilter"><a href="#列名过滤器-QualifierFilter" class="headerlink" title="列名过滤器(QualifierFilter)"></a>列名过滤器(QualifierFilter)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">QualifierFilter filter = new QualifierFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-column"</span>))); // 列名为 my-column</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="值过滤器"><a href="#值过滤器" class="headerlink" title="值过滤器"></a>值过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">BinaryComparator comp = new BinaryComparator(Bytes.toBytes(<span class="string">"xmei"</span>)); //</div><div class="line">ValueFilter filter = new ValueFilter(CompareOp.EQUAL, comp);</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="参考列过滤器"><a href="#参考列过滤器" class="headerlink" title="参考列过滤器"></a>参考列过滤器</h4><p>该过滤器尝试找到该列所在的每一行，并返回该行具有该列相同时间戳的全部键值对。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">DependentColumnFilter filter = new DependentColumnFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h3 id="专用过滤器"><a href="#专用过滤器" class="headerlink" title="专用过滤器"></a>专用过滤器</h3><h4 id="单列值过滤器"><a href="#单列值过滤器" class="headerlink" title="单列值过滤器"></a>单列值过滤器</h4><p>下面一个检测列族 family 下的列 qualifier 的列值和字符串 “my-value” 相等的部分示例代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueFilter filter = new SingleColumnValueFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h4 id="单列排除过滤器"><a href="#单列排除过滤器" class="headerlink" title="单列排除过滤器"></a>单列排除过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueExcludeFilter filter = new SingleColumnValueExcludeFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="前缀过滤器"><a href="#前缀过滤器" class="headerlink" title="前缀过滤器"></a>前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Filter filter=new PrefixFilter(Bytes.toBytes(<span class="string">"row-1"</span>));</div><div class="line">Scan scan=new Scan();</div><div class="line">scan.setFilter(filter);</div><div class="line">ResultScanner result=table.getScanner(scan);</div></pre></td></tr></table></figure>
<h4 id="分页过滤器"><a href="#分页过滤器" class="headerlink" title="分页过滤器"></a>分页过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">long pageSize = 10;</div><div class="line">int totalRowsCount = 0;</div><div class="line">PageFilter filter = new PageFilter(pageSize);</div><div class="line">byte[] lastRow = null;</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line"> Scan scan = new Scan();</div><div class="line"> scan.setFilter(filter);</div><div class="line"> <span class="keyword">if</span>(lastRow != null) &#123;</div><div class="line">  byte[] postfix = Bytes.toBytes(<span class="string">"postfix"</span>);</div><div class="line">  byte[] startRow = Bytes.add(lastRow, postfix);</div><div class="line">  scan.setStartRow(startRow);</div><div class="line">  System.out.println(<span class="string">"start row : "</span> + Bytes.toString(startRow));</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> ResultScanner scanner = _hTable.getScanner(scan);</div><div class="line"> int <span class="built_in">local</span>RowsCount = 0;</div><div class="line"> <span class="keyword">for</span>(Result result : scanner) &#123;</div><div class="line">  System.out.println(<span class="built_in">local</span>RowsCount++ + <span class="string">" : "</span> + result);</div><div class="line">  totalRowsCount++;</div><div class="line">  lastRow = result.getRow(); // ResultScanner 的结果集是排序好的，这样就可以取到最后一个 row 了</div><div class="line"> &#125;</div><div class="line"> scanner.close();</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(<span class="built_in">local</span>RowsCount == 0) <span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"total rows is : "</span> + totalRowsCount);</div></pre></td></tr></table></figure>
<h4 id="行键过滤器"><a href="#行键过滤器" class="headerlink" title="行键过滤器"></a>行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">KeyOnlyFilter filter = new KeyOnlyFilter(); // 只查询每行键值对中有 <span class="string">"键"</span> 元数据信息，不显示值，可以提升扫描的效率</div></pre></td></tr></table></figure>
<h4 id="首次行键过滤器"><a href="#首次行键过滤器" class="headerlink" title="首次行键过滤器"></a>首次行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//该过滤器只查询每个行键的第一个键值对，在统计计数的时候提高效率。（HBase-Coprocessor 做 RowCount 的时候可以提高效率）。</div><div class="line">Scan scan = new Scan();</div><div class="line">FirstKeyOnlyFilter filter = new FirstKeyOnlyFilter(); // 只查询每个行键的第一个键值对</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="包含结束的过滤器"><a href="#包含结束的过滤器" class="headerlink" title="包含结束的过滤器"></a>包含结束的过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//常规的 Scan 包含 start-row 但不包含 stop-row，如果使用该过滤器便可以包含 stop-row。</div><div class="line">Scan scan = new Scan();</div><div class="line">InclusiveStopFilter filter = new InclusiveStopFilter(Bytes.toBytes(<span class="string">"stopRowKey"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="时间戳过滤器"><a href="#时间戳过滤器" class="headerlink" title="时间戳过滤器"></a>时间戳过滤器</h4><h4 id="列计数过滤器"><a href="#列计数过滤器" class="headerlink" title="列计数过滤器"></a>列计数过滤器</h4><h4 id="列分页计数器"><a href="#列分页计数器" class="headerlink" title="列分页计数器"></a>列分页计数器</h4><h4 id="列前缀过滤器"><a href="#列前缀过滤器" class="headerlink" title="列前缀过滤器"></a>列前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//用于列名（Qualifier）前缀过滤，即包含某个前缀的所有列名。</div><div class="line">Scan scan = new Scan();</div><div class="line">  ColumnPrefixFilter filter = new ColumnPrefixFilter(Bytes.toBytes(<span class="string">"my-prefix"</span>)); // 前缀为 my-prefix</div><div class="line">  scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="随机行过滤器"><a href="#随机行过滤器" class="headerlink" title="随机行过滤器"></a>随机行过滤器</h4><h3 id="附加过滤器"><a href="#附加过滤器" class="headerlink" title="附加过滤器"></a>附加过滤器</h3><h4 id="跳转过滤器"><a href="#跳转过滤器" class="headerlink" title="跳转过滤器"></a>跳转过滤器</h4><p>这是一种附加过滤器，其与ValueFilter结合使用，如果发现一行中的某一列不符合条件，那么整行就会被过滤掉：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Filter skf = new SkipFilter(vf); // OK 发现某一行中的一列需要过滤时，整个行就会被过滤掉</div></pre></td></tr></table></figure></p>
<h4 id="全匹配过滤器（whileMatchFilter）"><a href="#全匹配过滤器（whileMatchFilter）" class="headerlink" title="全匹配过滤器（whileMatchFilter）"></a>全匹配过滤器（whileMatchFilter）</h4><p>如果你想要在遇到某种条件数据之前的数据时，就可以使用这个过滤器；当遇到不符合设定条件的数据的时候，整个扫描也就结束了：</p>
<h3 id="filterList"><a href="#filterList" class="headerlink" title="filterList"></a>filterList</h3><p>用于综合使用多个过滤器。其有两种关系：FilterList.Operator.MUST_PASS_ONE和FilterList.Operator.MUST_PASS_ALL，默认的是FilterList.Operator.MUST_PASS_ALL，顾名思义，它们分别是AND和OR的关系，并且FilterList可以嵌套使用FilterList，使我们能够表达更多的需求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();  </div><div class="line">filters.add(rf);  </div><div class="line">filters.add(vf);  </div><div class="line">FilterList fl = new FilterList(FilterList.Operator.MUST_PASS_ALL, filters); // OK 综合使用多个过滤器， AND 和 OR 两种关系</div></pre></td></tr></table></figure></p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="计数器简介"><a href="#计数器简介" class="headerlink" title="计数器简介"></a>计数器简介</h3><p>1.许多收集统计信息的应用有点击流或在线广告意见，这些应用需要收集到日志文件用作后续的分析，用户可以使用计数器做实时统计，从而放弃延时较高的批量处理操作。<br>2.原子操作检查并修改：将当前列当作计数器。<br>即把一个 column 当作一个 counter，这样便于给某些在线应用提供实时统计功能。（PS：比如帖子的实时浏览量：PV）<br>3.如果没有计数器特性：用户需要对一行数据加锁，然后读取数据，再对当前数据做加法，最后写回Hbase并释放该行锁。这样会引起大量的资源竞争，有其是当客户端进程崩溃之后，尚未释放的锁需要等待超时恢复，这会是一个高负载的系统中引起灾难性的后果。<br>4.计数器的增量可以是正数负数，正数代表加，负数代表减。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hbase(main):006:0&gt; create<span class="string">'counters'</span>,<span class="string">'daily'</span>,<span class="string">'weekly'</span>,<span class="string">'monthly'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 2.2260 seconds</div><div class="line">hbase(main):007:0&gt; incr <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 1</div><div class="line">hbase(main):008:0&gt; incr<span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 2</div><div class="line">hbase(main):009:0&gt; get_counter  <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span></div><div class="line">COUNTER VALUE = 2</div></pre></td></tr></table></figure></p>
<p>终端命令为incr ‘tablename’,’row’,’column’,[increment_value]</p>
<h4 id="单计数器"><a href="#单计数器" class="headerlink" title="单计数器"></a>单计数器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void oneCounter(long num) throws IOException&#123;</div><div class="line">long cnt1 = table.incrementColumnValue(Bytes.toBytes(<span class="string">"3100"</span>),</div><div class="line">Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"name"</span>), num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多计数器"><a href="#多计数器" class="headerlink" title="多计数器"></a>多计数器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void moreCounter() throws IOException&#123;</div><div class="line">Increment increment1 = new Increment(Bytes.toBytes(<span class="string">"3100"</span>));</div><div class="line"></div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 20);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 10);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 10);</div><div class="line"></div><div class="line">Result result1 = table.increment(increment1);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result1.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV1: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div><div class="line">Increment increment2 = new Increment(Bytes.toBytes(<span class="string">"3102"</span>));</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 5);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 0);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), -5);</div><div class="line">Result result2 = table.increment(increment2);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result2.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV2: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="协处理器"><a href="#协处理器" class="headerlink" title="协处理器"></a>协处理器</h3><p>协处理器允许用户在region server上运行自己的代码，准确的说是执行region级的操作，并且可以使用关系型数据库的触发器的功能。有很多使用协处理器的场景，使用钩子关联行修改操作来维护一个辅助索引，或维护一些数据间的引用完整性。协处理器主要提供两大类，observer和endpoint。<br>1）Observer（观察者）<br>该类是与RDMS中的触发器类似。回调函数在一些特定的事件发生时被调用。<br>事件包括：用户产生的事件或者服务端内部产生的事件。<br>协处理器框架提供的接口如下：<br>a、RegionObserver：用户可以通过这种处理器来处理数据修改事件，它们与表的Region紧密关联。region级的操作。对应的操作是：put/delete/scan/get<br>b、MasterObserver：可以用作管理或DDL类型的操作，是集群级的操作。对应的操作是：创建、删除、修改表。<br>c、WALObserver：提供控制WAL的钩子函数。(WAL: write ahead log)<br>Observer定义好钩子函数，服务端可以调用。<br>2）endPoint<br>该类的功能类似RDMS中的存储过程。将用户的自定义操作添加到服务器端，endPoint可以通过添加远程过程调用来扩展RPC协议。用户可以将自定义完成某项操作代码部署到服务器端。其中Endpoint可以理解为传统数据库的存储过程操作，比如可以进行某族某列值得加和。无Endpoint特性的情况下需要全局扫描表，通过Endpoint则可以在多台分布有对应表的regionserver上同步加和，在将加和数返回给客户端进行全局加和操作，充分利用了集群资源，增加性能。</p>
<h4 id="coprocessor类"><a href="#coprocessor类" class="headerlink" title="coprocessor类"></a>coprocessor类</h4><p>1）协处理器的执行顺序<br>Coprocessor.Priority枚举类型定义了两个值：SYSTEM、USER。前者优于后者执行，后者定义的按顺序执行。<br>2）协处理器的生命周期<br>协处理器的生命周期是由框架管理的，接口定义两个方法start、stop。这两个方法的参数是：CoprocessorEnvironment。该类提供了访问HBase的版本、Coprocessor版本、协处理器优先级等方法。start/stop方法是被隐式调用的，且关于协处理器的状态的定义是有一个枚举类Coprocessor.State对应的。<br>3）协处理器环境和实例的维护<br>CoprocessorHost类来完成，其有相应的子类来完成维护region、master协处理器的实例和环境。</p>
<h4 id="协处理器加载"><a href="#协处理器加载" class="headerlink" title="协处理器加载"></a>协处理器加载</h4><p>1.从配置中加载，hbase-site.xml;2.从表描述符中加载</p>
<h4 id="RegionObserver类"><a href="#RegionObserver类" class="headerlink" title="RegionObserver类"></a>RegionObserver类</h4><p>1.处理生命周期事件<br>状态1：pendingOpen，region将要被打开的状态。<br>协处理器以实现的方法是：<br>preOpen()/postOpen().完成功能是：搭载或者阻止这次打开过程。<br>preWALRestore()/postWALRestore.完成的功能是：用户可以访问那些记录被修改了，监督那些记录被实施了。<br>状态2：open，这个状态的标志是：region被部署到一个region server上且正常工作时。<br>协处理器可以实现的方法是：<br>void preFlush()/void postFlush()     内存被持久到磁盘<br>void preSpilt()/void postSpilt()          region达到足够大时进行拆分<br>状态3：pendingClose。region将要被关闭时的状态。<br>协处理器可以实现的方法是：<br>void preClose()/void postClose()<br>2.处理客户端API事件<br>这里是指在调用Java API 时，响应的事件。如：<br>void prePut()/void postPut、void preDelete()/postDelete()、void preGet()/void postGet()……..</p>
<h4 id="MasterObserver"><a href="#MasterObserver" class="headerlink" title="MasterObserver"></a>MasterObserver</h4><p>协处理器定义明确为master服务器的所有回调函数。这些回调函数中的操作是类似DDL，创建、删除、修改表。<br>1）MasterCoprocessorEnvironment<br>MasterCoprocessorEnvironment封装了MasterObserver实例，通过该类可以访问MasterService实例。<br>2）BaseMasterServer<br>BaseMasterServer是MasterServer的空实现，可以通过实现相应的pre/post来自定义相关操作。                        例如：  void preCreateTable()/void postCreateTable()  void preDeleteTable()/void postDeleteTable()……</p>
<h4 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h4><p>该接口可以使用户自定义RPC协议，它的实现代码被安装在服务端，在客户端HTable提供调用方法，使用该协议可以和协处理器实例之间通信。</p>
<h2 id="HTablePool"><a href="#HTablePool" class="headerlink" title="HTablePool"></a>HTablePool</h2><p>创建一个HTable实例，然后去复用它，可以通过HTableFactory来创建HTable，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Configuration conf = HBaseConfiguration.create();</div><div class="line">HTablePool pool = new HTablePool(conf, 10);</div><div class="line"></div><div class="line">public void createUser(String username, String firstName, String lastName, String email, String password,String roles) throws IOException &#123;</div><div class="line">　　HTable table = rm.getTable(UserTable.NAME);</div><div class="line">　　Put put = new Put(Bytes.toBytes(username));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.FIRSTNAME,</div><div class="line">　　Bytes.toBytes(firstName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.LASTNAME,</div><div class="line">　　　　Bytes.toBytes(lastName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.EMAIL, Bytes.toBytes(email));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.CREDENTIALS,</div><div class="line">　　　　Bytes.toBytes(password));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.ROLES, Bytes.toBytes(roles));</div><div class="line">　　table.put(put);</div><div class="line">　　table.flushCommits();</div><div class="line">　　rm.putTable(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h2&gt;&lt;h3 id=&quot;过滤器简介&quot;&gt;&lt;a href=&quot;#过滤器简介&quot; class=&quot;headerlink&quot; title=&quot;过滤器简介&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hbase java api</title>
    <link href="http://yoursite.com/2017/11/02/hbase-java-api/"/>
    <id>http://yoursite.com/2017/11/02/hbase-java-api/</id>
    <published>2017-11-02T08:29:51.000Z</published>
    <updated>2017-11-03T15:19:39.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.hadoop.conf.Configuration;</div><div class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</div><div class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</div><div class="line">import org.apache.hadoop.hbase.HTableDescriptor;</div><div class="line">import org.apache.hadoop.hbase.KeyValue;</div><div class="line">import org.apache.hadoop.hbase.client.Delete;</div><div class="line">import org.apache.hadoop.hbase.client.Get;</div><div class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</div><div class="line">import org.apache.hadoop.hbase.client.HTable;</div><div class="line">import org.apache.hadoop.hbase.client.HTablePool;</div><div class="line">import org.apache.hadoop.hbase.client.Put;</div><div class="line">import org.apache.hadoop.hbase.client.Result;</div><div class="line">import org.apache.hadoop.hbase.client.ResultScanner;</div><div class="line">import org.apache.hadoop.hbase.client.Scan;</div><div class="line">import org.apache.hadoop.hbase.util.Bytes;</div><div class="line"></div><div class="line">public class Hbase &#123;</div><div class="line">    // 声明静态配置</div><div class="line">    static Configuration conf = null;</div><div class="line">    static &#123;</div><div class="line">        conf = HBaseConfiguration.create();</div><div class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"localhost"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 创建表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @family 列族列表</div><div class="line">     */</div><div class="line">    public static void creatTable(String tableName, String[] family)</div><div class="line">            throws Exception &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        HTableDescriptor desc = new HTableDescriptor(tableName);</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; family.length; i++) &#123;</div><div class="line">            desc.addFamily(new HColumnDescriptor(family[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</div><div class="line">            System.out.println(<span class="string">"table Exists!"</span>);</div><div class="line">            System.exit(0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            admin.createTable(desc);</div><div class="line">            System.out.println(<span class="string">"create table Success!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 为表添加数据（适合知道有多少列族的固定表）</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @column1 第一个列族列表</div><div class="line">     *</div><div class="line">     * @value1 第一个列的值的列表</div><div class="line">     *</div><div class="line">     * @column2 第二个列族列表</div><div class="line">     *</div><div class="line">     * @value2 第二个列的值的列表</div><div class="line">     */</div><div class="line">    public static void addData(String rowKey, String tableName,</div><div class="line">            String[] column1, String[] value1, String[] column2, String[] value2)</div><div class="line">            throws IOException &#123;</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));// 设置rowkey</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// HTabel负责跟记录相关的操作如增删改查等//</div><div class="line">                                                                    // 获取表</div><div class="line">        HColumnDescriptor[] columnFamilies = table.getTableDescriptor() // 获取所有的列族</div><div class="line">                .getColumnFamilies();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; columnFamilies.length; i++) &#123;</div><div class="line">            String familyName = columnFamilies[i].getNameAsString(); // 获取列族名</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"article"</span>)) &#123; // article列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column1.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column1[j]), Bytes.toBytes(value1[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"author"</span>)) &#123; // author列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column2.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column2[j]), Bytes.toBytes(value2[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"add data Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 根据rwokey查询</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static Result getResult(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// 获取表</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName, String start_rowkey,</div><div class="line">            String stop_rowkey) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        scan.setStartRow(Bytes.toBytes(start_rowkey));</div><div class="line">        scan.setStopRow(Bytes.toBytes(stop_rowkey));</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void getResultByColumn(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName)); // 获取指定列族和列修饰符对应的列</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 更新表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     *</div><div class="line">     * @value 更新后的值</div><div class="line">     */</div><div class="line">    public static void updateTable(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName, String value)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));</div><div class="line">        put.add(Bytes.toBytes(familyName), Bytes.toBytes(columnName),</div><div class="line">                Bytes.toBytes(value));</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"update table Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询某列数据的多个版本</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void getResultByVersion(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</div><div class="line">        get.setMaxVersions(5);</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">         * List&lt;?&gt; results = table.get(get).list(); Iterator&lt;?&gt; it =</div><div class="line">         * results.iterator(); <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">         * System.out.println(it.next().toString()); &#125;</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void deleteColumn(String tableName, String rowKey,</div><div class="line">            String falilyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteColumn = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        deleteColumn.deleteColumns(Bytes.toBytes(falilyName),</div><div class="line">                Bytes.toBytes(columnName));</div><div class="line">        table.delete(deleteColumn);</div><div class="line">        System.out.println(falilyName + <span class="string">":"</span> + columnName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void deleteAllColumn(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteAll = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        table.delete(deleteAll);</div><div class="line">        System.out.println(<span class="string">"all columns are deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void deleteTable(String tableName) throws IOException &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        admin.disableTable(tableName);</div><div class="line">        admin.deleteTable(tableName);</div><div class="line">        System.out.println(tableName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">        // 创建表</div><div class="line">        String tableName = <span class="string">"blog2"</span>;</div><div class="line">        String[] family = &#123; <span class="string">"article"</span>, <span class="string">"author"</span> &#125;;</div><div class="line">        // creatTable(tableName, family);</div><div class="line"></div><div class="line">        // 为表添加数据</div><div class="line"></div><div class="line">        String[] column1 = &#123; <span class="string">"title"</span>, <span class="string">"content"</span>, <span class="string">"tag"</span> &#125;;</div><div class="line">        String[] value1 = &#123;</div><div class="line">                <span class="string">"Head First HBase"</span>,</div><div class="line">                <span class="string">"HBase is the Hadoop database. Use it when you need random, realtime read/write access to your Big Data."</span>,</div><div class="line">                <span class="string">"Hadoop,HBase,NoSQL"</span> &#125;;</div><div class="line">        String[] column2 = &#123; <span class="string">"name"</span>, <span class="string">"nickname"</span> &#125;;</div><div class="line">        String[] value2 = &#123; <span class="string">"nicholas"</span>, <span class="string">"lee"</span> &#125;;</div><div class="line">        addData(<span class="string">"rowkey1"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey2"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey3"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line"></div><div class="line">        // 遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line">        // 根据row key范围遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line"></div><div class="line">        // 查询</div><div class="line">        getResult(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 更新列</div><div class="line">        updateTable(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>, <span class="string">"bin"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 查询某列的多版本</div><div class="line">        getResultByVersion(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 删除一列</div><div class="line">        deleteColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"nickname"</span>);</div><div class="line"></div><div class="line">        // 删除所有列</div><div class="line">        deleteAllColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 删除表</div><div class="line">        deleteTable(<span class="string">"blog2"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>事实上，许多基于列表的操作，如delete(List <delete> deletes)或者get(List <get> gets)，都是基于batch()方法实现的。它们都是一些为了方便用户使用而保留的方法。如果你是新手，推荐使用batch()方法进行所有操作。<br>下面的客户端API方法提供了批量处理操作。用户可能注意到这里引入了一个新的名为Row的类，它是Put、Get和Delete的祖先，或者是父类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void batch(List&lt;Row&gt; actions,Object[] results) throws IOException,InterruptedException</div><div class="line">Object [] batch(List&lt;Row&gt; actions) throws IOException,InterruptedException</div></pre></td></tr></table></figure></get></delete></p>
<p>使用同样的父类允许在列表中实现多态，即放入以上3种不同的子类。这种调用跟之前介绍的基于列表的调用方法一样简单调用。请注意，不可以将针对同一行的Put和Delete操作放在同一个批量处理请求中，为了保证最好的性能，这些操作的处理顺序可能不同，但是这样会产生不可预料的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void batchDone(HTable hTable,String[] family,String[] column1) throws IOException&#123;</div><div class="line"></div><div class="line">      List&lt;Row&gt; batch = new ArrayList&lt;Row&gt;();</div><div class="line">        Put put = new Put(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        put.add(family[0].getBytes(), column1[1].getBytes(), Bytes.toBytes(<span class="string">"valTest"</span>));</div><div class="line">        batch.add(put);</div><div class="line">        Get get1 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get1.addColumn(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(get1);</div><div class="line">        Delete delete = new Delete(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        delete.deleteColumns(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(delete);</div><div class="line">        Get get2 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get2.addFamily(family[0].getBytes());</div><div class="line">        batch.add(get2);</div><div class="line">        Object[] results = new Object[batch.size()];</div><div class="line">        try &#123;</div><div class="line">            hTable.batch(batch,results);</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; results.length; i++) &#123;</div><div class="line">     System.out.println(results[i]);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>results返回值有<br>null    操作与远程服务器的通信失败<br>EmptyResult    Put与Delete操作成功后的返回结果<br>Result    Get操作成功的返回结果，如果没有匹配的行或列，会返回空的Result<br>Throwable    当服务器端返回一个异常时，这个异常会按原样返回给客户端。用户可以使用这个异常检查哪里出了错，也许可以在自己的代码中自动处理异常<br>void batch(List<row> actions,Object[] results)和Object [] batch(List<row> actions)<br>不同点：后面那个批量操作一旦出现异常，将不会获取到结果<br>相同点：get、delete和put都支持，如果执行时出现问题，客户端将抛出异常并报告问题。</row></row></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>像put、delete、checkAndPut这样的修改操作是独立执行的，这意味者在一个串行方式的执行中，对于每一行必须保证行级别的操作是原子性，region服务器提供了行锁的特性，这个特性保证只有一个客户获得一行数据对应的锁，同时对该行进行修改。使用如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RowLock lock=table.lockRow(row1);</div><div class="line">Put put=new Put(row1,lock);</div><div class="line">table.put(put);</div><div class="line">table.unlockRow(lock);</div></pre></td></tr></table></figure></p>
<p>获取数据也可以加显式锁，历史提供了Get(byte[] row,RowLock lock)，但服务器根本用不到这个方法，首先不说加锁的性能影响，原因在于获取数据时，应用了多版本并发控制保证行级读操作。<br>备注：MVCC算法<br>HBase采用了MVCC算法来避免读操作去获取行锁。<br>对于写操作：<br>(w1) 获取行锁后，每个写操作都立即分配一个写序号<br>(w2) 写操作在保存每个数据cell时都要带上写序号<br>(w3) 写操作需要申明以这个写序号来完成本次写操作（标注该行）<br>对于读操作:<br>(r1) 每个读操作开始都分配一个读序号，也称为读取点<br>(r2) 读取点的值是所有的写操作完成序号中的最大整数(所有的写操作完成序号&lt;=读取点）<br>(r3) 对某个(row,column)的读取操作r来说，结果是满足写序号为“写序号&lt;=读取点这个范围内”的最大整数的所有cell值的组合</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>Put、Delete与Get对象都是Row的子类，从该继承关系中我们就可以了解到Get、Delete与Pu对象本身就只能进行单行的操作，HBase客户端还提供了一套能够进行全表扫描的API，方便用户能够快速对整张表进行扫描，以获取想要的结果—scan</p>
<h3 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h3><p>全表扫描是一种不需要行键值的操作，因此初始化时不需要指定行键值，因此就产生了不同的使用方法<br>1、不进行Scan对象创建的全表扫描<br>在该过程中，Htable对象会在扫描请求发送前隐式的创建一个scan对象，然后传递给Hbase服务器集群。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void scanWithoutInit(String tableName,String family)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            //获取全表扫描  </div><div class="line">            ResultScanner resultScanner=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            //对结果进行显示  </div><div class="line">            Iterator&lt;Result&gt; results=resultScanner.iterator();  </div><div class="line">            <span class="keyword">while</span>(results.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                Result result=results.next();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:result.raw())  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>getScanner()方法时，如果不输入指定的scan对象，则需要输入相应的列簇或者列。因此在不进行scan对象创建的扫描中，需要明确指出列簇或者列，如果需要扫描多个列簇时，该方法就无法起到作用了。<br>2、进行初始化的全表扫描<br>初始化一个scan对象，然后对该对象进行相应的配置过，通过 getScanner(Scan scan) 函数进行全表扫描。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void scanWithInit(String tableName)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建扫描类  </div><div class="line">            Scan scan=new Scan();  </div><div class="line">            scan.setStartRow(Bytes.toBytes(<span class="string">"row-1"</span>));  </div><div class="line">            scan.setStopRow(Bytes.toBytes(<span class="string">"row-9"</span>));  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            ResultScanner rs=table.getScanner(scan);  </div><div class="line">            Result result;  </div><div class="line">            <span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">            &#123;  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();  </div><div class="line">            table.close();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在上段代码中，使用了setStartRow() 与 setStopRow() 两个函数进行调优。Scan有多个函数可以进行对全表扫描做出相应的规范。<br>3、数据遍历与显示ScannerResult<br>通过上述两种方法可以发送对一张表是遍历请求，当发送后，服务器会相应的启动全表扫面程序，从而准备向客户端返回相应的数据。因此根据客户端的遍历需要对数据尽心请求，然后将请求的结果进行返回，客户端拿到后进行展示<br>（1）next()的单行返回数据的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ResultScanner rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">//进项单行获取演示  </div><div class="line">Result result=null;  </div><div class="line"><span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">&#123;  </div><div class="line">    KeyValue[] kvs=result.raw();  </div><div class="line">    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">rs.close();</div></pre></td></tr></table></figure></p>
<p>next()方法会默认想客户端请求发送一行数据请求，刚服务器端的scan程序接收到请求后会将经需要返回的数据封装成一个result对象返回给客户端，因此客户端可以通过result对象去接受该行数据。接收到的数据则跟Get中的result使用方法是相同的。<br>（2）next(int n)的多行返回数据的方法<br>next(int n)：该函数会向服务器发送多个请求，以返回多条数据请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//一次获取多个结果（行数据）进行展示  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Result[] results=null;  </div><div class="line">            <span class="keyword">while</span>((results=rs.next(2))!=null)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">for</span>(Result r:results)  </div><div class="line">                &#123;  </div><div class="line">                    KeyValue[] kvs=r.raw();  </div><div class="line">                    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                    &#123;  </div><div class="line">                        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>next(int n)函数返回的是一个result数组。用户接受到数据后可以进行相应的操作。<br>（3）迭代器遍历<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进行迭代的方式进行输出  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Iterator&lt;Result&gt; resultIterator=rs.iterator();  </div><div class="line">            <span class="keyword">while</span>(resultIterator.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                result=resultIterator.next();  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            //关闭表  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>（4）注意点<br>因为当用户发送一个scan全表扫描后，region服务器会为全表扫描创建扫描资源，因此长时间启用全表扫描的话会占用region服务器的大量资源，所以在要求在使用完scanner扫描器后尽快释放掉资源。<br>rs.close() 会告知服务其扫描器租约已经结束，服务器就会释相应的全局扫描的资源。<br>三、Scan对象<br>（1）setStartRow() / setStopRow<br>设置扫描的开始行与结束行，通过这两个可以直接确scan在扫描的范围，通过缩小范围可以减少扫描到时间，从而提高扫描的效率<br>（2）addFamily() / addColumn()<br>通过这两个函数，可以在列或者列簇上的扫描位置。HBase是面向lie出书的数据库，而同一个列簇的数据全部存放在同一个位置文件中。因此如果可以确定扫描那个一列簇时，可以减少扫描的范围，从而缩短扫描的时间。而在确定到某一个列时也会因为HBase的面向列存储使得其效率提高。<br>（3）setMaxVersion() / setMaxVersion(int version)<br>设置返回的版本数量，默认为返回最新的数据。第一个函数则会返回所有的版本数据，第二个函数可以设置返回的版本数量<br>（4）setTimeStamp(long max)<br>返回该时间戳的数据<br>（5）setTimeRange(long min,long max)<br>设定返回的时间戳的范围，只有版本值在该范围之内的数据才会被返回到客户端<br>（6）setFilter(Filter f)<br>设置过滤器，有时候扫描全表返回的数量过大时，可以通过过滤器将不符合的数据进行过滤，这样可以减少从服务器到客户端的数据传送，挺高扫描效率。<br>（7）setCacheBlocks(boole open)<br>在进行全表扫描过程中，服务器端提供了一个缓存区，该缓存区可以将指定的数据量全部放入到内存中，这样可以提高读取效率。缓存区的打开也可以通过htable客户端进行打开。在开发后用户可以通过 setCache(int n)的方式设置每次缓存的数量为多少。通过调整该函数以提高读取的效率。<br>四、总结<br>scan的全表扫描区别于其他三个操作，虽然获取数据与Get获取的数据是相同的，其与Get也具有形似的属性，可以通过修改这些属性去对数据获取进行调优，从而使得提高数据获取的效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CRUD操作&quot;&gt;&lt;a href=&quot;#CRUD操作&quot; class=&quot;headerlink&quot; title=&quot;CRUD操作&quot;&gt;&lt;/a&gt;CRUD操作&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hbase简介(第一章)</title>
    <link href="http://yoursite.com/2017/11/01/hbase%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/11/01/hbase简介/</id>
    <published>2017-11-01T01:38:49.000Z</published>
    <updated>2017-12-19T08:56:08.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="海量数据的黎明"><a href="#海量数据的黎明" class="headerlink" title="海量数据的黎明"></a>海量数据的黎明</h2><p>hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，可以帮助用户分析数据时决定如何解释这些数据，同时允许用户随时更改数据分类的方式；一旦用户更新了算法，只需要重新分析数据。Hadoop是现有数据库的一个补充，提供了数据存储无限的空间，并且针对大文件存储、批量访问和流式访问做了优化。<br>列式存储数据库，以列为单位聚合数据，然后将列值顺序存入磁盘，而行式数据库则是连续存储整行。<br>1.优点是：查询时只有涉及到的列会被读取；投影(projection)很高效；任何列都能作为索引。缺点：选择完成时，被选择的列要重新组装；INSERT/UPDATE比较麻烦。<br>2.更好的进行数据压缩：通过字典表压缩数据。经过字典表进行数据压缩后，表中的字符串才都变成数字了，比如我们的材料名可以用一张材料表，这样子在列存储就可以根据id来关联材料。<br>3.查询性能<br>我们能根据列查询结果通过为运算（&amp;或者|）进行结果合并，加快速度<br>关键步骤如下：<br>1.去字典表里找到字符串对应数字(只进行一次字符串比较)。<br>2.用数字去列表里匹配，匹配上的位置设为1。<br>3.把不同列的匹配结果进行位运算得到符合所有条件的记录下标。<br>4.使用这个下标组装出最终的结果集。<br>Hbase以列式存储的格式存储数据，传统的列式存储比较适合实时存储数据的场景，Hbase比较适合键值对的数据存取或者有序的数据存取。</p>
<h2 id="关系数据库系统的问题"><a href="#关系数据库系统的问题" class="headerlink" title="关系数据库系统的问题"></a>关系数据库系统的问题</h2><p>数据量大时，索引量也大到足以让数据库的性能直线下降。最后能够提供的查询也只剩下主键查询，最后的采取的方案就是数据分区，也就是分库分表。</p>
<h2 id="非关系型数据库系统"><a href="#非关系型数据库系统" class="headerlink" title="非关系型数据库系统"></a>非关系型数据库系统</h2><h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><p>包括数据模型、存储模型、一致性模型、物理模型、读写性能、辅助索引、故障处理、压缩、负载均衡、原子操作的读修改写、加锁等待死锁</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><h3 id="数据库的范式和反范式"><a href="#数据库的范式和反范式" class="headerlink" title="数据库的范式和反范式"></a>数据库的范式和反范式</h3><h2 id="Hbase结构"><a href="#Hbase结构" class="headerlink" title="Hbase结构"></a>Hbase结构</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="表、行、列和单元格"><a href="#表、行、列和单元格" class="headerlink" title="表、行、列和单元格"></a>表、行、列和单元格</h3><p>最基本的单位是列，一列或者多列构成一行，并由唯一的行健来确定存储。反过来，一个表中有若干行，其中每列可能有多个版本，在每个单元格中存储了不同值。行序是按照字典顺序进行排序的，意思是从左到右一次对比每一个键。关于排序：排列顺序如果跟预期的不一样，需要补键，比如  row-1 永远小于 row-2，无论后面是什么，将始终按照这个顺序排列。行健总是唯一的，否则你就是在更新同一行。行健可以是任意的字节数组，但它不一定是人直接可读。<br>一行由若干列组成，若干列构成一个列族，有助于构建语义边界，还有助于给他们设置某些特性（压缩），或者指示他们存储在内存中。一个列族所有列存储在HFile。<br>常用的引用列的格式为family：qualifier，qualifier是任意字节数组。一个列族没有列的数量限制，可以有数百万列。列值没有类型和长度的限制。NUll值在Hbase不占任何空间。<br>每一列的值或者单元格都有时间戳，不同时间戳区分不同的版本值，同一个单元格的不同版本值按照时间戳降序排序，访问时候优先读取最新的值。这样优化使得新值比老值更容易读到。用户可以指定每个值能保存的最大版本数，此外还支持谓词删除（LSM树）。<br>Hbase是一个稀疏的、分布式的、持久化的、多维的映射、由行健列键和时间戳索引。数据存储模式：(Table,RowKey,Family,Column,TimeStamp)-&gt;value</p>
<h3 id="自动分区"><a href="#自动分区" class="headerlink" title="自动分区"></a>自动分区</h3><p>Hbase中扩展和负载均衡的基本单元是region，region本质是以行键排序的连续存储的区间。如果region太大，系统会动态拆分，相反会合并region，减少存储文件数量。<br>一张表初始化只有一个region，用户不断插入数据，当数据量超过配置的最大值，会在中间键处将这个region拆分成两个大致相等的region。每一个region只能由一台regionServer加载，而一台RegionServer可以同时加载多个region。（每台regionServer1加载的最佳数量是10~1000，每个region最佳大小是1GB~2GB）。当某个region服务器由于负载过大等原因导致不可用时，系统会将该region转到其他服务器上。</p>
<h3 id="存储API"><a href="#存储API" class="headerlink" title="存储API"></a>存储API</h3><p>API提供了建表、删表、增加列族、删除列族、修改表、修改列族元数据（压缩，设置块大小）、行键值的增加，删除，查找<br>scan可以限定返回的列或者返回的版本数，可以设置过滤器。系统支持单行事务，进一步实现单行键下存储的数据的 读-修改-写（read-modify-write）序列。单元格的值可以当计数器用，并且支持原子更新，意味着这个计数器可以在一个操作中实现读写，客户端可以基于此实现一个全局强一致的计数器。协处理器(coprocessor): 可以在服务器的地址空间执行来自客户端的代码。用于实现轻量级的批处理作业，或者使用表达式分析或者汇总数据。通过包装器可以将表转换成MapReduce的输入输出目标</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>数据存储在存储文件中，称为HFile，HFile存储的是经过排序的键值映射结构。文件内部由连续的块组成，块的索引信息放在尾部，当打开HFile并加载在内存中，索引信息会优先加载到内存中，每个块的大小为64k。每个HFile都有一个块索引，通过一个磁盘查询就可以实现查询，存储文件写在HDFS中。每次更新数据，都会将数据记录在提交日志中，然后在将数据写入内存memstore,一旦内存超过一定的大小，就会移除内存，作为HFile写入磁盘。移除内存后，就会丢弃提交日志，只保留未持久化的提交日志。数据移出memstore，丢弃提交日志。采用滚动memstore可以实现不阻塞系统读写，即用空的新memstore获取更新数据，将旧的满的memstore转换成一个文件，由于memstore中的数据本来就排序好了，所以存储的时候不用再次排序。删除是在做个删除标记，让客户端无法读取到值。<br>HFile过多的时候有管家机制来处理，合并有两种类型：<br>minor合并：多个小文件合并成一个大文件，由于是多路归并所以速度快<br>major压缩合并：将region中一个列族的若干个HFile重写为一个新HFile。合并扫描所有键值对，顺序重写所有数据，重写数据的过程中会略过做了删除标记的数据。断言删除此时生效。<br>master 负责负载均衡，将繁忙服务器中的region移到负载轻的服务器中。还提供元数据的管理，例如创建表和创建列族。<br>region服务器负责为他们提供的Region提供读写功能<br>数十亿行<em>数百万列</em>数千个版本=TB级别或者PB级别的存储</p>
<h2 id="Hbase：Hadoop数据库"><a href="#Hbase：Hadoop数据库" class="headerlink" title="Hbase：Hadoop数据库"></a>Hbase：Hadoop数据库</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Hbase是一个分布式的、持久性的、强一致性的存储系统，具有近似最优的写性能和出色的读性能。它充分利用磁盘空间，支持特定列族切换可选压缩算法。Hbase支持行原子性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;海量数据的黎明&quot;&gt;&lt;a href=&quot;#海量数据的黎明&quot; class=&quot;headerlink&quot; title=&quot;海量数据的黎明&quot;&gt;&lt;/a&gt;海量数据的黎明&lt;/h2&gt;&lt;p&gt;hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch入门</title>
    <link href="http://yoursite.com/2017/10/31/elasticSearch%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/10/31/elasticSearch初步了解/</id>
    <published>2017-10-31T15:10:46.000Z</published>
    <updated>2017-11-13T12:40:24.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elasticSearch简介"><a href="#elasticSearch简介" class="headerlink" title="elasticSearch简介"></a>elasticSearch简介</h2><p>1.基于Apache Lucene构建的开源搜索引擎<br>2.基于java编写，提供简单易用的Resful API<br>3.轻松的横向扩展，可支持PB级别的结构化和非结构化的数据处理</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1.海量数据分析引擎<br>2.站内搜索引擎<br>3.数据仓库<br>备注应用：github站内搜索、维基百科、百度实时日志监控</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>版本历史 1.x-&gt;2.x-&gt;5.x</p>
<h2 id="安装head插件"><a href="#安装head插件" class="headerlink" title="安装head插件"></a>安装head插件</h2><p>安装elasticsearch-head,github地址：<a href="https://github.com/mobz/elasticsearch-head.git，然后进行npm" target="_blank" rel="external">https://github.com/mobz/elasticsearch-head.git，然后进行npm</a> install，在启动head插件（npm run start），<a href="http://localhost:9100。" target="_blank" rel="external">http://localhost:9100。</a><br>同时更改elasticsearch.yml，新增以下内容支持跨域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http.cors.enabled: <span class="literal">true</span></div><div class="line">http.cors.allow-origin: <span class="string">"*"</span></div></pre></td></tr></table></figure></p>
<h2 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h2><p>举个例子，三个节点<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: master</div><div class="line">node.master: <span class="literal">true</span></div><div class="line">network.host: 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>slave节点的配置如下，在elasticsearch.yml修改<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: slave1</div><div class="line">network.host: 127.0.0.1</div><div class="line">http.port: 8200</div><div class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"127.0.0.1"</span>]</div></pre></td></tr></table></figure></p>
<h2 id="集群和节点"><a href="#集群和节点" class="headerlink" title="集群和节点"></a>集群和节点</h2><p>集群有节点组成，每个集群有唯一的名字。 一个节点只是集群的一部分，节点通过集群名字加入集群</p>
<ul>
<li>索引(database)<br>含有相同属性的文档集合</li>
<li>类型(table)<br>索引可以定义一个或者多个类型，文档必须属于一个类型</li>
<li>文档(row)<br>文档是可以被索引的基本数据单位</li>
<li>分片<br>每个索引都有多个分片，每个分片是lucene索引</li>
<li>备份<br>拷贝一份分片就完成了分片的备份<br>备注：es默认五个分片一个备份<h2 id="es的基本用法"><a href="#es的基本用法" class="headerlink" title="es的基本用法"></a>es的基本用法</h2></li>
<li>api的基本格式：http://<ip>:<port>/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</port></ip></li>
<li>常用的动词有：GET/PUT/POST/DELETE<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3>在head插件创建索引<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:book put请求</div><div class="line">&#123;</div><div class="line">  <span class="string">"novel"</span>: &#123;</div><div class="line">    <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"title"</span>: &#123;</div><div class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用postman插件，可视化插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:people put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"settings"</span>:&#123;</div><div class="line">		<span class="string">"number_of_shards"</span>:3,</div><div class="line">		<span class="string">"number_of_replicas"</span>:1</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"mappings"</span>:&#123;</div><div class="line">		<span class="string">"man"</span>:&#123;</div><div class="line">			<span class="string">"properties"</span>:&#123;</div><div class="line">				<span class="string">"name"</span>:&#123;</div><div class="line">					<span class="string">"type"</span>:<span class="string">"text"</span></div><div class="line">				&#125;,</div><div class="line">			    <span class="string">"country"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"keyword"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"age"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"integer"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"date"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"date"</span>,</div><div class="line">			    	<span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss"</span></div><div class="line">			    &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入索引"><a href="#插入索引" class="headerlink" title="插入索引"></a>插入索引</h3><ul>
<li><p>指定文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1 Put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"lirui"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 24,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-09-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自动产生文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man POST请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"李睿"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 25,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-06-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/_update POST请求</div><div class="line">  &#123;</div><div class="line">  	<span class="string">"doc"</span>:&#123;</div><div class="line">       <span class="string">"name"</span>:<span class="string">"kobe_brant"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/ DELETE请求</div></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>使用head插件删除索引或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/ DELETE请求</div></pre></td></tr></table></figure></p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/_search POST</div><div class="line">//查询全部</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_all"</span>:&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//针对查询</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;<span class="string">"name"</span>:<span class="string">"kobe"</span>&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"sort"</span>:[</div><div class="line">    	   &#123;</div><div class="line">    	   	<span class="string">"date"</span>:&#123;</div><div class="line">    	   	  <span class="string">"order"</span>:<span class="string">"desc"</span></div><div class="line">    	   &#125;</div><div class="line">    	   &#125;</div><div class="line">    	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_name"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"country"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ul>
<li>子条件查询<br>特定字段查询所指的特定值<h4 id="query-context"><a href="#query-context" class="headerlink" title="query context"></a>query context</h4>查询过程中，除了判断文档是否满足条件外，es会计算一个_sore来标识匹配程度<br>分为全文本查询（文本类型数据）和字段级别查询（结构化数据如数字、日期）<h4 id="filter-context"><a href="#filter-context" class="headerlink" title="filter context"></a>filter context</h4>在查询时只需要判断文档是否满足条件，只有Yes或者No。</li>
<li>复合条件查询<br>以一定逻辑组合子条件查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line">      <span class="string">"should"</span>:[&#123;</div><div class="line">         <span class="string">"match"</span>:&#123;</div><div class="line">           <span class="string">"author"</span>:<span class="string">"瓦力"</span></div><div class="line">         &#125;</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">          <span class="string">"match"</span>:&#123;</div><div class="line">            <span class="string">"title"</span>:<span class="string">"瓦力"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"term"</span>:&#123;</div><div class="line">          <span class="string">"word_count"</span>:1000</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;elasticSearch简介&quot;&gt;&lt;a href=&quot;#elasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;elasticSearch简介&quot;&gt;&lt;/a&gt;elasticSearch简介&lt;/h2&gt;&lt;p&gt;1.基于Apache Lucene构
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
