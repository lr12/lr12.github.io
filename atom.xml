<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-03T10:02:11.699Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8</title>
    <link href="http://yoursite.com/2017/12/02/java8/"/>
    <id>http://yoursite.com/2017/12/02/java8/</id>
    <published>2017-12-02T07:22:38.000Z</published>
    <updated>2017-12-03T10:02:11.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>java8新特性：Lambda（匿名函数）、流、默认方法</p>
<h2 id="java中的函数"><a href="#java中的函数" class="headerlink" title="java中的函数"></a>java中的函数</h2><p>java8新增函数作为值的一种新形式。</p>
<h3 id="方法和-Lambda-作为一等公民"><a href="#方法和-Lambda-作为一等公民" class="headerlink" title="方法和 Lambda 作为一等公民"></a>方法和 Lambda 作为一等公民</h3><p>Java 8的第一个新功能是方法引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> File[] hiddenFiles= new File(<span class="string">"."</span>).listFiles(new <span class="function"><span class="title">FileFilter</span></span>()&#123;</div><div class="line">     public boolean accept(File file)&#123;</div><div class="line">         <span class="built_in">return</span> file.isHidden();</div><div class="line">     &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">File[] hiddenFiles1 = new File(<span class="string">"."</span>).listFiles(File::isHidden);</div></pre></td></tr></table></figure></p>
<h3 id="传递代码"><a href="#传递代码" class="headerlink" title="传递代码"></a>传递代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static boolean isGreenApple(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.color.equals(<span class="string">"green"</span>);</div><div class="line">	&#125;</div><div class="line">	public static boolean isHeavy(Apple apple)&#123;</div><div class="line">		<span class="built_in">return</span> apple.weight&gt;150;</div><div class="line">	&#125;</div><div class="line">	public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list,Predicate&lt;Apple&gt; p)&#123;</div><div class="line">		List&lt;Apple&gt; result=new ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(Apple apple:list)&#123;</div><div class="line">			<span class="keyword">if</span>(p.test(apple))</div><div class="line">			result.add(apple);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		List&lt;Apple&gt; list=new ArrayList&lt;Apple&gt;();</div><div class="line">		list.add(new Apple(150, <span class="string">"red"</span>));</div><div class="line">		filterApple(list, AppleExample::isHeavy);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从传递方法到Lambda"><a href="#从传递方法到Lambda" class="headerlink" title="从传递方法到Lambda"></a>从传递方法到Lambda</h3><p>不过Java 8也解决了这个问题，它引入了一套新记法（匿名函数或Lambda）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">filterApple(inventory, (Apple a) -&gt; <span class="string">"green"</span>.equals(a.getColor()) );</div><div class="line">filterApple(inventory, (Apple a) -&gt; a.weight &gt; 150 );</div></pre></td></tr></table></figure></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =</div><div class="line">transactions.stream()</div><div class="line">.filter((Transaction t) -&gt; t.getPrice() &gt; 1000)</div><div class="line">.collect(groupingBy(Transaction::getCurrency));</div></pre></td></tr></table></figure>
<p>Stream允许并提倡并行处理一个 Stream 中的元素。虽然可能乍看上去有点儿怪，但筛选一个 Collection （filterApples 应用在一个List 上）的最快方法常常是将其转换为 Stream ，进行并行处理，然后再转换回 List<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//顺序处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.stream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div><div class="line">//并行处理</div><div class="line">List&lt;Apple&gt; heavyApples =inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; 150).collect(toList());</div></pre></td></tr></table></figure></p>
<p>库会负责分块，即把大的流分成几个小的流，以便并行处理。其次，流提供的这个几乎免费的并行，只有在传递给 filter 之类的库方法的方法不会互动（比方说有可变的共享对象）时才能工作。</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8的解决方法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名<br>了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现） ，而不是由实现类提供。<br>这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明<br>中使用新的 default 关键字来表示这一点。例如，在Java 8里，你现在可以直接对 List 调用 sort 方法。它是用Java 8  List 接口中如下所示的默认方法实现的，它会调用 Collections.sort 静态方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">Collections.sort(this, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这意味着 List 的任何实体类都不需要显式实现 sort ，而在以前的Java版本中，除非提供了sort 的实现，否则这些实体类在重新编译时都会失败。</p>
<h1 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h1><h2 id="应对不断变化的需求"><a href="#应对不断变化的需求" class="headerlink" title="应对不断变化的需求"></a>应对不断变化的需求</h2><h3 id="初试牛刀：筛选绿苹果"><a href="#初试牛刀：筛选绿苹果" class="headerlink" title="初试牛刀：筛选绿苹果"></a>初试牛刀：筛选绿苹果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把颜色作为参数"><a href="#把颜色作为参数" class="headerlink" title="把颜色作为参数"></a>把颜色作为参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory,String color) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>(color.equals(apple.getColor() ) &#123;</div><div class="line">     result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三次尝试对属性做筛选"><a href="#第三次尝试对属性做筛选" class="headerlink" title="第三次尝试对属性做筛选"></a>第三次尝试对属性做筛选</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</div><div class="line">  <span class="keyword">for</span> (Apple apple: inventory)&#123;</div><div class="line">    <span class="keyword">if</span>((flag&amp;&amp;apple.getColor().equals(color))||(!flag&amp;&amp;apple.getWeight()&gt;150))&#123;</div><div class="line">      result.add(apple);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h2><p>1.传递代码/行为，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt;inventory, ApplePredicate p)&#123;</div><div class="line">  List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(Apple apple: inventory)&#123;</div><div class="line">   <span class="keyword">if</span>(p.test(apple))&#123;</div><div class="line">      result.add(apple);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">  ApplePredicate p=new AppleRedAndHeavyPredicate();</div><div class="line">  List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.多种行为，一种参数<br>行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应用的行为区分开来。这样你可以重复使用同一个方法，给它不同的行为来达到不同的目的。<br><img src="/2017/12/02/java8/行为参数化.PNG" alt=""></p>
<h2 id="对付啰嗦"><a href="#对付啰嗦" class="headerlink" title="对付啰嗦"></a>对付啰嗦</h2><p>当要把新的行为传递给filterApples方法的时候，你不得不声明好几个实现 ApplePredicate接口的类，然后实例化好几个只会提到一次的ApplePredicate对象.</p>
<h3 id="使用匿名类"><a href="#使用匿名类" class="headerlink" title="使用匿名类"></a>使用匿名类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new <span class="function"><span class="title">ApplePredicate</span></span>() &#123;</div><div class="line">  public boolean <span class="built_in">test</span>(Apple apple)&#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>匿名类在GUI经常用到，但是有缺点：1.很笨重；2.用起来费解。</p>
<h3 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; result=filterApples(list,(Apple a)-&gt;<span class="string">"red"</span>.equals(a.color));</div></pre></td></tr></table></figure>
<p><img src="/2017/12/02/java8/参数化和值参数化.PNG" alt=""></p>
<h3 id="List抽象化"><a href="#List抽象化" class="headerlink" title="List抽象化"></a>List抽象化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Predicate&lt;T&gt;&#123;</div><div class="line">   boolean <span class="built_in">test</span>(T t);</div><div class="line">&#125;</div><div class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list,Predicate&lt;T&gt; p)&#123;</div><div class="line">   List&lt;T&gt; result=new ArrayList&lt;T&gt;();</div><div class="line">   <span class="keyword">for</span>(T t:list)&#123;</div><div class="line">     <span class="keyword">if</span>(p.test(t))&#123;</div><div class="line">       result.add(t);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="真实的例子"><a href="#真实的例子" class="headerlink" title="真实的例子"></a>真实的例子</h2><h3 id="使用Comparator排序"><a href="#使用Comparator排序" class="headerlink" title="使用Comparator排序"></a>使用Comparator排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a,Apple b)-&gt; a.getWeight().compareTo(b.getWeight()));</div></pre></td></tr></table></figure>
<h3 id="用runnable执行代码块"><a href="#用runnable执行代码块" class="headerlink" title="用runnable执行代码块"></a>用runnable执行代码块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=new Thread(()-&gt;System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure>
<h3 id="GUI例子"><a href="#GUI例子" class="headerlink" title="GUI例子"></a>GUI例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnAction((ActionEvent event)-&gt;lable.setText(<span class="string">"hello"</span>));</div></pre></td></tr></table></figure>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h2><p>Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：没有名称、有参数列表函数主体、返回类型、可能还会有可抛出的异常列表。<br>特点：<br>匿名：不像普通方法有明确的名称：写得少而想得多<br>函数：Lambda函数不像方法那样属于某个特定的类。但和方法一样，有参数列表，函数主体，返回类型，还可能有可抛出的异常列表。<br>传递：Lambda表达式可作为参数传递给方法或者存储在变量中<br>简洁：无需像匿名类写很多模板代码<br><img src="/2017/12/02/java8/Lambda表达式.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//有效Lambda表达式</div><div class="line">(String s)-&gt; s.length()</div><div class="line">(Apple a)-&gt; a.weigth&gt;150</div><div class="line">(int x,int y)-&gt;&#123;</div><div class="line">   System.out.println(<span class="string">"result:"</span>);</div><div class="line">   System.out.println(x+y);</div><div class="line">&#125;</div><div class="line">()-&gt;42</div><div class="line">(Apple a1,Apple a2)-&gt; a1.getWeight().compareTo(a2.getWeight())</div></pre></td></tr></table></figure></p>
<p>Lambda语法：(parameters)-&gt;expression或者(parameters)-&gt;{statements;}<br>案例|示例<br>-|-<br>布尔表达式|(List<string> list)-&gt; list.isEmpty()<br>创建一个对象|()-&gt;new Apple(10)|<br>消费一个对象|(Apple a)-&gt;{System.out.println(a.getWeight());}<br>从一个对象中选择或选取|(String s)-&gt; s.length()<br>组合两个值|(int a,int b)-&gt;a*b<br>三比较两个对象|(Apple a1,Apple a2)-&gt; a1.getWeight.compareTo(12.getWeight())</string></p>
<h2 id="在哪里以及如何使用Lambda"><a href="#在哪里以及如何使用Lambda" class="headerlink" title="在哪里以及如何使用Lambda"></a>在哪里以及如何使用Lambda</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;java8新特性：Lambda（匿名函数）、流、默认方法&lt;/p&gt;
&lt;h2 id=&quot;java中的函数&quot;&gt;&lt;a href=&quot;#j
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络通讯</title>
    <link href="http://yoursite.com/2017/12/01/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2017/12/01/高性能网络通讯/</id>
    <published>2017-12-01T01:31:02.000Z</published>
    <updated>2017-12-02T07:58:36.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的RPC调用问题"><a href="#简单的RPC调用问题" class="headerlink" title="简单的RPC调用问题"></a>简单的RPC调用问题</h2><h3 id="简单的远程调用"><a href="#简单的远程调用" class="headerlink" title="简单的远程调用"></a>简单的远程调用</h3><h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HelloService helloService=getProxy(HelloService.class,<span class="string">"127.0.0.1"</span>,<span class="string">"2580"</span>);</div><div class="line">System.out.println(helloService.sayHello(<span class="string">"hi, charles"</span>));</div><div class="line">Public &lt;T&gt; T getProxy(Class&lt;T&gt; interfaceClass, String host, int port)&#123;</div><div class="line"><span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new</div><div class="line">Class&lt;?&gt;[] &#123;interfaceClass&#125;,</div><div class="line">new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</div><div class="line">public Object invoke(Object proxy, Method method, Object[]</div><div class="line">arguments) throws Throwable &#123;</div><div class="line">Socket socket = new Socket(host, port);</div><div class="line">ObjectOutputStream output = new</div><div class="line">ObjectOutputStream(socket.getOutputStream());</div><div class="line">output.writeUTF(method.getName());</div><div class="line">output.writeObject(method.getParameterTypes());</div><div class="line">output.writeObject(arguments);</div><div class="line">ObjectInputStream input = new</div><div class="line">ObjectInputStream(socket.getInputStream());</div><div class="line"><span class="built_in">return</span> input.readObject();&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务器端调用"><a href="#服务器端调用" class="headerlink" title="服务器端调用"></a>服务器端调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = new ServerSocket(port);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">   final Socket socket= server.accept();</div><div class="line">   new Thread(new Runnable(</div><div class="line">     public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">       ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</div><div class="line">       String methodName=input.readUTF();</div><div class="line">       Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();</div><div class="line">       Object[] arguments = (Object[])input.readObject();</div><div class="line">       ObjectOutputStream output = new</div><div class="line">       ObjectOutputStream(socket.getOutputStream());</div><div class="line">       Method method = service.getClass().getMethod(methodName,</div><div class="line">       parameterTypes);</div><div class="line">       Object result = method.invoke(service, arguments);</div><div class="line">       output.writeObject(result);</div><div class="line">     &#125;</div><div class="line">   )).start();</div><div class="line">&#125;</div><div class="line">Public String sysHello(String input)&#123;</div><div class="line">  <span class="built_in">return</span> input+<span class="string">":wellcome."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>网络传输方式：BIO</li>
<li>序列化方式：java序列化</li>
<li>线程模型：每次连接每线程</li>
<li>jdk代理</li>
</ol>
<h3 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h3><ol>
<li>协议；用什么数据格式进行传输。双方的约定</li>
<li>传输；用什么样的通道将数据发送给对方</li>
<li>线程；当接收到数据时，如何分发数据进行处理</li>
</ol>
<p><img src="/2017/12/01/高性能网络通讯/dataProtocol.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dataFlow.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/dubbohead.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/datahead.png" alt=""></p>
<h3 id="data-Header"><a href="#data-Header" class="headerlink" title="data Header"></a>data Header</h3><p>magic code<br>多协议支持<br>Telnet<br>兼容<br>Long id vs id轮转<br>同步转异步<br>过期策略+id轮转<br>扩展header（拥塞控制&amp;response header增加服务器状态）</p>
<h4 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h4><p>并行发起多个请求，但只使用一个线程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxxService.find();</div><div class="line">Future&lt;Xxx&gt; future=RpcContext.getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/01/高性能网络通讯/asy.png" alt=""></p>
<h4 id="body序列化"><a href="#body序列化" class="headerlink" title="body序列化"></a>body序列化</h4><p>数据大小（传输速度）<br>序列化和反序列速度(CPU资源)<br>兼容性和易用性<br><img src="/2017/12/01/高性能网络通讯/序列化.png" alt=""><br><img src="/2017/12/01/高性能网络通讯/size_dfl.png" alt=""></p>
<ul>
<li>远程服务调用时间主要消耗<br>网络开销主要是数据包大小<br>生产环境某应用容量测试</li>
<li>dubbo序列化主要优化目标：<br>减少数据包大小<br>提高序列化反序列化性能</li>
</ul>
<h2 id="IO-model"><a href="#IO-model" class="headerlink" title="IO model"></a>IO model</h2><p>IO Model、NIO、TCP选项、IRQ</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>IO请求分为两个阶段：<br>等待数据就绪；从内存缓存区拷贝数据到进程缓存区<br>Unix5种IO模型：<br>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO<br><img src="/2017/12/01/高性能网络通讯/io.png" alt=""></p>
<h3 id="NIO的好处"><a href="#NIO的好处" class="headerlink" title="NIO的好处"></a>NIO的好处</h3><ul>
<li>事件驱动模型，避免多线程和单线程处理多任务。</li>
<li>IO读写不再阻塞，而是返回0.</li>
<li>基于block的传输，比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了java网络应用的可伸缩性和实用性</li>
</ul>
<h3 id="NIO-reactor模式"><a href="#NIO-reactor模式" class="headerlink" title="NIO reactor模式"></a>NIO reactor模式</h3><ul>
<li>NIO网络框架典型模式</li>
<li>核心组件<br>同步事件多路复用器(event loop 事件分离)<br>分发器（事件派发，可以多线程）<br>请求处理（事件处理，业务代码）</li>
<li>mina netty都是此模式的实现</li>
</ul>
<p><img src="/2017/12/01/高性能网络通讯/reactor.png" alt=""></p>
<h3 id="NIO优化-TCP选项"><a href="#NIO优化-TCP选项" class="headerlink" title="NIO优化-TCP选项"></a>NIO优化-TCP选项</h3><p>合理设置tcp/ip在某些时候可以起到显著的效果</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><ul>
<li>Socket缓冲区至少应该是连接的MSS的四倍，MSS=MTU+40，一般以太网的MTU等于1500字节，MSS：最大分段大小，MTU：最大传输单元</li>
<li>在以太网上4k是不够的，增加到16k，吞吐量增加40%</li>
<li>对于一次性发送大量数据的应用，增加发送缓冲区到48k、64k才是可能唯一有效提高性能的方式。为了最大化性能，发送缓冲区可能至少要跟BDP（带宽延迟乘积）一样大小。</li>
<li>对于大量接收数据的应用，提高接收缓冲区，能减少发送端的阻塞。</li>
<li>如果应用既发送大量数据，也接收大量数据，recvbuffer和send buffer应该同时增加</li>
</ul>
<h3 id="带宽延迟乘积–BDP"><a href="#带宽延迟乘积–BDP" class="headerlink" title="带宽延迟乘积–BDP"></a>带宽延迟乘积–BDP</h3><p>为了优化TCP 吞吐量（假设为合理的无差错传输路径），发送端应该发送足够的数据包以填满发送端和接收端之间的逻辑管道。<br>逻辑管道的容量计算：BDP= 带宽x RTT</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>nagle算法通过将缓冲区的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。<br>实时性要求较高的应用，需要关闭算法，否则响应时间会受影响。</p>
<h3 id="SO-KeepAlive"><a href="#SO-KeepAlive" class="headerlink" title="SO_KeepAlive"></a>SO_KeepAlive</h3><p>Socket.setKeepAlive(boolean)<br>这是TCP层，而非HTTP协议的keep-alive概念,默认一般为false，用于TCP连接保活，默认间<br>隔2个小时.TCP心跳间隔是全局设置，建议在应用层做心跳</p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断此时都是运行在在硬件中断相应的cpu上。<br>如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>
<h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS (Receive Packet Steering) 基本原理<br>– 根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，<br>– 从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="线程模型内容"><a href="#线程模型内容" class="headerlink" title="线程模型内容"></a>线程模型内容</h3><ul>
<li>Reactor线程模型</li>
<li>序列化线程</li>
<li>业务线程派发策略</li>
</ul>
<h3 id="Reator单线程模型"><a href="#Reator单线程模型" class="headerlink" title="Reator单线程模型"></a>Reator单线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor单线程.png" alt=""></p>
<h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h3><p><img src="/2017/12/01/高性能网络通讯/reactor多线程.png" alt=""></p>
<h3 id="线程派发策略"><a href="#线程派发策略" class="headerlink" title="线程派发策略"></a>线程派发策略</h3><p>五个事件：连接建立（Connection）、连接断开（Disconnection）、消息已接受(MessageReceived)、消息已发送（sent）、异常（Exception  caught）<br>派发策略：1.五个事件共享一个线程池；2.Connection和disconnect使用独立的线程池，size为1；3.全部不派发线程池，IO线程处理</p>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p>有这样一个模块<br>cpu 计算时间 18ms （ running ）<br>查询数据库，网络 io 时间 80ms （ waiting ）<br>解析结果 2ms 如果服务器 2CPU ，大家看看这里多少线程合适<br>充分利用cpu资源：<br>线程数量=100/20*2=10<br>从CPU角度而言<br>线程数量=（cpu时间+cpu等待时间）/cpu时间*cpu数量</p>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p>有这样一个模块：<br>线程同步锁 ( 数据库事务锁 )50ms<br>cpu 时间 18ms<br>查询数据库，网络 io 时间 80ms<br>解析结果 2ms  如果服务器有 2 个 CPU ，这个模块线程多少合适？<br>CPU计算为瓶颈，计算线程数量<br>线程数=(18 + 2 + 50 + 80) /20 *2 = 15<br>以线程同步锁为瓶颈，计算线程数<br>线程数=(50 + 18 + 2 + 80) / 50 * 1/1 = 3<br>公式一：<br>线程数量= （线程总时间/ 瓶颈资源时间）*  瓶颈资源的线程并行数<br>准确的讲<br>瓶颈资源的线程并行数= 瓶颈资源的总份数/ 单次请求占用瓶颈资源的份数<br>约束：<br>在计算的时候，对同一类资源的消耗时间进行合并<br>公式二：<br>QPS=1000/线程总时间*线程数<br>注意：如果线程数不够，则QPS减少。线程本身也要消耗资源，如果线程太多，同样QPS会下降。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>• 其他优化<br>– Lock free data structure（无锁数据结构）<br>– Buffer copy (Zero Copy)：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。一个关键的api是java.nio.channel.FileChannel的transferTo()方法。我们可以用transferTo()来把bytes直接从调用它的channel传输到另一个writable byte channel，中间不会使data经过应用程序。<br>– JVM GC tuning<br>– Context Switch 线程上下文切换<br>– 同步转异步<br>– JavassistProxy改进JDK proxy<br>  注意性能的短板效应，避免过度优化<br>– 优化的代价，通常是牺牲未来的可能性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的RPC调用问题&quot;&gt;&lt;a href=&quot;#简单的RPC调用问题&quot; class=&quot;headerlink&quot; title=&quot;简单的RPC调用问题&quot;&gt;&lt;/a&gt;简单的RPC调用问题&lt;/h2&gt;&lt;h3 id=&quot;简单的远程调用&quot;&gt;&lt;a href=&quot;#简单的远程调用&quot; class
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch深入搜索</title>
    <link href="http://yoursite.com/2017/11/27/es%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2017/11/27/es全文搜索/</id>
    <published>2017-11-27T02:55:25.000Z</published>
    <updated>2017-11-28T08:27:07.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><h2 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h2><h3 id="基于词项查询"><a href="#基于词项查询" class="headerlink" title="基于词项查询"></a>基于词项查询</h3><p>如 term 或 fuzzy 这样的底层查询不需要分析阶段，它们对单个词项进行操作。用 term 查询词项 Foo 只要在倒排索引中查找 准确词项 ，并且用 TF/IDF 算法为每个包含该词项的文档计算相关度评分score 。<br>记住 term 查询只对倒排索引的词项精确匹配，这点很重要，它不会对词的多样性进行处理（如， foo 或 FOO ）。这里，无须考虑词项是如何存入索引的。如果是将 [“Foo”,”Bar”] 索引存入一个不分析的（ not_analyzed ）包含精确值的字段，或者将 Foo Bar 索引到一个带有 whitespace 空格分析器的字段，两者的结果都会是在倒排索引中有 Foo 和 Bar 这两个词。</p>
<h3 id="基于全文查询"><a href="#基于全文查询" class="headerlink" title="基于全文查询"></a>基于全文查询</h3><p>像 match 或 query_string 这样的查询是高层查询，它们了解字段映射的信息：<br>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。<br>如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。<br>但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分。<br>当我们想要查询一个具有精确值的 not_analyzed 未分析字段之前， 需要考虑，是否真的采用评分查询，或者非评分查询会更好。<br>单词项查询通常可以用是、非这种二元问题表示，所以更适合用过滤， 而且这样做可以有效利用缓存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"constant_score"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">          <span class="string">"term"</span>:&#123;</div><div class="line">            <span class="string">"sex"</span>:<span class="string">"男"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h2><p>匹配查询match是核心查询，它是一个高级全文查询 ，这表示它既能处理全文字段，又能处理精确字段。</p>
<h3 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:<span class="string">"quick"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询步骤如下：</p>
<ol>
<li>检查字段类型；标题 title 字段是一个 string 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。</li>
<li>分析查询字符串；将查询的字符串quick传入标准分析器中，输出的结果是单个项 quick 。因为只有一个单词项，所以 match 查询执行的是单个底层 term 查询。</li>
<li>查找匹配文档；用 term 查询在倒排索引中查找 quick 然后获取一组包含该项的文档，本例的结果是文档：1、2 和 3 。</li>
<li>为每个文档评分；用 term 查询计算每个文档相关度评分score ，这是种将 词频（term frequency，即词 quick 在相关文档的 title 字段中出现的频率）和反向文档频率（inverse document frequency，即词 quick 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。<h3 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">        <span class="string">"title"</span>:<span class="string">"BROWN DOG"</span></div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//返回结果解释</div><div class="line">文档 4 最相关，因为它包含词 <span class="string">"brown"</span> 两次以及 <span class="string">"dog"</span> 一次。</div><div class="line">文档 2、3 同时包含 brown 和 dog 各一次，而且它们 title 字段的长度相同，所以具有相同的评分。</div><div class="line">文档 1 也能匹配，尽管它只有 brown 没有 dog 。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 match 查询必须查找两个词（ [“brown”,”dog”] ），它在内部实际上先执行两次 term 查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个 term 查询包入一个 bool 查询中。<br>以上示例告诉我们一个重要信息：即任何文档只要 title 字段里包含 指定词项中的至少一个词 就能匹配，被匹配的词项越多，文档就越相关。</p>
<h3 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h3><p>用 任意 查询词项匹配文档可能会导致结果中出现不相关的长尾。 这是种散弹式搜索。可能我们只想搜索包含 所有 词项的文档，也就是说，不去匹配 brown OR dog ，而通过匹配 brown AND dog 找到所有文档。<br>match 查询还可以接受 operator 操作符作为输入参数，默认情况下该操作符是 or 。我们可以将它修改成 and 让所有指定词项都必须匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"title"</span>:&#123;</div><div class="line">           <span class="string">"query"</span>: <span class="string">"brown dog"</span>,</div><div class="line">           <span class="string">"operator"</span>:<span class="string">"and"</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h3><p>在 所有 与 任意 间二选一有点过于非黑即白。 如果用户给定 5 个查询词项，想查找只包含其中 4 个的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。<br>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。<br>match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">        <span class="string">"query"</span>:<span class="string">"a brown dog"</span>,</div><div class="line">        <span class="string">"minimun_should_match"</span>:<span class="string">"75%"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当给定百分比的时候， minimum_should_match 会做合适的事情：在之前三词项的示例中， 75% 会自动被截断成 66.6% ，即三个里面两个词。无论这个值设置成什么，至少包含一个词项的文档才会被认为是匹配的。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>在 组合过滤器 中，我们讨论过如何使用 bool 过滤器通过 and 、 or 和 not 逻辑组合将多个过滤器进行组合。在查询中， bool 查询有类似的功能，只有一个重要的区别。<br>过滤器做二元判断：文档是否应该出现在结果中？但查询更精妙，它除了决定一个文档是否应该被包括在结果中，还会计算文档的 相关程度 。<br>与过滤器一样， bool 查询也可以接受 must 、 must_not 和 should 参数下的多个查询语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /index/<span class="built_in">type</span>/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"must"</span>:     &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;,</div><div class="line">      <span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"lazy"</span>  &#125;&#125;,</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">                  &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h3><p>以上的查询结果返回 title 字段包含词项 quick 但不包含 lazy 的任意文档。目前为止，这与 bool 过滤器的工作方式非常相似。<br>区别就在于两个 should 语句，也就是说：一个文档不必包含 brown 或 dog 这两个词项，但如果一旦包含，我们就认为它们更相关。<br>bool查询会为每个文档计算相关度评分，再将所有匹配must和should语句的分数score求和，最后除以must和should语句总数，must_not不会影响评分，只会将不想关的文档排除。</p>
<h3 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h3><p>所有 must 语句必须匹配，所有 must_not 语句都必须不匹配，但有多少 should 语句应该匹配呢？ 默认情况下，没有 should 语句是必须匹配的，只有一个例外：那就是当没有 must 语句的时候，至少有一个 should 语句必须匹配。<br>就像我们能控制 match 查询的精度 一样，我们可以通过 minimum_should_match 参数控制需要匹配的 should 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">      <span class="string">"should"</span>: [</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</div><div class="line">      ],</div><div class="line">      <span class="string">"minimum_should_match"</span>: 2</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个查询结果会将所有满足以下条件的文档返回： title 字段包含 “brown” AND “fox” 、 “brown” AND “dog” 或 “fox” AND “dog” 。如果有文档包含所有三个条件，它会比只包含两个的文档更相关。</p>
<h2 id="bool匹配"><a href="#bool匹配" class="headerlink" title="bool匹配"></a>bool匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">//以下两两是等价的</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown fox"</span>&#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//must</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>:    <span class="string">"brown fox"</span>,</div><div class="line">            <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"must"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//</div><div class="line">&#123;</div><div class="line">    <span class="string">"match"</span>: &#123;</div><div class="line">        <span class="string">"title"</span>: &#123;</div><div class="line">            <span class="string">"query"</span>: <span class="string">"quick brown fox"</span>,</div><div class="line">            <span class="string">"minimum_should_match"</span>: <span class="string">"75%"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="string">"bool"</span>: &#123;</div><div class="line">    <span class="string">"should"</span>: [</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</div><div class="line">      &#123; <span class="string">"term"</span>: &#123; <span class="string">"title"</span>: <span class="string">"quick"</span> &#125;&#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"minimum_should_match"</span>: 2</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询语句提升比重"><a href="#查询语句提升比重" class="headerlink" title="查询语句提升比重"></a>查询语句提升比重</h2><p>我们可以通过指定 boost 来控制任何查询语句的相对的权重， boost 的默认值为 1 ，大于 1 会提升一个语句的相对权重。<br>boost 参数被用来提升一个语句的相对权重（ boost 值大于 1 ）或降低相对权重（ boost 值处于 0 到 1 之间），但是这种提升或降低并不是线性的，换句话说，如果一个 boost 值为 2 ，并不能获得两倍的评分score 。<br>相反，新的评分score 会在应用权重提升之后被 归一化 ，每种类型的查询都有自己的归一算法，细节超出了本书的范围，所以不作介绍。简单的说，更高的 boost 值为我们带来更高的评分 score 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    <span class="string">"query"</span>: &#123;</div><div class="line">        <span class="string">"bool"</span>: &#123;</div><div class="line">            <span class="string">"must"</span>: &#123;</div><div class="line">                <span class="string">"match"</span>: &#123;  </div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>:    <span class="string">"full text search"</span>,</div><div class="line">                        <span class="string">"operator"</span>: <span class="string">"and"</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"should"</span>: [</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Elasticsearch"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 3</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;,</div><div class="line">                &#123; <span class="string">"match"</span>: &#123;</div><div class="line">                    <span class="string">"content"</span>: &#123;</div><div class="line">                        <span class="string">"query"</span>: <span class="string">"Lucene"</span>,</div><div class="line">                        <span class="string">"boost"</span>: 2</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="控制分析"><a href="#控制分析" class="headerlink" title="控制分析"></a>控制分析</h2><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>在搜索时，顺序有些许不同：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default 的分析器，默认为standard 标准分析器<br>有时，在索引时和搜索时使用不同的分析器是合理的。 我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。<br>为了区分，Elasticsearch 也支持一个可选的 search_analyzer 映射，它仅会应用于搜索时（ analyzer 还用于索引时）。还有一个等价的 default_search 映射，用以指定索引层的默认配置。<br>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：<br>查询自己定义的 analyzer ，否则<br>字段映射里定义的 search_analyzer ，否则<br>字段映射里定义的 analyzer ，否则<br>索引设置中名为 default_search 的分析器，默认为索引设置中名为 default 的分析器，默认为standard 标准分析器</p>
<h2 id="被破坏的相关度！"><a href="#被破坏的相关度！" class="headerlink" title="被破坏的相关度！"></a>被破坏的相关度！</h2><p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。<br>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤： 用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。<br>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。<br>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。<br>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。 相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。<br>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。<br>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。<br>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。<br>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF。不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h1 id="多字段搜索"><a href="#多字段搜索" class="headerlink" title="多字段搜索"></a>多字段搜索</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html</a></p>
<h1 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/proximity-matching.html</a></p>
<h1 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a>控制相关度</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/guide/current/scoring-theory.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全文搜索&quot;&gt;&lt;a href=&quot;#全文搜索&quot; class=&quot;headerlink&quot; title=&quot;全文搜索&quot;&gt;&lt;/a&gt;全文搜索&lt;/h1&gt;&lt;h2 id=&quot;基于词项与基于全文&quot;&gt;&lt;a href=&quot;#基于词项与基于全文&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>dubbo_framework_extensions</title>
    <link href="http://yoursite.com/2017/11/27/dubbo-framework-extensions/"/>
    <id>http://yoursite.com/2017/11/27/dubbo-framework-extensions/</id>
    <published>2017-11-27T02:41:29.000Z</published>
    <updated>2017-11-30T03:31:12.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/27/dubbo-framework-extensions/do.png" alt="do"></p>
<h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><h3 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h3><p><img src="/2017/11/27/dubbo-framework-extensions/framework1.png" alt="do"><br><img src="/2017/11/27/dubbo-framework-extensions/extension.png" alt="do"></p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p><img src="/2017/11/27/dubbo-framework-extensions/modules.png" alt="do"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="IOC-amp-AOP"><a href="#IOC-amp-AOP" class="headerlink" title="IOC&amp;AOP"></a>IOC&amp;AOP</h3><p>对于扩展实现IOC依赖注入功能：<br>举例来说：接口A，实现者A1、A2。接口B，实现者B1、B2。<br>现在实现者A1含有setB()方法，会自动注入一个接口B的实现者，此时注入B1还是B2呢？都不是，而是注入一个动态生成的接口B的实现者B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能.对扩展采用装饰器模式进行功能增强，类似AOP实现的功能.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//IOC</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private LoadBalance loadbalance;</div><div class="line">   public void <span class="built_in">set</span>LoadBalance(LoadBalance loadbalance) &#123;</div><div class="line">       this.loadbalance = loadbalance;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">//AOP</div><div class="line">public XxxCluster implements Cluster &#123;</div><div class="line">   private Cluster cluster;</div><div class="line">   public XxxCluster(Cluster cluster) &#123;</div><div class="line">      this.cluster = cluster;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/27/dubbo-framework-extensions/protocol.png" alt="protocol"><br><img src="/2017/11/27/dubbo-framework-extensions/filter.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/proxyFactory.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/javassist.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/cluster.png" alt=""><br><img src="/2017/11/27/dubbo-framework-extensions/remoting.png" alt=""></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//Application shared</div><div class="line">&lt;dubbo:application name=<span class="string">"xxx"</span> /&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"127.0.0.1"</span> /&gt;</div><div class="line">//provider</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"7777"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> /&gt;</div><div class="line">//consumer</div><div class="line">&lt;dubbo:reference interface=<span class="string">"xxxx"</span> /&gt;</div><div class="line">&lt;dubbo:consumer timeout /&gt;</div></pre></td></tr></table></figure>
<h3 id="config-type"><a href="#config-type" class="headerlink" title="config type"></a>config type</h3><ul>
<li>Service Identification<br>group<br>version<br>interface</li>
<li>Service Governance<br>deprecated<br>application</li>
<li>performance optimize<br>timeout<br>threads</li>
</ul>
<h3 id="config-Override"><a href="#config-Override" class="headerlink" title="config Override"></a>config Override</h3><p>method 继承 接口 继承缺失，消费者继承服务提供者</p>
<h3 id="编程配置"><a href="#编程配置" class="headerlink" title="编程配置"></a>编程配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServiceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“xxx”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– <span class="built_in">export</span>();</div><div class="line">• ReferenceConfig</div><div class="line">– <span class="built_in">set</span>Application(new ApplicationConfig(“yyy”));</div><div class="line">– <span class="built_in">set</span>Registry(new RegistryConfig(“10.20.153.186”));</div><div class="line">– <span class="built_in">set</span>Interface(“com.xxx.XxxService”);</div><div class="line">– get();</div></pre></td></tr></table></figure>
<h3 id="context-amp-trace"><a href="#context-amp-trace" class="headerlink" title="context&amp;trace"></a>context&amp;trace</h3><p><img src="/2017/11/27/dubbo-framework-extensions/context&amp;trace.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadLocal context</div><div class="line">RpcContext.getContext().getRemoteHost();</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>,<span class="string">"1"</span>);</div><div class="line">RpcContext.getContext().getAttachment(<span class="string">"index"</span>);</div><div class="line">like http cookie</div></pre></td></tr></table></figure></p>
<h3 id="GenericService"><a href="#GenericService" class="headerlink" title="GenericService"></a>GenericService</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// java interface</div><div class="line">MemberService memberService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">memberService.findPeople(memberId);</div><div class="line">//Generic interface POJO需要转化为map</div><div class="line">GenericService genericService=application.getBean(<span class="string">"memberService"</span>);</div><div class="line">genericService.invoke(<span class="string">"findPeople"</span>,new String[]&#123;<span class="string">"java.lang.String"</span>&#125;,new Object[]&#123;memberId&#125;);</div><div class="line">//java implement</div><div class="line">public class MemberServiceImpl implements MemberService&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//Generic implement</div><div class="line">public class MemberServiceImpl implement GenericService&#123;</div><div class="line">  public Object invoke(String method,String[] ptypes,Object[] args)&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="local-amp-mock"><a href="#local-amp-mock" class="headerlink" title="local&amp;mock"></a>local&amp;mock</h3><p><img src="/2017/11/27/dubbo-framework-extensions/mock.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dubbo://10.20.153.10?<span class="built_in">local</span>=<span class="literal">true</span>&amp;mock=<span class="literal">true</span></div><div class="line">Constructor:</div><div class="line">public XxxServiceLocal(XxxService xxxService)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public <span class="function"><span class="title">XxxServiceMock</span></span>()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/27/dubbo-framework-extensions/do.png&quot; alt=&quot;do&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;framework&quot;&gt;&lt;a href=&quot;#framework&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>dubbo功能介绍</title>
    <link href="http://yoursite.com/2017/11/24/dubbo%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/11/24/dubbo功能介绍/</id>
    <published>2017-11-24T14:53:33.000Z</published>
    <updated>2017-11-29T02:57:06.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo简要介绍"><a href="#dubbo简要介绍" class="headerlink" title="dubbo简要介绍"></a>dubbo简要介绍</h1><h2 id="dubbo是什么"><a href="#dubbo是什么" class="headerlink" title="dubbo是什么"></a>dubbo是什么</h2><p>它是分布式服务框架，高性能和透明化的RPC远程服务调用方案；SOA服务治理方案</p>
<h2 id="如何使用dubbo"><a href="#如何使用dubbo" class="headerlink" title="如何使用dubbo"></a>如何使用dubbo</h2><p>本地服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>远程服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"xxxServiceImpl"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"xxxInterface"</span> ref=<span class="string">"xxxService"</span>&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span> interface=<span class="string">"xxxInterface"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="dubbo能做什么"><a href="#dubbo能做什么" class="headerlink" title="dubbo能做什么"></a>dubbo能做什么</h2><h3 id="透明化的远程调用"><a href="#透明化的远程调用" class="headerlink" title="透明化的远程调用"></a>透明化的远程调用</h3><p>就像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p>
<h3 id="软负载均衡和容错机制"><a href="#软负载均衡和容错机制" class="headerlink" title="软负载均衡和容错机制"></a>软负载均衡和容错机制</h3><p>可在内网替代F5等硬件负载均衡器</p>
<h3 id="服务自动注册与发现"><a href="#服务自动注册与发现" class="headerlink" title="服务自动注册与发现"></a>服务自动注册与发现</h3><p>不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加和删除服务提供者。</p>
<h2 id="dubbo基本原理"><a href="#dubbo基本原理" class="headerlink" title="dubbo基本原理"></a>dubbo基本原理</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本原理.png" alt="dubbo基本原理"></p>
<h2 id="dubbo-rpc基本功能"><a href="#dubbo-rpc基本功能" class="headerlink" title="dubbo rpc基本功能"></a>dubbo rpc基本功能</h2><p><img src="/2017/11/24/dubbo功能介绍/dubbo基本功能.png" alt="dubbo-rpc 基本功能"></p>
<h3 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h3><p>实际使用中发现服务器比消费者更清楚一个方法的执行时间和是否允许重试等信息，所以增加允许服务提供者为消费者设置缺省值，并采用继承风格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//服务提供者配置</div><div class="line">&lt;dubbo:service timeout=<span class="string">"3000"</span> retries=<span class="string">"0"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=3000&amp;retries=0</div><div class="line">服务提供者提供配置参考值</div><div class="line">//注册中心</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=4000&amp;retries=1</div><div class="line">注册中心可在服务治理过程中修改配置值，如果不修改则使用provider的配置值</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">""</span> interface=<span class="string">""</span> timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">dubbo://10.20.130.230:20880/xxxService?timeout=5000&amp;retries=2</div><div class="line">服务消费者如果出现网络慢等因素，可再修改配置值，如果不修改使用前面的配置值</div></pre></td></tr></table></figure></p>
<h3 id="可编程配置"><a href="#可编程配置" class="headerlink" title="可编程配置"></a>可编程配置</h3><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 服务实现</div><div class="line">XxxService xxxService = new XxxServiceImpl();</div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"xxx"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务提供者协议配置</div><div class="line">ProviderConfig provider = new ProviderConfig();</div><div class="line">provider.setProtocol(<span class="string">"dubbo"</span>);</div><div class="line">provider.setPort(12345);</div><div class="line">provider.setThreads(200);</div><div class="line">// 服务提供者暴露服务配置</div><div class="line">ServiceConfig service = new ServiceConfig();</div><div class="line">service.setApplication(application);</div><div class="line">service.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">service.setProvider(provider); // 多个提供者可以用<span class="built_in">set</span>Providers()</div><div class="line">service.setInterfaceClass(XxxService.class);</div><div class="line">service.setRef(xxxService);</div><div class="line">service.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">service.export(); // 触发服务注册</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!--服务实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"xxxService"</span> class=<span class="string">"com.alibaba.xxx.XxxServiceImpl"</span> /&gt;</div><div class="line">&lt;!--当前应用配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"morgan"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者协议配置 --&gt;</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> port=<span class="string">"12345"</span> threads=<span class="string">"200"</span> /&gt;</div><div class="line">&lt;!-- 服务提供者暴露服务配置 --&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> ref=<span class="string">"xxxService"</span> /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h4><ol>
<li><p>编程配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(<span class="string">"yyy"</span>);</div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(<span class="string">"10.20.130.230:9090"</span>);</div><div class="line">registry.setUsername(<span class="string">"aaa"</span>);</div><div class="line">registry.setPassword(<span class="string">"bbb"</span>);</div><div class="line">// 服务消费者缺省值配置</div><div class="line">ConsumerConfig consumer = new ConsumerConfig();</div><div class="line">consumer.setTimeout(5000);</div><div class="line">consumer.setRetries(2);</div><div class="line">// 引用远程服务</div><div class="line">ReferenceConfig reference = new ReferenceConfig();</div><div class="line">reference.setApplication(application);</div><div class="line">reference.setRegistry(registry); // 多个注册中心可以用<span class="built_in">set</span>Registries()</div><div class="line">reference.setConsumer(consumer);</div><div class="line">reference.setInterfaceClass(XxxService.class);</div><div class="line">reference.setVersion(<span class="string">"1.0.0"</span>);</div><div class="line">XxxService xxxService = reference.get(); // 获取远程xxxService代理</div></pre></td></tr></table></figure>
</li>
<li><p>schema配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">xmlns:dubbo=<span class="string">"http://repo.alibaba-inc.com/schema/dubbo"</span></div><div class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo</div><div class="line">http://repo.alibaba-inc.com/schema/dubbo/dubbo-component-2.0.xsd"&gt;</div><div class="line">&lt;!-- 当前应用信息配置 --&gt;</div><div class="line">&lt;dubbo:application name=<span class="string">"kylin"</span> /&gt;</div><div class="line">&lt;!-- 连接注册中心配置 --&gt;</div><div class="line">&lt;dubbo:registry address=<span class="string">"10.20.130.230:9090"</span> username=<span class="string">"admin"</span></div><div class="line">password=<span class="string">"hello1234"</span> /&gt;</div><div class="line">&lt;!-- 服务消费者缺省值配置 --&gt;</div><div class="line">&lt;dubbo:consumer timeout=<span class="string">"5000"</span> retries=<span class="string">"2"</span> /&gt;</div><div class="line">&lt;!-- 引用远程服务 --&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"xxxService"</span></div><div class="line">interface=<span class="string">"com.alibaba.xxx.XxxService"</span> version=<span class="string">"1.0.0 /&gt;</span></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h3><p>当一个接口有不同实现，可以用group区分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//服务提供者</div><div class="line">&lt;dubbo:service group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:service group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">//服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"fsService"</span> group=<span class="string">"feeback"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"mservice"</span> group=<span class="string">"member"</span> interface=<span class="string">"com.xxx.IndexService"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用<br>一般处理步骤<br>1）在低压力时间段，先升级一半提供者为新版本<br>2）再将所有消费者升级为新版本<br>3）然后将剩下的一半提供者升级为新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">服务提供者</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div><div class="line">服务消费者</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"1.0.0"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> version=<span class="string">"2.0.0"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="指定调用"><a href="#指定调用" class="headerlink" title="指定调用"></a>指定调用</h3><p>点对点直连/指定调用需求（开发/测试环境）。在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表。</p>
<ol>
<li><p>spring配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference interface=<span class="string">"com.alibaba.xxx.XxxService"</span> url=<span class="string">"dubbo://localhost:20890"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>java -D参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>映射文件方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">– java -Ddubbo.resolve.file=xxx.properties</div><div class="line">– com.alibaba.xxx.XxxService=dubbo://localhost:20890</div></pre></td></tr></table></figure>
</li>
<li><p>路由方式<br>– 参数匹配 host、clssifier</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//对于所有调用com.foo.BarService接口的消费者，如果消费者的ip是<span class="string">"10.20.153.10"</span>，那么这个消费者将调用ip为<span class="string">"10.20.153.11"</span>的提供者，这样，通过动态配置注册中心的路由规则，就实现了动态指定某个提供者的需求。</div><div class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</div><div class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</div><div class="line">registry.register(URL.valueOf(<span class="string">"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule="</span>+ URL.encode(<span class="string">"http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11"</span>)));</div></pre></td></tr></table></figure>
</li>
<li><p>修改version<br>不推荐</p>
</li>
</ol>
<h3 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h3><p>共用注册中心，开发人员机器上的服务提供者被误调，影响其他开发人员（开发、测试环境）<br>场景：为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p><dubbo:registry register="false"><br><img src="/2017/11/24/dubbo功能介绍/只订阅结构.png" alt="只订阅"></dubbo:registry></p>
<h3 id="集群和容错"><a href="#集群和容错" class="headerlink" title="集群和容错"></a>集群和容错</h3><p><img src="/2017/11/24/dubbo功能介绍/集群容错.png" alt="集群容错"><br>将Directory中的多个Invoker伪装成一个Invoker, 对上层透明，包含集群的容错机制<br>Cluster接口定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SPI(FailoverCluster.NAME)</div><div class="line">public interface Cluster &#123;</div><div class="line">    @Adaptive</div><div class="line">    &lt;T&gt; Invoker&lt;T&gt;join(Directory&lt;T&gt; directory) throws RpcException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cluster可以看做是工厂类， 将目录directory下的invoker合并成一个统一的Invoker，根据不同集群策略的Cluster创建不同的Invoker我们来看下默认的失败转移，当出现失败重试其他服务的策略, 这个Cluster实现很简单就是创建FailoverCluseterInvoker对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class FailoverCluster implements Cluster &#123;</div><div class="line">    public final static String NAME =<span class="string">"failover"</span>;</div><div class="line">    public&lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory)throws RpcException&#123;</div><div class="line">        <span class="built_in">return</span> new FailoverClusterInvoker&lt;T&gt;(directory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/集群方案.png" alt="集群方案"><br>1）AvailableCluster: 获取可用的调用。遍历所有Invokers判断Invoker.isAvalible,只要一个有为true直接调用返回，不管成不成功<br>2）BroadcastCluster: 广播调用。遍历所有Invokers, 逐个调用每个调用catch住异常不影响其他invoker调用<br>3）FailbackCluster: 失败自动恢复， 对于invoker调用失败， 后台记录失败请求，任务定时重发, 通常用于通知<br>4）FailfastCluster: 快速失败，只发起一次调用，失败立即保错，通常用于非幂等性操作<br>5）FailoverCluster: 失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟<br>（1）   目录服务directory.list(invocation) 列出方法的所有可调用服务<br>获取重试次数，默认重试两次<br>（2）   根据LoadBalance负载策略选择一个Invoker<br>（3）   执行invoker.invoke(invocation)调用<br>（4）   调用成功返回<br>调用失败小于重试次数，重新执行从3）步骤开始执行<br>       调用次数大于等于重试次数抛出调用失败异常<br>6）FailsafeCluster: 失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。<br>7）ForkingCluster: 并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。<br>8）  MergeableCluster: 分组聚合， 按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。<br>这个还蛮有意思，我们分析下是如何实现的<br>（1）   根据MERGE_KEY从url获取参数值<br>（2）   为空不需要merge， 正常调用<br>（3）   按group分组调用，将返回接口保存到集合中<br>（4）   获取MERGE_KEY如果是默认的话，获取默认merge策略，主要根据返回类型判断<br>（5）   如果不是，获取自定义的merge策略<br>（6）   Merge策略合并调用结果返回<br><img src="/2017/11/24/dubbo功能介绍/merge.png" alt="merge"><br>9）MockClusterWrapper: 具备调用mock功能是其他Cluster包装<br>获取url的MOCK_KEY属性<br>（1）   不存在直接调用其他cluster<br>（2）   存在值startsWith(“force”) 强制mock调用<br>（3）   存在值不是startsWith(“force”) 先正常调用， 出现异常在mock调用<br>集群模式的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:service cluster=<span class="string">"failsafe"</span> /&gt;    服务提供方</div><div class="line">&lt;dubbo:reference cluster=<span class="string">"failsafe"</span> /&gt;  服务消费方</div></pre></td></tr></table></figure></p>
<h3 id="多注册中心引用"><a href="#多注册中心引用" class="headerlink" title="多注册中心引用"></a>多注册中心引用</h3><p>解决CRM需同时调用中文站和国际站PC2相同接口相同版本服务的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">定义多个注册中心：</div><div class="line">&lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"172.29.63.18:9090"</span> /&gt;</div><div class="line">&lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"172.29.61.132:9090"</span> /&gt;</div><div class="line">不同注册中心使用不同引用：</div><div class="line">&lt;dubbo:reference id=<span class="string">"chinaXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</div><div class="line">&lt;dubbo:reference id=<span class="string">"intlXxxService"</span> interface=<span class="string">"com.alibaba.xxx.XxxService"</span></div><div class="line">version=<span class="string">"1.0.0"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="graceful-shutdown"><a href="#graceful-shutdown" class="headerlink" title="graceful shutdown"></a>graceful shutdown</h3><p><img src="/2017/11/24/dubbo功能介绍/shutdown.png" alt="shutdown"></p>
<h2 id="dubbo-Rpc高级功能"><a href="#dubbo-Rpc高级功能" class="headerlink" title="dubbo-Rpc高级功能"></a>dubbo-Rpc高级功能</h2><p><img src="/2017/11/24/dubbo功能介绍/高级功能.png" alt="高级功能"></p>
<h3 id="telnet互操作"><a href="#telnet互操作" class="headerlink" title="telnet互操作"></a>telnet互操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\&gt; telnet localhost 20880</div><div class="line">dubbo&gt; <span class="built_in">help</span></div><div class="line">ls <span class="_">-l</span></div><div class="line">ps <span class="_">-l</span></div><div class="line">status <span class="_">-l</span></div><div class="line">trace XxxService 10</div><div class="line">count XxxService</div><div class="line">invoke XxxService.xxxMethod(args)</div><div class="line"><span class="built_in">log</span> 100</div></pre></td></tr></table></figure>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>泛接口调用方式主要用于客户端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过GenericService调用所有服务实现。所谓泛化调用是使用通用服务接口.GenericService来invoke需要调用的服务方法，这种设计无疑是可复用、可扩展之典范。 GenericService只有一个方法Object$invoke(String method,String[] parameterTypes,Object[] args)throwsGenericException;invoke接受三个参数，分别为方法名，参数类型组以及参数值组，其中参数类型和参数值一一对应.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=<span class="string">"barService"</span> interface=<span class="string">"com.foo.BarService"</span> generic=<span class="string">"true"</span> /&gt;</div><div class="line">GenericService barService = (GenericService) applicationContext.getBean(<span class="string">"barService"</span>);</div><div class="line">Object result = barService.<span class="variable">$invoke</span>(<span class="string">"sayHello"</span>, new String[] &#123; <span class="string">"java.lang.String"</span> &#125;, new Object[] &#123; <span class="string">"World"</span> &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="显示回调"><a href="#显示回调" class="headerlink" title="显示回调"></a>显示回调</h3><p><img src="/2017/11/24/dubbo功能介绍/回调.png" alt="回调"><br>参数回调方式与调用本地callback或listener相同，只需要在Spring的配置文件中声明哪个参数是callback类型即可，Dubbo将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>并行发起多个请求，但只使用一个线程,基于NIO非阻塞实现并行调用，不用开启多线程，开销变小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:method name=<span class="string">"findXxx"</span> async=<span class="string">"true"</span> /&gt;</div><div class="line">xxxService.findXxx();//返回null</div><div class="line">Future&lt;Xxx&gt; future=RpcContext。getContext().getFuture();</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/24/dubbo功能介绍/async.png" alt="async"></p>
<h3 id="框架事件"><a href="#框架事件" class="headerlink" title="框架事件"></a>框架事件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Dubbo:service … ondisconnected= xxx &gt;</div><div class="line">&lt;Dubbo:reference … ondisconnected =xxx&gt;</div></pre></td></tr></table></figure>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>在客户端执行部分代码，比如：<br>– 在客户端缓存已查询过的数据<br>– 当服务器端全部不可用时，伪造容错数据<br><img src="/2017/11/24/dubbo功能介绍/本地执行.png" alt="本地执行"></p>
<h3 id="隐式传参"><a href="#隐式传参" class="headerlink" title="隐式传参"></a>隐式传参</h3><p>隐式传参，比如：<br>– 验权扩展点需要携带一些用户凭证信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">• ThreadLocal Context</div><div class="line">– RpcContext.setAttachment(<span class="string">"password"</span>, <span class="string">"xxx"</span>);</div><div class="line">– RpcContext.getAttachment(<span class="string">"password"</span>);</div><div class="line"></div><div class="line">//Consumer</div><div class="line">RpcContext.getContext().setAttachment(<span class="string">"parm"</span>, <span class="string">"嘿嘿"</span>+i);</div><div class="line">//server</div><div class="line">Map&lt;String, String&gt; attachments = RpcContext.getContext()</div><div class="line">               .getAttachments();</div><div class="line">String parm = attachments.get(<span class="string">"parm"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>注册中心路由<br>注册中心根据路由规则挑选服务提供者列表<br>RPC路由<br>根据类、方法、参数级别的路由规则<br>数据sharding<br>– 开发阶段的服务过滤(classifier)<br>– 可扩展的路由接口&amp;基于ScriptEngine的实现<br>• simpleEL<br>• Groovy ..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(invokers,invocation,context)&#123;</div><div class="line">var result = new java.util.ArrayList();</div><div class="line"><span class="keyword">if</span> (invokers.size()&gt;1 &amp;&amp;</div><div class="line">invocation.getMethodName() .equals(<span class="string">"method1"</span>)) &#123;</div><div class="line">result.add(invokers.get(0)) ;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">result.add(invokers.get(1)) ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;;</div><div class="line">route(invokers,invocation,context);</div></pre></td></tr></table></figure></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>actives:consumer并发数限制<br>executes:provider并发数限制<br>connections：consumer连接数限制<br>accept：provider连接数限制<br>短连接是连接上限，长连接则是启用的连接数<br>LeastActive LoadBalance:<br>调用并发数最少的provider，调节provider的并发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">并发控制</div><div class="line">限制com.foo.BarService的每个方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，服务器端并发执行（或占用线程池线程数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> executes=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">限制com.foo.BarService的每个方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">限制com.foo.BarService的sayHello方法，每客户端并发执行（或占用连接的请求数）不能超过10个：</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span>&gt;</div><div class="line">&lt;dubbo:method name=<span class="string">"sayHello"</span> actives=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了actives，&lt;dubbo:reference&gt;优先，参见：配置的覆盖策略。</div><div class="line">Load Balance均衡：</div><div class="line">配置服务的客户端的loadbalance属性为leastactive，此Loadbalance会调用并发数最小的Provider（Consumer端并发数）。</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> loadbalance=<span class="string">"leastactive"</span> /&gt;</div><div class="line">连接控制</div><div class="line">限制服务器端接受的连接不能超过10个：（以连接在Server上，所以配置在Provider上）</div><div class="line">&lt;dubbo:provider protocol=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> accepts=<span class="string">"10"</span> /&gt;</div><div class="line">限制客户端服务使用连接连接数：(如果是长连接，比如Dubbo协议，connections表示该服务对每个提供者建立的长连接数)</div><div class="line">&lt;dubbo:reference interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">Or:</div><div class="line">&lt;dubbo:service interface=<span class="string">"com.foo.BarService"</span> connections=<span class="string">"10"</span> /&gt;</div><div class="line">如果&lt;dubbo:service&gt;和&lt;dubbo:reference&gt;都配了connections，&lt;dubbo:reference&gt;优先</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dubbo简要介绍&quot;&gt;&lt;a href=&quot;#dubbo简要介绍&quot; class=&quot;headerlink&quot; title=&quot;dubbo简要介绍&quot;&gt;&lt;/a&gt;dubbo简要介绍&lt;/h1&gt;&lt;h2 id=&quot;dubbo是什么&quot;&gt;&lt;a href=&quot;#dubbo是什么&quot; class=&quot;
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch权威后续</title>
    <link href="http://yoursite.com/2017/11/15/elasticsearch%E6%9D%83%E5%A8%81%E5%90%8E%E7%BB%AD/"/>
    <id>http://yoursite.com/2017/11/15/elasticsearch权威后续/</id>
    <published>2017-11-15T13:44:09.000Z</published>
    <updated>2017-11-27T08:44:31.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式增删改查"><a href="#分布式增删改查" class="headerlink" title="分布式增删改查"></a>分布式增删改查</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard=<span class="built_in">hash</span>(routing)%number_of_primary_shards</div></pre></td></tr></table></figure>
<p>routing是一个字符串，默认是_id；这也就解释了主分片的数量只能在创建索引时定义且不能修改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档也就永远找不到了</p>
<h2 id="分片交互"><a href="#分片交互" class="headerlink" title="分片交互"></a>分片交互</h2><p>我们能够发送请求给集群中任意一个节点。每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。下面的例子中，我们将发送所有请求给 Node 1  ，这个节点我们将会称之为请求节点</p>
<h2 id="新建、索引、删除文档"><a href="#新建、索引、删除文档" class="headerlink" title="新建、索引、删除文档"></a>新建、索引、删除文档</h2><p>新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。<br>罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：</p>
<ul>
<li>客户端给Node1发送新建、索引或删除请求。</li>
<li>节点使用文档的_id  确定文档属于分片0。它转发请求到 Node3，分片0位于这个节点上</li>
<li>Node3在主分片上执行请求，如果成功，它转发请求到相应的位于 Node1和 Node2的复制节点上当所有的复制节点报告成功,Node 3报告成功到请求的节点，请求的节点再报告给客户端。客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</li>
</ul>
<h3 id="replication（注意在ElasticSearch-5-0开始被废弃）"><a href="#replication（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="replication（注意在ElasticSearch 5.0开始被废弃）"></a>replication（注意在ElasticSearch 5.0开始被废弃）</h3><p>复制默认的值是 sync。这将导致主分片得到复制分片的成功响应后才返回。<br>如果你设置 replication为 async，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。</p>
<h3 id="consistency（注意在ElasticSearch-5-0开始被废弃）"><a href="#consistency（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="consistency（注意在ElasticSearch 5.0开始被废弃）"></a>consistency（注意在ElasticSearch 5.0开始被废弃）</h3><p>默认主分片在尝试写入时需要<strong>规定数量(quorum)或过半的分片（可以是主节点或复制节点）可用。这是防止数据被写入到错的网络分区</strong>。规定的数量计算公式如下：<br>int( (primary + number_of_replicas) / 2 ) + 1<br>consistency允许的值为one（只有一个主分片），all（所有主分片和复制分片）或者默认的quorum或过半分片。<br>注意number_of_replicas是在索引中的的设置，用来定义复制分片的数量，而不是现在活动的复制节点的数量。如果你定义了索引有3个复制节点，那规定数量是：int( (primary + 3 replicas) / 2 ) + 1 = 3<br>但如果你只有2个节点，那你的活动分片不够规定数量，也就不能索引或删除任何文档。<br>注意: 新索引默认有1个复制分片，这意味着为了满足quorum的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在number_of_replicas大于一时才生效。</p>
<h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。默认等待一分钟。如果需要，你可以设置 timeout参数让它终止的更早： 100  表示100毫秒， 30s  表示30秒。</p>
<blockquote>
<p>新索引默认有 1  个复制分片，这意味着为了满足 quorum  的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在 number_of_replicas  大于一时才生效</p>
</blockquote>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><ol>
<li>客户端给Node1发送get请求。</li>
<li>节点使用文档的id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。此时，它转发请求到 Node2。</li>
<li>Node2返回endangered给Node1然后返回给客户端。</li>
</ol>
<p>对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本。可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol>
<li>客户端给Node1发送更新请求。</li>
<li>它转发请求到主分片所在节点Node3。</li>
<li>Node3从主分片检索出文档，修改source字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以retry_on_conflict设置的次数重复步骤3，都未成功则放弃。</li>
<li>如果 Node3成功更新文档，它同时转发文档的新版本到Node1和Node2上的复制节点以重建索引。当所有复制节点报告成功,Node3返回成功给请求节点，然后返回给客户端.<blockquote>
<p>当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本。记住这些修改转发到复制节点是异步的，它们并不能保证到达的顺序与发送相同。如果Elasticsearch转发的仅仅是修改请求，修改的顺序可能是错误的，那得到的就是个损坏的文档。</p>
</blockquote>
</li>
</ol>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p>mget请求检索多个文档的顺序步骤：</p>
<ol>
<li>客户端向Node1发送mget请求。</li>
<li>Node1为每个分片构建一个多条数据检索请求，然后转发到这些请求所需的主分片或复制分片上。当所有回复被接收，Node1构建响应并返回给客户端</li>
</ol>
<p>bulk执行多个create、index、delete和update请求的顺序步骤：</p>
<ol>
<li>客户端向Node1发送bulk请求。</li>
<li>Node1为每个分片构建批量请求，然后转发到这些请求所需的主分片上。</li>
<li>主分片一个接一个的按序执行操作。当一个操作执行完，主分片转发新文档（或者删除部分）给对应的复制节点，然后执行下一个操作。复制节点为报告所有操作完成，节点报告给请求节点，请求节点整理响应并返回给客户端。</li>
</ol>
<p>这里我们可以解释bulk的格式，而不是包装成json格式请求：意味着我们需要解析JSON为数组（包括文档数据，可能非常大）、检查每个请求决定应该到哪个分片上、为每个分片创建一个请求的数组、序列化这些数组为内部传输格式、发送请求到每个分片。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><table>
<thead>
<tr>
<th>概念</th>
<th style="text-align:right">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mappings(映射)</td>
<td style="text-align:right">数据在每个字段中的解释说明</td>
</tr>
<tr>
<td>analysis(分析)</td>
<td style="text-align:right">全文是如何处理的可以被搜索的</td>
</tr>
<tr>
<td>领域特定语句查询(query DSL)</td>
<td style="text-align:right">Elasticsearch使用的灵活的、强大的查询语言</td>
</tr>
</tbody>
</table>
<h2 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h2><p>没有指定任何的查询条件，只返回集群索引中的所有文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure></p>
<h2 id="多索引和多类别"><a href="#多索引和多类别" class="headerlink" title="多索引和多类别"></a>多索引和多类别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/_search  //在所有索引的所有类型中搜索</div><div class="line">/gb/_search //在索引gb的所有类型中搜索</div><div class="line">/gb,us/_search //在索引gb us的所有类型中搜索</div><div class="line">/g*,u*/_search //在索引g或u开头的所有类型中搜索</div><div class="line">/gb/user/_search //在索引 gb的类型user中搜索</div><div class="line">/gb,us/user,tweet/_search //在gb、us的user和tweet类型中搜索</div><div class="line">/_all/user,tweet/_search //在user和tweet类型中搜索</div></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>size默认为10 from默认为0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure></p>
<p>注意：现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长</p>
<h1 id="映射分析"><a href="#映射分析" class="headerlink" title="映射分析"></a>映射分析</h1><h2 id="确切值和全文文本"><a href="#确切值和全文文本" class="headerlink" title="确切值和全文文本"></a>确切值和全文文本</h2><p>确切值是确定的，正如它的名字一样。比如一个date或用户ID，也可以包含更多的字符串比如username或email地址。全文文本，从另一个角度来说是文本化的数据(常常以人类的语言书写)，比如一片推文(Twitter的文章)或邮件正文<br>确切值是很容易查询的，因为结果是二进制的 – 要么匹配，要么不匹配。</p>
<h2 id="分析和分析器"><a href="#分析和分析器" class="headerlink" title="分析和分析器"></a>分析和分析器</h2><p>分析(analysis)是这样一个过程：<br>首先，表征化一个文本块为适用于倒排索引单独的词(term)<br>然后标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><table>
<thead>
<tr>
<th>类型</th>
<th>标识的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
</tr>
<tr>
<td>whole number</td>
<td>byte、short、integer、long</td>
</tr>
<tr>
<td>floating point</td>
<td>float、double</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Date</td>
<td>date</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>field type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean:true,false</td>
<td>“boolean”</td>
</tr>
<tr>
<td>whole number:123</td>
<td>“long”</td>
</tr>
<tr>
<td>floating point:123.45</td>
<td>“double”</td>
</tr>
<tr>
<td>String:”123”</td>
<td>“string”</td>
</tr>
<tr>
<td>string valid date:”2016-05-01”</td>
<td>date”</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这意味着，如果你索引一个带引号的数字—— “123”  ，它将被映射为 “string”  类型，而不是 “long”  类型。然而，如果字段已经被映射为 “long”  类型，Elasticsearch将尝试转换字符串为long，并在转换失败时会抛出异常。</p>
</blockquote>
<h3 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get sjjhpt/_mapping/fwjbl</div></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>analyzed</td>
<td>首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。</td>
</tr>
<tr>
<td>not_analyzed</td>
<td>索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段</td>
</tr>
<tr>
<td>no</td>
<td>不索引这个字段。这个字段不能为搜索到</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="string">"userid"</span>:&#123;</div><div class="line">     <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">     <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line"></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其他简单类型——long、double、date等等——也接受index参数，但相应的值只能是 no和not_analyzed,它们的值不能被分析</p>
</blockquote>
<h3 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PUT /gb/_mapping/tweet</div><div class="line">&#123;</div><div class="line"><span class="string">"properties"</span> : &#123;</div><div class="line"><span class="string">"tag"</span> :&#123;</div><div class="line"><span class="string">"type"</span> : <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复合核心字段类型"><a href="#复合核心字段类型" class="headerlink" title="复合核心字段类型"></a>复合核心字段类型</h2><h3 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h3><p>数组：{ “tag”: [ “search”, “nosql” ]}<br>对于数组不需要特殊的映射。任何一个字段可以包含零个、一个或多个值，同样对于全文字段将被分析并产生多个词。这意味着数组中所有值必须为同一类型。你不能把日期和字符窜混合。如果你创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型。</p>
<h3 id="空字段"><a href="#空字段" class="headerlink" title="空字段"></a>空字段</h3><p>Lucene没法存放null值，所以一个null值的字段被认为是空字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"empty_string"</span>: <span class="string">""</span>,</div><div class="line"><span class="string">"null_value"</span>: null,</div><div class="line"><span class="string">"empty_array"</span>: [],</div><div class="line"><span class="string">"array_with_null_value"</span>: [ null ]</div></pre></td></tr></table></figure></p>
<h3 id="多层对象"><a href="#多层对象" class="headerlink" title="多层对象"></a>多层对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="string">"gb"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123;</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"tweet"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"user"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"id"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"gender"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"age"</span>: &#123; <span class="string">"type"</span>: <span class="string">"long"</span> &#125;,</div><div class="line">      <span class="string">"name"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line">      <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"full"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"first"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;,</div><div class="line">      <span class="string">"last"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span> &#125;</div><div class="line">       &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多层对像user的first，我们需要制定他的完整路径，像”user.name.first”或者tweet.user.name.first，而对于lucene，我们不能检索user或者user.name,我们不能检索复杂的结构体.</p>
<h1 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h1><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 30,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结构化查询-1"><a href="#结构化查询-1" class="headerlink" title="结构化查询"></a>结构化查询</h2><p>使用结构化查询，你需要传递query参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: your_query_here</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/_search POST</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">       <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询子句"><a href="#查询子句" class="headerlink" title="查询子句"></a>查询子句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> QUERY_NAME: &#123;</div><div class="line"> ARGUMENT: VALUE</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>: &#123;</div><div class="line">  <span class="string">"match"</span>: &#123;</div><div class="line">  <span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并多字句"><a href="#合并多字句" class="headerlink" title="合并多字句"></a>合并多字句</h3><p>复合子句(compound)用以合并其他的子句。bool子句允许你合并其他的合法子句，无论是must，must_not还是should<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"> <span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"spam"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#125;&#125;</div><div class="line">],</div><div class="line"><span class="string">"minimum_should_match"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h2><p>一条查询语句会计算每个文档与查询语句的相关性，会给出一个相关性评分_score并且按照相关性对匹配到的文档进行排序。这种评分方式非常适用于一个没有完全配置结果的全文本搜索。</p>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p>使用过滤语句得到的结果集 – 一个简单的文档列表，快速匹配运算并存入内存是十分方便的，每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。<br>查询语句不仅要查找相匹配的文档，还需要计算每个文档的相关性，所以一般来说查询语句要比过滤语句更耗时，并且查询结果也不可缓存。<br>原则上来说，使用查询语句做全文本搜索或其他需要进行相关性评分的时候，剩下的全部用过滤语句</p>
<h2 id="查询过滤语句"><a href="#查询过滤语句" class="headerlink" title="查询过滤语句"></a>查询过滤语句</h2><h3 id="term过滤"><a href="#term过滤" class="headerlink" title="term过滤"></a>term过滤</h3><p>term用于精确匹配哪些值，比如数字，日期，布尔值或not_analyzed的字符串(未经分析的文本数据类型)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="terms过滤"><a href="#terms过滤" class="headerlink" title="terms过滤"></a>terms过滤</h3><p>terms允许指定多个匹配条件.如果某个字段指定了多个值，那么文档需要一起去做匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"terms"</span>:&#123;</div><div class="line">      <span class="string">"jkbsf"</span>:[<span class="string">"test"</span>,<span class="string">"test1"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="range过滤"><a href="#range过滤" class="headerlink" title="range过滤"></a>range过滤</h3><p>用于查询范围<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"range"</span>:&#123;</div><div class="line">      <span class="string">"age"</span>:&#123;</div><div class="line">          <span class="string">"gte"</span>:10,</div><div class="line">          <span class="string">"lt"</span>:20</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gt：大于、gte:大于等于、lt:小于、lte：小于等于</p>
<h3 id="exists和missing过滤"><a href="#exists和missing过滤" class="headerlink" title="exists和missing过滤"></a>exists和missing过滤</h3><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"exists"</span>:   &#123;</div><div class="line">        <span class="string">"field"</span>:    <span class="string">"title"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="bool过滤"><a href="#bool过滤" class="headerlink" title="bool过滤"></a>bool过滤</h3><p>bool 过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含一下操作符：<br>must :: 多个查询条件的完全匹配,相当于 and。<br>must_not :: 多个查询条件的相反匹配，相当于 not。<br>should :: 至少有一个查询条件匹配, 相当于 or。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"bool"</span>: &#123;</div><div class="line">        <span class="string">"must"</span>:     &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</div><div class="line">        <span class="string">"must_not"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"tag"</span>:    <span class="string">"spam"</span>  &#125;&#125;,</div><div class="line">        <span class="string">"should"</span>: [</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"starred"</span>: <span class="literal">true</span>   &#125;&#125;,</div><div class="line">                    &#123; <span class="string">"term"</span>: &#123; <span class="string">"unread"</span>:  <span class="literal">true</span>   &#125;&#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"match_all"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">### match查询</span></div><div class="line">match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它</div><div class="line">如果你使用  match  查询一个全文本字段，它会在真正查询之前用分析器先分析 match  一下查询字符</div><div class="line">``` bash</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"About Search"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 match下指定了一个确切值，在遇到数字，日期，布尔值或者 not_analyzed的字符串时，它将为你搜索你给定的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"age"</span>: 26 &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"date"</span>: <span class="string">"2014-09-01"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"public"</span>: <span class="literal">true</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"full_text"</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。</p>
</blockquote>
<h3 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"full text search"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"body"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询与bool过滤相似，用于合并多个查询子句。不同的是，bool过滤可以直接给出是否匹配成功，而bool查询要计算每一个查询子句的score（相关性分值）。<br>must  :: 查询指定文档一定要被包含。<br>must_not  :: 查询指定文档一定不要被包含。<br>should  :: 查询指定文档，有则可以为文档相关性加分。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</div><div class="line"><span class="string">"must_not"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"spam"</span> &#125;&#125;,</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"match"</span>: &#123; <span class="string">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"range"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 如果bool查询下没有must子句，那至少应该有一个should子句。但是如果有must子句，那么没有should子句也可以进行查询。</p>
</blockquote>
<h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>查询语句和过滤语句可以放在各自的上下文中。在 ElasticSearch API 中我们会看到许多带有query或 filter的语句。这些语句既可以包含单条 query 语句，也可以包含一条 filter子句。换句话说，这些语句需要首先创建一个query或filter的上下文关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"filtered"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"email"</span>: <span class="string">"business opportunity"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /gb/tweet/_validate/query</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span> : &#123;</div><div class="line"><span class="string">"match"</span> : <span class="string">"really powerful"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="字段值排序"><a href="#字段值排序" class="headerlink" title="字段值排序"></a>字段值排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 1 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: &#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="默认排序"><a href="#默认排序" class="headerlink" title="默认排序"></a>默认排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//默认以顺序排序，_score以倒序排序</div><div class="line"><span class="string">"sort"</span>: <span class="string">"number_of_children"</span></div></pre></td></tr></table></figure>
<h2 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match"</span>: &#123; <span class="string">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: [</div><div class="line">&#123; <span class="string">"date"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"_score"</span>: &#123; <span class="string">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</div></pre></td></tr></table></figure>
<h3 id="多值字段字符串排序"><a href="#多值字段字符串排序" class="headerlink" title="多值字段字符串排序"></a>多值字段字符串排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//改变前的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">//改变后的mapping</div><div class="line"><span class="string">"tweet"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span>,</div><div class="line"><span class="string">"fields"</span>: &#123;</div><div class="line"><span class="string">"raw"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"index"</span>: <span class="string">"not_analyzed"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//现在，在给数据重建索引后，我们既可以使用  tweet  字段进行全文本搜索，也可以用 tweet.raw  字段进行排序</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"tweet"</span>: <span class="string">"elasticsearch"</span></div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"sort"</span>: <span class="string">"tweet.raw"</span></div><div class="line">&#125;</div><div class="line">对analyzed字段进行强制排序会消耗大量内存</div></pre></td></tr></table></figure>
<h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><p>每个文档都有相关性评分，用一个相对的浮点数字段_score来表示,_score的评分越高，相关性越高.fuzzy查询会计算与关键词的拼写相似程度,terms查询会计算 找到的内容与关键词组成部分匹配的百分比，但是一般意义上我们说的全文本搜索是指计算内容与关键词的类似程度。<br>es的相似度算法被定义为TF/IDF,即检索词频率和反向文档频率，<br>检索词频率：检索词在该字段出现的频率；也就是出现频率越高，相关性越高。<br>反向文档频率：每个检索词在索引中出现的频率；频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低，即检验一个检索词在文档中的普遍重要性<br>字段长度准则：长度越长，相关度越低。<br>如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
<h3 id="理解评分规则"><a href="#理解评分规则" class="headerlink" title="理解评分规则"></a>理解评分规则</h3><p>explain参数可以让返回结果添加一个_score评分的得来依据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /_search?explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Explain-Api"><a href="#Explain-Api" class="headerlink" title="Explain Api"></a>Explain Api</h3><p> explain  选项加到某一文档上时，它会告诉你为何这个文档会被匹配，以及一个文档为何没有被匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /us/tweet/12/_explain</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123; <span class="string">"term"</span> : &#123; <span class="string">"user_id"</span> : 2 &#125;&#125;,</div><div class="line"><span class="string">"query"</span> : &#123; <span class="string">"match"</span> : &#123; <span class="string">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//response</div><div class="line"><span class="string">"failure to match filter: cache(user_id:[2 TO 2])"</span></div></pre></td></tr></table></figure></p>
<h2 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h2><p>为了提高排序效率，ElasticSearch 会将所有字段的值加载到内存中，这就叫做”数据字段”</p>
<blockquote>
<p>es将所有字段数据加载到内存中并不是匹配到的那部分数据,而是索引下所有文档中的值，包括所有类型</p>
</blockquote>
<p>将所有字段数据加载到内存中是因为从硬盘反向倒排索引是非常缓慢的。尽管你这次请求需要的是某些文档中的部分数据，但你下个请求却需要另外的数据，所以将所有字段数据一次性加载到内存中是十分必要的。<br>ElasticSearch中的字段数据常被应用到以下场景：</p>
<ol>
<li>对一个字段进行排序</li>
<li>对一个字段进行聚合</li>
<li>某些过滤，比如地理位置过滤</li>
<li>某些与字段相关的脚本计算<br>这会消耗掉很多内存，尤其是大量的字符串数据 – string字段可能包含很多不同的值，比如邮件内容。 值得庆幸的是，内存不足是可以通过横向扩展解决的，我们可以增加更多的节点到集群。<h1 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h1>一个CRUD操作只处理一个单独的文档。文档的唯一性由 _index  ,  _type  和 routing-value  （通常默认是该文档的 _id  ）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。但如果针对复杂的搜索模型，由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上）。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。搜索的执行过程分两个阶段，称为查询然后取回（query then fetch）<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2>在初始化查询阶段，查询被向索引中的每个分片或者副本广播，每个分片会在本地执行搜索并建立匹配文档的优先队列。<blockquote>
<p>优先队列<br>一个优先队列（priority queue is）只是一个存有前n个（top-n）匹配document的有序列表。这个优先队列的大小由分页参数from和size决定。例如，下面这个例子中的搜索请求要求优先队列要能够容纳100个document</p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"from"</span>: 90,</div><div class="line"><span class="string">"size"</span>: 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询阶段包含以下三步：<br>1.客户端发送一个search给node3，node3创建一个from+size的空优先队列；<br>2.node3转发请求到索引中每个分片的原本或者副本，每个分片在本地执行这个查询并且将结果放到一个from+size的优先队列里；<br>3.每个分片返回documentid和它优先队列里所有document的排序值给协调节点node3.协调节点node3把这些值合并到自己的优先队列产生全局排列的结果<br>当一个搜索请求被发送到一个节点node时，这个节点就成了协调节点，这个节点工作是向所有相关的分片广播搜索请求并把他们的响应整合成全局的有序结果集。<br>第一步是向索引里的每个节点的分片副本广播请求。就像document的 GET  请求一样，搜索请求可以被每个分片的原本或任意副本处理。对于后续请求，协调节点会轮询所有的分片副本以分摊负载。<br>每一个分片在本地执行查询和建立一个长度为 from+size  的有序优先队列——这个长度意味着它自己的结果数量就足够满足全局的请求要求。分片返回一个轻量级的结果列表给协调节点。只包含documentID值和排序需要用到的值，例如 _score。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>分布式搜索取回阶段如下：<br>1.协调节点需要辨别哪个document需要取回，并且向相关分片发送GET请求。<br>2.每个分片加载document并根据需要丰富他，然后再将document返回给协调节点。<br>3.一旦所有的document都被取回，协调节点会将结果返回给客户端<br>分片加载document主体—— _source  field。如果需要，还会根据元数据丰富结果和高亮搜索片断。一旦协调节点收到所有结果，会将它们汇集到单一的回答响应里，这个响应将会返回给客户端。  </p>
<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>是机器人或者网络爬虫的行为。它们会持续不断地一页接着一页地获取页面直到服务器到底崩溃的边缘<br>查询然后取回过程虽然支持通过使用 from  和 size  参数进行分页，但是要在有限范围内（within limited）。还记得每个分片必须构造一个长度为 from+size  的优先队列吧，所有这些都要传回协调节点。这意味着协调节点要通过对 分片数量 * (from +size)  个document进行排序来找到正确的 size  个document。</p>
<h2 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h2><h3 id="preference（偏爱）"><a href="#preference（偏爱）" class="headerlink" title="preference（偏爱）"></a>preference（偏爱）</h3><p>preference  参数允许你控制使用哪个分片或节点来处理搜索请求。她接受如下一些参数<br>primary：搜索只在主分片执行搜索请求，副本不参与搜索；性能会打折扣，达不到性能的水平扩展。<br>_primary_first：优先在主分片执行，如果主分片挂掉，会在副本执行请求。<br>_local：搜索请求优先于在本地执行。<br>_only_node:xyz：只在xyz节点执行搜索。<br>_prefer_node:xyz：搜索请求优先在节点xyz执行。<br>_shards:2,3：搜索只在分片2、3执行，可以与_primary参数一起使用如：_shards:2,3;_primary<br>随机字符串：指定一个随机字符串，可以保证同样的请求，被分配到同样的副本上面，从而保证同一请求结果的稳定性。<br>结果震荡<br>想像一下，你正在按照 timestamp  字段来对你的结果排序，并且有两个document有相同的timestamp。由于搜索请求是在所有有效的分片副本间轮询的，这两个document可能在原始分片里是一种顺序，在副本分片里是另一种顺序.这就是被称为结果震荡（bouncing results）的问题：用户每次刷新页面，结果顺序会发生变化。避免这个问题方法是对于同一个用户总是使用同一个分片。方法就是使用一个随机字符串例如用户的会话ID（session ID）来设置 preference  参数</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。<br>timeout参数告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回。返回部分结果总比什么都没有好<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"timed_out"</span>: <span class="literal">true</span>, (1)</div><div class="line"><span class="string">"_shards"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: 5,</div><div class="line"><span class="string">"successful"</span>: 4,</div><div class="line"><span class="string">"failed"</span>: 1 (2)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>在搜索时，你可以指定一个或多个 routing  值来限制只搜索那些分片而不是搜索index里的全部分片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?routing=user_1,user2</div></pre></td></tr></table></figure></p>
<h3 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h3><p>默认的搜索类型是query_then_fetch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?search_type=count</div></pre></td></tr></table></figure></p>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>count（计数）搜索类型只有一个 query（查询）  的阶段。当不需要搜索结果只需要知道满足查询的document的数量时，可以使用这个查询类型。</p>
<h4 id="query-then-fetch-查询并且取回"><a href="#query-then-fetch-查询并且取回" class="headerlink" title="query_then_fetch 查询并且取回"></a>query_then_fetch 查询并且取回</h4><p>query_and_fetch（查询并且取回）  搜索类型将查询和取回阶段合并成一个步骤。这是一个内部优化选项，当搜索请求的目标只是一个分片时可以使用，例如指定了 routing（路由选择）  值时。虽然你可以手动选择使用这个搜索类型，但是这么做基本上不会有什么效果</p>
<h4 id="dfs-query-then-fetch-和-dfs-query-and-fetch"><a href="#dfs-query-then-fetch-和-dfs-query-and-fetch" class="headerlink" title="dfs_query_then_fetch 和 dfs_query_and_fetch"></a>dfs_query_then_fetch 和 dfs_query_and_fetch</h4><p>dfs  搜索类型有一个预查询的阶段，它会从全部相关的分片里取回项目频数来计算全局的项目频数。我们将在relevance-is-broken（相关性被破坏）里进一步讨论这个</p>
<h4 id="scan-扫描"><a href="#scan-扫描" class="headerlink" title="scan(扫描)"></a>scan(扫描)</h4><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API连在一起使用的，可以高效地取回巨大数量的结果。它是通过禁用排序来实现的</p>
<h2 id="扫描和滚屏"><a href="#扫描和滚屏" class="headerlink" title="扫描和滚屏"></a>扫描和滚屏</h2><p>scan（扫描）  搜索类型是和 scroll（滚屏）  API一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价。<br>为了使用scan-and-scroll（扫描和滚屏），需要执行一个搜索请求，将 search_type  设置成 scan  ，并且传递一个 scroll  参数来告诉Elasticsearch滚屏应该持续多长时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl -XGET <span class="string">'localhost:9200/twitter/tweet/_search?scroll=1m'</span> <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query": &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "title" : "elasticsearch"</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    size:1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个请求的应答没有包含任何命中的结果，但是包含了一个Base-64编码的 _scroll_id（滚屏id）  字符串。现在我们可以将 _scroll_id  传递给 _search/scroll  末端来获取第一批结果</div><div class="line">curl -XGET  'localhost:9200/_search/scroll<span class="string">'  -d'</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"scroll"</span> : <span class="string">"1m"</span>,</div><div class="line">    <span class="string">"scroll_id"</span> : <span class="string">"c2Nhbjs2OzM0NDg1ODpzRlBLc0FXNlNyNm5JWUc1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(1) 保持滚屏开启另一分钟。<br>(2)  _scroll_id  可以在body或者URL里传递，也可以被当做查询参数传递。注意，要再次指定 ?scroll=1m  。滚屏的终止时间会在我们每次执行滚屏请求时刷新，所以他只需要给我们足够的时间来处理<br>当前批次的结果而不是所有的匹配查询的document。<br>这个滚屏请求的应答包含了第一批次的结果。虽然指定了一个1000的size，但是获得了更多的document。当扫描时,size被应用到每一个分片上，所以我们在每个批次里最多或获得 size <em> number_of_primary_shards（size</em>主分片数）个document。</p>
<blockquote>
<p>滚屏请求也会返回一个新的_scroll_id  。每次做下一个滚屏请求时，必须传递前一次请求返回的_scroll_id  。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /_index</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"mappings"</span>:&#123;</div><div class="line">    <span class="string">"type_one"</span>:&#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>config/elasticsearch.yml,添加下面的配置来防止自动创建索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action.auto_create_index: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">number_of_shards 定义一个索引的主分片个数，默认值是 `5`。这个配置在索引创建后不能修改。</div><div class="line">number_of_replicas 每个主分片的复制分片个数，默认是 `1`。这个配置可以随时在活跃的索引上修改</div><div class="line">PUT /my_temp_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"number_of_shards"</span> : 1,</div><div class="line"><span class="string">"number_of_replicas"</span> : 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//修改</div><div class="line">PUT /my_temp_index/_settings</div><div class="line">&#123;</div><div class="line"><span class="string">"number_of_replicas"</span>: 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置分词器"><a href="#配置分词器" class="headerlink" title="配置分词器"></a>配置分词器</h2><p>standard分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了这几点<br>standard  分词器，在词层级上分割输入的文本。<br>standard  表征过滤器，被设计用来整理分词器触发的所有表征（但是目前什么都没做）。<br>lowercase  表征过滤器，将所有表征转换为小写。<br>stop  表征过滤器，删除所有可能会造成搜索歧义的停用词，如a、the、and、is  。</p>
<h2 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h2><p>字符过滤器、分词器、表征过滤器</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>字符过滤器是让字符串在被分词前变得更加“整洁”。例如，如果我们的文本是 HTML 格式，它可能会包含一些我们不想被索引的 HTML 标签，诸如</p><p>或<div>。我们可以使用html_strip字符过滤器 来删除所有的HTML标签，并且将HTML实体转换成对应的 Unicode字符，比如将&Aacute;  转成Á。一个分析器可能包含零到多个字符过滤器</div></p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>一个分析器必须包含一个分词器。分词器将字符串分割成单独的词（terms）或表征（tokens）。standard分析器使用standard分词器将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。</p>
<h3 id="表征过滤器"><a href="#表征过滤器" class="headerlink" title="表征过滤器"></a>表征过滤器</h3><p>表征过滤器可能修改，添加或删除表征。我们已经提过lowercase和stop表征过滤器，但是 Elasticsearch 中有更多的选择。</p>
<h3 id="创建自定义的分词器"><a href="#创建自定义的分词器" class="headerlink" title="创建自定义的分词器"></a>创建自定义的分词器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123; ... custom character filters ... &#125;,</div><div class="line"><span class="string">"tokenizer"</span>: &#123; ... custom tokenizers ... &#125;,</div><div class="line"><span class="string">"filter"</span>: &#123; ... custom token filters ... &#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123; ... custom analyzers ... &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//实例</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"settings"</span>: &#123;</div><div class="line"><span class="string">"analysis"</span>: &#123;</div><div class="line"><span class="string">"char_filter"</span>: &#123;</div><div class="line"><span class="string">"&amp;_to_and"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"mapping"</span>,</div><div class="line"><span class="string">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"my_stopwords"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"stop"</span>,</div><div class="line"><span class="string">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</div><div class="line">&#125;&#125;,</div><div class="line"><span class="string">"analyzer"</span>: &#123;</div><div class="line"><span class="string">"my_analyzer"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"custom"</span>,</div><div class="line"><span class="string">"char_filter"</span>: [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</div><div class="line"><span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</div><div class="line"><span class="string">"filter"</span>: [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</div><div class="line">&#125;&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>除非我们告诉es在哪里使用，否则分析器不会起作用。我们可以通过下面的映射将它应用在一个string类型的字段上.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">PUT /_index/_mapping/_type</div><div class="line">&#123;</div><div class="line">  <span class="string">"properties"</span>:&#123;</div><div class="line">      <span class="string">"title"</span>:&#123;</div><div class="line">          <span class="string">"type"</span>:<span class="string">"string"</span>,</div><div class="line">          <span class="string">"analyzer"</span>:<span class="string">"my_analyzer"</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">## 映射</span></div><div class="line">Lucene 中，一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换成多个值。Lucene 不关心这些值是字符串，数字或日期，所有的值都被当成不透明字节</div><div class="line"><span class="comment">### 预防类型陷阱</span></div><div class="line">想象一下我们的索引中有两种类型： blog_en  表示英语版的博客， blog_es  表示西班牙语版的博客。两种类型都有  title字段，但是其中一种类型使用  english  分析器，另一种使用  spanish  分析器。</div><div class="line">``` bash</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"multi_match"</span>: &#123;</div><div class="line"><span class="string">"query"</span>: <span class="string">"The quick brown fox"</span>,</div><div class="line"><span class="string">"fields"</span>: [ <span class="string">"blog_en.title"</span>, <span class="string">"blog_es.title"</span> ]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>一个 properties 节点，列出了文档中可能包含的每个字段的映射<br>多个元数据字段，每一个都以下划线开头，例如  _type  ,  _id  和  _source<br>设置项，控制如何动态处理新的字段，例如analyzer,dynamic_date_formats和dynamic_templates  。其他设置，可以同时应用在根对象和其他object类型的字段上，例如enabled,dynamic和 include_in_all<br>属性重要有三个type、index、analyzer</p>
<h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>默认情况下，Elasticsearch 用 JSON 字符串来表示文档主体保存在  _source  字段中。像其他保存的字段一样,_source字段也会在写入硬盘前压缩<br>需要source的理由：</p>
<ol>
<li>搜索结果中能得到完整的文档 —— 不需要额外去别的数据源中查询文档</li>
<li>如果缺少_source字段，部分更新请求不会起作用</li>
<li>当你的映射有变化，而且你需要重新索引数据时，你可以直接在 Elasticsearch 中操作而不需要重新从别的数据源中取回数据</li>
<li>你可以从  _source  中通过  get  或  search  请求取回部分字段，而不是整个文档</li>
<li>这样容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆ID中猜测他们的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//禁用<span class="built_in">source</span></div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_source"</span>: &#123;</div><div class="line"><span class="string">"enabled"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123; <span class="string">"match_all"</span>: &#123;&#125;&#125;,</div><div class="line"><span class="string">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="元数据-all字段"><a href="#元数据-all字段" class="headerlink" title="元数据:_all字段"></a>元数据:_all字段</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//当你还不清楚最终文档的结构时，可以将任何查询用于这个字段</div><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line"><span class="string">"match"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: <span class="string">"john smith marketing"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 禁用_all</div><div class="line">PUT /my_index/_mapping/my_type</div><div class="line">&#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过  include_in_all  选项可以控制字段是否要被包含在_all字段中，默认值是true。</p>
<h2 id="文档id"><a href="#文档id" class="headerlink" title="文档id"></a>文档id</h2><p>文档唯一标识由_index、_type、_id、_uid组成</p>
<h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>它通过动态映射来确定字段的数据类型且自动将该字段加到类型映射中，通过dynamic设置来控制这些行为，它接受下面几个选项true：自动添加字段（默认）、false：忽略字段、strict：当遇到未知字段时抛出异常<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic"</span>: <span class="string">"strict"</span>, &lt;1&gt;</div><div class="line"><span class="string">"properties"</span>: &#123;</div><div class="line"><span class="string">"title"</span>: &#123; <span class="string">"type"</span>: <span class="string">"string"</span>&#125;,</div><div class="line"><span class="string">"stash"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"object"</span>,</div><div class="line"><span class="string">"dynamic"</span>: <span class="literal">true</span> &lt;2&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断字符串为日期的规则可以通过dynamic_date_formats配置来修改</p>
<h2 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h2><p>使用dynamic_templates，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//es  : 字段名以  _es  结尾需要使用spanish分析器 ;en:所有其他字段使用english分析器。</div><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"my_type"</span>: &#123;</div><div class="line"><span class="string">"dynamic_templates"</span>: [</div><div class="line">自定义动态索引</div><div class="line">日期检测</div><div class="line">动态模板</div><div class="line">&#123; <span class="string">"es"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*_es"</span>, &lt;1&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"spanish"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"en"</span>: &#123;</div><div class="line"><span class="string">"match"</span>: <span class="string">"*"</span>, &lt;2&gt;</div><div class="line"><span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"mapping"</span>: &#123;</div><div class="line"><span class="string">"type"</span>: <span class="string">"string"</span>,</div><div class="line"><span class="string">"analyzer"</span>: <span class="string">"english"</span></div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="默认映射"><a href="#默认映射" class="headerlink" title="默认映射"></a>默认映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /my_index</div><div class="line">&#123;</div><div class="line"><span class="string">"mappings"</span>: &#123;</div><div class="line"><span class="string">"_default_"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">false</span> &#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"blog"</span>: &#123;</div><div class="line"><span class="string">"_all"</span>: &#123; <span class="string">"enabled"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><p>_source字段的一个最大的好处是你已经在 Elasticsearch 中有了完整的文档，你不再需要从数据库中重建你的索引。你可以在同一时间执行多个重新索引的任务，但是你显然不愿意它们的结果有重叠。所以，可以将重建大索引的任务通过日期或时间戳字段拆分成较小的任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span>: &#123;</div><div class="line"><span class="string">"range"</span>: &#123;</div><div class="line"><span class="string">"date"</span>: &#123;</div><div class="line"><span class="string">"gte"</span>: <span class="string">"2014-01-01"</span>,</div><div class="line"><span class="string">"lt"</span>: <span class="string">"2014-02-01"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="string">"size"</span>: 1000</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建一个索引  my_index_v1  ，然后将别名  my_index  指向它</div><div class="line">PUT /my_index_v1 &lt;1&gt;</div><div class="line">PUT /my_index_v1/_alias/my_index &lt;2&gt;</div><div class="line">//你可以检测这个别名指向哪个索引</div><div class="line">GET /*/_alias/my_index</div><div class="line">//哪些别名指向这个索引</div><div class="line">GET /my_index_v1/_alias/*</div><div class="line">//别名可以指向多个索引，所以我们需要在新索引中添加别名的同时从旧索引中删除它</div><div class="line">POST /_aliases</div><div class="line">&#123;</div><div class="line"><span class="string">"actions"</span>: [</div><div class="line">&#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</div><div class="line">&#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="深入分片"><a href="#深入分片" class="headerlink" title="深入分片"></a>深入分片</h1><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。<br>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：<br>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。<br>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h2 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h2><p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到–从最早的开始–查询完后再对结果进行合并。Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件<br>新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，在一次提交后，一个新的段被添加到提交点而且缓存被清空。<br>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存，不时地, 缓存被提交</li>
<li>不时地, 缓存被 提交 ：<br>一个新的段–一个追加的倒排索引–被写入磁盘。<br>一个新的包含新段名字的 提交点 被写入磁盘。<br>磁盘进行同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。新的段被开启，让它包含的文档可见以被搜索。内存缓存被清空，等待接收新的文档。</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<h2 id="删除更新"><a href="#删除更新" class="headerlink" title="删除更新"></a>删除更新</h2><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。<br>当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。<br>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h2 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h2><p>随着按段（per-segment）搜索的发展， 一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。<br>磁盘在这里成为了瓶颈。 提交（Commiting）一个新的段到磁盘需要一个 fsync 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 fsync 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。<br>但是这里新段会被先写入到文件系统缓存–这一步代价会比较低，稍后再被刷新到磁盘–这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。Lucene 允许新段被写入和打开–使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<h3 id="refresh-api"><a href="#refresh-api" class="headerlink" title="refresh api"></a>refresh api</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST /_refresh //刷新所有索引</div><div class="line">POST /blogs/_refresh //刷新blogs索引</div><div class="line">//正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率</div><div class="line">PUT /my_logs</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>: &#123;</div><div class="line">    <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span> //每30秒刷新 my_logs 索引</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//当你在建立一个大索引时，可以关闭自动刷新</div><div class="line">PUT /my_logs/_settings</div><div class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125;</div></pre></td></tr></table></figure></p>
<h2 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h2><p>1.新的文档被添加到内存缓冲区并且被追加到了事务日志<br>2.刷新（refresh）完成后, 缓存被清空但是事务日志不会<br>3.事务日志不断积累文档<br>4.在刷新（flush）之后，段被全量提交，并且事务日志被清空<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST /blogs/_flush //刷新（flush） blogs 索引</div><div class="line">POST /_flush?wait_for_ongoing //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</div></pre></td></tr></table></figure></p>
<h2 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h2><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。启动段合并不需要你做任何事。进行索引和搜索时会自动进行。步骤如下：</p>
<ol>
<li>两个提交了的段和一个未提交的段正在被合并到一个更大的段</li>
<li>一旦合并结束，老的段被删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</div><div class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h1><p>结构化搜索是查询包含内部结构的数据。日期、数字、时间都是结构化的，或者是结构化文本，比如蜡笔的颜色或者博客的标签。通过结构化搜索，你的查询结果始终是 是或非；是否应该属于集合。结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档</p>
<h2 id="查找准确的值"><a href="#查找准确的值" class="headerlink" title="查找准确的值"></a>查找准确的值</h2><p>对于准确值，你需要使用过滤器。过滤器的重要性在于它们非常的快。它们不计算相关性（避过所有计分阶段）而且很容易被缓存。<br>在5里filtered被去掉，放在bool里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"query"</span>:&#123;</div><div class="line">			<span class="string">"filter"</span>:&#123;</div><div class="line">				<span class="string">"terms"</span>:&#123;</div><div class="line">					<span class="string">"jkbsf"</span>:[<span class="string">"tyws-AddCaseTrial"</span>,<span class="string">"mrshjbs tyws-AddCaseTrial"</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SELECT document FROM products WHERE price = 20</div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;</div><div class="line"><span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合过滤"><a href="#组合过滤" class="headerlink" title="组合过滤"></a>组合过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">SELECT product</div><div class="line">FROM products</div><div class="line">WHERE (price = 20 OR productID = <span class="string">"XHDK-A-1293-#fJ3"</span>)</div><div class="line">AND (price != 30)</div><div class="line"></div><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"bool"</span> : &#123;</div><div class="line"><span class="string">"should"</span> : [</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 20&#125;&#125;, &lt;2&gt;</div><div class="line">&#123; <span class="string">"term"</span> : &#123;<span class="string">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125; &lt;2&gt;</div><div class="line">],</div><div class="line"><span class="string">"must_not"</span> : &#123;</div><div class="line"><span class="string">"term"</span> : &#123;<span class="string">"price"</span> : 30&#125; &lt;3&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嵌套布尔过滤器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT document</div><div class="line">FROM products</div><div class="line">WHERE productID = <span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">OR ( productID = <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">AND price = 30</div><div class="line"></div><div class="line">&#123;</div><div class="line">   <span class="string">"query"</span>:&#123;</div><div class="line">     <span class="string">"filtered"</span>:&#123;</div><div class="line">        <span class="string">"filter"</span>:&#123;</div><div class="line">           <span class="string">"bool"</span>:&#123;</div><div class="line">             <span class="string">"should"</span>:[</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"term"</span>:&#123;</div><div class="line">                    <span class="string">"productID"</span>:<span class="string">"KDKE-B-9947-#kL5"</span></div><div class="line">                  &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"bool"</span>:&#123;</div><div class="line">                    <span class="string">"must"</span>:[</div><div class="line">                    &#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span></div><div class="line">                      &#125;</div><div class="line">                    &#125;,&#123;</div><div class="line">                      <span class="string">"term"</span>:&#123;</div><div class="line">                        <span class="string">"price"</span>: 30</div><div class="line">                      &#125;</div><div class="line">                    &#125;</div><div class="line">                    ]</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">             ]</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查询多个准确值"><a href="#查询多个准确值" class="headerlink" title="查询多个准确值"></a>查询多个准确值</h2><p>terms过滤器是term过滤器的复数版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"terms"</span> : &#123; &lt;1&gt;</div><div class="line"><span class="string">"price"</span> : [20, 30]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="包含而不是相等"><a href="#包含而不是相等" class="headerlink" title="包含而不是相等"></a>包含而不是相等</h2><p>假如你有一个 term 过滤器  { “term” : { “tags” : “search” } }  ，它将匹配下面两个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>] &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>假如你真的需要完全匹配这种行为，最好是通过添加另一个字段来实现。在这个字段中，你索引原字段包含值的个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>], <span class="string">"tag_count"</span> : 1 &#125;</div><div class="line">&#123; <span class="string">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="string">"tag_count"</span> : 2</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"filtered"</span>:&#123;</div><div class="line">      <span class="string">"filter"</span>:&#123;</div><div class="line">        <span class="string">"bool"</span>:&#123;</div><div class="line">          <span class="string">"must"</span>:[</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tags"</span>:<span class="string">"search"</span></div><div class="line">              &#125;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="string">"term"</span>:&#123;</div><div class="line">                <span class="string">"tag_count"</span>:1</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="范围过滤"><a href="#范围过滤" class="headerlink" title="范围过滤"></a>范围过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /my_store/products/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"price"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : 20,</div><div class="line"><span class="string">"lt"</span> : 40</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用于日期字段时,range过滤器支持日期数学操作。例如，我们想找到所有最近一个小时的文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"now-1h"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日期计算也能用于实际的日期，而不是仅仅是一个像 now 一样的占位符。只要在日期后加上双竖线  ||  ，就能使用日期数学表达式了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"timestamp"</span> : &#123;</div><div class="line"><span class="string">"gt"</span> : <span class="string">"2014-01-01 00:00:00"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"2014-01-01 00:00:00||+1M"</span> &lt;1&gt;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>range  过滤器也可以用于字符串。字符串范围根据字典或字母顺序来计算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"range"</span> : &#123;</div><div class="line"><span class="string">"title"</span> : &#123;</div><div class="line"><span class="string">"gte"</span> : <span class="string">"a"</span>,</div><div class="line"><span class="string">"lt"</span> : <span class="string">"b"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字符串范围适用于一个基数较小的字段，一个唯一短语个数较少的字段。你的唯一短语数越多，搜索就越慢</p>
<h2 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h2><p>本质上来说null[]（空数组）和[null]是相等的。它们都不存在于倒排索引中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span> : &#123;</div><div class="line"><span class="string">"exists"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">GET /my_index/posts/_search</div><div class="line">&#123;</div><div class="line"><span class="string">"query"</span> : &#123;</div><div class="line"><span class="string">"filtered"</span> : &#123;</div><div class="line"><span class="string">"filter"</span>: &#123;</div><div class="line"><span class="string">"missing"</span> : &#123; <span class="string">"field"</span> : <span class="string">"tags"</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>它们的核心是一个字节集来表示哪些文档符合这个过滤器。Elasticsearch 主动缓存了这些字节集留作以后使用。一旦缓存后，当遇到相同的过滤时，这些字节集就可以被重用，而<br>不需要重新运算整个过滤。<br>缓存的字节集很“聪明”：他们会增量更新。你索引中添加了新的文档，只有这些新文档需要被添加到已存的字节集中，而不是一遍遍重新计算整个缓存的过滤器。过滤器和整个系统的其他部分一样是实时的，你不需要关心缓存的过期时间。<br>独立的过滤缓存<br>每个过滤器都被独立计算和缓存，而不管它们在哪里使用。如果两个不同的查询使用相同的过滤器，则会使用相同的字节集。同样，如果一个查询在多处使用同样的过滤器，只有一个字节集会被计算和重用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这两个过滤器相同，而且会使用同一个字节集</div><div class="line"><span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"should"</span>: [</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must"</span>: [</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;, &lt;1&gt;</div><div class="line">&#123; <span class="string">"term"</span>: &#123; <span class="string">"read"</span>: <span class="literal">false</span> &#125;&#125;</div><div class="line">]</div><div class="line">&#125;&#125;,</div><div class="line">&#123; <span class="string">"bool"</span>: &#123;</div><div class="line"><span class="string">"must_not"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"folder"</span>: <span class="string">"inbox"</span> &#125; &lt;1&gt;</div><div class="line">&#125;,</div><div class="line"><span class="string">"must"</span>: &#123;</div><div class="line"><span class="string">"term"</span>: &#123; <span class="string">"important"</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;</div><div class="line">&#125;&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤顺序"><a href="#过滤顺序" class="headerlink" title="过滤顺序"></a>过滤顺序</h2><p>在  bool  条件中过滤器的顺序对性能有很大的影响。更详细的过滤条件应该被放置在其他过滤器之前，以便在更早的排除更多的文档。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式增删改查&quot;&gt;&lt;a href=&quot;#分布式增删改查&quot; class=&quot;headerlink&quot; title=&quot;分布式增删改查&quot;&gt;&lt;/a&gt;分布式增删改查&lt;/h1&gt;&lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch数据</title>
    <link href="http://yoursite.com/2017/11/15/elasticSearch%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2017/11/15/elasticSearch数据/</id>
    <published>2017-11-15T05:41:31.000Z</published>
    <updated>2017-11-15T13:35:52.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档元数据如下<br>_index 文档存储的地方；_type文档代表的对象的类；_id 文档的唯一标识*</p>
<h3 id="index"><a href="#index" class="headerlink" title="_index"></a>_index</h3><p>索引(index)类似于关系型数据库里的”数据库”——它是我们存储和索引关联数据的地方。索引名必须是全部小写，不能以下划线开头，不能包含逗号.</p>
<h3 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h3><p>在Elasticsearch中，我们使用相同类型(type)的文档表示相同的”事物”，类似关系型数据库中的表，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引._type 的名字可以是大写或小写，不能包含下划线或逗号。</p>
<h3 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h3><p>唯一标识一个文档，如果不指定，es自动生成</p>
<h2 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h2><p>自动生成的id一般是22个字节长的uuid<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _index/_type/_id 或者 GET _index/_type/_id?pretty 美化字符串</div></pre></td></tr></table></figure>
<p>pretty:在任意的查询字符串中增加 pretty  参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。_source  字段不会被美化，它的样子与我们输入的一致。</p>
<h3 id="检索文档的一部分"><a href="#检索文档的一部分" class="headerlink" title="检索文档的一部分"></a>检索文档的一部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id?_source=field,filed</div></pre></td></tr></table></figure>
<h3 id="只获取元数据"><a href="#只获取元数据" class="headerlink" title="只获取元数据"></a>只获取元数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_index/_type/_id/_source</div></pre></td></tr></table></figure>
<h3 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -i -XHEAD http://localhost:9200/website/blog/123</div></pre></td></tr></table></figure>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT _index/_type/_id //更新后version要改变</div><div class="line">&#123;</div><div class="line"><span class="string">"field"</span>:<span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE /_index/_type/_id</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>数据库在并发冲突时提供了悲观锁和乐观锁的机制，es提供的机制是乐观并发控制。每个文档都有个版本号，当修改时version加一，如果指定的version不是现在的就会失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//插入一行记录</div><div class="line">PUT /website/blog/1/_create</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//获取当前数据,可以知道当前版本是1</div><div class="line">GET /website/blog/1</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : <span class="string">"1"</span>,</div><div class="line"><span class="string">"_version"</span> : 1,</div><div class="line"><span class="string">"found"</span> : <span class="literal">true</span>,</div><div class="line"><span class="string">"_source"</span> : &#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Just trying this out..."</span></div><div class="line">&#125;</div><div class="line">//根据当前版本对数据进行修改</div><div class="line">PUT /website/blog/1?version=1</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//如果当前版本不是1则会失败</div></pre></td></tr></table></figure></p>
<h3 id="使用外部版本控制系统"><a href="#使用外部版本控制系统" class="headerlink" title="使用外部版本控制系统"></a>使用外部版本控制系统</h3><p>一种常见的结构是使用一些其他的数据库做为主数据库，然后使用Elasticsearch搜索数据，这意味着所有主数据库发生变化，就要将其拷贝到Elasticsearch中。如果有多个进程负责这些数据的同步，就会遇到上面提到的并发问题。如果主数据库有版本字段——或一些类似于 timestamp  等可以用于版本控制的字段——是你就可以在Elasticsearch的查询字符串后面添加 version_type=external  来使用这些版本号。版本号必须是整数，大于零小于 9.2e+18  ——Java中的正的 long  。<br>外部版本号与之前说的内部版本号在处理的时候有些不同。它不再检查 _version  是否与请求中指定的一致，而是检查是否小于指定的版本。如果请求成功，外部版本号就会被存储到 _version  中。外部版本号不仅在索引和删除请求中指定，也可以在创建(create)新文档中指定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/2?version=5&amp;version_type=external</div><div class="line">&#123;</div><div class="line"><span class="string">"title"</span>: <span class="string">"My first external blog entry"</span>,</div><div class="line"><span class="string">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="更新文档-1"><a href="#更新文档-1" class="headerlink" title="更新文档"></a>更新文档</h2><p>update  请求表单接受一个局部文档参数 doc  ，它会合并到现有文档中——对象合并在一起，存在的标量字段被覆盖，新字段被添加。注：更新文档如果不存在，则会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"doc"</span> : &#123;</div><div class="line"><span class="string">"tags"</span> : [ <span class="string">"testing"</span> ],</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">POST /website/blog/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span></div><div class="line">&#125;</div><div class="line">//更新不存在的文档，如果有加一，没有初始化为1</div><div class="line">POST /website/pageviews/1/_update</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 1</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更新和冲突"><a href="#更新和冲突" class="headerlink" title="更新和冲突"></a>更新和冲突</h3><p>这些可以通过 retry_on_conflict  参数设置重试次数来自动完成，这样 update  操作将会在发生错误前重试——这个值默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /website/pageviews/1/_update?retry_on_conflict=5</div><div class="line">&#123;</div><div class="line"><span class="string">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</div><div class="line"><span class="string">"upsert"</span>: &#123;</div><div class="line"><span class="string">"views"</span>: 0</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h2><p>检索多个文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">GET /_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_id"</span> : 2</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line"><span class="string">"_index"</span> : <span class="string">"website"</span>,</div><div class="line"><span class="string">"_type"</span> : <span class="string">"pageviews"</span>,</div><div class="line"><span class="string">"_id"</span> : 1,</div><div class="line"><span class="string">"_source"</span>: <span class="string">"views"</span></div><div class="line">&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果你想检索的文档在同一个 _index  中（甚至在同一个 _type  中），你就可以在URL中定义一个默认的 /_index  或者 /_index/_type  </div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"docs"</span> : [</div><div class="line">&#123; <span class="string">"_id"</span> : 2 &#125;,</div><div class="line">&#123; <span class="string">"_type"</span> : <span class="string">"pageviews"</span>, <span class="string">"_id"</span> : 1 &#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">//如果所有文档具有相同 _index  和 _type  ，你可以通过简单的 ids  数组来代替完整的 docs 数组</div><div class="line">GET /website/blog/_mget</div><div class="line">&#123;</div><div class="line"><span class="string">"ids"</span> : [ <span class="string">"2"</span>, <span class="string">"1"</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><p>bulk  API允许我们使用单一请求来实现多个文档的 create  、 index  、 update  或 delete  。这对索引类似于日志活动这样的数据流非常有用，它们可以以成百上千的数据为一个批次按序进行索引。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div><div class="line">&#123; action: &#123; metadata &#125;&#125;\n</div><div class="line">&#123; request body &#125;\n</div></pre></td></tr></table></figure></p>
<p>注意：1.每行必须以 “\n”  符号结尾，包括最后一行。这些都是作为每行有效的分离而做的标记；2.每一行的数据不能包含未被转义的换行符，它们会干扰分析——这意味着JSON不能被美化打印<br>action: create（创建、若存在则报错）、index（创建或替换）、update（更新）、delete（删除文档）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /_bulk</div><div class="line">&#123; <span class="string">"delete"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125; &lt;1&gt;</div><div class="line">&#123; <span class="string">"create"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My first blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"My second blog post"</span> &#125;</div><div class="line">&#123; <span class="string">"update"</span>: &#123; <span class="string">"_index"</span>: <span class="string">"website"</span>, <span class="string">"_type"</span>: <span class="string">"blog"</span>, <span class="string">"_id"</span>: <span class="string">"123"</span>, <span class="string">"_retry_on_conflict"</span> : 3&#125; &#125;</div><div class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"title"</span> : <span class="string">"My updated blog post"</span>&#125; &#125;</div></pre></td></tr></table></figure></p>
<p>当然，你可以指定index和type，当下面指定时会覆盖掉<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST /website/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"log"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line"></div><div class="line">POST /website/<span class="built_in">log</span>/_bulk</div><div class="line">&#123; <span class="string">"index"</span>: &#123;&#125;&#125;</div><div class="line">&#123; <span class="string">"event"</span>: <span class="string">"User logged in"</span> &#125;</div><div class="line">&#123; <span class="string">"index"</span>: &#123; <span class="string">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</div><div class="line">&#123; <span class="string">"title"</span>: <span class="string">"Overriding the default type"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>批量最好的批次在5Mb~15Mb</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h2&gt;&lt;p&gt;文档元数据如下&lt;br&gt;_index 文档存储的地方；_type文档代表的对象的类；_id 文档的唯一标识*&lt;/p&gt;
&lt;h3 id=&quot;inde
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式集群</title>
    <link href="http://yoursite.com/2017/11/14/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2017/11/14/分布式集群/</id>
    <published>2017-11-14T13:22:00.000Z</published>
    <updated>2017-11-14T14:31:21.187Z</updated>
    
    <content type="html"><![CDATA[<p>一个节点就是一个elasticsearch实例，一个集群由一个或者多个节点组成，具有相同的cluster.name，它们协同工作，分享数据和负载。<br>集群中的一个节点选举称为master，将临时管理集群级别的一些变更，<strong>例如新建、删除索引、增加或移除节点。主节点不参与文档级别的变更或搜索，意味着在流量增长时，master不会成为瓶颈。</strong></p>
<h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><p>集群健康分为三种：red、yellow、green,green代表所有的主分片和复制分片都可用，yellow代表所有主要分片可用，但是不是所有复制分片可用，red代表不是所有主分片可用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _cluster/health</div></pre></td></tr></table></figure></p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>索引是用来指向一个或者多个分片的逻辑命名空间，一个分片是一个最小级别工作单元。分片可以是主分片或者复制分片，索引的每一个文档属于一个主分片，主分片的数量决定了索引最终存储的数量。复制分片是主分片的一个副本，可以防止硬件故障导致的数据丢失，同时提供读请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PUT /sjjhpt</div><div class="line">//创建三个主分片，一个副本</div><div class="line">&#123;</div><div class="line">  <span class="string">"settings"</span>:&#123;</div><div class="line">     <span class="string">"number_of_shards"</span>:3,</div><div class="line">     <span class="string">"number_of_replicas"</span>: 1.</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="增加故障转移"><a href="#增加故障转移" class="headerlink" title="增加故障转移"></a>增加故障转移</h2><p>在单一节点运行会有单点故障的风险，要防止单点故障，要启动另外一个节点。文档首先会在主分片中存储，然后并发复制到其他复制分片，确保主分片和复制分片都会被检索。</p>
<h2 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h2><p>可以增加节点数，最多节点数为(主分片个数)* (副本数量+1)</p>
<h2 id="更多扩展"><a href="#更多扩展" class="headerlink" title="更多扩展"></a>更多扩展</h2><p>当然，只是有更多的复制分片在同样数量的节点上并不能提高我们的性能，因为每个分片都要访问更小比重的节点资源（译者注：大部分请求都聚集到了分片少的节点，导致一个节点吞吐量太大，反而降低性能）。你需要增加硬件来提高吞吐量。<br>不过这些额外的复制节点意味着我们有更多的冗余：通过以上对接点的设置，我们更够承受两个节点故障而不丢失数据.</p>
<h2 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h2><p>当主节点故障后，会重新选举主节点，如果主分片不能正常工作，重新选举的主节点会提升副本分片为主分片</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个节点就是一个elasticsearch实例，一个集群由一个或者多个节点组成，具有相同的cluster.name，它们协同工作，分享数据和负载。&lt;br&gt;集群中的一个节点选举称为master，将临时管理集群级别的一些变更，&lt;strong&gt;例如新建、删除索引、增加或移除节点。
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch入门</title>
    <link href="http://yoursite.com/2017/11/14/elasticsearch%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/11/14/elasticsearch入门/</id>
    <published>2017-11-14T06:16:48.000Z</published>
    <updated>2017-11-16T12:17:46.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>elasticSearch是基于Lucene的开源搜索引擎。lucene是现在最先进、性能最好、功能最全的搜索引擎库。但是lucene是一个库，你必须使用java语言集成到你的应用。Lucene通过restful api隐藏Lucene的复杂性。es的特性如下：</p>
<ul>
<li>分布式的实时存储</li>
<li>分布式的实时搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="java-API"><a href="#java-API" class="headerlink" title="java API"></a>java API</h2><h3 id="节点客户端"><a href="#节点客户端" class="headerlink" title="节点客户端"></a>节点客户端</h3><p>节点客户端是以无数据节点加入集群，它自己不存储数据，它知道数据在集群里的具体位置，并且能够直接转发请求到对应节点上</p>
<h3 id="传输客户端"><a href="#传输客户端" class="headerlink" title="传输客户端"></a>传输客户端</h3><p>能够发送请求到远程集群，它自己不加入集群，只是简单转发请求到集群的节点</p>
<h3 id="基于http协议，以json为数据交互格式的Restful-ApI"><a href="#基于http协议，以json为数据交互格式的Restful-ApI" class="headerlink" title="基于http协议，以json为数据交互格式的Restful ApI"></a>基于http协议，以json为数据交互格式的Restful ApI</h3><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>es是面向文档的，他可以存储整个对象或者文档。并且文档可以被索引、搜索、排序、过滤。json是文档序列化的格式。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>es的索引一个文档指的是将一个文档存储到索引里，以便检索和查询，类似数据库的insert。但是如果文档已存在，会覆盖文档。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/1 //索引 类型 文档id</div></pre></td></tr></table></figure>
<h3 id="简单检索"><a href="#简单检索" class="headerlink" title="简单检索"></a>简单检索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search //默认返回前十个数据</div></pre></td></tr></table></figure>
<h3 id="查询字符串查询"><a href="#查询字符串查询" class="headerlink" title="查询字符串查询"></a>查询字符串查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get sjjhpt/fwjlb/_search?q=userid:hxdt</div></pre></td></tr></table></figure>
<h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><p>以json请求体出现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"userid"</span>:<span class="string">"hxdt"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更复杂的搜索"><a href="#更复杂的搜索" class="headerlink" title="更复杂的搜索"></a>更复杂的搜索</h3><p>filter重点在区间查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">POST sjjhpt/fwjlb/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line"></div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"range"</span>:&#123;</div><div class="line">           <span class="string">"dyrq"</span>:&#123;</div><div class="line">           	  <span class="string">"gt"</span>:<span class="string">"2017-05-06"</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //elkname包含aa或包含bb</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h3><p>搜索确切的匹配若干个单词或者短语<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search //询同时包含<span class="string">"aa"</span>和<span class="string">"bb"</span>,并且是相邻的</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_phrase"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa bb"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">POST /elkdb/elktable/_search</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;</div><div class="line">       <span class="string">"elkname"</span>:<span class="string">"aa"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"highlight"</span>:&#123;</div><div class="line">  	<span class="string">"pre_tags"</span>: [</div><div class="line">          <span class="string">"&lt;em class=\"c_color\"&gt;"</span></div><div class="line">      ],</div><div class="line">      <span class="string">"post_tags"</span>: [</div><div class="line">        <span class="string">"&lt;/em&gt;"</span></div><div class="line">      ],</div><div class="line">  	<span class="string">"fields"</span>:&#123;</div><div class="line">  		<span class="string">"elkname"</span>:&#123;</div><div class="line"></div><div class="line">  		&#125;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>类比数据库的group by<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>聚合允许分级汇总<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sjjhpt/fwjlb/_search POST //查询相同接口标识符的平均id</div><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_jkbsf"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"jkbsf"</span></div><div class="line">			&#125;,</div><div class="line">			<span class="string">"aggs"</span>:&#123;</div><div class="line">				<span class="string">"avg_id"</span>:&#123;</div><div class="line">					<span class="string">"avg"</span>:&#123;</div><div class="line">						<span class="string">"field"</span>:<span class="string">"id"</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;elasticSearch是基于Lucene的开源搜索引擎。lucene是现在最先进、性能最好、功能最全的搜索引擎库。但是lucene是一个
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="elasticSearch权威入门指南" scheme="http://yoursite.com/tags/elasticSearch%E6%9D%83%E5%A8%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>logstash同步数据库</title>
    <link href="http://yoursite.com/2017/11/13/logstash%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/11/13/logstash配置/</id>
    <published>2017-11-13T11:56:34.000Z</published>
    <updated>2017-11-19T09:18:03.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><h2 id="安装logstash"><a href="#安装logstash" class="headerlink" title="安装logstash"></a>安装logstash</h2><p>下载地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.5.1.zip</div></pre></td></tr></table></figure></p>
<h3 id="准备MySQL的驱动"><a href="#准备MySQL的驱动" class="headerlink" title="准备MySQL的驱动"></a>准备MySQL的驱动</h3><p>在lib下新建mysqldriver文件夹，并将mysql-connector-java-5.1.25.jar拷贝到mysqldriver文件夹中。</p>
<h3 id="配置模板"><a href="#配置模板" class="headerlink" title="配置模板"></a>配置模板</h3><h4 id="配置动态模板"><a href="#配置动态模板" class="headerlink" title="配置动态模板"></a>配置动态模板</h4><ol>
<li>切换到根目录</li>
<li>新建template目录</li>
<li>进入template目录</li>
<li>新建文件 logstash-ik.json   </li>
<li>编辑文件内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"template"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"version"</span>: 50001,</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"index.refresh_interval"</span>: <span class="string">"5s"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"mappings"</span>: &#123;</div><div class="line">        <span class="string">"_default_"</span>: &#123;</div><div class="line">            <span class="string">"_all"</span>: &#123;</div><div class="line">                <span class="string">"enabled"</span>: <span class="literal">true</span>,</div><div class="line">                <span class="string">"norms"</span>: <span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"dynamic_templates"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"message_field"</span>: &#123;</div><div class="line">                        <span class="string">"match"</span>: <span class="string">"jkbsf"</span>,</div><div class="line">                        <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line">                        <span class="string">"mapping"</span>: &#123;</div><div class="line">                            <span class="string">"type"</span>: <span class="string">"keyword"</span>,</div><div class="line">                            <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">							              <span class="string">"index"</span>:<span class="string">"not_analyzed"</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"string_fields"</span>: &#123;</div><div class="line">                        <span class="string">"match"</span>: <span class="string">"*"</span>,</div><div class="line">                        <span class="string">"match_mapping_type"</span>: <span class="string">"string"</span>,</div><div class="line">                        <span class="string">"mapping"</span>: &#123;</div><div class="line">                            <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                            <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                            <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                            <span class="string">"fields"</span>: &#123;</div><div class="line">                                <span class="string">"keyword"</span>: &#123;</div><div class="line">                                    <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            ],</div><div class="line">            <span class="string">"properties"</span>: &#123;</div><div class="line">                <span class="string">"@timestamp"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"date"</span>,</div><div class="line">                    <span class="string">"include_in_all"</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"@version"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"keyword"</span>,</div><div class="line">                    <span class="string">"include_in_all"</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="静态模板"><a href="#静态模板" class="headerlink" title="静态模板"></a>静态模板</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"template"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"version"</span>: 50001,</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"index.refresh_interval"</span>: <span class="string">"5s"</span></div><div class="line">     &#125;,</div><div class="line">    <span class="string">"mappings"</span>: &#123;</div><div class="line">        <span class="string">"into_es_type_define"</span> :&#123;</div><div class="line">         <span class="string">"properties"</span>: &#123;</div><div class="line">               <span class="string">"ct"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"@timestamp"</span>: &#123;</div><div class="line">                   <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</div><div class="line">                   <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                &#125;,</div><div class="line">               <span class="string">"@version"</span>: &#123;</div><div class="line">                  <span class="string">"include_in_all"</span>: <span class="literal">false</span>,</div><div class="line">                  <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                &#125;,</div><div class="line">               <span class="string">"name"</span>: &#123;</div><div class="line">                  <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                  <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                  <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                  <span class="string">"fields"</span>: &#123;</div><div class="line">                     <span class="string">"keyword"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"id"</span>: &#123;</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"long"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"type"</span>: &#123;</div><div class="line">                     <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                     <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                     <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                     <span class="string">"fields"</span>: &#123;</div><div class="line">                     <span class="string">"keyword"</span>: &#123;</div><div class="line">                         <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                          &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"age"</span>: &#123;</div><div class="line">                   <span class="string">"type"</span>: <span class="string">"long"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"desc"</span>: &#123;</div><div class="line">                    <span class="string">"norms"</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="string">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</div><div class="line">                    <span class="string">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                    <span class="string">"fields"</span>: &#123;</div><div class="line">                    <span class="string">"keyword"</span>: &#123;</div><div class="line">                         <span class="string">"type"</span>: <span class="string">"keyword"</span></div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">                &#125;,</div><div class="line">               <span class="string">"ut"</span>: &#123;</div><div class="line">                      <span class="string">"type"</span>: <span class="string">"date"</span></div><div class="line">                 &#125;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="准备Logstash的配置文件"><a href="#准备Logstash的配置文件" class="headerlink" title="准备Logstash的配置文件"></a>准备Logstash的配置文件</h3><p>在config下新建mysql.conf文件，编辑内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    jdbc &#123;</div><div class="line">        jdbc_driver_library =&gt; <span class="string">"D:/logstash-5.5.1/lib/mysqldriver/mysql-connector-java-5.1.25.jar"</span></div><div class="line">        jdbc_driver_class =&gt; <span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">        jdbc_connection_string =&gt; <span class="string">"jdbc:mysql://localhost:3306/sjjhpt?autoReconnect=true&amp;useSSL=false"</span></div><div class="line">        jdbc_user =&gt; <span class="string">"root"</span></div><div class="line">        jdbc_password =&gt; <span class="string">"123456"</span></div><div class="line">        schedule =&gt; <span class="string">"* * * * *"</span></div><div class="line">        jdbc_default_timezone =&gt; <span class="string">"Asia/Shanghai"</span></div><div class="line">        statement =&gt; <span class="string">"SELECT * FROM pub_sjjhpt_fwjlb;"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        index =&gt; <span class="string">"sjjhpt"</span></div><div class="line">        document_type =&gt; <span class="string">"fwjlb"</span></div><div class="line">        document_id =&gt; <span class="string">"%&#123;id&#125;"</span></div><div class="line">        hosts =&gt; [<span class="string">"localhost:9200"</span>]</div><div class="line">        <span class="comment">## 模板</span></div><div class="line">        template_overwrite =&gt; <span class="literal">true</span></div><div class="line">        template =&gt; <span class="string">"/usr/local/logstash-5.5.2/template/logstash-ik.json"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">参数说明：</div><div class="line">jdbc_driver_library：</div><div class="line">数据库驱动路径，这里我填写的是绝对路径，可自行尝试相对路径；</div><div class="line">jdbc_driver_class：</div><div class="line">驱动名称；</div><div class="line">jdbc_connection_string：</div><div class="line">数据库的连接字符串；</div><div class="line">forelk为数据库名；</div><div class="line">?autoReconnect=<span class="literal">true</span>&amp;useSSL=<span class="literal">false</span>自动重连并禁用SSL；</div><div class="line">jdbc_user：</div><div class="line">数据库用户名；</div><div class="line">jdbc_password：</div><div class="line">数据库密码；</div><div class="line">schedule：</div><div class="line">重复执行导入任务的时间间隔；</div><div class="line">jdbc_default_timezone：</div><div class="line">默认时区设置；</div><div class="line">statement：</div><div class="line">导入的表（查询SQL，可以过滤数据）</div><div class="line">index:</div><div class="line">索引名称（类似数据库名称）；</div><div class="line">document_type：</div><div class="line">类型名称（类似数据库表名）；</div><div class="line">document_id：</div><div class="line">类似主键；</div><div class="line">hosts：</div><div class="line">要导入到的Elasticsearch所在的主机；</div></pre></td></tr></table></figure></p>
<h3 id="执行导入"><a href="#执行导入" class="headerlink" title="执行导入"></a>执行导入</h3><p>首先启动elasticsearch，然后在logstash目录下Shift+鼠标右键，选择在此处打开命令窗口(W),输入命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin\logstash <span class="_">-f</span> config\mysql.conf</div></pre></td></tr></table></figure></p>
<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>可以启动head插件查看也可以通过kibana</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装mysql&quot;&gt;&lt;a href=&quot;#安装mysql&quot; class=&quot;headerlink&quot; title=&quot;安装mysql&quot;&gt;&lt;/a&gt;安装mysql&lt;/h2&gt;&lt;h2 id=&quot;安装logstash&quot;&gt;&lt;a href=&quot;#安装logstash&quot; class=&quot;head
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="logstash" scheme="http://yoursite.com/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>面向服务的体系架构-SOA(第一章)</title>
    <link href="http://yoursite.com/2017/11/10/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-SOA/"/>
    <id>http://yoursite.com/2017/11/10/面向服务的体系架构-SOA/</id>
    <published>2017-11-10T02:57:29.000Z</published>
    <updated>2017-11-12T01:44:03.987Z</updated>
    
    <content type="html"><![CDATA[<p>伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提供服务，达成业务之间相互复用，系统也因此演变为分布式应用架构体系。<br>基于http协议之间的系统间的RPC，具有使用灵活、实现便捷、开放且天生支持异构平台间的调用等多个优点。与之对应的是tcp协议的实现版本，效率更高，实现更复杂，但由于协议和标准不同，很难跨平台和企业间的通信。</p>
<h2 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h2><h3 id="RPC名词解释"><a href="#RPC名词解释" class="headerlink" title="RPC名词解释"></a>RPC名词解释</h3><p>remote process call，远程过程调用，拥有着RMI、webservice等诸多成熟的方案。RPC将原来的本地调用转变为调用远端的服务器上的方法。<br>RPC的实现包括客户端和服务器端，即服务的调用方和服务提供方。服务调用方发送RPC请求到服务提供方，服务提供方根据调用方提供的参数执行请求方法，将执行结果返回给调用方。其中参数和返回结果序列化。</p>
<h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>将对象转成二进制流的过程称为对象的序列化<br>将二进制流转成对象的过程称为对象的反序列化<br>对象的序列化和反序列化有很多成熟的方案：Google protocol Buffers协议、java内置的序列化方式、Hessian、json以及xml。</p>
<h3 id="基于TCP实现的RPC"><a href="#基于TCP实现的RPC" class="headerlink" title="基于TCP实现的RPC"></a>基于TCP实现的RPC</h3><p>基于java socket的api，能够实现简单的RPC调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伴随着业务体系的发展，系统拆分变成了不可避免的事，由此演变成了垂直应用架构体系。但是随着垂直应用的增多，达到一定的规模，应用之间的相互交互、相互调用不可避免。否则，不同系统之间存在着重复的业务，容易形成信息孤岛，重复造轮子。此时相对核心的业务会被抽出来，作为单独的系统对外提
    
    </summary>
    
      <category term="大型分布式网站架构" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="大型分布式网站架构设计与实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hbase架构</title>
    <link href="http://yoursite.com/2017/11/07/hbase%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2017/11/07/hbase架构/</id>
    <published>2017-11-07T14:19:10.000Z</published>
    <updated>2017-11-10T01:10:07.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据查找和存储"><a href="#数据查找和存储" class="headerlink" title="数据查找和存储"></a>数据查找和存储</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树的性质使得能够对主键进行高效的插入、查找以及删除，B+树远好于二叉树的数据划分，大大减少查询特定主键所需要的IO。此外，B+树能够提供高效的范围扫描，由于叶节点相互连接且主键有序，扫描时避免了耗时的遍历树的操作。在很多关系型数据库中，都把该数据结构用做索引。<br>当添加新的索引时，可能会使得页表满了拆分成两个页表，若页表不在一块，在进行范围查询时，需要读取不在一块的页表甚至很远的页表，因此我们需要优化该表，使用optimize table，将B+顺序写，使得范围查找时加快。</p>
<h3 id="LSM树-Log-Structured-Merge"><a href="#LSM树-Log-Structured-Merge" class="headerlink" title="LSM树(Log Structured Merge)"></a>LSM树(Log Structured Merge)</h3><p>输入数据首先存储在日志文件中，这些文件的完全有序，当有日志文件被修改时，对应的更新会保存在内存中，来加速查询。在经历数次数据进行修改后，内存逐渐被占满后，LSM树会把有序的键数据对写入磁盘，同时创建一个新的数据存储文件，并且内存中的数据可以丢弃。存储文件组织与B树相似，不过其为磁盘顺序读取做了优化，所有节点都是满的并按页存储，修改数据文件通过滚动合并完成。如果数据量过于庞大，磁盘中的树相应地也会很大，导致的后果是合并的速度会变慢。一个解决方法是建立各个层次的树，低层次的树都比上一层次的树数据集大。假设内存中的树为c0, 磁盘中的树按照层次一次为c1, c2, c3, … ck-1, ck。合并的顺序是(c0, c1), (c1, c2)…(ck-1, ck)。<br>查询时先查找内存中的存储，然后在查找磁盘文件。删除是一种特殊的更改，当删除标记被存储后，查找时会跳过被删除的键。当页被重写时，有删除标记的键会被丢掉。后台运维可以设定一个TTL，在TTL后，检查时间戳，然后重写丢弃过期的记录。<br><strong>B+树与LSM树对比</strong><br>在没有太多修改（插入或者删除）时，B+树表现得很好，因为这些修改要求执行高性能的优化操作以保证查询能在有限的时间内完成。在任意位置添加的数据规模越大，速度越快，这些页成为碎片的速度越快，最后用户写入的速度比优化重写速度更快，导致碎片化。因而只能多次随机io，导致建立索引速度变慢。<br>LSM树使用日志文件内存存储将随机写变为顺序写，因此也能保证稳定的插入速率，由于读写独立，所以不会存在冲突。由于存储数据布局更优，查询一个键需要的磁盘寻道次数在一个可预测的范围，并且读取与改建连续任意数量的记录都不会引发额外的磁盘寻道。一般来说，有几个存储文件，最多几次寻道。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Hbase主要处理两种文件：1.预写文件(write ahead file,WAL);2.实际数据文件，由HRegionServer管理。基本流程是：客户端首先联系Zookeeper子集群（quorum）查找行健，通过Zookeeper获取含有-ROOT-的region服务器名来完成。通过含有-ROOT-的region服务器可以查询到含有.meta表中对应的region服务器名。这两处内容会被缓存。最终通过.meta服务器获取客户端查询的行键所在region服务器名。一旦知道数据所在的位置，Hbase会缓存信息，后面客户端就不需要查询.meta.</p>
<h3 id="写路径"><a href="#写路径" class="headerlink" title="写路径"></a>写路径</h3><p>当用户向HregionServer发起HTable.put(Put)请求时，其会交给对应的region来处理。第一步是要决定数据是否需要写到HLog类实现的预写日志中，一旦数据被写入WAL中，数据就会放到Memstore中，同时还会检查memstore是否已经满了，如果满了，就会将请求刷新到磁盘里。刷新请求由另外一个RegionServer的线程处理，它会把数据写成HDFS中的一个新HFile，同时保存最后写的序号。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>根级文件<br>一个region服务器所有region共享一个对应的子目录，在Hbase根目录下命名为logs的目录</li>
<li>表级文件<br>每张表都有自己的目录，其位于文件系统中的hbase根目录下，每张表包括一个名为.tableinfo的顶层文件</li>
<li>region级文件<br>每张表的目录里面，每个列族都有单独一个目录。</li>
<li>region拆分<br>region存储文件增长超过配置的大小就会一分为二</li>
<li>region合并<br>合并会把磁盘文件合并成数量更少的体积更大的文件<h3 id="HFile格式"><a href="#HFile格式" class="headerlink" title="HFile格式"></a>HFile格式</h3>存储Hbase的数据，分为Trailer、MetaIndex、DataIndex、FileInfo、Data，Data一般存放Magic和keyvalue，keyvalue可以采用压缩算法压缩数据。<h3 id="keyvalue格式"><a href="#keyvalue格式" class="headerlink" title="keyvalue格式"></a>keyvalue格式</h3>keyvalue的格式：KeyLength、ValueLength、(RowLength、Row、ColumnFamilyLength、ColumnFamily、ColumnQualifier、TimeStamp、KeyType)、value,括号部分是key，可以转化为java实例，就可以通过get方法获取属性。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">System.out.println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>region服务器会将数据保存在内存中，直到积攒足够多的数据刷新到磁盘，但是存储在磁盘中的数据是不稳定的，例如断电时候就会数据丢失，比较常见的解决方案是预写日志(WAL):每次更新都会写入日志，只有当写入成功才会通知客户端操作成功。</p>
<h3 id="HLog"><a href="#HLog" class="headerlink" title="HLog"></a>HLog</h3><p>实现WAL类叫做HLog，当region收到更新操作，就直接把数据保存到一个共享的WAL实例中。</p>
<h3 id="HLog-key"><a href="#HLog-key" class="headerlink" title="HLog key"></a>HLog key</h3><p>存储keyvalue的归属，即region和表名，信息存储在HLogKey中。还存储了序列号，每一条的记录都是递增的，还记录了写入到日志的时间戳。</p>
<h3 id="WalEdit"><a href="#WalEdit" class="headerlink" title="WalEdit"></a>WalEdit</h3><p>每一个修改都会被封装为WalEdit实例。</p>
<h3 id="LogSyncer"><a href="#LogSyncer" class="headerlink" title="LogSyncer"></a>LogSyncer</h3><p>延迟日志刷写标记，如果设置为false，每一次编辑发送到服务器，都会调用写日志的sync。</p>
<h3 id="LogRoller"><a href="#LogRoller" class="headerlink" title="LogRoller"></a>LogRoller</h3><p>在特定时间内滚动日志</p>
<h2 id="读路径"><a href="#读路径" class="headerlink" title="读路径"></a>读路径</h2><p>Hbase的每个列族使用多个存储文件进行数据存储。后台合并将小文件写入到大文件减少文件的数目。墓碑标记是可以标记一个单元格，多个单元格，一整行。</p>
<h2 id="region查找"><a href="#region查找" class="headerlink" title="region查找"></a>region查找</h2><p>为了让客户端查找到包含特定主键的region，Hbase提供两张目录表，一张-ROOT-和.META.。-ROOT-用来查询所有.META.表中region的位置。Hbase的设计时只有一个root region，从而保证类似于B+树结构的三层查找：第一层是Zookeeper中包含root region位置信息的节点。第二层是从-ROOT-中查找对应meta region位置。第三层是从.META.表中查找用户表中对应region的位置。</p>
<h2 id="region的生命周期"><a href="#region的生命周期" class="headerlink" title="region的生命周期"></a>region的生命周期</h2><p>offline、pending open、opening、open、pending close、closing、closed、splitting</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>主要功能有跟踪region服务器、保存root region地址。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Hbase最基本的架构师主推送，一个主集群可以将数据复制到任意数目的从集群。所有的WALEdits都会被复制以保证原子性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据查找和存储&quot;&gt;&lt;a href=&quot;#数据查找和存储&quot; class=&quot;headerlink&quot; title=&quot;数据查找和存储&quot;&gt;&lt;/a&gt;数据查找和存储&lt;/h2&gt;&lt;h3 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>慕课网java</title>
    <link href="http://yoursite.com/2017/11/05/%E6%85%95%E8%AF%BE%E7%BD%91java/"/>
    <id>http://yoursite.com/2017/11/05/慕课网java/</id>
    <published>2017-11-05T00:49:22.000Z</published>
    <updated>2017-11-05T09:08:00.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="程序设计语言基础"><a href="#程序设计语言基础" class="headerlink" title="程序设计语言基础"></a>程序设计语言基础</h2><h2 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象不可变性"><a href="#面向对象不可变性" class="headerlink" title="面向对象不可变性"></a>面向对象不可变性</h3><p>final关键字<br>类申明：类不可集成<br>函数申明：函数不可在派生类重写<br>变量申明：变量不可指向其他对象，但是变量指向对象的内容可以改变<br>习惯性常量 static final 一般大写<br>实现不可变性：<br>1.final关键字无法保证不可变性<br>2.从接口的定义上，类的实现上保证不可变性（例如通过暴露部分变量的接口只能获取部分变量，而不能获取整个类的实例，String类的substring方法和replace方法，都不会改变自身的内容，都是new）<br>3.Collections.unmodifiableXXX(例如：list=Collections.unmodifiable(new ArrayList&lt;&gt;(t)))，编译通过，运行add会抛异常</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型。Java 编译器在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。<br>从List到List<t><br>规定类型只能是类型T，但是实现无所谓T是什么类型。<br>从List到List<t>语法<br>List<string> list=new ArrayList&lt;&gt;();//1.7<br>List<integer> list=LinkedList.of(1,2,3);<br>List<string> list=LinkedList.newEmptyList();<br>java Type erasure<br>1.早期java没有泛型；2.为了兼容性，在运行时将所有泛型擦除<br>运行时：List、List<string>、List<integer>没有区别<br>covariance<br>ArrayList<integer>是List<integer>,但是List<integer>不是List<object><br>将List<integer>转化成List<object>:<br>new ArrayList<object>(intList)或者List<object>(List) intList（危险，先要明确目的为什么转）</object></object></object></integer></object></integer></integer></integer></integer></string></string></integer></string></t></t></p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><h2 id="高级知识点"><a href="#高级知识点" class="headerlink" title="高级知识点"></a>高级知识点</h2><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>并行计算的方法：<br>把数据拆分到每个节点<br>每个节点并行的计算结果<br>把结果汇总<br>k路归并排序。把数据切分成k份，每份内部进行排序（可以用快排或者归并），然后进行k路归并，可以用k最小堆，PriorityQueue,从数据源拿数据需要使用缓存，读一段，可以考虑Iterable接口<br>Iterable<t> merge(List<iterable<t> sortedData&gt;)<br>Iterable接口的next方法，如果缓存区空，读取一段数据到缓存，给出缓存区第一个元素，缓存区元素大小（可配置）</iterable<t></t></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>死锁条件：<br>1.互斥等待<br>2.hold and wait<br>3.循环等待<br>4.无法剥夺的等待<br>解决：<br>1.一次性获取所有资源；2.顺序获取资源（根据资源某个标识顺序加锁）；3.加入超时机制</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>创建线程开销大<br>线程池：预先建立好线程，等待任务派发。</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><p>corePoolSize：线程池初始线程的数量<br>maximumPoolSize：线程中最大允许数量<br>KeepAliveTime：超出corePoolSize的线程如果等待时间超过这个时间就会被回收<br>TimeUnit:时间单位，毫秒、秒微秒，描述KeepAliveTime<br>BlockingQueue<runnable>:<br>资源的连接问题：例如数据库的连接，虽然对象被回收但是资源依然不释放。</runnable></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java视频" scheme="http://yoursite.com/tags/java%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>hbase高级特性</title>
    <link href="http://yoursite.com/2017/11/04/hbase%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/11/04/hbase高级特性/</id>
    <published>2017-11-04T02:29:11.000Z</published>
    <updated>2017-11-04T13:50:18.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器简介"><a href="#过滤器简介" class="headerlink" title="过滤器简介"></a>过滤器简介</h3><p>Get和Scan都支持过滤器，过滤器最基本的接口是Filter，所有的过滤器都在服务器生效（谓词下推），可以保证过滤的数据不会传递到客户端。<br>1.过滤器层次结构<br>最底层的过滤器是Filter和FilterBase，定好的过滤器可以传递给get和scan，通过setFilter<br>2.比较运算符<br>CompareFilter多了个compare方法，需要使用传递参数，参数有<br>LESS,LESS_OR_EQUAL,EQUAL,NOT_EQUAL,GREATER_OR_EQUAL,GREATER,NO_OP<br>3.比较器<br>CompareFilter所需要的第二个类型是比较器，比较常用的比较器有：BinaryComparator、NullComparator（判断是否为null）、RegexStringComparator（正则比较）、SubstringComparator（通过contains去操作）、BitComparator（位比较&amp;|^）</p>
<h3 id="比较过滤器"><a href="#比较过滤器" class="headerlink" title="比较过滤器"></a>比较过滤器</h3><p>CompareFilter创建实例需要运算符和比较器，</p>
<h4 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">RowFilter filter = new RowFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-row-1"</span>)));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列族过滤器"><a href="#列族过滤器" class="headerlink" title="列族过滤器"></a>列族过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">FamilyFilter filter = new FamilyFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-family"</span>))); // 列族为 my-family</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="列名过滤器-QualifierFilter"><a href="#列名过滤器-QualifierFilter" class="headerlink" title="列名过滤器(QualifierFilter)"></a>列名过滤器(QualifierFilter)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">QualifierFilter filter = new QualifierFilter(CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(<span class="string">"my-column"</span>))); // 列名为 my-column</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="值过滤器"><a href="#值过滤器" class="headerlink" title="值过滤器"></a>值过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">BinaryComparator comp = new BinaryComparator(Bytes.toBytes(<span class="string">"xmei"</span>)); //</div><div class="line">ValueFilter filter = new ValueFilter(CompareOp.EQUAL, comp);</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="参考列过滤器"><a href="#参考列过滤器" class="headerlink" title="参考列过滤器"></a>参考列过滤器</h4><p>该过滤器尝试找到该列所在的每一行，并返回该行具有该列相同时间戳的全部键值对。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">DependentColumnFilter filter = new DependentColumnFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h3 id="专用过滤器"><a href="#专用过滤器" class="headerlink" title="专用过滤器"></a>专用过滤器</h3><h4 id="单列值过滤器"><a href="#单列值过滤器" class="headerlink" title="单列值过滤器"></a>单列值过滤器</h4><p>下面一个检测列族 family 下的列 qualifier 的列值和字符串 “my-value” 相等的部分示例代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueFilter filter = new SingleColumnValueFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure></p>
<h4 id="单列排除过滤器"><a href="#单列排除过滤器" class="headerlink" title="单列排除过滤器"></a>单列排除过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">SingleColumnValueExcludeFilter filter = new SingleColumnValueExcludeFilter(Bytes.toBytes(<span class="string">"family"</span>), Bytes.toBytes(<span class="string">"qualifier"</span>), CompareOp.EQUAL, Bytes.toBytes(<span class="string">"my-value"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="前缀过滤器"><a href="#前缀过滤器" class="headerlink" title="前缀过滤器"></a>前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Filter filter=new PrefixFilter(Bytes.toBytes(<span class="string">"row-1"</span>));</div><div class="line">Scan scan=new Scan();</div><div class="line">scan.setFilter(filter);</div><div class="line">ResultScanner result=table.getScanner(scan);</div></pre></td></tr></table></figure>
<h4 id="分页过滤器"><a href="#分页过滤器" class="headerlink" title="分页过滤器"></a>分页过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">long pageSize = 10;</div><div class="line">int totalRowsCount = 0;</div><div class="line">PageFilter filter = new PageFilter(pageSize);</div><div class="line">byte[] lastRow = null;</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line"> Scan scan = new Scan();</div><div class="line"> scan.setFilter(filter);</div><div class="line"> <span class="keyword">if</span>(lastRow != null) &#123;</div><div class="line">  byte[] postfix = Bytes.toBytes(<span class="string">"postfix"</span>);</div><div class="line">  byte[] startRow = Bytes.add(lastRow, postfix);</div><div class="line">  scan.setStartRow(startRow);</div><div class="line">  System.out.println(<span class="string">"start row : "</span> + Bytes.toString(startRow));</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> ResultScanner scanner = _hTable.getScanner(scan);</div><div class="line"> int <span class="built_in">local</span>RowsCount = 0;</div><div class="line"> <span class="keyword">for</span>(Result result : scanner) &#123;</div><div class="line">  System.out.println(<span class="built_in">local</span>RowsCount++ + <span class="string">" : "</span> + result);</div><div class="line">  totalRowsCount++;</div><div class="line">  lastRow = result.getRow(); // ResultScanner 的结果集是排序好的，这样就可以取到最后一个 row 了</div><div class="line"> &#125;</div><div class="line"> scanner.close();</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(<span class="built_in">local</span>RowsCount == 0) <span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"total rows is : "</span> + totalRowsCount);</div></pre></td></tr></table></figure>
<h4 id="行键过滤器"><a href="#行键过滤器" class="headerlink" title="行键过滤器"></a>行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scan scan = new Scan();</div><div class="line">KeyOnlyFilter filter = new KeyOnlyFilter(); // 只查询每行键值对中有 <span class="string">"键"</span> 元数据信息，不显示值，可以提升扫描的效率</div></pre></td></tr></table></figure>
<h4 id="首次行键过滤器"><a href="#首次行键过滤器" class="headerlink" title="首次行键过滤器"></a>首次行键过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//该过滤器只查询每个行键的第一个键值对，在统计计数的时候提高效率。（HBase-Coprocessor 做 RowCount 的时候可以提高效率）。</div><div class="line">Scan scan = new Scan();</div><div class="line">FirstKeyOnlyFilter filter = new FirstKeyOnlyFilter(); // 只查询每个行键的第一个键值对</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="包含结束的过滤器"><a href="#包含结束的过滤器" class="headerlink" title="包含结束的过滤器"></a>包含结束的过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//常规的 Scan 包含 start-row 但不包含 stop-row，如果使用该过滤器便可以包含 stop-row。</div><div class="line">Scan scan = new Scan();</div><div class="line">InclusiveStopFilter filter = new InclusiveStopFilter(Bytes.toBytes(<span class="string">"stopRowKey"</span>));</div><div class="line">scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="时间戳过滤器"><a href="#时间戳过滤器" class="headerlink" title="时间戳过滤器"></a>时间戳过滤器</h4><h4 id="列计数过滤器"><a href="#列计数过滤器" class="headerlink" title="列计数过滤器"></a>列计数过滤器</h4><h4 id="列分页计数器"><a href="#列分页计数器" class="headerlink" title="列分页计数器"></a>列分页计数器</h4><h4 id="列前缀过滤器"><a href="#列前缀过滤器" class="headerlink" title="列前缀过滤器"></a>列前缀过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//用于列名（Qualifier）前缀过滤，即包含某个前缀的所有列名。</div><div class="line">Scan scan = new Scan();</div><div class="line">  ColumnPrefixFilter filter = new ColumnPrefixFilter(Bytes.toBytes(<span class="string">"my-prefix"</span>)); // 前缀为 my-prefix</div><div class="line">  scan.setFilter(filter);</div></pre></td></tr></table></figure>
<h4 id="随机行过滤器"><a href="#随机行过滤器" class="headerlink" title="随机行过滤器"></a>随机行过滤器</h4><h3 id="附加过滤器"><a href="#附加过滤器" class="headerlink" title="附加过滤器"></a>附加过滤器</h3><h4 id="跳转过滤器"><a href="#跳转过滤器" class="headerlink" title="跳转过滤器"></a>跳转过滤器</h4><p>这是一种附加过滤器，其与ValueFilter结合使用，如果发现一行中的某一列不符合条件，那么整行就会被过滤掉：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Filter skf = new SkipFilter(vf); // OK 发现某一行中的一列需要过滤时，整个行就会被过滤掉</div></pre></td></tr></table></figure></p>
<h4 id="全匹配过滤器（whileMatchFilter）"><a href="#全匹配过滤器（whileMatchFilter）" class="headerlink" title="全匹配过滤器（whileMatchFilter）"></a>全匹配过滤器（whileMatchFilter）</h4><p>如果你想要在遇到某种条件数据之前的数据时，就可以使用这个过滤器；当遇到不符合设定条件的数据的时候，整个扫描也就结束了：</p>
<h3 id="filterList"><a href="#filterList" class="headerlink" title="filterList"></a>filterList</h3><p>用于综合使用多个过滤器。其有两种关系：FilterList.Operator.MUST_PASS_ONE和FilterList.Operator.MUST_PASS_ALL，默认的是FilterList.Operator.MUST_PASS_ALL，顾名思义，它们分别是AND和OR的关系，并且FilterList可以嵌套使用FilterList，使我们能够表达更多的需求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();  </div><div class="line">filters.add(rf);  </div><div class="line">filters.add(vf);  </div><div class="line">FilterList fl = new FilterList(FilterList.Operator.MUST_PASS_ALL, filters); // OK 综合使用多个过滤器， AND 和 OR 两种关系</div></pre></td></tr></table></figure></p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="计数器简介"><a href="#计数器简介" class="headerlink" title="计数器简介"></a>计数器简介</h3><p>1.许多收集统计信息的应用有点击流或在线广告意见，这些应用需要收集到日志文件用作后续的分析，用户可以使用计数器做实时统计，从而放弃延时较高的批量处理操作。<br>2.原子操作检查并修改：将当前列当作计数器。<br>即把一个 column 当作一个 counter，这样便于给某些在线应用提供实时统计功能。（PS：比如帖子的实时浏览量：PV）<br>3.如果没有计数器特性：用户需要对一行数据加锁，然后读取数据，再对当前数据做加法，最后写回Hbase并释放该行锁。这样会引起大量的资源竞争，有其是当客户端进程崩溃之后，尚未释放的锁需要等待超时恢复，这会是一个高负载的系统中引起灾难性的后果。<br>4.计数器的增量可以是正数负数，正数代表加，负数代表减。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hbase(main):006:0&gt; create<span class="string">'counters'</span>,<span class="string">'daily'</span>,<span class="string">'weekly'</span>,<span class="string">'monthly'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 2.2260 seconds</div><div class="line">hbase(main):007:0&gt; incr <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 1</div><div class="line">hbase(main):008:0&gt; incr<span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span>,1</div><div class="line">COUNTER VALUE = 2</div><div class="line">hbase(main):009:0&gt; get_counter  <span class="string">'counters'</span>,<span class="string">'201031003100'</span>,<span class="string">'daily:hites'</span></div><div class="line">COUNTER VALUE = 2</div></pre></td></tr></table></figure></p>
<p>终端命令为incr ‘tablename’,’row’,’column’,[increment_value]</p>
<h4 id="单计数器"><a href="#单计数器" class="headerlink" title="单计数器"></a>单计数器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void oneCounter(long num) throws IOException&#123;</div><div class="line">long cnt1 = table.incrementColumnValue(Bytes.toBytes(<span class="string">"3100"</span>),</div><div class="line">Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"name"</span>), num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多计数器"><a href="#多计数器" class="headerlink" title="多计数器"></a>多计数器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void moreCounter() throws IOException&#123;</div><div class="line">Increment increment1 = new Increment(Bytes.toBytes(<span class="string">"3100"</span>));</div><div class="line"></div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 20);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 10);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 10);</div><div class="line"></div><div class="line">Result result1 = table.increment(increment1);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result1.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV1: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div><div class="line">Increment increment2 = new Increment(Bytes.toBytes(<span class="string">"3102"</span>));</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 5);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"info"</span>), Bytes.toBytes(<span class="string">"hits"</span>), 1);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"clicks"</span>), 0);</div><div class="line">increment1.addColumn(Bytes.toBytes(<span class="string">"class"</span>), Bytes.toBytes(<span class="string">"hits"</span>), -5);</div><div class="line">Result result2 = table.increment(increment2);</div><div class="line"><span class="keyword">for</span>(KeyValue kv:result2.raw())&#123;</div><div class="line">System.out.println(<span class="string">"KV2: "</span>+kv +<span class="string">"value: "</span>+Bytes.toLong(kv.getValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="协处理器"><a href="#协处理器" class="headerlink" title="协处理器"></a>协处理器</h3><p>协处理器允许用户在region server上运行自己的代码，准确的说是执行region级的操作，并且可以使用关系型数据库的触发器的功能。有很多使用协处理器的场景，使用钩子关联行修改操作来维护一个辅助索引，或维护一些数据间的引用完整性。协处理器主要提供两大类，observer和endpoint。<br>1）Observer（观察者）<br>该类是与RDMS中的触发器类似。回调函数在一些特定的事件发生时被调用。<br>事件包括：用户产生的事件或者服务端内部产生的事件。<br>协处理器框架提供的接口如下：<br>a、RegionObserver：用户可以通过这种处理器来处理数据修改事件，它们与表的Region紧密关联。region级的操作。对应的操作是：put/delete/scan/get<br>b、MasterObserver：可以用作管理或DDL类型的操作，是集群级的操作。对应的操作是：创建、删除、修改表。<br>c、WALObserver：提供控制WAL的钩子函数。(WAL: write ahead log)<br>Observer定义好钩子函数，服务端可以调用。<br>2）endPoint<br>该类的功能类似RDMS中的存储过程。将用户的自定义操作添加到服务器端，endPoint可以通过添加远程过程调用来扩展RPC协议。用户可以将自定义完成某项操作代码部署到服务器端。其中Endpoint可以理解为传统数据库的存储过程操作，比如可以进行某族某列值得加和。无Endpoint特性的情况下需要全局扫描表，通过Endpoint则可以在多台分布有对应表的regionserver上同步加和，在将加和数返回给客户端进行全局加和操作，充分利用了集群资源，增加性能。</p>
<h4 id="coprocessor类"><a href="#coprocessor类" class="headerlink" title="coprocessor类"></a>coprocessor类</h4><p>1）协处理器的执行顺序<br>Coprocessor.Priority枚举类型定义了两个值：SYSTEM、USER。前者优于后者执行，后者定义的按顺序执行。<br>2）协处理器的生命周期<br>协处理器的生命周期是由框架管理的，接口定义两个方法start、stop。这两个方法的参数是：CoprocessorEnvironment。该类提供了访问HBase的版本、Coprocessor版本、协处理器优先级等方法。start/stop方法是被隐式调用的，且关于协处理器的状态的定义是有一个枚举类Coprocessor.State对应的。<br>3）协处理器环境和实例的维护<br>CoprocessorHost类来完成，其有相应的子类来完成维护region、master协处理器的实例和环境。</p>
<h4 id="协处理器加载"><a href="#协处理器加载" class="headerlink" title="协处理器加载"></a>协处理器加载</h4><p>1.从配置中加载，hbase-site.xml;2.从表描述符中加载</p>
<h4 id="RegionObserver类"><a href="#RegionObserver类" class="headerlink" title="RegionObserver类"></a>RegionObserver类</h4><p>1.处理生命周期事件<br>状态1：pendingOpen，region将要被打开的状态。<br>协处理器以实现的方法是：<br>preOpen()/postOpen().完成功能是：搭载或者阻止这次打开过程。<br>preWALRestore()/postWALRestore.完成的功能是：用户可以访问那些记录被修改了，监督那些记录被实施了。<br>状态2：open，这个状态的标志是：region被部署到一个region server上且正常工作时。<br>协处理器可以实现的方法是：<br>void preFlush()/void postFlush()     内存被持久到磁盘<br>void preSpilt()/void postSpilt()          region达到足够大时进行拆分<br>状态3：pendingClose。region将要被关闭时的状态。<br>协处理器可以实现的方法是：<br>void preClose()/void postClose()<br>2.处理客户端API事件<br>这里是指在调用Java API 时，响应的事件。如：<br>void prePut()/void postPut、void preDelete()/postDelete()、void preGet()/void postGet()……..</p>
<h4 id="MasterObserver"><a href="#MasterObserver" class="headerlink" title="MasterObserver"></a>MasterObserver</h4><p>协处理器定义明确为master服务器的所有回调函数。这些回调函数中的操作是类似DDL，创建、删除、修改表。<br>1）MasterCoprocessorEnvironment<br>MasterCoprocessorEnvironment封装了MasterObserver实例，通过该类可以访问MasterService实例。<br>2）BaseMasterServer<br>BaseMasterServer是MasterServer的空实现，可以通过实现相应的pre/post来自定义相关操作。                        例如：  void preCreateTable()/void postCreateTable()  void preDeleteTable()/void postDeleteTable()……</p>
<h4 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h4><p>该接口可以使用户自定义RPC协议，它的实现代码被安装在服务端，在客户端HTable提供调用方法，使用该协议可以和协处理器实例之间通信。</p>
<h2 id="HTablePool"><a href="#HTablePool" class="headerlink" title="HTablePool"></a>HTablePool</h2><p>创建一个HTable实例，然后去复用它，可以通过HTableFactory来创建HTable，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Configuration conf = HBaseConfiguration.create();</div><div class="line">HTablePool pool = new HTablePool(conf, 10);</div><div class="line"></div><div class="line">public void createUser(String username, String firstName, String lastName, String email, String password,String roles) throws IOException &#123;</div><div class="line">　　HTable table = rm.getTable(UserTable.NAME);</div><div class="line">　　Put put = new Put(Bytes.toBytes(username));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.FIRSTNAME,</div><div class="line">　　Bytes.toBytes(firstName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.LASTNAME,</div><div class="line">　　　　Bytes.toBytes(lastName));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.EMAIL, Bytes.toBytes(email));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.CREDENTIALS,</div><div class="line">　　　　Bytes.toBytes(password));</div><div class="line">　　put.add(UserTable.DATA_FAMILY, UserTable.ROLES, Bytes.toBytes(roles));</div><div class="line">　　table.put(put);</div><div class="line">　　table.flushCommits();</div><div class="line">　　rm.putTable(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h2&gt;&lt;h3 id=&quot;过滤器简介&quot;&gt;&lt;a href=&quot;#过滤器简介&quot; class=&quot;headerlink&quot; title=&quot;过滤器简介&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hbase java api</title>
    <link href="http://yoursite.com/2017/11/02/hbase-java-api/"/>
    <id>http://yoursite.com/2017/11/02/hbase-java-api/</id>
    <published>2017-11-02T08:29:51.000Z</published>
    <updated>2017-11-03T15:19:39.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.hadoop.conf.Configuration;</div><div class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</div><div class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</div><div class="line">import org.apache.hadoop.hbase.HTableDescriptor;</div><div class="line">import org.apache.hadoop.hbase.KeyValue;</div><div class="line">import org.apache.hadoop.hbase.client.Delete;</div><div class="line">import org.apache.hadoop.hbase.client.Get;</div><div class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</div><div class="line">import org.apache.hadoop.hbase.client.HTable;</div><div class="line">import org.apache.hadoop.hbase.client.HTablePool;</div><div class="line">import org.apache.hadoop.hbase.client.Put;</div><div class="line">import org.apache.hadoop.hbase.client.Result;</div><div class="line">import org.apache.hadoop.hbase.client.ResultScanner;</div><div class="line">import org.apache.hadoop.hbase.client.Scan;</div><div class="line">import org.apache.hadoop.hbase.util.Bytes;</div><div class="line"></div><div class="line">public class Hbase &#123;</div><div class="line">    // 声明静态配置</div><div class="line">    static Configuration conf = null;</div><div class="line">    static &#123;</div><div class="line">        conf = HBaseConfiguration.create();</div><div class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"localhost"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 创建表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @family 列族列表</div><div class="line">     */</div><div class="line">    public static void creatTable(String tableName, String[] family)</div><div class="line">            throws Exception &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        HTableDescriptor desc = new HTableDescriptor(tableName);</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; family.length; i++) &#123;</div><div class="line">            desc.addFamily(new HColumnDescriptor(family[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</div><div class="line">            System.out.println(<span class="string">"table Exists!"</span>);</div><div class="line">            System.exit(0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            admin.createTable(desc);</div><div class="line">            System.out.println(<span class="string">"create table Success!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 为表添加数据（适合知道有多少列族的固定表）</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @column1 第一个列族列表</div><div class="line">     *</div><div class="line">     * @value1 第一个列的值的列表</div><div class="line">     *</div><div class="line">     * @column2 第二个列族列表</div><div class="line">     *</div><div class="line">     * @value2 第二个列的值的列表</div><div class="line">     */</div><div class="line">    public static void addData(String rowKey, String tableName,</div><div class="line">            String[] column1, String[] value1, String[] column2, String[] value2)</div><div class="line">            throws IOException &#123;</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));// 设置rowkey</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// HTabel负责跟记录相关的操作如增删改查等//</div><div class="line">                                                                    // 获取表</div><div class="line">        HColumnDescriptor[] columnFamilies = table.getTableDescriptor() // 获取所有的列族</div><div class="line">                .getColumnFamilies();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; columnFamilies.length; i++) &#123;</div><div class="line">            String familyName = columnFamilies[i].getNameAsString(); // 获取列族名</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"article"</span>)) &#123; // article列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column1.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column1[j]), Bytes.toBytes(value1[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (familyName.equals(<span class="string">"author"</span>)) &#123; // author列族put数据</div><div class="line">                <span class="keyword">for</span> (int j = 0; j &lt; column2.length; j++) &#123;</div><div class="line">                    put.add(Bytes.toBytes(familyName),</div><div class="line">                            Bytes.toBytes(column2[j]), Bytes.toBytes(value2[j]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"add data Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 根据rwokey查询</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static Result getResult(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));// 获取表</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 遍历查询hbase表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void getResultScann(String tableName, String start_rowkey,</div><div class="line">            String stop_rowkey) throws IOException &#123;</div><div class="line">        Scan scan = new Scan();</div><div class="line">        scan.setStartRow(Bytes.toBytes(start_rowkey));</div><div class="line">        scan.setStopRow(Bytes.toBytes(stop_rowkey));</div><div class="line">        ResultScanner rs = null;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        try &#123;</div><div class="line">            rs = table.getScanner(scan);</div><div class="line">            <span class="keyword">for</span> (Result r : rs) &#123;</div><div class="line">                <span class="keyword">for</span> (KeyValue kv : r.list()) &#123;</div><div class="line">                    System.out.println(<span class="string">"row:"</span> + Bytes.toString(kv.getRow()));</div><div class="line">                    System.out.println(<span class="string">"family:"</span></div><div class="line">                            + Bytes.toString(kv.getFamily()));</div><div class="line">                    System.out.println(<span class="string">"qualifier:"</span></div><div class="line">                            + Bytes.toString(kv.getQualifier()));</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">                    System.out.println(<span class="string">"timestamp:"</span> + kv.getTimestamp());</div><div class="line">                    System.out</div><div class="line">                            .println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            rs.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void getResultByColumn(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName)); // 获取指定列族和列修饰符对应的列</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 更新表中的某一列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     *</div><div class="line">     * @value 更新后的值</div><div class="line">     */</div><div class="line">    public static void updateTable(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName, String value)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Put put = new Put(Bytes.toBytes(rowKey));</div><div class="line">        put.add(Bytes.toBytes(familyName), Bytes.toBytes(columnName),</div><div class="line">                Bytes.toBytes(value));</div><div class="line">        table.put(put);</div><div class="line">        System.out.println(<span class="string">"update table Success!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 查询某列数据的多个版本</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void getResultByVersion(String tableName, String rowKey,</div><div class="line">            String familyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Get get = new Get(Bytes.toBytes(rowKey));</div><div class="line">        get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</div><div class="line">        get.setMaxVersions(5);</div><div class="line">        Result result = table.get(get);</div><div class="line">        <span class="keyword">for</span> (KeyValue kv : result.list()) &#123;</div><div class="line">            System.out.println(<span class="string">"family:"</span> + Bytes.toString(kv.getFamily()));</div><div class="line">            System.out</div><div class="line">                    .println(<span class="string">"qualifier:"</span> + Bytes.toString(kv.getQualifier()));</div><div class="line">            System.out.println(<span class="string">"value:"</span> + Bytes.toString(kv.getValue()));</div><div class="line">            System.out.println(<span class="string">"Timestamp:"</span> + kv.getTimestamp());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">         * List&lt;?&gt; results = table.get(get).list(); Iterator&lt;?&gt; it =</div><div class="line">         * results.iterator(); <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">         * System.out.println(it.next().toString()); &#125;</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     *</div><div class="line">     * @familyName 列族名</div><div class="line">     *</div><div class="line">     * @columnName 列名</div><div class="line">     */</div><div class="line">    public static void deleteColumn(String tableName, String rowKey,</div><div class="line">            String falilyName, String columnName) throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteColumn = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        deleteColumn.deleteColumns(Bytes.toBytes(falilyName),</div><div class="line">                Bytes.toBytes(columnName));</div><div class="line">        table.delete(deleteColumn);</div><div class="line">        System.out.println(falilyName + <span class="string">":"</span> + columnName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除指定的列</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     *</div><div class="line">     * @rowKey rowKey</div><div class="line">     */</div><div class="line">    public static void deleteAllColumn(String tableName, String rowKey)</div><div class="line">            throws IOException &#123;</div><div class="line">        HTable table = new HTable(conf, Bytes.toBytes(tableName));</div><div class="line">        Delete deleteAll = new Delete(Bytes.toBytes(rowKey));</div><div class="line">        table.delete(deleteAll);</div><div class="line">        System.out.println(<span class="string">"all columns are deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 删除表</div><div class="line">     *</div><div class="line">     * @tableName 表名</div><div class="line">     */</div><div class="line">    public static void deleteTable(String tableName) throws IOException &#123;</div><div class="line">        HBaseAdmin admin = new HBaseAdmin(conf);</div><div class="line">        admin.disableTable(tableName);</div><div class="line">        admin.deleteTable(tableName);</div><div class="line">        System.out.println(tableName + <span class="string">"is deleted!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">        // 创建表</div><div class="line">        String tableName = <span class="string">"blog2"</span>;</div><div class="line">        String[] family = &#123; <span class="string">"article"</span>, <span class="string">"author"</span> &#125;;</div><div class="line">        // creatTable(tableName, family);</div><div class="line"></div><div class="line">        // 为表添加数据</div><div class="line"></div><div class="line">        String[] column1 = &#123; <span class="string">"title"</span>, <span class="string">"content"</span>, <span class="string">"tag"</span> &#125;;</div><div class="line">        String[] value1 = &#123;</div><div class="line">                <span class="string">"Head First HBase"</span>,</div><div class="line">                <span class="string">"HBase is the Hadoop database. Use it when you need random, realtime read/write access to your Big Data."</span>,</div><div class="line">                <span class="string">"Hadoop,HBase,NoSQL"</span> &#125;;</div><div class="line">        String[] column2 = &#123; <span class="string">"name"</span>, <span class="string">"nickname"</span> &#125;;</div><div class="line">        String[] value2 = &#123; <span class="string">"nicholas"</span>, <span class="string">"lee"</span> &#125;;</div><div class="line">        addData(<span class="string">"rowkey1"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey2"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line">        addData(<span class="string">"rowkey3"</span>, <span class="string">"blog2"</span>, column1, value1, column2, value2);</div><div class="line"></div><div class="line">        // 遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line">        // 根据row key范围遍历查询</div><div class="line">        getResultScann(<span class="string">"blog2"</span>, <span class="string">"rowkey4"</span>, <span class="string">"rowkey5"</span>);</div><div class="line"></div><div class="line">        // 查询</div><div class="line">        getResult(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 更新列</div><div class="line">        updateTable(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>, <span class="string">"bin"</span>);</div><div class="line"></div><div class="line">        // 查询某一列的值</div><div class="line">        getResultByColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 查询某列的多版本</div><div class="line">        getResultByVersion(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"name"</span>);</div><div class="line"></div><div class="line">        // 删除一列</div><div class="line">        deleteColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>, <span class="string">"author"</span>, <span class="string">"nickname"</span>);</div><div class="line"></div><div class="line">        // 删除所有列</div><div class="line">        deleteAllColumn(<span class="string">"blog2"</span>, <span class="string">"rowkey1"</span>);</div><div class="line"></div><div class="line">        // 删除表</div><div class="line">        deleteTable(<span class="string">"blog2"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>事实上，许多基于列表的操作，如delete(List <delete> deletes)或者get(List <get> gets)，都是基于batch()方法实现的。它们都是一些为了方便用户使用而保留的方法。如果你是新手，推荐使用batch()方法进行所有操作。<br>下面的客户端API方法提供了批量处理操作。用户可能注意到这里引入了一个新的名为Row的类，它是Put、Get和Delete的祖先，或者是父类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void batch(List&lt;Row&gt; actions,Object[] results) throws IOException,InterruptedException</div><div class="line">Object [] batch(List&lt;Row&gt; actions) throws IOException,InterruptedException</div></pre></td></tr></table></figure></get></delete></p>
<p>使用同样的父类允许在列表中实现多态，即放入以上3种不同的子类。这种调用跟之前介绍的基于列表的调用方法一样简单调用。请注意，不可以将针对同一行的Put和Delete操作放在同一个批量处理请求中，为了保证最好的性能，这些操作的处理顺序可能不同，但是这样会产生不可预料的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void batchDone(HTable hTable,String[] family,String[] column1) throws IOException&#123;</div><div class="line"></div><div class="line">      List&lt;Row&gt; batch = new ArrayList&lt;Row&gt;();</div><div class="line">        Put put = new Put(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        put.add(family[0].getBytes(), column1[1].getBytes(), Bytes.toBytes(<span class="string">"valTest"</span>));</div><div class="line">        batch.add(put);</div><div class="line">        Get get1 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get1.addColumn(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(get1);</div><div class="line">        Delete delete = new Delete(<span class="string">"rowkey4"</span>.getBytes());</div><div class="line">        delete.deleteColumns(family[0].getBytes(), column1[1].getBytes());</div><div class="line">        batch.add(delete);</div><div class="line">        Get get2 = new Get(<span class="string">"rowkey1"</span>.getBytes());</div><div class="line">        get2.addFamily(family[0].getBytes());</div><div class="line">        batch.add(get2);</div><div class="line">        Object[] results = new Object[batch.size()];</div><div class="line">        try &#123;</div><div class="line">            hTable.batch(batch,results);</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; results.length; i++) &#123;</div><div class="line">     System.out.println(results[i]);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>results返回值有<br>null    操作与远程服务器的通信失败<br>EmptyResult    Put与Delete操作成功后的返回结果<br>Result    Get操作成功的返回结果，如果没有匹配的行或列，会返回空的Result<br>Throwable    当服务器端返回一个异常时，这个异常会按原样返回给客户端。用户可以使用这个异常检查哪里出了错，也许可以在自己的代码中自动处理异常<br>void batch(List<row> actions,Object[] results)和Object [] batch(List<row> actions)<br>不同点：后面那个批量操作一旦出现异常，将不会获取到结果<br>相同点：get、delete和put都支持，如果执行时出现问题，客户端将抛出异常并报告问题。</row></row></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>像put、delete、checkAndPut这样的修改操作是独立执行的，这意味者在一个串行方式的执行中，对于每一行必须保证行级别的操作是原子性，region服务器提供了行锁的特性，这个特性保证只有一个客户获得一行数据对应的锁，同时对该行进行修改。使用如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RowLock lock=table.lockRow(row1);</div><div class="line">Put put=new Put(row1,lock);</div><div class="line">table.put(put);</div><div class="line">table.unlockRow(lock);</div></pre></td></tr></table></figure></p>
<p>获取数据也可以加显式锁，历史提供了Get(byte[] row,RowLock lock)，但服务器根本用不到这个方法，首先不说加锁的性能影响，原因在于获取数据时，应用了多版本并发控制保证行级读操作。<br>备注：MVCC算法<br>HBase采用了MVCC算法来避免读操作去获取行锁。<br>对于写操作：<br>(w1) 获取行锁后，每个写操作都立即分配一个写序号<br>(w2) 写操作在保存每个数据cell时都要带上写序号<br>(w3) 写操作需要申明以这个写序号来完成本次写操作（标注该行）<br>对于读操作:<br>(r1) 每个读操作开始都分配一个读序号，也称为读取点<br>(r2) 读取点的值是所有的写操作完成序号中的最大整数(所有的写操作完成序号&lt;=读取点）<br>(r3) 对某个(row,column)的读取操作r来说，结果是满足写序号为“写序号&lt;=读取点这个范围内”的最大整数的所有cell值的组合</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>Put、Delete与Get对象都是Row的子类，从该继承关系中我们就可以了解到Get、Delete与Pu对象本身就只能进行单行的操作，HBase客户端还提供了一套能够进行全表扫描的API，方便用户能够快速对整张表进行扫描，以获取想要的结果—scan</p>
<h3 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h3><p>全表扫描是一种不需要行键值的操作，因此初始化时不需要指定行键值，因此就产生了不同的使用方法<br>1、不进行Scan对象创建的全表扫描<br>在该过程中，Htable对象会在扫描请求发送前隐式的创建一个scan对象，然后传递给Hbase服务器集群。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void scanWithoutInit(String tableName,String family)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            //获取全表扫描  </div><div class="line">            ResultScanner resultScanner=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            //对结果进行显示  </div><div class="line">            Iterator&lt;Result&gt; results=resultScanner.iterator();  </div><div class="line">            <span class="keyword">while</span>(results.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                Result result=results.next();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:result.raw())  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>getScanner()方法时，如果不输入指定的scan对象，则需要输入相应的列簇或者列。因此在不进行scan对象创建的扫描中，需要明确指出列簇或者列，如果需要扫描多个列簇时，该方法就无法起到作用了。<br>2、进行初始化的全表扫描<br>初始化一个scan对象，然后对该对象进行相应的配置过，通过 getScanner(Scan scan) 函数进行全表扫描。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void scanWithInit(String tableName)  </div><div class="line">    &#123;  </div><div class="line">        Configuration conf=init();  </div><div class="line">        try &#123;  </div><div class="line">            HBaseAdmin admin=new HBaseAdmin(conf);  </div><div class="line">            <span class="keyword">if</span>(!admin.tableExists(tableName))  </div><div class="line">            &#123;  </div><div class="line">                System.err.println(<span class="string">"the table "</span>+tableName+<span class="string">" is not exist"</span>);  </div><div class="line">                admin.close();  </div><div class="line">                System.exit(1);  </div><div class="line">            &#125;  </div><div class="line">            //创建扫描类  </div><div class="line">            Scan scan=new Scan();  </div><div class="line">            scan.setStartRow(Bytes.toBytes(<span class="string">"row-1"</span>));  </div><div class="line">            scan.setStopRow(Bytes.toBytes(<span class="string">"row-9"</span>));  </div><div class="line">            //创建表连接  </div><div class="line">            HTable table=new HTable(conf, tableName);  </div><div class="line">            ResultScanner rs=table.getScanner(scan);  </div><div class="line">            Result result;  </div><div class="line">            <span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">            &#123;  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();  </div><div class="line">            table.close();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            // TODO: handle exception  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在上段代码中，使用了setStartRow() 与 setStopRow() 两个函数进行调优。Scan有多个函数可以进行对全表扫描做出相应的规范。<br>3、数据遍历与显示ScannerResult<br>通过上述两种方法可以发送对一张表是遍历请求，当发送后，服务器会相应的启动全表扫面程序，从而准备向客户端返回相应的数据。因此根据客户端的遍历需要对数据尽心请求，然后将请求的结果进行返回，客户端拿到后进行展示<br>（1）next()的单行返回数据的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ResultScanner rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">//进项单行获取演示  </div><div class="line">Result result=null;  </div><div class="line"><span class="keyword">while</span>((result=rs.next())!=null)  </div><div class="line">&#123;  </div><div class="line">    KeyValue[] kvs=result.raw();  </div><div class="line">    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">rs.close();</div></pre></td></tr></table></figure></p>
<p>next()方法会默认想客户端请求发送一行数据请求，刚服务器端的scan程序接收到请求后会将经需要返回的数据封装成一个result对象返回给客户端，因此客户端可以通过result对象去接受该行数据。接收到的数据则跟Get中的result使用方法是相同的。<br>（2）next(int n)的多行返回数据的方法<br>next(int n)：该函数会向服务器发送多个请求，以返回多条数据请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//一次获取多个结果（行数据）进行展示  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Result[] results=null;  </div><div class="line">            <span class="keyword">while</span>((results=rs.next(2))!=null)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">for</span>(Result r:results)  </div><div class="line">                &#123;  </div><div class="line">                    KeyValue[] kvs=r.raw();  </div><div class="line">                    <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                    &#123;  </div><div class="line">                        System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                        System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>next(int n)函数返回的是一个result数组。用户接受到数据后可以进行相应的操作。<br>（3）迭代器遍历<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进行迭代的方式进行输出  </div><div class="line">            rs=table.getScanner(Bytes.toBytes(family));  </div><div class="line">            Iterator&lt;Result&gt; resultIterator=rs.iterator();  </div><div class="line">            <span class="keyword">while</span>(resultIterator.hasNext())  </div><div class="line">            &#123;  </div><div class="line">                result=resultIterator.next();  </div><div class="line">                KeyValue[] kvs=result.raw();  </div><div class="line">                <span class="keyword">for</span>(KeyValue kv:kvs)  </div><div class="line">                &#123;  </div><div class="line">                    System.out.println(Bytes.toString(kv.getRow()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getFamily()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getQualifier()));  </div><div class="line">                    System.out.println(Bytes.toString(kv.getValue()));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            //关闭表  </div><div class="line">            rs.close();</div></pre></td></tr></table></figure></p>
<p>（4）注意点<br>因为当用户发送一个scan全表扫描后，region服务器会为全表扫描创建扫描资源，因此长时间启用全表扫描的话会占用region服务器的大量资源，所以在要求在使用完scanner扫描器后尽快释放掉资源。<br>rs.close() 会告知服务其扫描器租约已经结束，服务器就会释相应的全局扫描的资源。<br>三、Scan对象<br>（1）setStartRow() / setStopRow<br>设置扫描的开始行与结束行，通过这两个可以直接确scan在扫描的范围，通过缩小范围可以减少扫描到时间，从而提高扫描的效率<br>（2）addFamily() / addColumn()<br>通过这两个函数，可以在列或者列簇上的扫描位置。HBase是面向lie出书的数据库，而同一个列簇的数据全部存放在同一个位置文件中。因此如果可以确定扫描那个一列簇时，可以减少扫描的范围，从而缩短扫描的时间。而在确定到某一个列时也会因为HBase的面向列存储使得其效率提高。<br>（3）setMaxVersion() / setMaxVersion(int version)<br>设置返回的版本数量，默认为返回最新的数据。第一个函数则会返回所有的版本数据，第二个函数可以设置返回的版本数量<br>（4）setTimeStamp(long max)<br>返回该时间戳的数据<br>（5）setTimeRange(long min,long max)<br>设定返回的时间戳的范围，只有版本值在该范围之内的数据才会被返回到客户端<br>（6）setFilter(Filter f)<br>设置过滤器，有时候扫描全表返回的数量过大时，可以通过过滤器将不符合的数据进行过滤，这样可以减少从服务器到客户端的数据传送，挺高扫描效率。<br>（7）setCacheBlocks(boole open)<br>在进行全表扫描过程中，服务器端提供了一个缓存区，该缓存区可以将指定的数据量全部放入到内存中，这样可以提高读取效率。缓存区的打开也可以通过htable客户端进行打开。在开发后用户可以通过 setCache(int n)的方式设置每次缓存的数量为多少。通过调整该函数以提高读取的效率。<br>四、总结<br>scan的全表扫描区别于其他三个操作，虽然获取数据与Get获取的数据是相同的，其与Get也具有形似的属性，可以通过修改这些属性去对数据获取进行调优，从而使得提高数据获取的效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CRUD操作&quot;&gt;&lt;a href=&quot;#CRUD操作&quot; class=&quot;headerlink&quot; title=&quot;CRUD操作&quot;&gt;&lt;/a&gt;CRUD操作&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hbase简介(第一章)</title>
    <link href="http://yoursite.com/2017/11/01/hbase%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/11/01/hbase简介/</id>
    <published>2017-11-01T01:38:49.000Z</published>
    <updated>2017-11-02T02:11:44.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="海量数据的黎明"><a href="#海量数据的黎明" class="headerlink" title="海量数据的黎明"></a>海量数据的黎明</h2><p>hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，可以帮助用户分析数据时决定如何解释这些数据，同时允许用户随时更改数据分类的方式；一旦用户更新了算法，只需要重新分析数据。Hadoop是现有数据库的一个补充，提供了数据存储无限的空间，并且针对大文件存储、批量访问和流式访问做了优化。<br>列式存储数据库，以列为单位聚合数据，然后将列值顺序存入磁盘，而行式数据库则是连续存储整行。<br>1.优点是：查询时只有涉及到的列会被读取；投影(projection)很高效；任何列都能作为索引。缺点：选择完成时，被选择的列要重新组装；INSERT/UPDATE比较麻烦。<br>2.更好的进行数据压缩：通过字典表压缩数据。经过字典表进行数据压缩后，表中的字符串才都变成数字了，比如我们的材料名可以用一张材料表，这样子在列存储就可以根据id来关联材料。<br>3.查询性能<br>我们能根据列查询结果通过为运算（&amp;或者|）进行结果合并，加快速度<br>关键步骤如下：<br>1.去字典表里找到字符串对应数字(只进行一次字符串比较)。<br>2.用数字去列表里匹配，匹配上的位置设为1。<br>3.把不同列的匹配结果进行位运算得到符合所有条件的记录下标。<br>4.使用这个下标组装出最终的结果集。<br>Hbase以列式存储的格式存储数据，传统的列式存储比较适合实时存储数据的场景，Hbase比较适合键值对的数据存取或者有序的数据存取。</p>
<h2 id="关系数据库系统的问题"><a href="#关系数据库系统的问题" class="headerlink" title="关系数据库系统的问题"></a>关系数据库系统的问题</h2><p>数据量大时，索引量也大到足以让数据库的性能直线下降。最后能够提供的查询也只剩下主键查询，最后的采取的方案就是数据分区，也就是分库分表。</p>
<h2 id="非关系型数据库系统"><a href="#非关系型数据库系统" class="headerlink" title="非关系型数据库系统"></a>非关系型数据库系统</h2><h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><p>包括数据模型、存储模型、一致性模型、物理模型、读写性能、辅助索引、故障处理、压缩、负载均衡、原子操作的读修改写、加锁等待死锁</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><h3 id="数据库的范式和反范式"><a href="#数据库的范式和反范式" class="headerlink" title="数据库的范式和反范式"></a>数据库的范式和反范式</h3><h2 id="Hbase结构"><a href="#Hbase结构" class="headerlink" title="Hbase结构"></a>Hbase结构</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="表、行、列和单元格"><a href="#表、行、列和单元格" class="headerlink" title="表、行、列和单元格"></a>表、行、列和单元格</h3><p>最基本的单位是列，一列或者多列构成一行，并由唯一的行健来确定存储。反过来，一个表中有若干行，其中每列可能有多个版本，在每个单元格中存储了不同值。行序是按照字典顺序进行排序的，意思是从左到右一次对比每一个键。关于排序：排列顺序如果跟预期的不一样，需要补键，比如  row-1 永远小于 row-2，无论后面是什么，将始终按照这个顺序排列。行健总是唯一的，否则你就是在更新同一行。行健可以是任意的字节数组，但它不一定是人直接可读。<br>一行由若干列组成，若干列构成一个列族，有助于构建语义边界，还有助于给他们设置某些特性（压缩），或者指示他们存储在内存中。一个列族所有列存储在HFile。<br>常用的引用列的格式为family：qualifier，qualifier是任意字节数组。一个列族没有列的数量限制，可以有数百万列。列值没有类型和长度的限制。NUll值在Hbase不占任何空间。<br>每一列的值或者单元格都有时间戳，不同时间戳区分不同的版本值，同一个单元格的不同版本值按照时间戳降序排序，访问时候优先读取最新的值。这样优化使得新值比老值更容易读到。用户可以指定每个值能保存的最大版本数，此外还支持谓词删除（LSM树）。<br>Hbase是一个稀疏的、分布式的、持久化的、多维的映射、由行健列键和时间戳索引。数据存储模式：(Table,RowKey,Family,Column,TimeStamp)-&gt;value</p>
<h3 id="自动分区"><a href="#自动分区" class="headerlink" title="自动分区"></a>自动分区</h3><p>Hbase中扩展和负载均衡的基本单元是region，region本质是以行键排序的连续存储的区间。如果region太大，系统会动态拆分，相反会合并region，减少存储文件数量。<br>一张表初始化只有一个region，用户不断插入数据，当数据量超过配置的最大值，会在中间键处将这个region拆分成两个大致相等的region。每一个region只能由一台regionServer加载，而一台RegionServer可以同时加载多个region。（每台regionServer1加载的最佳数量是10~1000，每个region最佳大小是1GB~2GB）。当某个region服务器由于负载过大等原因导致不可用时，系统会将该region转到其他服务器上。</p>
<h3 id="存储API"><a href="#存储API" class="headerlink" title="存储API"></a>存储API</h3><p>API提供了建表、删表、增加列族、删除列族、修改表、修改列族元数据（压缩，设置块大小）、行键值的增加，删除，查找<br>scan可以限定返回的列或者返回的版本数，可以设置过滤器。系统支持单行事务，进一步实现单行键下存储的数据的 读-修改-写（read-modify-write）序列。单元格的值可以当计数器用，并且支持原子更新，意味着这个计数器可以在一个操作中实现读写，客户端可以基于此实现一个全局强一致的计数器。协处理器(coprocessor): 可以在服务器的地址空间执行来自客户端的代码。用于实现轻量级的批处理作业，或者使用表达式分析或者汇总数据。通过包装器可以将表转换成MapReduce的输入输出目标</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>数据存储在存储文件中，称为HFile，HFile存储的是经过排序的键值映射结构。文件内部由连续的块组成，块的索引信息放在尾部，当打开HFile并加载在内存中，索引信息会优先加载到内存中，每个块的大小为64k。每个HFile都有一个块索引，通过一个磁盘查询就可以实现查询，存储文件写在HDFS中。每次更新数据，都会将数据记录在提交日志中，然后在将数据写入内存memstore,一旦内存超过一定的大小，就会移除内存，作为HFile写入磁盘。移除内存后，就会丢弃提交日志，只保留未持久化的提交日志。数据移出memstore，丢弃提交日志。采用滚动memstore可以实现不阻塞系统读写，即用空的新memstore获取更新数据，将旧的满的memstore转换成一个文件，由于memstore中的数据本来就排序好了，所以存储的时候不用再次排序。删除是在做个删除标记，让客户端无法读取到值。<br>HFile过多的时候有管家机制来处理，合并有两种类型：<br>minor合并：多个小文件合并成一个大文件，由于是多路归并所以速度快<br>major压缩合并：将region中一个列族的若干个HFile重写为一个新HFile。合并扫描所有键值对，顺序重写所有数据，重写数据的过程中会略过做了删除标记的数据。断言删除此时生效。<br>master 负责负载均衡，将繁忙服务器中的region移到负载轻的服务器中。还提供元数据的管理，例如创建表和创建列族。<br>region服务器负责为他们提供的Region提供读写功能<br>数十亿行<em>数百万列</em>数千个版本=TB级别或者PB级别的存储</p>
<h2 id="Hbase：Hadoop数据库"><a href="#Hbase：Hadoop数据库" class="headerlink" title="Hbase：Hadoop数据库"></a>Hbase：Hadoop数据库</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Hbase是一个分布式的、持久性的、强一致性的存储系统，具有近似最优的写性能和出色的读性能。它充分利用磁盘空间，支持特定列族切换可选压缩算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;海量数据的黎明&quot;&gt;&lt;a href=&quot;#海量数据的黎明&quot; class=&quot;headerlink&quot; title=&quot;海量数据的黎明&quot;&gt;&lt;/a&gt;海量数据的黎明&lt;/h2&gt;&lt;p&gt;hadoop项目有两个模块：HDFS和MapReduce。Hadoop擅长存储任意的、半结构化数据，
    
    </summary>
    
      <category term="hbase" scheme="http://yoursite.com/categories/hbase/"/>
    
    
      <category term="hbase权威指南" scheme="http://yoursite.com/tags/hbase%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch入门</title>
    <link href="http://yoursite.com/2017/10/31/elasticSearch%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/10/31/elasticSearch初步了解/</id>
    <published>2017-10-31T15:10:46.000Z</published>
    <updated>2017-11-13T12:40:24.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elasticSearch简介"><a href="#elasticSearch简介" class="headerlink" title="elasticSearch简介"></a>elasticSearch简介</h2><p>1.基于Apache Lucene构建的开源搜索引擎<br>2.基于java编写，提供简单易用的Resful API<br>3.轻松的横向扩展，可支持PB级别的结构化和非结构化的数据处理</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1.海量数据分析引擎<br>2.站内搜索引擎<br>3.数据仓库<br>备注应用：github站内搜索、维基百科、百度实时日志监控</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>版本历史 1.x-&gt;2.x-&gt;5.x</p>
<h2 id="安装head插件"><a href="#安装head插件" class="headerlink" title="安装head插件"></a>安装head插件</h2><p>安装elasticsearch-head,github地址：<a href="https://github.com/mobz/elasticsearch-head.git，然后进行npm" target="_blank" rel="external">https://github.com/mobz/elasticsearch-head.git，然后进行npm</a> install，在启动head插件（npm run start），<a href="http://localhost:9100。" target="_blank" rel="external">http://localhost:9100。</a><br>同时更改elasticsearch.yml，新增以下内容支持跨域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http.cors.enabled: <span class="literal">true</span></div><div class="line">http.cors.allow-origin: <span class="string">"*"</span></div></pre></td></tr></table></figure></p>
<h2 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建</h2><p>举个例子，三个节点<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: master</div><div class="line">node.master: <span class="literal">true</span></div><div class="line">network.host: 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>slave节点的配置如下，在elasticsearch.yml修改<br>master节点配置如下，在elasticsearch.yml修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cluster.name: lili</div><div class="line">node.name: slave1</div><div class="line">network.host: 127.0.0.1</div><div class="line">http.port: 8200</div><div class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"127.0.0.1"</span>]</div></pre></td></tr></table></figure></p>
<h2 id="集群和节点"><a href="#集群和节点" class="headerlink" title="集群和节点"></a>集群和节点</h2><p>集群有节点组成，每个集群有唯一的名字。 一个节点只是集群的一部分，节点通过集群名字加入集群</p>
<ul>
<li>索引(database)<br>含有相同属性的文档集合</li>
<li>类型(table)<br>索引可以定义一个或者多个类型，文档必须属于一个类型</li>
<li>文档(row)<br>文档是可以被索引的基本数据单位</li>
<li>分片<br>每个索引都有多个分片，每个分片是lucene索引</li>
<li>备份<br>拷贝一份分片就完成了分片的备份<br>备注：es默认五个分片一个备份<h2 id="es的基本用法"><a href="#es的基本用法" class="headerlink" title="es的基本用法"></a>es的基本用法</h2></li>
<li>api的基本格式：http://<ip>:<port>/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</port></ip></li>
<li>常用的动词有：GET/PUT/POST/DELETE<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3>在head插件创建索引<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:book put请求</div><div class="line">&#123;</div><div class="line">  <span class="string">"novel"</span>: &#123;</div><div class="line">    <span class="string">"properties"</span>: &#123;</div><div class="line">      <span class="string">"title"</span>: &#123;</div><div class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用postman插件，可视化插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//localhost:9200:people put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"settings"</span>:&#123;</div><div class="line">		<span class="string">"number_of_shards"</span>:3,</div><div class="line">		<span class="string">"number_of_replicas"</span>:1</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"mappings"</span>:&#123;</div><div class="line">		<span class="string">"man"</span>:&#123;</div><div class="line">			<span class="string">"properties"</span>:&#123;</div><div class="line">				<span class="string">"name"</span>:&#123;</div><div class="line">					<span class="string">"type"</span>:<span class="string">"text"</span></div><div class="line">				&#125;,</div><div class="line">			    <span class="string">"country"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"keyword"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"age"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"integer"</span></div><div class="line">			    &#125;,</div><div class="line">			    <span class="string">"date"</span>:&#123;</div><div class="line">			    	<span class="string">"type"</span>:<span class="string">"date"</span>,</div><div class="line">			    	<span class="string">"format"</span>:<span class="string">"yyyy-MM-dd HH:mm:ss"</span></div><div class="line">			    &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入索引"><a href="#插入索引" class="headerlink" title="插入索引"></a>插入索引</h3><ul>
<li><p>指定文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1 Put请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"lirui"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 24,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-09-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自动产生文档id插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man POST请求</div><div class="line">&#123;</div><div class="line">	<span class="string">"name"</span>:<span class="string">"李睿"</span>,</div><div class="line">	<span class="string">"country"</span>: <span class="string">"china"</span>,</div><div class="line">	<span class="string">"age"</span>: 25,</div><div class="line">	<span class="string">"date"</span>: <span class="string">"2000-06-01 11:00:23"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/_update POST请求</div><div class="line">  &#123;</div><div class="line">  	<span class="string">"doc"</span>:&#123;</div><div class="line">       <span class="string">"name"</span>:<span class="string">"kobe_brant"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/man/1/ DELETE请求</div></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>使用head插件删除索引或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/ DELETE请求</div></pre></td></tr></table></figure></p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//127.0.0.1:9200/people/_search POST</div><div class="line">//查询全部</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match_all"</span>:&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//针对查询</div><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"match"</span>:&#123;<span class="string">"name"</span>:<span class="string">"kobe"</span>&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"sort"</span>:[</div><div class="line">    	   &#123;</div><div class="line">    	   	<span class="string">"date"</span>:&#123;</div><div class="line">    	   	  <span class="string">"order"</span>:<span class="string">"desc"</span></div><div class="line">    	   &#125;</div><div class="line">    	   &#125;</div><div class="line">    	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"aggs"</span>:&#123;</div><div class="line">		<span class="string">"group_by_name"</span>:&#123;</div><div class="line">			<span class="string">"terms"</span>:&#123;</div><div class="line">				<span class="string">"field"</span>:<span class="string">"country"</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ul>
<li>子条件查询<br>特定字段查询所指的特定值<h4 id="query-context"><a href="#query-context" class="headerlink" title="query context"></a>query context</h4>查询过程中，除了判断文档是否满足条件外，es会计算一个_sore来标识匹配程度<br>分为全文本查询（文本类型数据）和字段级别查询（结构化数据如数字、日期）<h4 id="filter-context"><a href="#filter-context" class="headerlink" title="filter context"></a>filter context</h4>在查询时只需要判断文档是否满足条件，只有Yes或者No。</li>
<li>复合条件查询<br>以一定逻辑组合子条件查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"query"</span>:&#123;</div><div class="line">    <span class="string">"bool"</span>:&#123;</div><div class="line">      <span class="string">"should"</span>:[&#123;</div><div class="line">         <span class="string">"match"</span>:&#123;</div><div class="line">           <span class="string">"author"</span>:<span class="string">"瓦力"</span></div><div class="line">         &#125;</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">          <span class="string">"match"</span>:&#123;</div><div class="line">            <span class="string">"title"</span>:<span class="string">"瓦力"</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">    <span class="string">"filter"</span>:[</div><div class="line">      &#123;</div><div class="line">        <span class="string">"term"</span>:&#123;</div><div class="line">          <span class="string">"word_count"</span>:1000</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;elasticSearch简介&quot;&gt;&lt;a href=&quot;#elasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;elasticSearch简介&quot;&gt;&lt;/a&gt;elasticSearch简介&lt;/h2&gt;&lt;p&gt;1.基于Apache Lucene构
    
    </summary>
    
      <category term="elasticSearch" scheme="http://yoursite.com/categories/elasticSearch/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>构建大型网站的其他要素（第八章）</title>
    <link href="http://yoursite.com/2017/10/29/%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E5%85%B6%E4%BB%96%E8%A6%81%E7%B4%A0/"/>
    <id>http://yoursite.com/2017/10/29/构建大型网站的其他要素/</id>
    <published>2017-10-29T05:25:33.000Z</published>
    <updated>2017-11-07T14:20:08.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加速静态内容访问的速度的CDN"><a href="#加速静态内容访问的速度的CDN" class="headerlink" title="加速静态内容访问的速度的CDN"></a>加速静态内容访问的速度的CDN</h2><p>CDN，Content Delivery Network，内容分发网络。CDN的作用是把用户需要的内容分发到离用户近的地方，这样可以从用户能就近获取所需的内容。整个CDN系统分为CDN源站和CDN节点。CDN源站提供CDN节点使用的数据源头，CDN节点部署在离最终用户比较近的地方，加速用户对站点的访问。CDN就是网络缓存技术，一般存放静态文件（js，css，图片，视频，页面框架）。<br>浏览器访问网站的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，获取ip地址；<br>3.浏览器向所得到的ip发送请求；<br>4.浏览器根据返回的内容显示数据<br>有了CDN后的顺序：<br>1.用户提交要访问的域名地址；<br>2.浏览器对域名进行解析，由于CDN对域名解析过程做了调整，所以得到该域名对应的CNAME记录。<br>3.对CNAME进行解析得到实际的ip地址。在这次解析中会使用全局负载均衡CDN解析，需要我们根据地理位置以及所在的ISP确定结果，然后获取到具体的IP地址。<br>4.得到实际的ip地址后，我们会向服务器发送请求。<br>5.CDN会根据请求的内容是否在本地缓存进行不同的处理。<br>如果存在，直接返回结果；不存在，则请求CDN源站，获取内容，返回结果。<br>CDN关键的技术：<br>1.全局调度<br>全局调度是完成用户就近访问的第一步，我们需要根据用户地域、接入运营商、以及CDN机房的负载情况去调度。<br>2.缓存技术<br>如果请求不存在CDN节点，则请求CDN源站，获取内容，返回结果。如果命中率不高，加速有限。要提升命中率，首先缓存的容量要足够大，可以使用内存+SSD+硬盘混合存储。还有新增变更数据预加载也能提升命中<br>3.内容分发<br>内容分发主要包括在CDN上不用回源的数据的管理和分发，主要包括静态页面。<br>4.带宽优化<br>只返回必要数据和使用更好的压缩算法</p>
<h2 id="大型网站的存储支持"><a href="#大型网站的存储支持" class="headerlink" title="大型网站的存储支持"></a>大型网站的存储支持</h2><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><p>对一些图片、大文本的存储使用数据库就不合适了。GFS主要由三部分构成：GFS Client、GFS Master、GFS chunkserver</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>应用使用GFS的入口，Client负责从GFS Master上获取要操作的文件在chunkserver中的具体地址，然后直接和chunkserver通信，获取数据或者进行数据写入和更新。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>可以说是整个文件系统的大脑，这里维护了所有的文件系统的元数据，包括名字空间、访问控制信息、文件与chunk的映射信息、chunk的当前位置。Master也控制整个系统范围内的活动，例如，无效的chunk的回收以及chunksever之前的chunk迁移等。Master与chunkServer之间通过周期性的心跳进行通信，检测对方是否在线。</p>
<h4 id="ChunkServer"><a href="#ChunkServer" class="headerlink" title="ChunkServer"></a>ChunkServer</h4><p>这是文件系统存储的地方。在每个chunkserver上会用chunk的方式管理数据。每个chunk是固定大小的文件，超过chunk的文件会被分为多个chunk进行存储，小于chunk的文件则会将多个文件存储在一个chunk中。<br>GFS主要解决单机的存储问题和安全问题，HDFS是java的类GFS的实现。</p>
<h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h3><p>not only sql。基本上处于分布式文件系统和SQL关系型数据库之间的系统都被归为NoSql范畴。<br>在NoSql Data Modeling Techniques文章中，一个NoSql和Sql的基础都来自key value，另外一个NoSql继续发展，就会变成Sql数据库。</p>
<h4 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h4><p>最基础的技术支撑，后续的产品都基于key-value存储发展起来。但是有个问题，没有办法进行高效的范围查询。</p>
<h4 id="ordered-key-value"><a href="#ordered-key-value" class="headerlink" title="ordered key-value"></a>ordered key-value</h4><p>key是有序的，可以解决key的范围查询的效率，但是在这个模型中，value本身的内容和结构是由应用来负责解析和存储的。</p>
<h4 id="Big-Table"><a href="#Big-Table" class="headerlink" title="Big Table"></a>Big Table</h4><p>是google发表的名为BigTable：A Distributed Storage System for Structured Data论文中提到的一个产品，是一个结构化数据的分布式存储系统。BigTable对value进行了schema的支持，value是由多个Column family组成，Column family的内部是Column，ColumnFamily不能动态扩展，但是Column能够动态扩展。（hbase可以是里面的一个实现）</p>
<h4 id="Document-full-text-Search"><a href="#Document-full-text-Search" class="headerlink" title="Document full-text Search"></a>Document full-text Search</h4><p>Document数据库有两个很大的进步，一个是可以在内部任意定义schema，而不再仅仅是map的嵌套；另一个是全文检索的支持。</p>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>图数据库可以看成从有序的key-value数据库发展而来的一个分支，主要是支持图结构的数据模型。<br>这里面讲的Full-Text Search和Graph在一些地方可能不能归为NoSql。<br>Hbase是借鉴Google BigTable的一个java版本的实现，存储到hbase的数据是通过HRegionServer来管理，每个HRegionServer管理了多个HRegion，每个Region管理了具体数据。HMaster管理所有的HRegionServer节点，是一个中心控制结构。还有比较经典的Amazon的Dynamo，它是采用了一致性哈希来进行管理。</p>
<h3 id="缓存系统"><a href="#缓存系统" class="headerlink" title="缓存系统"></a>缓存系统</h3><p>缓存是非持久化，用来加速应用对数据的读取。Redis和Memcache是两个广泛的缓存系统，Redis已经有了对于集群的支持，memcache本身还是一个单机的应用。如果想把多个节点构成一个集群，常见的有一致性哈希。有两个使用缓存的场景<br>首先是使用缓存降低底层读的压力，需要注意缓存和数据一致性的问题。在这种方式中，应用不直接操作缓存，存储由缓存控制。但是这种场景下，因为保证写入缓存后要能写入存储，所以缓存本身的逻辑比较复杂，需要很多操作日志和故障恢复。<br>另一种使用缓存的方式是，应用直接与缓存和存储系统打交道，一般的做法是在写操作时更新缓存，然后失效缓存；而在读数据时先读缓存，如果缓存没有命中，再去读数据，写入缓存。<br>这里重点考虑缓存与存储数据一致性问题，这里指最终一致性。重点考虑缓存没有命中和数据更改的情况，以及更新存储中的数据后没来得及将缓存失效<br>还有就是全数据缓存，当存储的数据变化就直接同步到缓存，这样应用取数据都从缓存中取。用于数据变更通知平台<br>大型网站使用缓存的场景还有对于web应用页面渲染的缓存。以一个页面展示为例，我们队页面进行了分块，其中有静态内容，也有动态内容，如果整个页面采用服务器渲染的方式，我们希望相对静止的内容可以进行缓存而不用每次都要重新渲染。具体的技术有ESI（edge side includes），是通过在返回的页面加上标签，然后标签的内容去用缓存填充的一个过程。处理ESI标签可以放在java应用容器中去处理，也可以放在java应用容器前置的服务器去处理。<br>两种方式对比如下：<br>1.渲染页面和ESI处理在一个进程里，处理效率会提升，当页面内容是内部对象时就可以处理ESI标签，而如果放在前置服务器，需要对内容进行一次扫描，定位到ESI标签后再处理。<br>2.ESI放在Web前置服务器去处理，对于后端来说可以不用去考虑ESI标签问题，例如当后端处理请求为java应用、php 应用时，可以统一把ESI处理放在前置服务器上，这样后端就只用处理请求，不必对每个应用做都去处理ESI工作。</p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>当网站的数据量和访问量很小时候，一些数据的查询可以用数据库的like操作来实现，当然这种操作比较效率很低也不够智能。当数据量和访问量很大时候，就需要在站内使用搜索技术来解决这问题。</p>
<h3 id="爬虫问题"><a href="#爬虫问题" class="headerlink" title="爬虫问题"></a>爬虫问题</h3><p>对于全网搜索来说，我们需要爬虫去获取被检索的网站内容。这里我们要讲更新索引的方式<br>1.定时从数据源中拉取，我们称之为增量dump。这要求数据库有个记录变更时间的字段，否则无法获取一段时间变更的数据，而这个字段需要有索引，否则效率变得很低。增量dump开始前，需要全量dump构造初始化的数据。增量的时间间隔一般在分钟级，这会引起明显延迟。<br>2.通过数据变更的通知，及时通过搜索引擎构建索引及时性会很好不过带来的系统压力会很大。因而这种方式主要用在实时性很高的场景。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引是很重要的一项搜索引擎技术。正向索引可以理解为文章和关键词的映射。相对于正向索引，倒排索引是把值的内容拆分成了索引的key，而原来用做索引的key则变成了值，也就是关键词和文档之间的映射。搜索引擎比数据库高效的原因就在于倒排索引。如何确定倒排索引的关键词，关键在于分词。</p>
<h3 id="查询预处理"><a href="#查询预处理" class="headerlink" title="查询预处理"></a>查询预处理</h3><p>查询表预处理主要负责对用户搜索内容进行分词及分词后的分析，包括同义词的替换和及词后的分析，包括一些同义词的替换和纠错等。这一部分是在使用搜索引擎前对搜索内容的梳理，这部分的工作也最终影响到搜索结果的质量。<br>备注：1、在建立索引时，拆词建索引时就把同义词考虑进去，将同义词的词条加入到索引中，然后检索时，直接根据输入拆词来检索2、在建立索引时，不对同义词进行任何处理，在检索时，先拆词，针对拆分出来的词元（呵呵，自创的称呼）也即关键字，进行同义词匹配，把匹配好的同义词拼成一个新的关键字，搜索索引时根据此关键字来进行检索。个人觉得，方案二更优于方案一，理由如下：在建立索引时，就处理同义词，一方面会增加索引库的容量，导致索引效率的降低；其次，如果后期对同义词进行了扩展，比如原来，一个单词有2个同义词，后面增加到3个，就需要对索引进行重建了，！<br>似,is,are =&gt; 是（一般适用于纠错，格式一表示如果文本中出现了is,are,那么直接替换成是。expand参数对此没有影响。）好人,好心人,热心人（格式二表示如果文本中出现了好人或者好心人或者热心人，当expand=true时，把待替换的文本用好人好心人 热心人替换；当expand=false时，把待替换文本用第一个单词即好人替换。）</p>
<h3 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h3><p>查询在搜索引擎上被执行，对于返回的结果，需要计算和搜索内容的相关度展示给用户，相关度计算是指不指定按照某个字段排序的基础上对结果的排序，排序的原则是被搜索到的内容和搜索内容之间的相关度。<br>相关度的计算方式很多，例如有空间向量模型、概率模型<br><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7981145</a></p>
<h2 id="数据计算支撑"><a href="#数据计算支撑" class="headerlink" title="数据计算支撑"></a>数据计算支撑</h2><h3 id="离线计算"><a href="#离线计算" class="headerlink" title="离线计算"></a>离线计算</h3><p>离线计算是业务产生数据离开生产环境后进行的计算。就是业务数据从在线存储中移动到离线存储中，然后进行数据处理的过程。<br>在离线计算领域里，MapReduce模型十分著名和常用，MapReduce是google在2004发表的论文：MapReduce：simplified Data Processing On Large Clusters.<br>（<a href="http://www.cnblogs.com/fuzhe1989/p/3413457.html）。" target="_blank" rel="external">http://www.cnblogs.com/fuzhe1989/p/3413457.html）。</a><br>主要分为两个阶段，Map阶段和Reduce阶段。在map阶段，我们根据设定的规则，把整体数据集映射给不同的worker来处理，并且生成各自的处理结果。而在reduce阶段，是对前面处理过的数据进行聚合，形成不同的结果，一个任务的处理可能是不止一次MapReduce过程。<br>Hadoop是MapReduce的一个开源实现，Hadoop使用HDFS进行数据存储，Spark提供了基于内存的集群计算的支持，Spark本身是为了集群计算中特定类型工作而设计的。例如机器学习，基于内存的方式使得spark的速度非常快</p>
<h3 id="在线计算"><a href="#在线计算" class="headerlink" title="在线计算"></a>在线计算</h3><p>Storm是在线计算的一个框架<br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。</p>
<h2 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h2><p>当完成应用的开发和测试后，需要使应用上线来为最终用户提供服务。<br>1.分发应用<br>我们需要提供自动高效且容易操作的机制把经过测试的程序包分发到线上的应用，我们一般会采用web的操作方式，通过专用通道把应用程序包从线下环境传送到线上的发布服务器。发布控制台-&gt;多机房-&gt;发布服务器<br>2.启动校验<br>应用重启启动后，需要进行校验从而完成这台应用服务器上的应用发布，对应用的校验通常是应用自身提供一个检测脚本或者页面，发布系统执行这个脚本或者访问页面后来判断返回的结果。<br>停止应用时,需要优雅的关闭，需要在关闭应用前把这个应用从负载均衡或者软负载中心上移除<br>3.灰度发布<br>会对新应用进行分批发布，逐步扩大新应用在整个集群中的比例直至最后全部完成。这里讲的灰度发布主要是针对新应用在用户体验方面完全感知不到的更新.<br>4.产品改版Beta<br>提供新旧应用的共存</p>
<h2 id="应用监控系统"><a href="#应用监控系统" class="headerlink" title="应用监控系统"></a>应用监控系统</h2><p>1.数据监视维度<br>系统数据和应用自身的数据.系统数据指的就是当前应用运行的系统环境的信息，如CPU使用率、内存使用情况、交换分区使用情况、当前系统负载、IO情况等;而应用自身的数据，则是不同应用有不同的数据，一般会是调用次数、成功率、响应时间、异常数量等维度的数据<br>2.数据记录方式<br>系统自身的数据已经被记录到了本地磁盘，应用的数据一般也是存放在应用自身的目录中，便于采集。也有直接把应用日志通过网络发送到采集服务器的情况，可以减轻本地写日志的压力<br>对于应用数据的记录，会考虑用定时统计的方式记录一些量很大的信息.如对于一个提供服务的应用，在没有特别需求时，并不直接记录每次调用的信息，而是会记录一段时间如5s或者一个间隔时间内的总调用次数、总响应时间这样写信息，而对于异常信息则每次都会予以记录;采用统计的方式是为了减小记录的大小以及对本地磁盘的写入压力。<br>3.数据采集方式<br>采集方式有应用服务器主动对同给监控中心以及等待监控中心来拉取两种方式。前者控制权在应用服务器上,可能出现的问题是应用服务器推送的压力超过采集的中心服务器的能力，会造成重试等额外开销并且需要应用服务器上的推送程序控制重试逻辑和当前传送位置等信息。后者把复杂性都放在中心采集服务器上处理，使得应用服务器中支持数据采集的部分变的简单<br>4.展示与警告<br>提供图表的形式可以提供Web页面的展示-&gt;通过手机应用来接收报警-&gt;短信方式好<br>5.控制<br>控制<br>应用启动后在运行期对于应用的行为改变-&gt;对于应用的运维，最低的要求是出现问题时可以通过重启应用解决，但是我们还是需要更加精细化的控制应用-降低和一些切换。降级是我们遇到大量请求且不能扩容的情况时所进行的功能限制的行为-&gt;而切换更多的是当依赖的下层系统出现故障并且需要手工进行切换时的一个管理，这些控制一般都是通过开关，参数设置来完成</p>
<h2 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h2><p>随着网站功能增多，应用的个数迅速增加，应用之间的关系也会越来越复杂，理清这些依赖关系并能够管理这些依赖会非常重要<br>-&gt;一个应用在完成某个功能时到底需要依赖哪些外部系统、这些依赖中哪些是必要依赖，强依赖(登陆验证用户名和密码)，哪些是有了更好没有也可以的依赖，弱依赖（如记录登陆时间和ip等）-&gt;<br>-&gt;动态检测（在系统运行阶段，通过功能的调用来发现应用的依赖关系）和静态检测（分析代码来确定所调用的具体外部应用）-&gt;动态检测的主要检查方式是模拟被调用系统不可用和响应慢的两种情况-&gt;<br>-&gt;Google#Dapper,A Large-Scale Distributed Systems Tracing Infrastructure-&gt;traceId,index-&gt;形成一个调用时序图</p>
<h2 id="多机房问题分析"><a href="#多机房问题分析" class="headerlink" title="多机房问题分析"></a>多机房问题分析</h2><p>同城机房和异地机房<br>同城多个机房中，对于重要的应用系统，会在不止一个机房中部署；而对于数据库系统，则会把主备放在不同机房。尽量避免不必要的跨机房的内部系统调用，为了数据安全，把产生的业务数据都同步到异地的机房。把一些对数据延迟不敏感的系统部署到异地,如只读系统….</p>
<h2 id="系统容量规划"><a href="#系统容量规划" class="headerlink" title="系统容量规划"></a>系统容量规划</h2><p>我们应该知道的信息就是整个系统的容量以及运行时所处的水位。我们把某个应用系统集群能够提供的并发能力和当前的压力比作一个水桶的容量和水位。那么准确知道各个系统的容量和当前高峰时的水位是一件很重要的事情。因为我们还是希望优先通过扩大容量来支持更多的请求而不是首选降级的方案。<br>考虑过去的增长情况并结合人为的判断<br>1.弄清楚当前系统高峰期的水位<br>2.弄清楚当前各个系统的容量<br>3.通过测试，压力测试，设置警戒值，高峰水位搞过警戒值就增加容量，保持高峰的水位是低于警戒值的</p>
<h2 id="内部私有云"><a href="#内部私有云" class="headerlink" title="内部私有云"></a>内部私有云</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加速静态内容访问的速度的CDN&quot;&gt;&lt;a href=&quot;#加速静态内容访问的速度的CDN&quot; class=&quot;headerlink&quot; title=&quot;加速静态内容访问的速度的CDN&quot;&gt;&lt;/a&gt;加速静态内容访问的速度的CDN&lt;/h2&gt;&lt;p&gt;CDN，Content Delive
    
    </summary>
    
      <category term="大型网站中间件" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>软负载中心与集中配置管理（第七章）</title>
    <link href="http://yoursite.com/2017/10/27/%E8%BD%AF%E8%B4%9F%E8%BD%BD%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/27/软负载中心与集中配置管理/</id>
    <published>2017-10-27T07:39:30.000Z</published>
    <updated>2017-11-07T14:20:20.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始软负载中心"><a href="#初始软负载中心" class="headerlink" title="初始软负载中心"></a>初始软负载中心</h2><p>在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知也是通过软负载中心。<br>软负载中心有两个最基本的职能：<br>1.聚合地址信息；无论是服务框架中需要用到的服务提供者地址还是消息中间件系统中的消息中间件地址，都需要由软负载中心去聚合地址列表，形成一个可供服务调用者及消息发送者、接收者接收的列表。<br>2.生命周期感知；软件负载中心能够对服务上下线自动感知，并且根据这个变化去更新服务地址数据，形成新的地址列表后，把数据传给需要数据的调用者或者消息的发送者和接收者。</p>
<h2 id="软负载中心的结构"><a href="#软负载中心的结构" class="headerlink" title="软负载中心的结构"></a>软负载中心的结构</h2><p>软负载中心包括：一个是软负载中心的服务端，另一个是软负载中心的客户端；服务端主要负责感知提供服务的机器是否在线，聚合提供者的机器信息，并且负责把数据传给使用数据的应用。客户端承载了两个角色，作为服务提供者，客户端主要是把服务提供者提供服务的具体信息主动传给服务端，并且随着提供服务的变化去更新数据；而作为服务使用者，客户端主要向服务端告知自己所需要的数据，并负责去更新数据，还要进行本地缓存，使得每次去请求服务来获取列表都是一个本地操作。<br>软件负载中心内部有三部分重要数据<br>1.聚合数据<br>聚合后的地址列表。对于提供的服务信息，我们使用唯一的dataId来标识，同时dataId支持分组（group），通过dataId和group可以定位到唯一的数据内容，这个内容是通过聚合完成的完整数据，而这个信息在内部就是一个key-value结构。<br>2.订阅关系<br>在软负载中心中，需要数据的应用把自己需要的数据告诉软负载中心，这就是订阅关系，订阅的粒度也是通过dataId和group来确定数据，那么会有dataId和group到数据订阅者的分组ID的一个映射关系，当聚合的数据发生变化，通过订阅关系的数据找到需要通知的数据订阅者，然后去进行数据更新操作。<br>3.连接关系<br>连接到软负载中心的节点和软负载中心已经建立的连接管理。使用软负载中心的应用，无论是发布数据还是订阅数据，都会有一个独立的分组，而连接数据就是用groupId作为key，然后对应管理这个物理连接，采用的是长连接方式。当订阅的数据发生变化，通过订阅关系找到需要通知的groupId，在连接数据这里就能够找到对应的连接，完成对应用的更新。</p>
<h2 id="内容聚合功能的设计"><a href="#内容聚合功能的设计" class="headerlink" title="内容聚合功能的设计"></a>内容聚合功能的设计</h2><p>保证数据的正确性<br>内容聚合主要需要保证的是并发场景下的数据聚合的正确性。另外需要考虑发布数据的机器短时间内上下线的问题，指发布数据刚连接上来，然后就断线了就是断线后又很快上线发布数据。内容聚合主要保证在这些异常又较为复杂的场景中保证数据的正确性<br>高效聚合数据<br>因为软负载中心是系统的中枢，虽然软负载中心不再服务调用或者消息投递的路径上，但是服务提供者以及消息中间件的服务地址列表都是由软负载中心进行管理的，高效聚合数据在软负载中心自身重启或者服务提供者大面积重启带来很大的便利。<br>在这里，我们讨论下实现（前提是java实现），我们可以用map来存储，用dataId和group作为key，value就是聚合后的数据。有几个关键点需要注意<br>1.并发下的数据正确性的保证<br>先看看场景，并发操作会是数据插入、更新、删除三个一起在一起的操作，其中删除、更新主要因同一个数据的不同数据发布者变化产生，而数据插入是由于多个新的dataId有进入到Map结构的需求。（如软件负载中心重启和大量的数据发布者重启时）<br>我们可以用ConcurrentHashMap线程安全管理所有dataId的数据，也可以用linkedlist来操作，但是要在增删或者读加锁，否则线程不安全。<br>2.数据更新、删除的顺序保证<br>所发布数据变化主要有新增、更新和删除，而处理顺序一定要跟真实世界的顺序一致，比较容易出现的问题是在网络断开后删除数据与数据新增和删除的问题。我们采用NIO的方式通信，通过selector感知连接的事件，包括数据可读、数据可写、建立连接、连接断开的事件，然后把这些交给IO线程池中的线程去处理，那么更新、新增数据和连接断开要去删除数据有可能在两个线程中去处理。如果是发布数据很快就断开，那么就有可能会出现先删除再新增。一个解决方案是新增数据时查看下是否连接还存在。<br>3.大量数据的同时插入、更新时的性能保证<br>ConcurrentHashmap在写时候采用分段锁，在读的时候不加锁，但在大量数据也遇到性能问题，改进的方案是：增加任务队列，对应的处理线程，以及对应的数据存储。这样针对同样的数据处理任务都放在同一个线程里，我们可以直接使用线程不安全容器；多线程的请求变成一个顺序的队列操作，交给任务队列处理，任务队列是需要线程安全，但是因为这里的操作主要是任务加入队列和任务从队列取出，都是简单的操作，锁冲突的情况相对之前加锁进行数据处理好多了。数据更新的线程如果需要等待更新结果，那就只要进行等待就可以了；而读取数据则一定需要等待任务执行结束后才能拿到结果。</p>
<h2 id="解决服务上下线的感知"><a href="#解决服务上下线的感知" class="headerlink" title="解决服务上下线的感知"></a>解决服务上下线的感知</h2><p>软负载的可用服务列表，当服务可用时，需要自动把服务加到服务地址列表，而服务不可用，需要自动从列表删除，这也就是上下线感知，这也是与使用硬件负载均衡需要配置服务列表的相比的一大优点<br>服务器的上下线的感知，具体有两种实现<br>1.通过客户端与服务器端的连接感知<br>无论是服务的发布者还是接收者都需要与软负载中心维持一个长连接。对于服务提供者来说，软负载中心可以通过这个长连接的心跳或者数据的发布来判断服务发布者是否在线。如果很久没有心跳或者数据的发布，则判定为不在线，那么就会取出这个发布者发布的数据。而对于新上线的发布者，通过连接建立和数据发布就实现了上线的通知。<br>这个方式有个结构的问题，即软负载中心属于旁路，也就是它不在调用链上，当软负载中心自身的负载很高时，是可能产生误判的。例如软负载中心负载压力很大，处理请求变慢，心跳数据来不及处理，会以为心跳超时而判定服务不在线，会导致原本可用的服务下线。<br>另外可能的问题是，如果服务发布者到软负载中心的网络链路有问题，而服务发布者到服务使用者本身没有问题，也会造成感知的问题，解决方案有在软负载中心的客户端增加逻辑，当收到软负载中心通知的应用下线数据时，需要服务调用者进行验证才能接收这个通知，但是这个方法带来的是对每个服务提供者的一次额外校验。<br>2.通过对于发布数据中提供的地址接口进行连接的检查<br>通过长连接的相关感知判断服务下线，不直接认定这个服务下线，而是交给另一个独立的监控应用去验证这个服务是否已经不在了，方式是通过地址、端口去进行连接验证，这种方法是有缺陷，所以还是需要服务调用者进行最终确认。</p>
<h2 id="软负载中心的数据分发的特点和设计"><a href="#软负载中心的数据分发的特点和设计" class="headerlink" title="软负载中心的数据分发的特点和设计"></a>软负载中心的数据分发的特点和设计</h2><h3 id="数据分发和消息订阅的区别"><a href="#数据分发和消息订阅的区别" class="headerlink" title="数据分发和消息订阅的区别"></a>数据分发和消息订阅的区别</h3><p>第一个差别是：消息中间件需要保证消息不丢失、每条消息都能送到消息订阅者，而软负载中心只需要保证最新的数据送到消息订阅者，不需要保证每次的数据变化都能让最终订阅者感知<br>第二个差别是：关于订阅者的集群，也就是订阅者的分组。在消息中间件中，一个集群的不同机器是分享所有消息，因为只要同一集群的一台机器去处理就好。而软负载中心不同，软负载中心维持的是大家需要的服务数据，所以需要把这个数据分发给所有机器。</p>
<h3 id="提升数据分发性能需要注意的问题"><a href="#提升数据分发性能需要注意的问题" class="headerlink" title="提升数据分发性能需要注意的问题"></a>提升数据分发性能需要注意的问题</h3><p>1.数据压缩<br>数据压缩可以降低数据量，提升网络吞吐量，使用cpu来换带宽。<br>2.全量与增量的选择<br>每次传输全量数据，逻辑简单，但是传输数据量大。使用增量，传输数据小，但实现复杂。建议刚开始数据量小时传输全量，数据量大传输增量</p>
<h2 id="针对服务化的特性支持"><a href="#针对服务化的特性支持" class="headerlink" title="针对服务化的特性支持"></a>针对服务化的特性支持</h2><h3 id="软负载特性分组"><a href="#软负载特性分组" class="headerlink" title="软负载特性分组"></a>软负载特性分组</h3><p>通过dataId和group来唯一确定数据。分组是为了隔离<br>1.根据环境区分<br>比较多的用于线下环境。在线下开发测试的环境中，需要对不同环境项目隔离和区分<br>2.分优先级的隔离<br>更多用于线上，也就是可以把提供同样的服务通过组的概念分开，也就是重要的服务使用者会有专门的组提供服务<br>关于分组，可以采用ip地址自动归组的方式</p>
<h3 id="提供自动感知以外的上下线开关"><a href="#提供自动感知以外的上下线开关" class="headerlink" title="提供自动感知以外的上下线开关"></a>提供自动感知以外的上下线开关</h3><p>1.优雅地停止应用<br>我们先从服务列表中去掉这个机器，然后等待这个机器的服务执行完成，然后再停止应用。通过指令直接从软负载中心使机器下线，是可以帮助做到这一点。<br>2.保持应用场景，用于排错<br>遇到服务的问题，可以把出问题的服务留下一台机器进行故障定位和场景分析，这时需要把这台机器从服务列表中拿下，以免有新的请求进来造成服务失败。</p>
<h3 id="维护路由规则"><a href="#维护路由规则" class="headerlink" title="维护路由规则"></a>维护路由规则</h3><p>路由规则需要统一维护，软负载中心可以管理这些数据。</p>
<h2 id="从单机到集群"><a href="#从单机到集群" class="headerlink" title="从单机到集群"></a>从单机到集群</h2><p>当系统规模不是很大时，可以使用单机加一个备用机器的方式充当软负载中心。<br>对于服务框架而言，用到的场景是服务调用，而服务本身多是无状态的，其中集群处理相对简单；对于消息中间件，如果本身存储系统不在本地，那也就是无状态的集群，如果存储在本地，还要考虑数据的迁移。而软负载中心要走向集群，需要考虑的问题有：<br>1.数据管理问题<br>软负载中心聚合了整个分布式集群中的服务地址信息，首先是信息存放的位置<br>2.连接管理问题</p>
<h3 id="数据统一管理方案"><a href="#数据统一管理方案" class="headerlink" title="数据统一管理方案"></a>数据统一管理方案</h3><p>把数据聚合信息放在同一个地方，那么也就变成了无状态；整个结构分三层：聚合数据这一层就是在管理数据；软负载中心的机器则是无状态的；最下层是数据发布者或者订阅者。此时软负载中心的机器是对等的。我们还可以对这个方案进行改进，把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；</p>
<h3 id="数据对等管理方案"><a href="#数据对等管理方案" class="headerlink" title="数据对等管理方案"></a>数据对等管理方案</h3><p>把数据分散到各个软负载中心的节点上，并且把自己管理的数据分发到其他节点上，从而保证每个节点都有整个集群的数据，并且这些节点的角色是对等的，数据发布者和数据订阅者，只需要去连软负载中心集群的任何一台机器就好，在软负载中心各个节点间会进行数据同步。同步的时候，我们没有必要每次变化都同步，我们可以批量处理更加高效，只要合并这些变化同步一次就好。一种方案是每个负载均衡节点互相同步；另一种是把软负载中心分为两类，一类是聚合数据的机器，另一类是数据推送机器；需要同步的是数据推送数据和聚合数据机器。</p>
<h2 id="集中配置管理中心"><a href="#集中配置管理中心" class="headerlink" title="集中配置管理中心"></a>集中配置管理中心</h2><p>软负载中心保存了管理服务地址列表、路由规则、消息的订阅关系，这些数据我们可以从是否持久和是否聚合两个维度分类。<br>持久性是数据本身跟发布者的生命周期无关，典型的是持久订阅关系、路由规则、数据访问层的分库分表规则和数据库配置。非持久指的是与发布者的生命周期有关，例如服务地址列表，此外服务地址列表和订阅关系是需要聚合的，而路由关系不需要聚合</p>
<h3 id="客户端的实现和容灾策略"><a href="#客户端的实现和容灾策略" class="headerlink" title="客户端的实现和容灾策略"></a>客户端的实现和容灾策略</h3><p>客户端通过http协议与集中配置管理中心进行通信，采用长轮询的方式。建立连接并且发送请求，如果有数据，长轮询和普通轮询就会返回；如果没有数据，长轮询就会等待直到有数据或者超时。普通轮询就会直接返回。容灾的考虑，客户端有四个特性：1.数据缓存；2.数据快照；3.本地配置；4.文件格式。</p>
<h3 id="服务端的实现和容灾策略"><a href="#服务端的实现和容灾策略" class="headerlink" title="服务端的实现和容灾策略"></a>服务端的实现和容灾策略</h3><h3 id="数据库策略"><a href="#数据库策略" class="headerlink" title="数据库策略"></a>数据库策略</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初始软负载中心&quot;&gt;&lt;a href=&quot;#初始软负载中心&quot; class=&quot;headerlink&quot; title=&quot;初始软负载中心&quot;&gt;&lt;/a&gt;初始软负载中心&lt;/h2&gt;&lt;p&gt;在服务框架，服务查找中心就是软负载中心；而在消息中间件中消息发送者以及消息消费者对于消息中间件的感知
    
    </summary>
    
      <category term="大型网站中间件" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件（第六章）</title>
    <link href="http://yoursite.com/2017/10/25/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/10/25/消息中间件/</id>
    <published>2017-10-25T07:23:21.000Z</published>
    <updated>2017-11-07T14:20:27.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息中间件的价值"><a href="#消息中间件的价值" class="headerlink" title="消息中间件的价值"></a>消息中间件的价值</h2><h3 id="消息中间件的定义"><a href="#消息中间件的定义" class="headerlink" title="消息中间件的定义"></a>消息中间件的定义</h3><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件</p>
<h3 id="通过示例看消息中间件对应用的解耦"><a href="#通过示例看消息中间件对应用的解耦" class="headerlink" title="通过示例看消息中间件对应用的解耦"></a>通过示例看消息中间件对应用的解耦</h3><h4 id="通过服务调用让其他系统感知事件发生的方式"><a href="#通过服务调用让其他系统感知事件发生的方式" class="headerlink" title="通过服务调用让其他系统感知事件发生的方式"></a>通过服务调用让其他系统感知事件发生的方式</h4><p>假设我们的登录系统，需要支持的一个功能是发短信给用户，如果在增加后续跟其他系统打交道的工作，会让登录系统变得十分复杂。<br>如登陆系统负责向消息中间件发送消息，而其他的系统则向消息中间件来订阅这个消息，然后完成自己的工作。</p>
<h4 id="通过消息中间件解耦服务调用"><a href="#通过消息中间件解耦服务调用" class="headerlink" title="通过消息中间件解耦服务调用"></a>通过消息中间件解耦服务调用</h4><p>从登陆系统的角度来看，这些系统都不是登录系统必须依赖的，登录系统只需要校验用户名和密码，而类似发短信系统不是登录系统必须依赖的系统。所以，我们需要解耦，服务调用会被固定格式的消息所取代。<br>通过消息中间件解耦，登录系统不需要知道有多少个系统需要知道登录成功这件事，也不用关心怎么传递给他们，只需要把登录成功这件事转化成一个消息发送到消息中间件就好。并且各个系统不受影响。</p>
<h2 id="互联网时代的消息中间件"><a href="#互联网时代的消息中间件" class="headerlink" title="互联网时代的消息中间件"></a>互联网时代的消息中间件</h2><p>JMS:Java Message Service-&gt;规范-&gt;Hornetq,ActiveMQ等产品是这个规范的实现</p>
<h3 id="如何解决消息发送的一致性"><a href="#如何解决消息发送的一致性" class="headerlink" title="如何解决消息发送的一致性"></a>如何解决消息发送的一致性</h3><h4 id="消息发送一致性的定义"><a href="#消息发送一致性的定义" class="headerlink" title="消息发送一致性的定义"></a>消息发送一致性的定义</h4><p>消息发送一致性指产生消息的业务动作与消息发送的一致。即如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了；而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去.</p>
<h4 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h4><p>JMS几个比较重要的元素：<br>Destination：消息所走的通道的目标定义，也就是消息从发送方发出后要走的通道，而不是最终接收方。<br>ConnectionFactory：用于创建连接的对象<br>Connection：连接接口，用于创建session<br>Session：会话接口，消息的发送者，消息的接收者以及消息都是由会话创建。<br>MessageConsumer：消息的消费者，用于订阅并处理消息的对象。<br>MessageProvider：消息的生产者，用于发送消息的对象<br>XXXMessage：指各种类型的对象，包括Bytemessage、MapMessage、ObjectMessage、StreamMesssage和TextMessage；<br>在jms的api接口中，有很多XA开头的类，他们是支持XA协议的接口。XA系列的接口集中在ConnectionFactory、Connection和Session上。但也会造成问题：<br>1.引入分布式事务，这会带来开销和复杂性；<br>2.对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起做分布式事务，这会造成限制（凡是参与全局事务的所有资源均应该使用其XA版。特别地，对于JDBC资源，必须使用JDBC XADataSource）。</p>
<h4 id="其他办法"><a href="#其他办法" class="headerlink" title="其他办法"></a>其他办法</h4><p>简单的方案不能保证一致性，但是出现问题的概率也不大；即便做到业务操作都支持XA，如果引入二阶段提交的分布式事务，则有点重。<br>简化流程：<br>1) 业务处理应用首先把消息发给消息中间件，标记消息的状态为待处理.<br>   (2) 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息.<br>   (3)消息中间件返回消息处理的结果，仅是入库的结果，结果是成功或者失败.<br>   (4)业务方收到消息中间件返回的结果并进行处理:<br>a) 如果收到的结果是失败，那么就放弃业务处理，结束<br>b) 如果收到的结果是成功，则进行业务自身的操作<br>   (5)业务操作完成，把业务操作的结果发送给消息中间件<br>   (6)消息中间件收到业务操作结果，根据结果进行处理<br>a) 如果业务失败，则删除消息存储中的消息，结束<br>b)如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递。<br>最终一致性方案的补偿流程:<br>(1)消息中间件询问状态为待处理的消息对应业务操作结果<br>(2)应用即消息发布者对业务操作检查操作结果<br>(3)发送业务处理结果给消息中间件<br>(4)消息中间件更新消息状态，业务成功，消息状态为待发送；业务失败则消息删除</p>
<h3 id="如何解决消息中间件与使用者的强依赖关系"><a href="#如何解决消息中间件与使用者的强依赖关系" class="headerlink" title="如何解决消息中间件与使用者的强依赖关系"></a>如何解决消息中间件与使用者的强依赖关系</h3><p>如果消息系统出现问题，就会导致业务操作无法继续操作。解决的思路如下：<br>1.提供消息中间件系统的可靠性，但是没办法办证百分百可靠；<br>2.对于消息中间件系统中影响业务的部分，其可靠性与业务系统一样；<br>3.提供弱依赖的功能；<br>对于思路一：我们无法保证百分百可靠；<br>对于思路二：把消息中间件所需要的消息表与业务数据表放到同一个业务数据库，业务操作和写入消息作为一个本地事务完成，然后再通知消息中间件有消息可以发送，解决一致性，也可以消息中间件定时去轮询业务数据库找到需要发送的消息，取出内容后进行发送。这个会有三个影响：<br>1.需要业务自己的数据库去承载消息数据；<br>2.需要消息中间件访问业务数据库；<br>3.需要业务操作的对象是数据库，或者说是支持事务的存储，必须这个存储能够支持消息中间件的需求。<br>所以我们有个折中的操作：消息中间件不再直接与业务数据库打交道，将业务操作、写入消息，轮询消息等全部放到业务应用。<br>加一个本地磁盘作为一个消息存储，如果消息中间件崩溃，我们可以把本地磁盘作为存储消息的地方。这有两种用法：1.作为一致性发送消息的解决方案的容灾手段，，平时不工作，出问题才切换。2.直接使用该方式；<br>最后我们看下业务操作与消息一致性带来的两个限制：<br>1.需要确定要发送的消息内容；2.需要实现对业务的检查</p>
<h3 id="消息模型对消息的接收的影响"><a href="#消息模型对消息的接收的影响" class="headerlink" title="消息模型对消息的接收的影响"></a>消息模型对消息的接收的影响</h3><p>在JMS中，有Queue（点对点）和Topic（发布/订阅）两种模型</p>
<h4 id="JMS-Queue模型"><a href="#JMS-Queue模型" class="headerlink" title="JMS Queue模型"></a>JMS Queue模型</h4><p>应用1和应用2发送消息到JMS服务器，这些消息根据到达的顺序形成一个队列，应用3和应用4进行消息的消费;如果Queue里面的消息被一个应用处理了，那么连接到JMS Queue上的另一个应用是收不到这个消息的。即连接到这个JMS Queue上的应用共同消费了所有的消息。消息从发送端发送出来时不能确定最终会被哪个应用消费，但是可以明确的是只有一个应用会去消费这条消息，Peer To Peer方式(PTP)</p>
<h4 id="JMS-Topic模型"><a href="#JMS-Topic模型" class="headerlink" title="JMS Topic模型"></a>JMS Topic模型</h4><p>和Queue模型的最大区别在于消息接收的部分，在该模型中，接收消息的应用3和应用4是可以独立收到所有到达Topic的消息的，Pub/Sub方式</p>
<h4 id="JMS中客户端连接的处理和带来的限制"><a href="#JMS中客户端连接的处理和带来的限制" class="headerlink" title="JMS中客户端连接的处理和带来的限制"></a>JMS中客户端连接的处理和带来的限制</h4><p>在使用JMS时，每个Connection都有一个ClientId，用于标记的唯一性。如果两个应用共建立三个连接，每个连接都会收到所有发送到topic的消息。</p>
<h4 id="我们需要什么样的消息模型"><a href="#我们需要什么样的消息模型" class="headerlink" title="我们需要什么样的消息模型"></a>我们需要什么样的消息模型</h4><p>我们要满足的需求为：<br>消息发送方和接收方都是集群；<br>同一个消息的接收方可能有多个集群进行消息的处理；<br>不同集群对于同一条消息的消息不能互相干扰；<br>现在我们需要每个集群使用topic模式，然后集群的内部使用queue模式；我们可以引入clusterId，用这个id标识不同的集群；集群内各个应用连接使用这个clusterid。当服务器端进行调度时，在不同的集群之间独立投递，而拥有相同的clusterId的共同消费这个消息。<br>还有一种思路是将JMS的topic和queue级联使用，首先最顶层是JMS topic，中间有一层消息中转层，再通过JMS queue，最下层是集群内消费使用。<br>缺点是级联方式过于繁重，处理复杂，好处是使用jms实现。</p>
<h3 id="消息订阅者订阅消息的方式"><a href="#消息订阅者订阅消息的方式" class="headerlink" title="消息订阅者订阅消息的方式"></a>消息订阅者订阅消息的方式</h3><p>分为持久订阅和非持久订阅<br>非持久化订阅指的是消息接收者和消息中间件之间的消息订阅关系的存续，与消息接收者自身运行的状态有直接的关系。<br>持久化订阅指的是消息订阅关系一旦建立，除非应用显式地取消订阅关系，否则订阅关系将一直存在，如果消息接收者应用停止，那么消息会保留，等待下次应用启用后投递给消息接收者。</p>
<h3 id="保证消息可靠性的做法"><a href="#保证消息可靠性的做法" class="headerlink" title="保证消息可靠性的做法"></a>保证消息可靠性的做法</h3><p>持久订阅能够保证消息的可靠性，消息从发送端到接收端，中间需要经历三个阶段可靠：<br>1.消息发送者把消息发送给消息中间件；<br>2.消息中间件把消息存入消息存储；<br>3.消息中间件把消息投递给消息接收端；</p>
<h4 id="消息发送端的可靠"><a href="#消息发送端的可靠" class="headerlink" title="消息发送端的可靠"></a>消息发送端的可靠</h4><p>发送者需要把消息的发送结果准确的传给应用，应用才能进行相关的业务操作。消息从发送者发送到消息中间件，只有消息中间件及时明确地返回成功，才能确认消息可靠地到达消息中间件。返回错误、异常或者超时，都可以认为这个动作失败。</p>
<h4 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h4><p>1.实现基于文件的消息存储<br>主要把消息直接存储在本地磁盘，不需要对额外独立存储。ActiveMQ（kaha db），KahaDB是基于文件的本地数据库储存形式<br>2.使用数据库作为消息存储<br>3.基于双机内存的消息存储<br>磁盘IO的关系，性能会受到影响，内存的速度远超磁盘，但断电会失去数据，正常情况下，消息持久存储不工作，一旦一个机器故障，会停止另一台的写，并把数据写入数据持久存储。</p>
<h4 id="消息系统的扩容"><a href="#消息系统的扩容" class="headerlink" title="消息系统的扩容"></a>消息系统的扩容</h4><p>1.消息中间件自身如何扩容<br>消息中间件本身没有持久态，扩容比较容易，只需要让消息发送者和消息订阅者能够感知到有新的消息中间件机器加入了集群。同一个存储区分存储的消息来自哪个消息中间件应用：增加一个server字段。<br>2.消息存储的扩容处理<br>优势：1.不用保证消息的顺序；2.提供从服务端对消息投递的方式，不支持主动获取消息。<br>首先，消息发送到消息中间件，消息中间件将消息入库，所以消息中间件一定知道消息存在哪。<br>其次，由于内存中进行调度的消息数量有限，因此我们会调度存在数据库的消息，这个调度必然会跨所有库和所有表，需要投递的消息会把相关索引消息加载到内存中，内存调度消息也自然有了存储节点的消息。</p>
<h4 id="消息投递的可靠性保证"><a href="#消息投递的可靠性保证" class="headerlink" title="消息投递的可靠性保证"></a>消息投递的可靠性保证</h4><p>1.消息投递简介<br>消息中间件需要显示地收到接收者确认消息处理完毕，才能删除消息。<br>2.投递处理的优化<br>投递处理第一个可优化的是在进行投递时一定要采用多线程方式处理，每个线程处理一条消息时，会得到需要接收该消息的订阅者集群Id列表，然后从每个订阅者集群Id里选择一个连接来处理，消息投递后会更新消息状态，然后统一更新消息表中的消息状态。如果订阅者集群有一个很慢的订阅者，负责投递的所有线程会慢慢堵死，都需要等待这个慢的订阅者返回。<br>我们还可以采用，采用异步的方式，把消息返回处理的工作放到另外的线程池中操作，保证投递的环节不会被堵死，返回的结果可以放在内存中，等待其他线程进行处理。<br>其次我们还要优化，即一个应用有多个订阅者订阅同样的消息，如果不加以优化，会发送多次同样的消息，我们的优化是：单机共享连接；消息只发送一次，然后传到单机多订阅者生成多个处理实例。</p>
<h3 id="订阅者视角的消息重复的产生和应对"><a href="#订阅者视角的消息重复的产生和应对" class="headerlink" title="订阅者视角的消息重复的产生和应对"></a>订阅者视角的消息重复的产生和应对</h3><h4 id="消息重复产生的原因"><a href="#消息重复产生的原因" class="headerlink" title="消息重复产生的原因"></a>消息重复产生的原因</h4><p>第一类原因是消息发送方重复发送消息<br>1.消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，这是消息中间件出现了问题，导致应用端没有收到消息发送成功的返回，因而进行了重复的发送。<br>2.消息中间件由于负载比较高变得比较慢，成功把消息存储到消息存储后，返回成功结果超时。<br>3.消息中间件收到消息存储后，但由于网络原因，导致应用端收不到消息，进行重试。<br>解决的办法有通过消息id来标识<br>第二类原因是消息中间件对外投递时发生了重复<br>1.消息中间件投递由于网络原因，消息中间件没能收到反馈消息；<br>2.消息接收者处理时间比较长，超时<br>3.消息中间件出现问题，没收到结果消息<br>4.消息存储出现故障，没能更新状态<br>可以采用分布式事务来解决，但是不过这种方式比较复杂，成本也比较高；另一种方式是要求消息消费者来处理这种重复的方式，也就是要求这是幂等操作。</p>
<h4 id="JMS消息确认与消息重复的关系"><a href="#JMS消息确认与消息重复的关系" class="headerlink" title="JMS消息确认与消息重复的关系"></a>JMS消息确认与消息重复的关系</h4><p>AUTO_ACKNOWLEDGE<br>自动确认，当JMS消息接收者接收到消息，JMS的客户端会自动进行确认。但是确认时消息还没来得及处理或者还未处理完成，所以这种确认方式也是不可靠<br>CLIENT-ACKNOWLEDGE<br>客户自己确认的方式，也就是客户端如果要确认消息处理成功，告诉服务器端确认消息，需要主动调用Message接口的acknowledge方法进行消息接收成功的调用；<br>DUPS_OK_ACKNOWLEDGE<br>这种方式是消息接收方的消息处理函数执行结束后确认，一方面保证消息一定是处理结束后才确认，另一方面也不需要客户端调用acknowledge接口<br>消息接收者接收的消息会出现下面两张情况：<br>1.at lease once<br>采用CLIENT-ACKNOWLEDGE或者DUPS_OK_ACKNOWLEDGE并且在消息处理前没有确认的话，就可能产生这种现象。<br>2.at most once<br>采用AUTO_ACKNOWLEDGE或者CLIENT-ACKNOWLEDGE并且在接收消息后立刻确认的情况</p>
<h3 id="消息投递的其他属性支持"><a href="#消息投递的其他属性支持" class="headerlink" title="消息投递的其他属性支持"></a>消息投递的其他属性支持</h3><p>1.消息优先级<br>一般情况下消息先到先投递，消息的优先级属性可以根据优先级确定投递顺序。<br>2.订阅者消息处理顺序和分级订阅<br>消息的多个订阅者之间是独立的，它们对消息的处理并不会相互造成影响。但对于一些场景，对于同样的消息，可能会希望有些订阅者处理结束后再让其他订阅者处理。另一种方案是分级订阅。<br>把优先接收者和一般接收者分开，优先接收者处理成功后主动把消息投递到另外的消息中间件，然后一般接收者接收新产生的消息。<br>3，自定义属性<br>消息自身的创建时间、类型、投递次数等属性属于基础属性，在消息体外，自定义属性会很方便，这种自定义属性类似http的header<br>4.局部顺序<br>局部顺序是指在众多消息中，和某件事情有关的多条消息之间有顺序，而多件事情之间的消息没有顺序。比如我们可以不必保持多个人之间的交易顺序，但是对同一个交易产生的变化需要保持其顺序。<br>比如线上的交易的消息状态依次生死：创建、付款、发货、确认（Kafka发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton和key是可选的。如果你指定了partition，那就是所有消息发往同1个partition，就是有序的。并且在消费端，Kafka保证，1个partition只能被1个consumer消费。）</p>
<h3 id="保证顺序的消息队列的设计"><a href="#保证顺序的消息队列的设计" class="headerlink" title="保证顺序的消息队列的设计"></a>保证顺序的消息队列的设计</h3><p>同一消息订阅者处理不同消息，成功与否跟消息的内容有关（比如手机充值，我们可以看到充值成功与否跟手机号码合法化有关），现在讨论依赖消息订阅者的状态有关（数据复制，只要源数据库可用，则复制一定成功）。<br>在这样场景下，一个吞吐量达且支持顺序的消息中间件是很有价值的，数据变更平台就是这样的一个场景。在这里，由原来的push模式变为pull模式，为了让消息接收者更好的控制消息的接收和处理，消息中间件逻辑也得到了简化。具体实现是消息存储写到文件中，采用顺序写入，消息必须按顺序消费，所以一个消息接收者在每一个他所接收的消息队列上有一个当前消费的位置，之前的位置代表已经消费的消息，不同消费者维护分别维护自己的指针，可以通过指针的回溯来进行消息的补发。接收端拥有比较大的自主权。</p>
<h4 id="单机多序列问题和优化"><a href="#单机多序列问题和优化" class="headerlink" title="单机多序列问题和优化"></a>单机多序列问题和优化</h4><p>单机多队列的隔离完成了对消息的有序支持。如果单的队列数量数量多，性能会下降很大，原因是队列数量大时，写就接近随机写。改进措施有按顺序写入，然后根据队列做个索引。<br>带来的好处是：<br>1.队列轻量化，单个队列数据量少<br>2.对磁盘访问串行化，避免竞争<br>缺点是：<br>1.写虽然是顺序写，但是读是随机读<br>2.读先读逻辑队列在读物理队列，增加开销<br>3.需要保证物理队列与逻辑队列的完全一致。编程复杂</p>
<h4 id="解决本地消息存储的可靠性"><a href="#解决本地消息存储的可靠性" class="headerlink" title="解决本地消息存储的可靠性"></a>解决本地消息存储的可靠性</h4><p>采用消息同步复制的方式解决可靠性的问题<br>把单个消息中间件变为主（master）备（slave）两个节点，slave订阅master所有消息，用来消息备份。不过需要注意这是一个异步操作，slave订阅收到的消息会比master略少一点，存在着丢失信息的可能，类似mysql的replication<br>同样是把单个节点扩展到Master/Slave节点，但是采用的是同步复制，而不是订阅。对于消息更为严格的场景，第二种更为安全可靠</p>
<h4 id="如何支持队列的扩容"><a href="#如何支持队列的扩容" class="headerlink" title="如何支持队列的扩容"></a>如何支持队列的扩容</h4><p>基本的策略是消息发送者能够知道应该把消息写入迁移到新的队列中，并且也让消息订阅者知道，当前队列消费完消息后要去新的队列去消费消息<br>有几个关键点：<br>1.原队列在开始扩容会有个标记，即便有新的消息进来，也不再接收<br>2.通知消息发送端发送新的队列位置<br>3.对于消息接收端，对原来队列的定位会收到新旧两个位置，当旧数据的数据接收完毕后，则只会关心新队列的位置</p>
<h3 id="push和pull方式对比"><a href="#push和pull方式对比" class="headerlink" title="push和pull方式对比"></a>push和pull方式对比</h3><p>1.从数据传输状态；push保存在服务器端，pull保存在消费端<br>2.从传输失败，重试；push要维护每次传输状态，pull不需要<br>3.数据传输的实时性；push非常实时，pull默认的短轮询方式的实时依赖性依赖于pull间隔时间，间隔越大，实时性越低，长轮询的方式实时性与pull一致。<br>4.从流控机制；push方式服务器需要根据订阅者的消费能力做流控，pull方式消费端可以根据自身消费能力决定是否去pull消息</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消息中间件的价值&quot;&gt;&lt;a href=&quot;#消息中间件的价值&quot; class=&quot;headerlink&quot; title=&quot;消息中间件的价值&quot;&gt;&lt;/a&gt;消息中间件的价值&lt;/h2&gt;&lt;h3 id=&quot;消息中间件的定义&quot;&gt;&lt;a href=&quot;#消息中间件的定义&quot; class=&quot;head
    
    </summary>
    
      <category term="大型网站中间件" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
