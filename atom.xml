<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-19T16:30:39.123Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李睿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>构建java中间件（第三章）</title>
    <link href="http://yoursite.com/2017/10/19/%E6%9E%84%E5%BB%BAjava%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/10/19/构建java中间件/</id>
    <published>2017-10-19T02:59:08.000Z</published>
    <updated>2017-10-19T16:30:39.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中间件的定义"><a href="#java中间件的定义" class="headerlink" title="java中间件的定义"></a>java中间件的定义</h2><p>基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的服务，中间件不是操作系统的一部分，不是数据库管理的一部分，不是软件应用的一部分，而是能够让软件开发者更方便的处理通信、输入、输出，能够专注在他们自己应用的部分。总体来说，中间件不是最上层应用，也不是最底层的操作系统，是处于中间的组件，起到桥梁的作用，是应用和应用之间，应用和服务之间的桥梁。<br>主要有三个领域的中间件：</p>
<h3 id="远程对象调用和对象访问中间件"><a href="#远程对象调用和对象访问中间件" class="headerlink" title="远程对象调用和对象访问中间件"></a>远程对象调用和对象访问中间件</h3><p>解决分布式的应用互相访问的问题</p>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>解决应用之间的消息传递、解耦、异步的问题</p>
<h3 id="数据访问中间件"><a href="#数据访问中间件" class="headerlink" title="数据访问中间件"></a>数据访问中间件</h3><p>主要解决应用访问数据库的共性问题的组件</p>
<h2 id="构建java中间件的基础知识"><a href="#构建java中间件的基础知识" class="headerlink" title="构建java中间件的基础知识"></a>构建java中间件的基础知识</h2><h3 id="跨平台的运行环境–jvm"><a href="#跨平台的运行环境–jvm" class="headerlink" title="跨平台的运行环境–jvm"></a>跨平台的运行环境–jvm</h3><p>java虚拟机所识别的是统一格式的中间代码也就是java字节码。</p>
<h3 id="垃圾回收与内存堆布局"><a href="#垃圾回收与内存堆布局" class="headerlink" title="垃圾回收与内存堆布局"></a>垃圾回收与内存堆布局</h3><p>java虚拟机是通过垃圾回收方式来回收内存的，而不像C/C++语言那样通过代码显示释放。JVM内存堆布局有新生代、年老代、持久代。对象创建一般在新生代的eden区，也有可能直接分配在年老区。</p>
<h2 id="java并发编程的类、接口和方法"><a href="#java并发编程的类、接口和方法" class="headerlink" title="java并发编程的类、接口和方法"></a>java并发编程的类、接口和方法</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池可以降低创建线程的开销，这是因为线程池在线程结束后进行的是回收操作，而不是销毁线程。在java中，我们主要使用的线程池是ThreadPoolExecutor,此外，我们还有定时线程池scheduledThreadPoolExecutor。需要注意的是ThredPool.newCachedThreadPool()返回的线程池的使用，该方法返回的线程池的线程使用没有上限。因而没办法控制总体线程的数量，因为每个内存都要占用内存，这会造成过多内存的占用。建议不要用这个线程池。而使用有固定线程上限的线程池。</p>
<h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><p>sychronized可以用于声明方法，也可以用于声明代码块。看一下三个使用场景。<br>场景一：<br>在这个类的两个静态方法中，不同线程中，两个方法的调用是互斥的，不仅这样任何两个线程都是互斥的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo1&#123;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo1</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized static void <span class="function"><span class="title">foo2</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景二：<br>foo3和foo4是类的两个成员函数，在多线程中，调用同一个对象的foo3和foo4才会互斥，这是同一对象的多线程调用互斥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo2&#123;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo3</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public sychronized void <span class="function"><span class="title">foo4</span></span>()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>场景三：<br>sychronized用来修饰代码块，后面的参数就是同步锁的对象。sychronized(this) 与Demo3中加sychronized成员方法是互斥，sychronized(Demo3.class)与Demo3中加sychronized静态方法是互斥的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo3&#123;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo5</span></span>()&#123;</div><div class="line">           sychronized(this)&#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">foo6</span></span>()&#123;</div><div class="line">          sychronized(Demo3.class)&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是java.util.concurrent.locks中的一个类，他的用法类似sychronized类似，但是需要显示unlock。</p>
<h4 id="ReentrantLock提供tryLock"><a href="#ReentrantLock提供tryLock" class="headerlink" title="ReentrantLock提供tryLock"></a>ReentrantLock提供tryLock</h4><p>调用的时候，如果锁被其他线程持有，那么tryLock就会立刻返回，返回结果为false，如果锁没有被其他线程持有，当前线程会持有锁，返回true。</p>
<h4 id="ReentrantLock提供公平锁和抢占锁"><a href="#ReentrantLock提供公平锁和抢占锁" class="headerlink" title="ReentrantLock提供公平锁和抢占锁"></a>ReentrantLock提供公平锁和抢占锁</h4><p>默认是抢占锁，通过参数boolean fair；公平锁的好处是等待锁的线程不会饿死，但是整体效率会降低；非公平锁的好处是整体效率会相对高点，但是有些线程会饿死或者等待很长时间才能获取。公平锁是按照锁的排队顺序需要获取锁，而非公平锁是抢占式的。此外ReentrantLock还提供了ReentrantReadWriteLock，读写锁，主要用于读多写少并且读不需要互斥的场景，这样的锁比全部互斥锁性能会高。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unlock写在finally表示一定可以释放锁，ReentrantReadWriteLock与ReentrantLock用法相似，但是通过readLock()和writeLock()两个方法来获取读锁和写锁，这两个锁按照前面的方式进行加锁和解锁。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>sychronized除了有互斥性，还有可见性。可见性是指一个线程修改了变量后，其他线程能够马上看到这个修改值。volatile能够保证变量的可见性，它更多是修饰开关的可见性，它不能保证操作的原子性。</p>
<h3 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h3><p>JDK 1.5增加了java.util.concurrent.atomic包，这些包是以Atomic开头的类，这些类提供了一些原子操作，以AtomicInteger为例，通过jni使用硬件支持的CAS指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Sample &#123;</div><div class="line"></div><div class="line">    private static AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">increment</span></span>() &#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">decrease</span></span>() &#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h3><p>wait、notify和notifyAll是java的object对象的三个方法，wait是用来等待的，notify和notifyAll是用来通知的。在多线程中，可以把某个对象做为事件对象，通过这个对象的wait、notify、notifyAll完成线程的通知。notify和notifyAll都是唤醒调用同一个对象的wait，但不同的是notify会唤醒一个等待线程，notifyAll会唤醒全部等待线程。对wait、notify、notifyAll的调用必须在对象的sychronized中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">testWait</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.wait();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">testNotify</span></span>()&#123;</div><div class="line">  sychronized(this)&#123;</div><div class="line">    this.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实践中，对wait的使用一般在循环里，并且会判断相关的数据状态是否达到预期，如果没有，继续等待，这样做主要是为了防止虚假唤醒。虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒，而此时是不应该唤醒的。<br>解决<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized (obj) &#123;  </div><div class="line">        <span class="keyword">while</span> (&lt;condition does not hold&gt;)  </div><div class="line">            obj.wait();  </div><div class="line">        ... // Perform action appropriate to condition  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java中间件的定义&quot;&gt;&lt;a href=&quot;#java中间件的定义&quot; class=&quot;headerlink&quot; title=&quot;java中间件的定义&quot;&gt;&lt;/a&gt;java中间件的定义&lt;/h2&gt;&lt;p&gt;基于java基础构建的中间件。中间件为软件应用提供操作系统所提供的服务之外的
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大型软件架构及其结构演进过程第二章</title>
    <link href="http://yoursite.com/2017/10/17/%E5%A4%A7%E5%9E%8B%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/17/大型软件架构及其结构演进过程/</id>
    <published>2017-10-17T09:25:39.000Z</published>
    <updated>2017-10-19T03:29:47.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是大型网站"><a href="#什么是大型网站" class="headerlink" title="什么是大型网站"></a>什么是大型网站</h1><p>访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是个分布式系统</p>
<h1 id="大型网站的架构演进"><a href="#大型网站的架构演进" class="headerlink" title="大型网站的架构演进"></a>大型网站的架构演进</h1><h2 id="用java技术和单机来构建网站"><a href="#用java技术和单机来构建网站" class="headerlink" title="用java技术和单机来构建网站"></a>用java技术和单机来构建网站</h2><p>选择一个开源的server作为容器，使用一些JSP/servlet技术或者开源框架构建我们的应用，选择一个数据库管理系统来管理数据，通过jdbc进行数据库的连接和操作。</p>
<h2 id="从一个单机的交易网站说起"><a href="#从一个单机的交易网站说起" class="headerlink" title="从一个单机的交易网站说起"></a>从一个单机的交易网站说起</h2><p>考虑一个交易网站，最基本功能有这么三个部分：用户模块、商品模块、交易模块，各个功能模块是通过JVM内部的方法调用来进行交互，应用和数据库之间是通过jdbc来访问的。同时应用和数据库放在同一台机子上。</p>
<h2 id="单机负载告警，数据库与应用分离"><a href="#单机负载告警，数据库与应用分离" class="headerlink" title="单机负载告警，数据库与应用分离"></a>单机负载告警，数据库与应用分离</h2><p>网站对外提供服务后，访问量不断增大，负载持续升高。我们可以把数据库和应用分开，分别放到两台机子上。</p>
<h2 id="应用服务器告警，如何让应用服务器走向集群"><a href="#应用服务器告警，如何让应用服务器走向集群" class="headerlink" title="应用服务器告警，如何让应用服务器走向集群"></a>应用服务器告警，如何让应用服务器走向集群</h2><p>服务器压力仍然变大，把应用从单机升级为集群，我们可以考虑一台应用服务器变为两台。我们要考虑如下两个问题，第一个是服务器的选择问题，可以用dns或者增加负载均衡设备来解决这个问题；第二个是session问题。</p>
<h3 id="引入负载均衡设备"><a href="#引入负载均衡设备" class="headerlink" title="引入负载均衡设备"></a>引入负载均衡设备</h3><h3 id="解决应用服务器变为集群后的session问题"><a href="#解决应用服务器变为集群后的session问题" class="headerlink" title="解决应用服务器变为集群后的session问题"></a>解决应用服务器变为集群后的session问题</h3><p>http协议本身是无状态的，需要基于http协议支持会话状态机制，具体的实现方式是：在会话开始时，分配唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后再每次请求的时候，浏览器会带上这个会话标识告诉web服务器请求属于哪个会话的。在web服务器上，各个会话有独立的存储，保存不同的会话信息。如果是禁用cookie的情况，就把会话标识放在url参数上。<br>当应用服务器扩展时就会遇到session问题。因为session是存在单机上的。</p>
<h4 id="session-sticky（保持-粘滞会话）"><a href="#session-sticky（保持-粘滞会话）" class="headerlink" title="session sticky（保持-粘滞会话）"></a>session sticky（保持-粘滞会话）</h4><p>在负载均衡器上做了操作，同样的session请求每次发送给同一个服务器端处理。但也带来以下的问题：1.如果一台服务器宕机或者重启，那么这台服务器上的会话数据会全部丢失，如果会话中有登录状态的数据的话，那就要重新登录。2.会话标识的应用层信息，那么负载均衡器需要进行应用层解析，这个开销比第四层交换大。3.负载均衡器变为有状态的节点，要将会话保存到web服务器映射。和无状态节点相比，内存消耗更大，容灾更麻烦。</p>
<h4 id="session-Replication（复制会话）"><a href="#session-Replication（复制会话）" class="headerlink" title="session Replication（复制会话）"></a>session Replication（复制会话）</h4><p>web服务器会增加会话的同步，但在一些场景存在问题：1.同步session造成网络的开销。只要session数据发生变化，就需要把数据同步到其他机器上，机器越多，同步带来的网络带宽的开销就会越大；2.每台web服务器都需要保存所有的session数据，如果整个集群的session数很多，每台机器用于保存session的内容占用会很严重。</p>
<h4 id="session数据集中存储"><a href="#session数据集中存储" class="headerlink" title="session数据集中存储"></a>session数据集中存储</h4><p>把session数据集中存储，不同的web服务器从相同的地方获取session数据。session会统一存储在另外的服务器上，这样可以保证web服务器读到的session数据都是一样的。存储session的具体方式，可以使用数据库或者其他分布式存储系统。这个方案解决了replication的内存问题和带宽问题。但也存在问题是：1.读写session引入网络操作，问题就在时延和不稳定性，但如果是内网，这个问题不大；2.如果集中存储session的机器或者集群有问题，会影响我们的应用。</p>
<h4 id="cookie-based（基于cookie1）"><a href="#cookie-based（基于cookie1）" class="headerlink" title="cookie based（基于cookie1）"></a>cookie based（基于cookie1）</h4><p>通过cookie传递session数据，我们的session数据存储在cookie里，然后web服务器从cookie中生成对应的session数据。这个方案存在着不足：1.cookie的长度限制限制了session的长度限制。2.安全性；session数据是服务器数据，而这个方案导致服务端数据到了外部网络和客户端，因而存在安全性问题。但也可以通过对session数据加密，但从安全角度来看物理上不接触才更安全。3.带宽消耗，数据中心整体的带宽消耗；4.性能影响；每次http请求和响应都带有session数据，对web服务器来说，响应结果输出越少，支持的并发请求越多</p>
<h2 id="数据读压力大，那么就读写分离吧"><a href="#数据读压力大，那么就读写分离吧" class="headerlink" title="数据读压力大，那么就读写分离吧"></a>数据读压力大，那么就读写分离吧</h2><p>接下来从数据库的角度来看。</p>
<h3 id="采用数据库作为读库"><a href="#采用数据库作为读库" class="headerlink" title="采用数据库作为读库"></a>采用数据库作为读库</h3><p>对于大型网站，有不少业务是读多写少，这个状况会直接反应到数据库上，我们考虑读写分离的方式。我们在前面结构增加一个读库，这个库不承担写工作，只提供读操作。这个结构的变化会带来两个问题：1.数据复制问题；2.应用对于数据源的问题<br>首先看下第一个问题，现在数据库系统一般都提供数据复制的功能，可以直接使用数据库系统的自身机制。除此，还需要考虑数据复制时延问题，以及复制过程中数据源和目标之间的映射关系以及过滤条件的支持问题。复制时延带来的是短期的数据不一致。<br>mysql支持master+slave模式，5.5版本以前是异步数据复制，会有延迟，提供完全镜像方式的复制；5.5以后采用semisync（半同步）<br>备注：异步复制模式：主库将已经提交的事务event 写入binlog后，即返回成功给app，该模式下并不保证任何已经提交的事务会传递到任何slave并被成功应用。全同步复制模式：当主库提交一个事务 event，主库会等待该事务被传递到所有的slave上，且所有slave applay 该事务/event 通知主库之后，才会返回会话，事务已经成功。Semisynchronous Replication模式下,在主库上提交一个事务/event，它会等待至少一个slave通知主库，slave 已经接收到传递过来的events并写入relay log，才返回给回话层 写入成功，或者直到传送日志发生超时。<br>对于一个应用来说，增加一个读库对结构变化有一个影响，我们应用需要根据不同情况选择不同的数据库源。写操作走主库，事务的读也要走主库，用时也要考虑备库相对于主库的数据延时。即使是不在事务的读，考虑备库数据延迟，不同业务选择也有差异。<br>广义读写分离的特点是增加读源，分担读写源的读压力，要考虑读源的数据复制问题。</p>
<h3 id="搜索引擎其实是一个读库"><a href="#搜索引擎其实是一个读库" class="headerlink" title="搜索引擎其实是一个读库"></a>搜索引擎其实是一个读库</h3><p>大型网站的站内搜索。在交易网站中，用户需要查找商品功能之类的，这就像数据库的like功能，但这种方式的代价很大。可以使用搜索引擎的倒排表方式，能够大大提升搜索效率。搜索集群的使用方式和读库我们希望的使用的方式是一样的。构建索引的方式有两种，一种按照全量/增量划分，另一种是实时/非实时划分。全量用于第一次建立索引。增量一般用于加入每日的全量作为补充。实时/非实时划分体现在索引更新时间上。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，也就是我们常说的cache。</p>
<h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p>缓存系统一般是用来保存和查询key-value键值对的。应用访问缓存，如果数据不存在，就从数据库中读出数据放入缓存。当缓存数量不够时，最近不被访问的数据就被清除。还有另外做法，在数据库中数据发生变化后，能主动把数据放入缓存系统中。这样的好处是能够及时地更新缓存数据，不会造成读取失效，一般用于全数据缓存，还要能够理解业务逻辑。</p>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>有些动态产生的页面特别热，我们可以对这些内容进行缓存。</p>
<h2 id="弥补关系型数据库的不足，引入分布式存储系统"><a href="#弥补关系型数据库的不足，引入分布式存储系统" class="headerlink" title="弥补关系型数据库的不足，引入分布式存储系统"></a>弥补关系型数据库的不足，引入分布式存储系统</h2><p>常见的分布式存储系统有分布式文件系统，分布式key-value系统和分布式数据库。通过分布式文件系统来解决小文件和大文件的存储问题，通过key-value系统提供高性能的半结构化的支持，通过分布式数据库提供一个支持大数据、高并发的数据库系统。</p>
<h2 id="读写分离后，数据库又遇到瓶颈"><a href="#读写分离后，数据库又遇到瓶颈" class="headerlink" title="读写分离后，数据库又遇到瓶颈"></a>读写分离后，数据库又遇到瓶颈</h2><p>通过读写分离，分布式存储来替代关系型数据库能够降低主库的压力，但是交易、商品、用户的数据还在同一个数据库中，这时候数据库的压力还在，这时候采取的方案有水平拆分和垂直拆分。</p>
<h3 id="专库专用，数据垂直拆分"><a href="#专库专用，数据垂直拆分" class="headerlink" title="专库专用，数据垂直拆分"></a>专库专用，数据垂直拆分</h3><p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合交易系统的例子，就是将交易、商品、用户的数据拆分开。所造成的的影响是需要配置多个数据源，这就增加了所需配置，所带来的的是每个数据库连接池的隔离，那就需要考虑单机跨业务的事务。一种方案是分布式事务，另一种是去掉事务或者不去追求强事务支持，则原来在单库中可以使用的表关联的查询也需要改变实现。</p>
<h3 id="垂直拆分后的单机遇到瓶颈，数据水平拆分"><a href="#垂直拆分后的单机遇到瓶颈，数据水平拆分" class="headerlink" title="垂直拆分后的单机遇到瓶颈，数据水平拆分"></a>垂直拆分后的单机遇到瓶颈，数据水平拆分</h3><p>数据水平拆分就是把同一个表的数据拆分成不同的数据库中去。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到单个数据库的瓶颈。这时就把一张表拆到两个或者多个数据库中。数据水平拆分和读写分离的区别是读写分离解决的是读压力大，对于数据量大或者更新量大的情况并不起到作用；数据水平拆分和数据垂直拆分区别是，垂直拆分是把不同表拆到不同数据中去；水平拆分是把同一张表拆分到不同数据库中去。水平拆分后的问题：1.需要解决SQL路由的问题；2.主键的处理也会变得不同。3.分页会变得困难。</p>
<h2 id="数据库问题解决后，应用面对的新挑战"><a href="#数据库问题解决后，应用面对的新挑战" class="headerlink" title="数据库问题解决后，应用面对的新挑战"></a>数据库问题解决后，应用面对的新挑战</h2><h3 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h3><p>前面都是在解决数据的问题，现在我们可以看应用的问题。随着功能越来越多，应用也越来越大，我们需要把应用拆开。在我们的例子中，主要业务功能分为：交易、商品、用户。我们可以把这个应用分为交易和商品两个应用。对于交易和商品都会有涉及用户的地方，我们让两个自己完成涉及用户的工作，类似用户工作</p>
<h3 id="走服务化的做法"><a href="#走服务化的做法" class="headerlink" title="走服务化的做法"></a>走服务化的做法</h3><p>我们把应用分为了三层，分为商品中心、用户中心、交易中心，处于最上层是web系统，用于完成不同的业务功能，处于中间是服务中心，最下层是业务数据库。服务化带来的变化：1.业务功能之间的访问不在是单机的简单方法调用，而是远程服务调用；2.共享的代码的实现放在服务中心；3.数据库的连接发生了变化，我们把数据库的交互工作放到服务中心，让前端专注与浏览器的交互上，而不必关注业务逻辑。连接数据库交给业务中心，减少数据库连接数；4.通过服务化，无论前端web应用还是服务中心，都可以由固定的小团队来维护的系统，这样更好地保持稳定和降低风险。</p>
<h2 id="初始消息中间件"><a href="#初始消息中间件" class="headerlink" title="初始消息中间件"></a>初始消息中间件</h2><p>Message oriented middleWare,面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件，消息中间件的好处是异步和解耦，生产者和消费者都直接跟消息中间件打交道，两个应用之间并不直接联系。这样完成了解耦，目的是希望双方彼此都不知道对方的存在，不受对方影响，消息投递给接收者用到异步的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是大型网站&quot;&gt;&lt;a href=&quot;#什么是大型网站&quot; class=&quot;headerlink&quot; title=&quot;什么是大型网站&quot;&gt;&lt;/a&gt;什么是大型网站&lt;/h1&gt;&lt;p&gt;访问量和数据量二者缺一不可，本身的业务和系统的复杂度也缺一不可。海量的数据和高并发的访问量，它肯定是
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统介绍（第一章）</title>
    <link href="http://yoursite.com/2017/10/16/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/16/大型网站系统与中间件实践读书笔记/</id>
    <published>2017-10-16T03:22:37.000Z</published>
    <updated>2017-10-19T03:04:46.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><p>1.组件分布在网络计算机上；<br>2.组件之间仅仅通过消息传递来通信并协调行动</p>
<h2 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h2><p>1.升级单机处理能力的性价比越来越低<br>2.单机处理能力存在瓶颈<br>3.出于稳定性和可用性的考虑</p>
<h2 id="线程和进程的执行模式"><a href="#线程和进程的执行模式" class="headerlink" title="线程和进程的执行模式"></a>线程和进程的执行模式</h2><h3 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h3><p>s(N)=1/(1-p+p/n);n代表核数，p代表并行部分在单核占的时间</p>
<h3 id="互不通信的多线程模式"><a href="#互不通信的多线程模式" class="headerlink" title="互不通信的多线程模式"></a>互不通信的多线程模式</h3><p>线程之间不需要处理共享的数据，也不需要进行动作协调，没有交集，各自执行自己的逻辑和任务。</p>
<h3 id="基于共享容器协同的多线程模式"><a href="#基于共享容器协同的多线程模式" class="headerlink" title="基于共享容器协同的多线程模式"></a>基于共享容器协同的多线程模式</h3><p>多个线程之间对共享数据进行处理。例如经典的有生产者和消费者，我们有个队列用于生产和消费，这个队列就是共享的对象，多个线程会并发的访问这个队列。对于存储数据的容器或者对象，有线程安全和线程不安全之分。对于线程不安全的容器或者对象，一般通过加锁或者copy on write的方式来处理（CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。CopyOnWriteArrayList、CopyOnWriteArraySet。问题：内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器）</p>
<h3 id="基于事件协同的多线程模式"><a href="#基于事件协同的多线程模式" class="headerlink" title="基于事件协同的多线程模式"></a>基于事件协同的多线程模式</h3><p>除了并发访问，线程之间会存在着协调的需求。例如线程B需要等到某个状态或者事件的发生后才能继续自己的工作。能够原子性的获取多个锁或者调整锁的顺序可以避免死锁。比如T1：A.lock();B.lock(); T2:B.lock();A.lock();这时候就发生死锁了。</p>
<h3 id="多进程模式"><a href="#多进程模式" class="headerlink" title="多进程模式"></a>多进程模式</h3><p>多线程和多进程不同在于线程是属于进程，一个进程内的多个线程共享了进程的内存空间；多个进程的内存空间是独立的。多进程可以共享数据，但代价比多线程大，会涉及到序列化和反序列化的开销。分布式系统是多机系统，可以看成是多机多进程。</p>
<h2 id="网络通信基础知识"><a href="#网络通信基础知识" class="headerlink" title="网络通信基础知识"></a>网络通信基础知识</h2><h3 id="osi和tcp-ip网络模型"><a href="#osi和tcp-ip网络模型" class="headerlink" title="osi和tcp/ip网络模型"></a>osi和tcp/ip网络模型</h3><p>osi是七层 物理层 数据链路层 网络层 运输层 会话层 展示层 应用层<br>tco/ip是四层 网络接口 网络层 运输层 应用层</p>
<h3 id="网络io的实现"><a href="#网络io的实现" class="headerlink" title="网络io的实现"></a>网络io的实现</h3><h4 id="BIO的方式"><a href="#BIO的方式" class="headerlink" title="BIO的方式"></a>BIO的方式</h4><p>Blocking IO，采用阻塞的方式去实现，也就是一个套接字需要使用一个线程处理。发生建立连接、读数据、写数据时都可能会发生阻塞。</p>
<h4 id="NIO的方式"><a href="#NIO的方式" class="headerlink" title="NIO的方式"></a>NIO的方式</h4><p>NonBlocking IO，基于事件驱动思想。相比较BIO，NIO不需要为每一个套接字分配一个线程，而可以在一个线程中处理多个套接字工作。reactor模式下，Reactor会管理所有的handler，并且把出现的事件交给相应的handler去处理。在NIO中统一通过reactor对所有客户端的套接字的事件做处理，然后在派发到不同的线程。这样解决了为了支撑更多套接字而打开更多线程的问题。</p>
<h4 id="AIO的方式"><a href="#AIO的方式" class="headerlink" title="AIO的方式"></a>AIO的方式</h4><p>Asynchronous IO（异步IO），AIO采用Proactor模式，AIO在进行读/写操作时，只需要调用对应的read/write方法，并且传入completionHandler；在动作完成后，会调用completionHandler。NIO的通知是发生在动作之前，是在可读可写，selector发现这些事件调用handler来处理。</p>
<h2 id="如何把应用从单机扩展到分布式"><a href="#如何把应用从单机扩展到分布式" class="headerlink" title="如何把应用从单机扩展到分布式"></a>如何把应用从单机扩展到分布式</h2><h3 id="输入设备的变化"><a href="#输入设备的变化" class="headerlink" title="输入设备的变化"></a>输入设备的变化</h3><p>两种：一种是互相连接的多个节点，接受其他节点信息的节点；一种是人机交互的输入设备</p>
<h3 id="输出设备的变化"><a href="#输出设备的变化" class="headerlink" title="输出设备的变化"></a>输出设备的变化</h3><p>两种：向其他节点传递信息的节点；人机交互的输出设备</p>
<h3 id="控制器的变化"><a href="#控制器的变化" class="headerlink" title="控制器的变化"></a>控制器的变化</h3><p>在单机中，控制器就是cpu，在分布式中，控制器就是协调和控制节点之间的动作和行为。</p>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>请求发起方需要确定谁来处理这个请求，请求发起方和请求处理方中间有一个硬件负载均衡设备，所有的请求都要经过这个负载均衡设备来完成请求转发的控制。</p>
<h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>把硬件负载均衡器换为LVS；特点：代价低，可控性强，你可以相对自由地按照自己的需要去增加负载均衡策略。在集群中，对于发起请求的一方和处理请求的一方来说都是透明的。发送请求的一方会认为中间代理提供了服务，而处理请求的一方会认为中间代理请求服务。发起方不需要知道有几台机器提供服务，也不需要知道提供服务的地址，只需要知道中间代理的地址。有两个不足：第一个是增加网络的开销，一方面指的是流量，一方面指的是延迟。第二个是这个透明代理在请求的必经路径上，如果这个代理出现问题，那么所有请求都会出现问题。所以要考虑热备份</p>
<h4 id="名称服务"><a href="#名称服务" class="headerlink" title="名称服务"></a>名称服务</h4><p>与透明服务最大的区别是，请求发起方和请求处理方两个集群间没有代理服务器这样的设备存在，而是请求方和处理方直接相连。除此之外，有一个名称服务的角色，主要作用有两个，收集请求服务处理的服务器的地址信息，和提供这些地址信息给请求发起方。名称服务只是起到地址交换的作用，在发起请求的机器上，需要根据从名称服务得到的地址进行负载均衡的工作。这种方案的优势是名称服务不在请求的必经路径上，就是说如果这个名称服务出现问题，很多时候我们有不少办法保证请求处理的正常。其次，发起请求的一方和处理请求的一方是直连的，减少了中间路径，以及可能的额外带宽消耗。劣势是升级代码复杂。</p>
<h4 id="规则服务器"><a href="#规则服务器" class="headerlink" title="规则服务器"></a>规则服务器</h4><p>请求发起方根据规则服务器给的规则选择请求处理方，在请求发起的机器上，会有对规则进行处理从而进行请求处理服务机器的选择代码。与名称服务不同的是，规则服务器不和请求处理机器进行交互，只负责把规则提供给请求发起方。</p>
<h4 id="master-worker"><a href="#master-worker" class="headerlink" title="master+worker"></a>master+worker</h4><p>存在一个master节点管理任务，由master分配给不同的woker去进行处理。</p>
<h3 id="运算器的变化"><a href="#运算器的变化" class="headerlink" title="运算器的变化"></a>运算器的变化</h3><p>单机中，运算器就是具体的电子元件，而多机中，运算器由多个节点组成，分布式的运算器是运用多个节点的计算能力来协同完成整体的计算任务。</p>
<h4 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h4><h4 id="多台服务器"><a href="#多台服务器" class="headerlink" title="多台服务器"></a>多台服务器</h4><p>方案一：通过DNS服务器进行调度控制，在用户解析dns时候，就会给予一个服务器地址。有点像名称服务和规则服务，中间没有代理。<br>方案二：在用户和服务器之间架起了负载均衡设备（硬件或者软件LVS）。DNS返回的是负载均衡的地址，用户的访问都是通过负载均衡器到达后面的网站服务器。</p>
<h4 id="日志的处理"><a href="#日志的处理" class="headerlink" title="日志的处理"></a>日志的处理</h4><p>增加日志的处理服务器的数量来提升处理日志的能力。一种方案是利用 master+worker方式的控制器运用到这个日志处理的场景。除了master以外，还可以用规则服务器来分配问题。</p>
<h4 id="存储器的变化"><a href="#存储器的变化" class="headerlink" title="存储器的变化"></a>存储器的变化</h4><p>存储器分为内存和外存，内存在断电、重启或者OS崩溃情况下会丢失，而外存是用来长久保存数据的。在分布式系统中，我们需要把承担存储功能的多个节点组织在一起，使之看起是一个存储器。以最基础的key-value为例。</p>
<h4 id="单机的key-value"><a href="#单机的key-value" class="headerlink" title="单机的key-value"></a>单机的key-value</h4><h4 id="在应用服务器与key-value存储服务器之间加了一个代理服务器"><a href="#在应用服务器与key-value存储服务器之间加了一个代理服务器" class="headerlink" title="在应用服务器与key-value存储服务器之间加了一个代理服务器"></a>在应用服务器与key-value存储服务器之间加了一个代理服务器</h4><h4 id="名称服务的key-value服务"><a href="#名称服务的key-value服务" class="headerlink" title="名称服务的key-value服务"></a>名称服务的key-value服务</h4><h4 id="规则服务器的key-value服务"><a href="#规则服务器的key-value服务" class="headerlink" title="规则服务器的key-value服务"></a>规则服务器的key-value服务</h4><h4 id="master控制的key-value服务"><a href="#master控制的key-value服务" class="headerlink" title="master控制的key-value服务"></a>master控制的key-value服务</h4><h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><h4 id="缺乏全局时钟"><a href="#缺乏全局时钟" class="headerlink" title="缺乏全局时钟"></a>缺乏全局时钟</h4><p>单机的以单机的时钟为准控制时序。多机每个节点都有自己的时钟，如果依赖时序，将会难以处理。</p>
<h4 id="面对故障的独立性"><a href="#面对故障的独立性" class="headerlink" title="面对故障的独立性"></a>面对故障的独立性</h4><p>在单机系统的单进程程序中，不会出现一些模块不行，一些模块正常。而在分布式系统中，整个系统一部分有问题而其他模块正常的情况是经常出现。我们称故障独立性。</p>
<h4 id="处理单点故障"><a href="#处理单点故障" class="headerlink" title="处理单点故障"></a>处理单点故障</h4><p>在分布式系统中，如果某个角色或者功能只有单机在支撑，那么这个节点我们称之为单点。避免单点的关键就是把这个功能从单机实现变为集群实现。如果不能把单机实现变为集群实现，那一般还有另外两种选择：<br>1.给单点做好备份<br>2.降低单点故障的影响范围（比如，在交易网站中，交易信息放在一个数据库里，这就形成了单点，我们会给这个数据库增加一个备库以解决容灾问题。我们可以考虑拆分数据，把一份数据库拆分成多个数据库后，出现故障的影响面就更小了。从本质上说，这种方式更多是转移和交换）</p>
<h4 id="分布式事务的挑战"><a href="#分布式事务的挑战" class="headerlink" title="分布式事务的挑战"></a>分布式事务的挑战</h4><p>2pc、3pc、最终一致、BASE、CAP、paxos算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式系统的定义&quot;&gt;&lt;a href=&quot;#分布式系统的定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的定义&quot;&gt;&lt;/a&gt;分布式系统的定义&lt;/h2&gt;&lt;p&gt;1.组件分布在网络计算机上；&lt;br&gt;2.组件之间仅仅通过消息传递来通信并协调行动&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="大型网站系统与中间件实践读书笔记" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云取证第八周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%85%AB%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第八周周报/</id>
    <published>2017-06-29T11:54:42.000Z</published>
    <updated>2017-07-05T14:57:11.842Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。<br>首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次。2.显示云测试的总体上下文；3.提供了包括Guidance EnCase和AccesData Forensic Toolkit在内的流行取证获取工具。<br>云计算使取证不同，特别是考虑到证据的远程性质，缺乏实体访问权限以及完整性和真实性所需的信任。虽然取证检查员的目标与以前相同，但非传统困难的问题包括：远程数据的取证知识获取，大量传播，分布式数据，监管链和数据所有权。检获和获取数字文物是取证进程的初步步骤。存在两种可能的情况：远程调查员可以从源头自己收集取证证据，或者提供者可以提供证据。每个场景需要对所返回数据的不同程度的信任。此外，每种情况都使用不同的技术实现来恢复数据。主要工作有亚马逊弹性计算云（EC2）在公共云中执行持续和非持久性数据收集的现有工具的三个实验结果。对于使用客户机操作系统的数据采集不够信任的情况，分析基础设施堆栈较低级别的取证方法。演示如何使用虚拟机内省来注入远程取证代理进行远程采集。用不受信任的管理程序探索取证数据采集的四个策略。<table><tr><td>Layer</td><td>Cloud layer</td><td>Acquisition method</td><td>Trust required</td></tr><br>    <tr><td>6</td><td>Guest application/data</td><td>Depends on data</td><td>Guest operating system (OS), hypervisor, host OS, hardware, network</td></tr>  <tr><td>5</td><td>Guest OS</td><td>Remote forensic software</td><td>Guest OS, hypervisor, host OS, hardware, network</td></tr><tr><td>4</td><td>Virtualization</td><td>Introspection</td><td>Hypervisor, host OS, hardware, network</td></tr><tr><td>3</td><td>Access virtual disk</td><td>Access virtual disk</td><td>Host OS, hardware, network</td></tr><tr><td>2</td><td>Physical hardware</td><td>Access physical disk</td><td>Hardware, network</td></tr><tr><td>1</td><td>Network</td><td>Packet capture </td><td>Network</td></tr></table><br>  在IaaS中，尽管没有物理访问，消费者仍保留对第5层（访客操作系统）和6（访客应用程序）的管理控制权。此外，各层次的取证行为将不同。每一层需要不同的信任，即该层是安全和信任的;堆栈越远，累积的信任就越少。在公共云中，所有层都需要提供商的一些信任，特别是对恶意内部人员的信任。防伪策略，病毒检测器应在多层次上检查证据。调查人员可以选择云层的哪一层进行取证处理。关于这一决定的考虑首先围绕在该级别进行取证的技术能力，再次对所返回数据的信任。该层还影响可用于收集的哪些类型的取证数据，例如第1层（网络）上的数据包捕获，第2层物理文件（物理硬件）或第3层（主机操作系统）上的虚拟文件。对于每种数据类型，数据必须遵守严格的监管链，并且必须包括完整性检查机制。云计算引入了一个强大的新选项：虚拟机快照。利用虚拟化的许多云实现可以拍摄正在运行的计算机的快照，然后像现在一样将该快照恢复并运行。这提供了创造历史记录的能力，以及事后做“活”取证。</p>
<p>  接下来就是实验。能够远程获取aharddrive和内存映像。分析EnCase Forensic和FTK Investigator中的这些映像分别正确显示了活动的时间表，包括安装Apache和网页创建和删除。分析显示虚拟环境的异常现象，也没有任何明显的异议，引起对数据完整性的怀疑。采集过程的速度受到我们学习如何使用远程代理和网络带宽传输数据的限制。每个EnCase和FTK大约12小时，使用我们大学的OC-12连接传输30 GB磁盘映像和2 GB内存映像。实验2成功地形成了驱动器的完整图像和正确的时间线。 VM内省是取证学的强大工具，允许人的实时调查，而不会显露调查人员的存在。然而，内省是云服务提供商必须实施的一个特殊功能。这是我们能够验证图像完整性的唯一实验，因为我们可以访问物理磁盘，并且可以比较EnCase映像和原始磁盘的散列值。实验3中的AWS导出过程也成功地返回了驱动器的完整映像。我们能够将驱动器加载到EnCase和FTK中，没有任何困难，并验证了驱动器的内容。这种方法的另外一个好处是，AWS会为导出的每个文件生成一个具有元数据的日志报告。此报告包含以下每个文件：传输的日期和时间，存储设备上的位置，MD5校验和和字节数。使用快速运输，花了五天时间收到我们的数据，费用为125美元。我们设想这个过程将会严格地模仿AWS在遵守搜索令或传票时所采取的步骤。 EnCase和FTK最容易使用。尽管使用远程功能需要安装和学习时间，但工具的功能是熟悉且易于执行的。检索磁盘映像所需的12小时时间远远少于此数据卷的AWS导出过程所需的120小时。下载数据平均每小时2.5 GB。 AWSExport花了4小时加载了我们的数据，而剩下的116小时在运输过程中花费了时间。按照这些速率，最有效的选择是导出过程，当超过240 GB的数据将被检索。</p>
<p>  A forensically robust method for acquisition of iCloud data主要讲一种方法，不仅使得下载数据到验证的计算机上然后验证数据的完整性，还可以定位到数据的来源。首先是采集云服务中存储的数据变得越来越重要数字取证调查。 苹果公司不断扩大其云端的功能服务，iCloud。 因此，确定取证获取的有效手段是至关重要的，来自该服务的数据的定义及其对原始文件数据和元数据的影响。本研究通过本机Mac OS X检查从iCloud服务获取的文件系统与服务同步。 目标是确定操作系统iCloud同步文件的位置。 一旦找到，次要目标是确定是否文件哈希值与原始文件匹配，特别是文件元数据时间戳，被改变。</p>
<p>  研究人员使用不同的技术去获取数据。有两种技术是先是通过虚拟机创建镜像，然后用FTK工具去分析这些镜像。还有一种是根据AWS去导出数据。导出的还包括包括“日期和时间传输，存储设备上的位置，MD5校验和，和字节数“。如果哈希值相同则代表数据并未改变。接下来是实验，有两台虚拟机，第一台在整个过程进行快照拍摄，并且数据与云服务同步，第二台新创建的iCloud帐户。然后进行分析以定位iCloud 。下载的文件是与原始文件进行比较以确定文件是否相符<br>  和元数据是一样的，如果不是，初始化配置。</p>
<p>  Side channels in cloud services, the case of deduplication in cloud storage云存储服务通常使用重复数据删除，通过仅存储每个文件或块的单个副本来消除冗余数据。重复数据删除减少了数据存储服务的空间和带宽需求，并且在跨多个用户应用时是最有效的，这是云存储产品的常见做法。我们研究跨用户重复数据删除的隐私含义。我们演示如何使用重复数据删除作为侧面通道，显示有关其他用户的文件内容的信息。在不同的情况下，重复数据删除可以用作隐藏通道，恶意软件可以通过该渠道与其控制中心进行通信，而不管受攻击机器上的任何防火墙设置如何。由于跨用户重复数据删除所带来的高额节省，云存储提供商不可能停止使用此技术。因此，我们提出了简单的机制，可以跨用户重复数据删除，同时大大降低数据泄露的风险。<br>  有两种主要的重复数据删除策略：（1）文件级重复数据删除，其中只存储每个文件的单个副本。如果两个或多个文件具有相同的哈希值，则它们将被标识为相同。这是一种非常受欢迎的多种产品提供的服务; （2）块级重复数据删除，将文件分割成块并仅存储每个块的单个副本。系统可以使用固定大小的块或可变大小的块。</p>
<p>  我们描述的攻击可以应用于在文件级别或块级执行的重复数据删除（具体来说，我们假设从现在开始，在文件级别执行重复数据删除）。但是，重复数据删除服务有两个对攻击至关重要的功能：•基于源的重复数据删除。也就是说，重复数据消除必须在客户端进行。如上所述，此版本的重复数据删除功能节省了带宽，因此常用。应用此方法的结果是，客户端可以观察某个文件或块是否被重复数据删除（或简称为“重复数据删除”）。这可以通过检查通过网络传输的数据量，或通过观察存储软件的日志（如果该软件提供此类报告）来完成。 •对攻击至关重要的第二个功能是跨用户重复数据删除。也就是说，将每个文件或块与其他用户的数据进行比较，如果在服务器上已经可以使用相同的副本，则将其重新排除。这种方法是受欢迎的，因为它不仅在单个用户具有相同数据的多个副本时，而且当不同的用户存储数据的副本时，可以节省存储和带宽。 （企业客户端通常存储相同或相似数据的多个副本，我们发现即使对于私人客户也是如此：几乎每个常用的软件手册或我们试图使用流行备份服务进行备份的媒体文件都已经可以使用请注意，这些是巨大的文件，因此重复数据删除为服务提供商节省了巨大的成本。）识别易受攻击的存储提供商：我们进行了以下测试，以确定执行基于源和跨平台的服务，用户重复数据删除（测试可以由任何读者重复，他选择的存储服务）：（1）我们在两台不同的计算机上安装了该服务的客户端软件，并创建了两个不同的用户帐户; （2）我们使用一个帐号上传文件（在我们的测试中，这个文件是Sun的VirtualBox软件，大小接近73M）; （3）我们使用第二个帐号再次上传同一个文件，检查是否确实上传了。当文件没有通过网络重新发送时，我们得出结论，备份服务执行基于源的跨用户重复数据删除。 （事实上​​，当检查流行的存储服务时，不需要使用两个帐号，因为如上所述，在网络上发现的任何流行的文件很可能存在于服务器上，因为它以前是由其他用户上传的，因此测试可以包括从Web下载流行的文件，将其上传到服务并检查重复数据删除是否发生。）我们确定了三个领先的备份和文件同步提供程序的服务，它们执行跨用户，基于源的重复数据删除。这些服务是（1）DropBox，一种流行的文件共享和备份服务，超过了300万用户里程碑; 2 2）Mozy是面向消费者和企业的在线备份的领先提供商，为超过一百万客户和50,000名业务用户提供备份，并存储超过25 PB; 3和（3）备份审查作为欧洲最佳在线备份服务的Memopal，每天有近1000个新用户4值得注意的是，大多数供应商并不试图隐藏重复数据删除的事实，在我们的测试中容易地以几种简单的方式检测：（1）检查历史记录或日志文件（此方法与MozyHome 5配合使用）; （2）根据上传状态消息，上传和重复数据删除的文件有所不同（此方法与Memopal 6配合使用）; （3）根据上传速度，检查文件上传是否在比客户机上传带宽所需的时间短得多的时间内完成（DropBox 7就是这样）; （4）最终，最常用的重复数据删除检测方法适用于所有服务，无论其接口如何，都是监控网络流量并测量传输数据量。我们注意到，大多数服务具有额外的客户端 - 服务器通信流量，但与上传大型文件时传输的大量数据相比，可以忽略不计。<br>  第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。此第一次攻击允许识别攻击者已知的特定文件是否先前已上传到存储服务。假设有一个攻击者，爱丽丝，谁想要了解有关Bob，云存储服务的用户的信息。那么显然，如果爱丽丝怀疑鲍勃有一些不太可能拥有任何其他用户的特定敏感文件X，她可以使用重复数据删除来检查这个猜想是否正确。 Alice应该做的是尝试备份X的副本，并检查是否发生重复数据删除。作为一个具体的例子，假设有一个文件证明一些非法活动（例如记录暴力事件，或者是具有一些被盗的敏感信息的文件，或与儿童色情相关的材料）。执法机关一旦掌握该文件的副本，就可以将文件上传到不同的云存储提供商，并识别存储文件副本的存储服务。然后，他们可以要求法院命令，要求服务提供商披露上传文件的用户的身份。 （如果文件被认为对于识别拥有该用户的用户来说太敏感，则如上所述，当局上传该文件的过程可以在确定是否在开始之后立即终止重复数据删除应用于此文件。）2.2攻击II：学习文件内容上述攻击仅允许检查特定文件是否存储在云存储服务中。但是，攻击者可能会将此攻击应用于同一文件的多个版本，对本文件内容的所有可能的值基本上执行强力攻击。例如，假设Alice和Bob在同一家公司工作，该公司使用云备份服务来备份所有员工的机器。每年一次，所有员工将收到一份新的标准合同副本，其中包含其更新的薪水。爱丽丝好奇地找到了鲍勃的新工资，这可能是$ 500- $ 200,000之间的$ 500的倍数。所有Alice必须做的是生成一个Bob的合同模板，Bob的名字和新合同的日期，然后为Bob的每个可能的工资（总共301个文件）生成合同的副本。然后，她运行备份到她和Bob使用的公司备份服务。发生重复数据删除的单个文件是包含Bob实际工资的单个文件。只要目标文件的可能版本数量适中，就可以应用此攻击。这对于企业环境来说似乎非常有用，通常文件是标准模板的小变体。请考虑以下三个示例：•网上银行服务向客户发送一个包含其登录名和PIN的文档，这是一个4位数字。因此，爱丽丝可以使用登录名“Bob”和PIN的所有可能值生成10,000个文档，并检查其中哪些文件已被存储。本文档对应于Bob的实际PIN码。相同的攻击可以应用于任意密码，如果它们来自中等大小的域。请注意，与在线字典攻击不同，受到攻击的银行服务不会注意到某人正在尝试某个用户的所有潜在密码。 •假设一个详细描述Bob的医学检查结果的文件存储在他的计算机上。爱丽丝可以使用这种攻击来查找测试的结果，这通常来自一个小域（例如，对于遗传性疾病的发生或怀孕测试的结果是一个是/否的答案，或来自一个范围，例如胆固醇测试的一百个可能的值）。转诊医生的姓名和转诊日期可能是爱丽丝所知，或者可能来自一个小领域。即使是测试的序列号，如果存在这样一个数字，可能会被Alice猜出，如果她有一个类似日期的测试结果的例子。 •假设爱丽丝和鲍勃都参与拍卖，要求投标人以包含其名称和出价的标准表格提交投标（这实际上是许多拍卖和采购流程中的常见做法）。如果爱丽丝可以推测出鲍勃的10,000个最有可能的出价值，她可以使用相同的攻击来查找鲍勃的实际出价，然后相应地设置出价。<br>  攻击III：隐蔽通道假设爱丽丝设法在Bob的机器上安装了一些恶意软件。然而，Bob运行防火墙，防止未经授权的程序连接到外部世界。即使这样的防火墙没有运行，Alice 3可能希望隐藏恶意软件与其命令和控制服务器之间的通信）。如果Bob正在使用使用跨用户重复数据删除的在线存储服务，则Alice可以使用重复数据删除攻击来建立从恶意软件到由其运行的远程控制中心的隐蔽通道。 （隐藏通道的存在可能是二次攻击，也可能有其他方法建立隐蔽通道，但是通过利用跨用户的重复数据删除来检查隐藏通道是如何建立起来的。我们先来描述一个位如何传输：软件生成文件的两个版本之一X 0或X 1，并将其保存在Bob的机器上。如果要传送消息“0”，则保存文件X 0;否则保存文件X 1。这些文件必须是足够随机的，因此任何其他用户不可能生成相同的文件。在某些时间点（例如每天），Bob运行备份并将文件存储在在线存储服务中。 Alice然后执行与Bob相同的服务的备份，并且学习以前存储哪些文件X 0或X 1，也就是说，她将学习软件发送的消息。隐藏通道可用于通过使软件保存多于一个文件，并为每个文件的内容使用两个以上的选项来传输任意长的消息。此方法的详细性能分析超出了本文的范围。我们在这里描述了恶意软件如何向其命令和控制中心发送消息。如果恶意软件有可能检查备份的日志文件，并在进行重复数据删除时进行观察，则可以使用相同的技术来发送相反方向的消息。</p>
<p>  重复数据删除的安全风险源于以下事实：文件的重复数据删除会发生，如果并且只有此文件已经上传到存储服务。通过削弱重复数据删除与存储服务中文件的存在之间的相关性，可以降低风险。这是通过为每个文件分配一个随机阈值，并且只有当文件的副本超过此阈值时才执行重复数据删除。在更详细地检查此解决方案之前，要检查类似的方法，这是不安全的：这里，服务器设置全局阈值t（例如，t = 10），并且只有至少在文件中执行重复数据删除t文件的副本已上传。在这种情况下，确实，Alice上传文件的单个副本并不能显示Bob先前是否已经上传过该文件。然而，Alice可以上传许多文件副本（甚至使用多个用户身份），并检查是否在t或t-1之后重复数据删除，文件副本由她上传。后一种情况表示该文件的副本以前由其他用户上传。 （我们可以放心地假设爱丽丝知道阈值t，因为她可以进行简单的实验来揭示t的价值。）解决方案：现在让我们更详细地描述随机解。对于每个文件X，存储服务器分配在[2，d]范围内随机均匀选择的阈值t X，其中d是可能是公共的参数。 （例如，假设d = 20）重要的是，除了服务器之外，没有人可以计算t X，即使X的内容是已知的。实现此属性的一种方式是服务器随机选择t X并私有存储该值。另一种方法是使用秘密密钥的服务器，并且根据文件的内容或其散列值和密钥的计算阈值。即，计算t X = F（X，s）。在这种情况下，不需要显式存储X的阈值，因为服务器可以轻松地重新计算它。现在，对于每个文件X，服务器保留先前已经上传X副本的客户端数量的计数器X.当上传文件的新副本时，如果存在以下两个条件之一，则在客户端进行重复数据删除保持：（1）c X≥t X，或（2）由以前上传过X的客户端上传副本。否则不会发生重复数据删除。请注意，重复数据删除的最小份数为2，因为在上传文件的第一个副本时，不可能执行5次重复数据删除。该解决方案在X上传的第一个t X - 1次中隐藏了用户重复数据删除的发生，因为该文件被上传，就像在服务器上没有可用的副本一样。然而，一旦将数据传输到服务器端，就可以执行重复数据删除。因此，此解决方案提供的整体磁盘空间节省与基本重复数据删除方案完全相同。唯一的赔偿是带宽利用率较小，因为与tp重复数据删除解决方案相比，（t X -1）·X个文件的多个副本被上传。图1说明了提出的解决方案及其数据流。处理删除：文件删除也必须加以修饰。当删除发生时，减少文件副本的计数器c X似乎是很自然的。但是，此设置可以进行以下攻击：Alice上传文件X的副本，并注意到t副本上传后会发生重复数据删除。然后，她再次从在线存储中删除X的两个副本，并再次上传这两个副本。如果在其中一个测试中，她注意到在上传两个副本中只有一个之后发生重复数据删除，则必须是其他用户刚刚上传了X的副本。同样，如果重复数据删除在上传三个之后发生，而不是两个，X的副本，那么另一个用户必须删除这个文件的副本。这种攻击并不实用，因为在删除后，在线存储服务通常会保留已删除文件的副本一段时间。例如，包括Mozy，DropBox和Memopal在内的大多数服务的策略是删除文件至少要保留30天。因此，攻击的每次迭代都需要至少30天才能执行。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。攻击的一个简单的解决方案是以下修改的策略：在计数器c X达到阈值t X之后，始终执行去除，而不管是否发生了删除。此解决方案的缺点是，即使在文件的所有副本被删除之后，也必须执行重复数据删除。这意味着一旦拷贝数达到阈值，即使被删除，服务器也必须保留该文件的副本。这种政策在实践中的含义可能不是太贵，因为（1）删除的文件的副本已经被长时间保留了，以及（2）该政策适用于已经上传的相对流行的文件t X次，因此这些文件的所有副本将不太可能被删除。安全性：上述随机化解决方案仍然允许攻击者区分文件X已由d个用户上传的情况以及没有用户上传X的情况。然而，这种信息告诉该文件的受欢迎程度，但是不太可能告诉任何特定的用户，因此防止这些信息的发布可能不太重要。我们希望显示该解决方案不会显示关于将任何文件X包含在服务器存储的数据中的太多信息。为了分析安全性，我们在两个实例中比较攻击者的视图：一个文件X已经被另一个用户上传，另一个没有X的副本先前已被上传。区分这两种情况似乎是违反任何单一用户隐私的最相关的。如果我们确保很难区分这两种情况，那么每个用户都可以放心，上传其文件副本并不会对攻击者的视图产生实质的影响，因此无法被它检测到。实际上，这种措施在差异隐私（见[4]和参考文献）的概念中被使用，其将大量数据库的统计查询中的隐私问题考虑在内。为了分析隐私，我们考虑在攻击者想要识别文档的（单个）副本是否上传的设置中的三种类型的事件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要阅读了云证据收集的一些文章。下面谈谈对这些论文的理解。&lt;br&gt;首先是Acquiring forensic evidence from infrastructure-as-a-service cloud。文章分这么个层次来阐述：1.创建一个模型来显示云中所需的信任层次
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第七周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%83%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第七周周报/</id>
    <published>2017-06-29T11:54:30.000Z</published>
    <updated>2017-07-01T14:29:21.914Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。</p>
<p>云计算安全研究主要讲云计算的趋势、云安全挑战、云安全现状、云计算安全框架的建议、云安全的技术研究。这里面我觉得这几点是比较重要的，例如云安全的挑战和云计算安全关键技术研究。<br>首先在于云安全的挑战，在于以下三点：1.建立以数据安全和隐私保护为主要目标的云安全技术框架，具体体现在：云计算服务计算模式所引发的安全问题、云计算的动态虚拟化管理方式引发的安全问题、 云计算中多层服务模式引发的安全问题；2.建立以安全目标验证、安全服务等级测评为核心的云计算安全标准及其测评体系；3.建立可控的云计算安全监管体系，具体体现在：实现基于云计算的安全攻击的快速识别、预警与防护；实现云计算内容监控的难度；识别并防止基于云计算的密码类犯罪活动。<br>接着是云计算安全关键技术研究，主要有以下几点：1.可信访问控制；2.密文检索与处理；3.数据存在与可使用性证明；4.数据隐私保护；5.虚拟安全技术；6.云资源访问控制；7.可信云计算；</p>
<p>云计算:系统实例与研究现状主要讲了针对云计算这样一个范畴综述了当前云计算所采用的技术,剖析其背后的技术含义以及当前云计算参与企业所采用的云计算实现方案。现有的云计算实现使用的技术体现了以下 3 个方面的特征:1) 硬件基础设施架构在大规模的廉价服务器集群之上.2) 应用程序与底层服务协作开发,最大限度地利用资源.3) 通过多个廉价服务器之间的冗余,使用软件获得高可用性.这里面讲了一下几个项目：清华大学透明计算平台、Google的云计算平台、IBM“蓝云”计算平台、Amazon的弹性计算云。.从平台技术构建来看,云计算具有3 个基本特征,即系统建立在大规模的廉价服务器集群之上,通过基础设施与上层应用程序的协同构建以达到最大效率利用硬件资源的目的,以及通过软件的方法容忍多个节点的错误.通过云计算对这 3 个方面基本特征的体现,达到了分布式系统两个方面的目标,即系统的可扩展性和可靠性。</p>
<p>Dependability in the Cloud: Challenges and Opportunitie主要讲了几个比较流行的问题，监控大量应用程序的能力可以使“人群智慧”方法提供更强大的安全性，其方式与网络提供商能够进行蠕虫和DDoS攻击相同，其中一些例子如下：几个大型云基础架构提供商的环境不仅增加了影响大量应用程序的103次共模中断的风险，而且为攻击者提供了高度可见的目标。社区驱动的网站，如主要云提供商的跟踪中断，并记录了过去两年影响数百个互联网站点的一些中断和安全漏洞。从事广泛的行为，并采用不同程度的最佳做法可以暴露云应用提高风险水平。例如，2008年4月26日，亚马逊的弹性云（EC2）在几个实例中出现了中断，原因是单个客户应用了一大批异常的防火墙规则，同时实例化了大量实例引发亚马逊分布式防火墙中的性能下降错误。</p>
<p>The Challenge of Cloud Control主要讨论了资源优化云数据中心的一些主要挑战。我们提出了一个称为云控制的新研究领域，这是一系列云管理问题的控制理论方法，旨在将当今的静态和能耗云数据中心转变为自我管理，动态和可靠的基础设施。<br>第一个挑战是性能模型，这对设计和开发至关重要稳健的控制系统。值得注意的是，云数据中心的规模大大增加，工作量动态变化比以前的电信和互联网系统多。服务器系统上的以前的结果表明，可以使用黑匣子方法和相当简单的队列模型或使用流模型。第二个挑战是服务准入控制，这在本质上是长期容量规划，控制系统根据预期的利润决定是否接受服务。此外，弹性控制器应该为正在运行的应用程序分配足够的资源，以提供可接受的QoS，同时避免昂贵的过度配置。这些解决方案分为三大类：基于机器学习算法的解决方案，基于控制理论的解决方案和基于统计工作负载分析的解决方案。此外，还有一些VM安置问题需要解决，以确定哪些部署新的VM以及要关闭的VM 。鉴于云的动态性质，随着需求和供应的变化随着时间的推移发生重大变化，VM布局决策需要频繁更新。最近关于重新布置的工作包括通过限制可以同时迁移的VM数量来实现VM迁移和性能转向的性能建模。其他动态方法包括使用随机整数规划来处理不确定性和遗传算法，以减少负载波动时的重新迁移。另一个挑战是提供云服务的大型数据中心不仅具有购买设备的成本，而且能源成本大幅提高，这意味着能源优化将至关重要。</p>
<p>首先，服务准入控制器决定是否接受弹性服务，随着时间的推移可能会有很大的变化。云提供商必须确定要承认的最佳服务数量，以最大限度地发挥其效用（收入，利用率等），而不会危及已提供服务的服务水平协议（SLA）。服务增加了云基础设施的随机负载。因此，需要接纳管制计划，以评估新服务的长期影响，具体取决于他们估计的工作量。第二，弹性控制系统的目标是分配足够的所谓的计算单位（CU），以便符合某些控制目标，以系统的性能期望为目标。我们提出定义CU术语，以便满足能力需求的要求，这与维护虚拟机的定义无关。后续的CU将被映射到合适的VM。如果假定系统状态和工作负荷可以用一定的精度来估计，则控制器设计基本上成为随机的最优控制问题。第三，VM布局控制器都执行从CU到适当的VM集的映射，以在本地或远程数据中心运行，并确定物理机器上的虚拟机的打包。在将VM分配到数据中心内的PM之前，我们考虑从CU到VM和从VM到数据中心的映射。可以制定的这些容量分配（分配）问题，例如作为限制线性问题，用于优化成本受制于容量和可能的其他约束，从而实现特定的负载平衡亲和力和抗亲和力的客观或要求（例如，在同一数据中心（或主机）中，而不是在相同的数据中心）。第四，数据中心能源优化器模型，优化机房定位决策的机房能量温度相互作用。能量优化将需要一个网络身体的看法。最后，整体管理系统监控整个系统的行为，并优化管理工具在整体数据中心管理目标方面的协同运作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要看了一些云安全综述的文章，云计算安全研究、云计算_系统实例与研究现状、Dependability in the Cloud: Challenges and Opportunitie、The Challenge of Cloud Control。&lt;/p&gt;
&lt;p&gt;云计算
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第六周周报</title>
    <link href="http://yoursite.com/2017/06/29/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%85%AD%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/29/云取证第六周周报/</id>
    <published>2017-06-29T04:44:53.000Z</published>
    <updated>2017-06-29T09:03:59.109Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。</p>
<p>首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件系统的源文件来收集系统级别的来源。虽然这种方法是有效的，但是它具有两个显着的缺点：内核的每个新版本都需要重新整合PASS变化，其稳定性必须不断测试; 同样，使用可堆叠的文件系统使得很难在根卷上收集来源，特别是在早期引导过程中。所通过以Xen虚拟机管理程序运行的虚拟客户机收集系统级别来源的方法可以有效解决这两个缺点。</p>
<p>PASS拦截execve，fork，exit，read，readv，write，writev，mmap，open，pipe以及内核操作drop inode。这些调用足以捕获Linux文件，管道和进程之间丰富的祖先关系。这种原始的“原始来源”转向观察者，将原始来源转化为证明记录。例如，当进程P读取文件A时，观察器生成包含P取决于A的事实的记录。接着是修改Xen虚拟机管理程序的方法（Xen 是一个开放源代码虚拟机监视器）。</p>
<p>首先是前提假设。假设目标虚拟机（我们将收集来源的目标虚拟机）正在运行一个PV密钥，但是也可以针对未修改的内核（如Windows）。 Linux，Minix，GNU Hurd，OpenSolaris，NetBSD和FreeBSD都支持PV内核。本文的其余部分假定我们正在运行Linux访客内核;假设Dom0和DomU密钥以及Xen管理程序本身是不妥协的，以便我们可以信任和验证任何生成的证明。我们的方法通过在Xen的系统调用进入机制中放置适当的钩子来拦截DomU系统调用。 该挂钩为拦截器提供系统调用号及其数值参数。 拦截器又通过查找表中的系统调用来确定哪些参数是数字，哪些是用户空间中的数据结构和字符串的指针。然后继续创建一个系统调用记录。用户空间守护程序在特权域中运行，定期地：1.消耗来自环形缓冲区的记录，2.使用来源分析器处理它们，3.输出源日志，4.并将日志提供给Waldo。我们可以在多处理器/多核系统中的专用CPU /内核上运行此过程，以提高访客性能。用户空间守护程序以及其他支持软件通过专用的超级呼叫与Xen的来源子系统进行通信，只能在特权域中访问。拦截器与源极分析仪的耦合使我们能够将CPU密集型分析转移到另一个CPU或核心上，从而使客户的单线程性能受到最小的影响。更重要的是，我们将不会担心可堆叠文件系统引用的API的更改;这些变化往往会经常发生，相当可观。我们的方法的一个障碍是拦截器需要一个大的环形缓冲区来保存分析器尚未消耗的所有系统调用的记录。<strong>典型的Linux客户机每秒产生数十个读/写系统调用，涉及标准输入和输出流。我们无法轻易地将其过滤掉在拦截器上，因为这些流可能已被重新排列到文件或管道。除了消耗大量内存之外，缓冲区操作通常会增加处理器高速缓存的压力。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要的工作有，对云取证数据定位及数据起源文章进行了一些阅读。&lt;/p&gt;
&lt;p&gt;首先谈谈对Collecting Provenance via the Xen Hypervisor。本文主要讲述对paas的改进。首先paas是通过在Linux内核中拦截系统调用，并从存储在文件
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第五周周报</title>
    <link href="http://yoursite.com/2017/06/25/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%BA%94%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/25/云取证第五周周报/</id>
    <published>2017-06-25T12:50:47.000Z</published>
    <updated>2017-06-26T13:21:05.375Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。</p>
<p>首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询SELECT taskname,datacenter FROM systemlog.today WHERE severity=’warning’，扫描的数据量有100GB级别的数据量，但是查询时间仅仅需要10秒左右。BigQuery旨在分析数十亿行近似的数据，使用类SQL语法。它并不是完全符合SQL数据库的替代，并不适用于交易处理应用。BigQuery支持分析交互风格。使用SELECT命令构建查询，对于任何SQL开发者都应该很熟悉。<strong>因为我以前在做数据交换平台的时候，对于非基于lucene的全文检索的传统数据库，例如mysql查询时候，对于上百万或者上千万条甚至在上亿条数据量的查询，即使是针对索引列的查询也会很慢，更不用说数据量达到pb级别的数据量</strong>。查了下资料，总体而言，BigQuery 在大规模数据（数十亿行）上查询有很好得速度、适合快速分析大规模数据，不支持数据修改；BigQuery是OLAP系统，通过CSV格式将数据导入BigQuery，数据以弱关系型存储与云上。BigQuery 不是一个数据库系统， 1. 不支持表索引和其他关系数据库特性 2. BigQuery支持SQL得一个子集，不支持update,delete操作 3.BigQuery得join只在一张表远比另一张表小时有效（也就是不支持两张大表得join）。BigQuery 支持REST接口。</p>
<p>其次是对于Regeneration of events using system snapshots for cloud forensic analysis。 这篇论文主要讲述了在这个一种新的云攻击分析方法通过事件再生。 VNsnaps用于定期进行虚拟网络环境（VNE）的快照通过使用模糊聚类检测的云攻击技术。 然后恢复这些快照以重新生成攻击事件。首先是对于公司来说，云安全依然是在云计算里面最关心的问题。 AAA协议大致将这些尝试分为三个阶段：认证，授权和会计。云取证专注于会计，并用于分析和调查云攻击的本质，试图恢复从他们的伤害。几个输入，如日志文件和孤立的系统快照用于提取信息关于袭击。然而，这些方法只能导致一个模糊的事件视图。另外，由于网络定时协议不适用于云计算，我们是不可避免的客户和CSP的时间戳差异这使得更难于将各种实例相关联两端因此，传统技术无法明确图片的整个操作顺序的数据和涉及的过程我们的工作，通过一系列定期的快照，旨在提供具体和顺序证明所有事件对安全构成威胁数据的隐私和委托云的计算。</p>
<p>通过使用一种检测攻击的技术来解决问题正确标注其开始和结束。我们实现这个使用模糊聚类算法的“距离”概念。 VNsnap：我们使用VNsnap，一个中建立的系统来采取系统来自虚拟机外部的整个VNE的快照（VM），从而提供所有信息关于有关组件。为全球一致快照，VNsnap使用Mattern的分布式快照算法基于消息着色。另外，VM快照操作与VM的正常操作同时进行操作因此隐藏来自用户的快照延迟应用程序和减少系统停机时间（少于一个）即使在最坏的情况下）。另一个优点VNsnap是不需要任何修改在虚拟机内运行的软件，从而与之配合使用未修改的应用程序和操作系统内置快照支持。B.正确记录攻击：在我们的工作中，我们假设有足够的文档可用关于以前采取的云攻击放在各种类似的环境中。一般来说，这些记录的攻击是使用硬聚类分类的。</p>
<p>技术如分区聚类、层次聚类，这意味着每次新的攻击都被放在现有的攻击中<br>“分区”或“细分”取决于一些固定的或预定特性。，学习后云攻击的复杂性，我们发现需要考虑新攻击与全部攻击之间的相似程度现有的集合而不是完整的任务之一固定集或攻击群集。因此，我们愿意依靠将决定程度的算法每个现有集合的新实体的归属而不是将它分配给只有一个的那些预定套。由于模糊聚类是一个软聚类将一组成员级别与之联系起来的技术每个新实体，通过这样做，我们实际上考虑到整体影响所有类似的攻击，从而确保更好的准确性结果。</p>
<p>快照可以给出：<br>A. 将攻击定义为群集 关于以前的攻击的可用文档应该是 首先被组织成小型的原始操作 每个组合都可以作为个人攻击。我们对待每一个这些攻击是单点（或单对象）集群。每个点或攻击随后以n维向量来表示，每个维度代表可量化的特征，如内存使用，处理能力要求，带宽使用，复杂度等。 因此，每个攻击Xp可以被假设为具有n维度的空间向（xp1，xp2，…，xpn）。<br>B.为尺寸分配权重： 同样重要的是我们考虑到这一点 在空间中定义的每个维度的相关性。因此， 我们将一个权重wi分配给第i个维度来量化它 确定相似性（或不相似性）的重要性 两个代码之间。这个权重应该通过实验确定。例如，如果我们找到相似性的顺序 复杂度是内存相似度的两倍,那么分配到复杂度的权重将是两倍分配给内存使用的权重。<br>C.当前代码模块距离：在每个VM中，首先确定执行中的代码模块。 这些模块中的每一个基于其自身的特性再次被分配在相同的n维空间中。 但是，请注意，在这种情况下，这些代码模块是时间的函数，它们的坐标也是这样。 例如，第q个VM中的代码模块Y q（t）将具有坐标：（y q1（t），y q2（t），…，y qn（t））。 然后我们从每个集群（攻击）中计算代码模块的距离。 攻击X p和代码模块Y q（t）之间的距离为：D pq i（t）=√（Σ（wi（x pi - y qi（t）））2）… i 1到n。注意，该距离表示第t个攻击与第t个虚拟机的代码模块在时间t的不相似性。 通过为维度分配权重，我们确保了关于测量的相似程度或不相似性的推论是正确的。<br>D.阈值：我们需要确定攻击和代码模块之间的距离的阈值，在该模块之下系统可能受到损害。为此，我们从实验中找出应该保持的最小距离<br>为了使系统安全起见。这个实验涉及：<br>1.常见攻击的模拟（文档中提供）<br>2.观察其所有特征（以其坐标的形式）的量化值，如内存使用量，带宽使用量，处理能力要求等<br>3.对VM上的无数代码模块进行仿真，并将其坐标与步骤2中获得的坐标进行比较<br>4.查找代码模块和每个维度中的攻击之间的最小差异。说，无害代码模块与维度“i”的攻击之间的最小差异是mi，那么我们为所有n个维度获得以下值：m1，m2，… mn。<br>5.计算阈值：<br>阈值=√Σ（wi*mi）2 … i从1到n不等。<br>以下是通过上述步骤获得的阈值的预期特性：<br>1.阈值足够高，以确保与攻击的意外相似性一般不予以考虑。<br>2.该值足够低以确保跟踪恶意代码模块的最大概率。<br>当前代码模块与已记录攻击的比较提出的技术的有效性在很大程度上取决于阈值的正确确定。 在获得一致的阈值时，我们的方法可以证明是足够可靠的，以便最终决定代码模块的有害性。<br>接着是再生事件的产生，我们使用连续运行的计算器来测量所有VM中的代码模块与攻击集合之间的时间依赖距离（如方程式）当使用VNsnap的任何时间点的距离开始使用VNsnap在时间循环中以编程方式定期执行快照一些攻击的代码模块降低到阈值以下，当所有距离都超过阈值时停止进程，因此记录了整个攻击。<br>可以通过将系统恢复到每个快照（以编程方式再次）按照与其创建顺序相同的顺序来重新生成攻击。但是，在该再生过程之前应该采取系统的孤立快照，以便一旦重播攻击就可以将系统恢复到原来的位置.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要的工作有，对云取证分析的文章进行阅读。下面谈谈对这些论文的看法。&lt;/p&gt;
&lt;p&gt;首先是System Log Analysis Using Google BigQuery。里面有提到通过谷歌的BigQuery在pb级别的数据，小于一分钟的响应速度。具体举了这么一个查询
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第四周周报</title>
    <link href="http://yoursite.com/2017/06/11/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/11/云取证第四周周报/</id>
    <published>2017-06-11T12:10:43.000Z</published>
    <updated>2017-06-11T12:47:26.878Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，将云取证收集文章看了一些，印象深刻的是Cloud application logging for forensics，即用于取证的云应用程序日志记录。这篇文章重点从日志的重要性、云的日志分析和取证相关的挑战、日志重点的记录方向以及日志的一些标准等这些方面论述。</p>
<p>首先是关于日志在云取证的重要性。日志是基于云的服务基础设施中最重要的分析数据之一。在任何时候，服务所有者和运营商都需要了解每个基础架构组件的状态，以进行故障监控，评估功能使用情况和监控业务流程。软件开发生命周期，用例按以下顺序：调试和取证、故障监控、故障排除、功能使用、绩效监测、安全/事件检测。监管和标准合规性这些用例都可以利用日志分析来完全解决或至少帮助大大加快和简化用例的解决方案。</p>
<p>基于云的日志分析和取证相关的挑战有：<strong>原木分散化、日志波动、多层和层、存档和保留、日志的可访问性、不存在日志、在日志中缺少关键信息等</strong>。不兼容/随机日志格式基于云的应用程序将日志存储在多个服务器和多个日志文件中。这些资源的易变性使日志文件只能在一段时间内可用。云应用程序堆栈中的每个层都生成日志，网络，操作系统，应用程序，数据库，网络服务等。一旦日志收集，他们需要在规定的时间内保持一段特定的时间，支持调查。我们需要向多个选区提供日志;应用程序开发人员，系统管理员，安全分析人员等。他们都需要访问，但只能访问一个子集而不是所有日志。平台即服务（PaaS）提供商通常不会将日志提供给他们的平台用户。尝试分析应用程序问题时，这可能是一个重大问题。例如，Amazon 不会使负载平衡器日志对他们的用户可用。最后，关键组件不能或不能正确地检测到生成必要的日志来回答具体问题。即使有日志可用，它们也有各种不同的格式，通常难以处理和分析。前五个挑战可以通过日志管理来解决。剩下的三个是更内在的问题，必须通过定义记录指南和标准来解决.</p>
<p>日志框架的功能列表：<strong>集中所有日志、可扩展日志存储、快速数据访问和检索、支持任何日志格式、运行数据分析作业（例如，map reduce）、保留日志记录、归档旧日志并按要求恢复、通过访问控制隔离数据访问、保存日志完整性</strong>。然而，它们并没有解决失踪和非标准化日志记录的挑战。 1例如，如果机器处于非常高的负载下，则可以启动新机器，如果不预先警告，则不再需要机器。 2请注意，在某些情况下，无法更改关于日志记录行为的任何内容，因为我们无法控制第三方应用程序的代码。 2.2日志记录如果没有为日志记录定义常见的准则或标准，会发生什么在很多情况下，应用程序开发者不会记录太多。有时候，日志记录是不完整的，如下例所示：3月16日08:09:58内核：[0.000000]普通1048576 - &gt; 1048576此日志中没有太多信息来确定实际发生了什么是正常。因此我们需要对一些操作进行日志处理以及标准化日志。</p>
<p>首先是重点记录方向：业务相关日志记录、基于操作的日志记录以及安全（取证）相关日志。云应用应该集中在以下用例：<strong>登录/注销（本地和远程）、密码更改/授权更改、资源访问失败（拒绝授权）</strong>。特权帐户执行的所有活动特权帐户，管理员或根用户都是对系统或应用程序的控制权。他们有权改变应用程序中的大部分参数。因此，对于安全目的来说，密切关注这些帐户正在做什么至关重要。</p>
<p>最后是日志的标准化.至少在日志记录中必须存在以下字段：<strong>时间戳记，应用程序，用户，会话ID，严重性，原因，分类</strong>。这些领域有助于回答问题：何时，什么，谁以及为什么。此外，它们负责提供我们的用例所规定的所有信息。需要一个时间戳来识别日志记录器记录的事件何时发生。时间戳记以标准格式记录[18]。应用程序字段标识日志条目的生成器。需要用户字段来确定哪个用户已经触发了一个活动。使用唯一的用户名或ID来区分用户彼此。 sessionID有助于跟踪跨不同应用程序和层次的单个请求。挑战是在整个组件中共享相同的ID。记录严重性以根据其重要性过滤日志。需要建立严重性系统。例如：debug，info，warn，error和crit。 sameschema应该在所有应用程序和层次中使用。通常情况下，需要找出原因来确定为什么会出现某些事情。例如，由于密码不足或密码错误，访问被拒绝。原因确定为什么。作为最后一组必填字段，类别或分类字段应该被记录。分类是通常用于在日志记录中增加信息以允许以常见方式处理类似事件的方法。这在例如报告中非常有用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，将云取证收集文章看了一些，印象深刻的是Cloud application logging for forensics，即用于取证的云应用程序日志记录。这篇文章重点从日志的重要性、云的日志分析和取证相关的挑战、日志重点的记录方向以及日志的一些标准等这些方
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第三周周报</title>
    <link href="http://yoursite.com/2017/06/04/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%89%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/06/04/云取证第三周周报/</id>
    <published>2017-06-04T12:44:36.000Z</published>
    <updated>2017-06-13T08:07:42.693Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，对云取证综述文章以及一些分析文章看了一些。接下来谈谈阅读Impact of Cloud Computing on Traditional Digital Forensic Investigations 的理解。</p>
<p>文章首先提出云取证的困难在于因为多个客户的日志记录和数据可能位于同一位置，也可能分布在不断变化的主机和数据中心集合中。如果有没有合同承诺支持具体形式的调查，那么调查和发现请求可能是不可能的。数字证据本身就非常脆弱。不正确的处理或检查可能会更改，损坏或毁坏。为此，必须采取预防措施来记录，收集，保存和检查此类证据。<strong>而在这点上我的一个想法是，能不能比如根据取得的证据例如云环境日志来复现操作顺序来达到重现犯罪现场进行案情重组的过程。比如说在初始环境1，经过若干步操作，变成环境2，环境2通过逆向操作，恢复成还原环境1，在还原过程中，其实也是对云攻击过程的一个模拟复原。当然这一切的假设都是建立在该云服务的的操作是可逆的。而在还原过程中，有利于对云攻击进行分析。</strong></p>
<p>紧接着，描述一系列有关取证的一些分析手段。例如传统的取证方法允许调查人员从实验室环境的相对安全性中抓取设备并进行调查。这在数字取证领域被称为“死亡分析”。还有一些比较高端的是，调查人员可能使用的最常见的工具包括：Guidance Software [11]的EnCase，Access Data [12]的取证工具包和Helix3 [13]，这是一个开源工具包。还有很多其他的，尽管三个突出显示的是最常用的和行业接受的工具[8]。这些工具非常强大，可以查找证据价值的文物，即使嫌疑人已经删除了被认为是妥协的数据。电子发现和现场取证是数字取证学的两个不断发展的领域，调查人员可以增加他们的武器组合来打击电子犯罪。<strong>这里，我在想是不是可以通过对这几个工具进行了解一下他们的分析方法。</strong></p>
<p>接着，描述了一系列攻击，如黑客攻击，分布式拒绝服务（DDOS）攻击，网络钓鱼，制药，恶意软件，病毒，特洛伊木马，间谍软件和蠕虫的分发。分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。基于现在攻击手段如此多和复杂，云计算问题服务级别协议（SLA）必须是强大的。<strong>然而在网上搜了下，现有应对DDOS已经有比较成熟的技术和方案。</strong></p>
<p>同时看了些关于云取证的一些分析方法，印象比较深刻的是。<strong>有一个使用Hadoop进行日志分析，使用K均值算法针对大数据量进行聚类，找出离群值，IP地址统计方法。汇总日志（存储到HDFS）,先是预处理（转成固定格式），使用MR进行处理分析（分析方法通过K-Means类似的数据挖掘手段），形成可视化结果。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，对云取证综述文章以及一些分析文章看了一些。接下来谈谈阅读Impact of Cloud Computing on Traditional Digital Forensic Investigations 的理解。&lt;/p&gt;
&lt;p&gt;文章首先提出云取证的困难在
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第二周周报</title>
    <link href="http://yoursite.com/2017/05/01/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/05/01/云取证第二周周报/</id>
    <published>2017-05-01T10:56:11.000Z</published>
    <updated>2017-06-11T12:48:32.497Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，看了几篇论文，主要还是了解现在云取证的一些情况和了解了一下docker这个新兴的技术在云计算中的应用和使用问题，印象比较深的有几篇云取证综述的论文。Cloud forensics State-of-the-art and future directions、cloud computing and digital forensics这两篇。</p>
<p>首先是Cloud forensics State-of-the-art and future directions。本论文主要讲的是在现有阶段下云取证的研究进展所面临的的挑战以及移动云取证的一些研究。首先文章开篇讲了在，美国国家标准与技术研究在“NIST云计算取证科学挑战”草案中，这致力于报告这一新兴调查领域的最新进展和最新进展。而在这里，接受率仅为15.4%。这侧面反应了这个评审的难度，也说明现在的挑战还是很大。其次是在新工具的使用上，文章只是提到了促进多节点Hadoop集群中的取证调查，但并没有进行展开讨论。以此为例引出了如果没有开发根本的新工具和能力，取证专家将面临越来越多的困难和成本。因此，今天的数字侦探不仅与罪犯进行军备竞赛，而且还与未来计算机系统的开发者进行了斗争。文章最后提到移动（云）取证是一个未被研究的主题，特别是从提供高级安全性的设备中获取数据，不仅可以用于静态数据（现在已经在所有智能移动设备中变得司空见惯），而且还通过高级加密的数据。NIST IR 8006将挑战分为九组，涉及架构，数据收集，分析，反取证，事件首次响应者，角色管理，法律话题，标准和培训等问题。我的体会是，首先这篇论文也算是我的看的入门第一篇论文，首先在现在云取证面临的挑战是非常大的，不仅在于理论研究还在于新技术的取证工具。文章最后提到的移动云取证现在还是一个比较新的主题，可以算是一个小小备选方案（但我上周和学长们简单交流了下，他们说现在移动云取证几乎该挖的坑都挖完了，所以在这边还是有分歧，有可能跟时间有问题或者跟看的问题角度有关）。</p>
<p>其次是cloud computing and digital forensics（云取证和数字取证）。这篇论文令我印象深的有这么几点：1.日志这一取证的手段。在网络入侵的情况下，受害者组织普遍存在于准备阶段，为了保护数字犯罪现场，关闭整个网络极少可行。因此，有用的证据可能不再可用，可能难以收集，也许完全不可接触，或者可能没有以法定的方式保存。例如，各种类型的日志在网络入侵调查中可能是非常有价值的，但是许多组织不会收集这些日志或不保留日志超过几天，或者不以确保其完整性的方式存储日志。这给我的体会是可以结合一个场景，将日志这个功能进行完善分析。2. 取证方法的分析，涉及哦取证技术；网络取证工具，内存取证方法和数据库取证方法。里面提到了计算机和智能手机云存储服务留下的痕迹的取证分析，是智能手机中碎片闪存页面的取证分析技术。Fasan和Olivier提出了一种重建存储在数据库中的数字证据的可靠方法（参见“数据库重建算法的正确性证明”）。这是一个重要的话题，因为更多的证据存储在数据库中，包括在云环境中，使得可以将很多证据得以保存，便于以后排查原因入侵者等因素。</p>
<p>关于Docker的研究。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。docker的出现极大了加快了PAAS的发展，企业私有PAAS构建蓬勃发展起来。可以看到PAAS核心是解决软件代码完成后部署运行运维到监控的所有事情。基于Docker的PaaS平台现在逐渐成为主流。关于docker的安全问题有：</p>
<h5 id="1-权限及资源限制。"><a href="#1-权限及资源限制。" class="headerlink" title="1.    权限及资源限制。"></a>1.    权限及资源限制。</h5><p>限制用户运行特权及访问资源。对于多租户应用，不同的容器共享同一主机的资源和环境，普通用户权限的恶意提升将会使宿主主机完全处于被非法操控的险境，而对于用户的合法操作，大量的资源申请也会将主机推向崩溃的编译。因此，有必要对用户权限进行限定，避免根权限的赋予，进而减少主机暴露的攻击面和潜力。同时，在CPU、内存及进程数等资源方面，限定用户在单一容器中的可用配额，来防止恶意的无限资源申请给整体系统带来的破坏。<br>镜像及制作管理</p>
<h5 id="2-对容器的镜像来源进行审核。"><a href="#2-对容器的镜像来源进行审核。" class="headerlink" title="2.对容器的镜像来源进行审核。"></a>2.对容器的镜像来源进行审核。</h5><p>容器镜像制作的简化让用户可以轻而易举的创建自定义的应用镜像，但制作的应用程序千差万别，功能完整性和测试完整性参差不齐。这让用户镜像的产生面临存在众多漏洞的风险，因此需要对镜像的制作过程尽量规范化，对放置的应用程序尽量做到测试完备并符合安全标准，从源头上减少漏洞镜像的生成。而在创建容器过程中，避免使用不受信任的镜像及应用程序，采用标准及合格厂商如时速云的镜像服务mirror，从而保证容器运行时的正规及安全。</p>
<h5 id="3-日志安全审计及升级补丁"><a href="#3-日志安全审计及升级补丁" class="headerlink" title="3.日志安全审计及升级补丁"></a>3.日志安全审计及升级补丁</h5><p>对容器及系统中宿主机进行定期安全检查及漏洞补丁升级。定期针对容器及所在宿主机的网络环境进行渗透安全测试，及时发现可疑容器或危险服务端口。对主机内核及原始镜像进行定时更新，及时修补公开漏洞。在应用层次，收集及检测容器的安全日志，统计监督应用的运行过程，及时发现服务异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，看了几篇论文，主要还是了解现在云取证的一些情况和了解了一下docker这个新兴的技术在云计算中的应用和使用问题，印象比较深的有几篇云取证综述的论文。Cloud forensics State-of-the-art and future directio
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>云取证第一周周报</title>
    <link href="http://yoursite.com/2017/04/25/%E4%BA%91%E5%8F%96%E8%AF%81%E7%AC%AC%E4%B8%80%E5%91%A8%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2017/04/25/云取证第一周周报/</id>
    <published>2017-04-25T02:33:03.000Z</published>
    <updated>2017-05-31T11:59:00.747Z</updated>
    
    <content type="html"><![CDATA[<p>本周我主要做的工作有，上网查询有关于云计算方面的知识点、云安全的相关知识点以及云取证的一些概念。</p>
<p>首先是对于云计算的一些见解，定义就是，云计算是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。特点是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将与互联网更相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。从我个人角度出发，我认为云这个概念其实就是任何可以通过互联网访问的服务。而这个服务往往通过分布式计算机来协助完成。</p>
<p>然后是云计算的分类，具体是分为IaaS、PaaS、SaaS。IaaS(Infrastructure as a Service，基础架构即服务)通过互联网提供了数据中心、基础架构硬件和软件资源。IaaS可以提供服务器、操作系统、磁盘存储、数据库和/或信息资源。IaaS通常会按照”弹性云”的模式引入其他的使用和计价模式，也就是在任何一个特定的时间，都只使用你需要的服务，并且只为之付费。PaaS(Platform as a Service，平台即服务)提供了基础架构，软件开发者可以在这个基础架构之上建设新的应用，或者扩展已有的应用，同时却不必购买开发、质量控制或生产服务器。这些平台允许公司创建个性化的应用，也允许独立软件厂商或者其他的第三方机构针对垂直细分行业创造新的解决方案。SaaS(Software as a Service，软件即服务)是最为成熟、最出名，也是得到最广泛应用的一种云计算。大家可以将它理解为一种软件分布模式，在这种模式下，应用软件安装在厂商或者服务供应商那里，用户可以通过某个网络来使用这些软件，通常使用的网络是互联网。这种模式通常也被称为”随需应变”软件，这是最成熟的云计算模式，因为这种模式具有高度的灵活性、已经证明可靠的支持服务、强大的可扩展性，因此能够降低客户的维护成本和投入，而且由于这种模式的多宗旨式的基础架构，运营成本也得以降低。</p>
<p>“云安全（Cloud Security）”计划是网络时代信息安全的最新体现，它融合了并行处理、网格计算、未知病毒行为判断等新兴技术和概念，通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。常见的云安全问题有：用户身份安全问题、共享业务安全问题、用户数据安全问题。</p>
<p>术语“云取证”是指从云基础设施采集数字取证数据。例如，本地取证证据包括从日志文件、存储在磁盘上的数据、网络流量和入侵标志物等收集到的信息。本地分析与云服务分析之间的基本区别是，使用本地计算机，通过简单地进入系统，从而可以收集并分析信息。然而，当涉及到云时，机器无法进行物理访问，只有计算机的某些部分，可以通过云应用程序接口进行访问。</p>
<p>我的个人见解是，对于云取证来说，可以从两个方面进行考虑。第一个是怎么取证，也就是取证的手段，换句话说就是在取证的技术或者方式上有所改善或者突破；第二个就是对于获取到的证据如何去分析，也就是在分析证据的手段上有所改善或者突破，我觉得这块可以跟比如数据挖掘或者人工智能联系起来，例如有个论文提到的，用数据挖掘来形成聚类，找出ip的之间的关系，具体是通过kmeans的算法针对原始数据进行聚类，将所有数据划分成不同的数据集；接着在各个聚类后的数据集内部，使用 IP 地址统计方法来捕捉各个数据集特征，从而找出离群值，即可能的入侵者。又比如可以对文件简历索引，通过搜索引擎大大提高海量数据查询的效率，具体做法是集中为每个文件创建唯一标志签名， 该签名会一直跟随文件直到文件被删除， 然后借助分布式任务检测海量数据中符合签名的匹配文件 ， 从而大大提高了文件搜索的效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周我主要做的工作有，上网查询有关于云计算方面的知识点、云安全的相关知识点以及云取证的一些概念。&lt;/p&gt;
&lt;p&gt;首先是对于云计算的一些见解，定义就是，云计算是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。特点是通过使计算
    
    </summary>
    
    
      <category term="云取证" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫问题</title>
    <link href="http://yoursite.com/2017/04/05/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/04/05/约瑟夫问题/</id>
    <published>2017-04-05T04:46:56.000Z</published>
    <updated>2017-05-31T11:51:31.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。"><a href="#问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。" class="headerlink" title="问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。"></a>问题：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。</h3><h4 id="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"><a href="#解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新" class="headerlink" title="解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新"></a>解法一，通过一个list存储现有节点，然后记录一个删除位置变量存上一次删除的位置，经过移动变量往后m-1次即可到删除节点，然后通过list删除该节点，将删除位置变量更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining(int n, int m) &#123;</div><div class="line">    <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">        <span class="built_in">return</span> -1;</div><div class="line">    &#125;</div><div class="line">    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        list.add(i);</div><div class="line">    &#125;</div><div class="line">    // 要删除元素的位置</div><div class="line">    int idx = 0;</div><div class="line">    // 开始计数的位置</div><div class="line">    int start = 0;</div><div class="line">    <span class="keyword">while</span> (list.size() &gt; 1) &#123;</div><div class="line">        // 只要移动m-1次就可以移动到下一个要删除的元素上</div><div class="line">        <span class="keyword">for</span> (int i = 1; i &lt; m; i++) &#123;</div><div class="line">            idx = (idx + 1) % list.size(); // 【A】</div><div class="line">        &#125;</div><div class="line">        list.remove(idx);</div><div class="line">        // 确保idx指向每一轮的第一个位置</div><div class="line">        // 下面的可以不用，【A】已经可以保证其正确性了，可以分析n=6，m=6的第一次删除情况</div><div class="line">    //  <span class="keyword">if</span> (idx == list.size()) &#123;</div><div class="line">    //      idx = 0;</div><div class="line">    //  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> list.get(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"><a href="#解法二：通过数学的思路-我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f-那么我们假设他的逆向映射关系为f-。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。" class="headerlink" title="解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。"></a>解法二：通过数学的思路, 我们假设我们每次删除完一个数字后，剩下的数字都要进行重新编号，他们的映射关系为f,那么我们假设他的逆向映射关系为f`。首先我们知道最后一定只剩下一个数字重新编号0，所以根据倒推规律，我们只需要做n-1次逆向映射即可推出原来该位置的映射关系。接下来是我们找寻逆向映射规律。</h4><p>首先我们定义一个关于 n 和 m 的方程时，表示每次在 n 个数字 0，1， … ，n-1中每次删除第 m 个数字最后剩下的数字。</p>
<p>在这 n个数字中， 第一个被删除的数字是(m-1)%n。为了简单起见，我们把(m- 1)%n 记为 k，那么删除k之后剩下的 n-1 个数字为 0，1，… ，k-1，k+1，… ，n-1，并且下一次删除从数字 k+1 开始计数。相当于在剩下的序列中， k+1 排在最前面，从而形成 k+1，… ，n- 1，0，I，… ，k-1 。该序列最后剩下的数字也应该是关于 n 和 m 的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从 0 开始的连续序列），因此该函数不同于前面的函数，记为 f’(n-1,m)。最初序列最后剩下的数字 f(n, m）一定是删除一个数字之后的序列最后剩下的数字，即 f(n, m)=f’(n-1, m）。</p>
<p>接下来我们把剩下的这 n-1 个数字的序列 k-1， …，n-1，0，1，… ，k-1 做一个映射，映射的结果是形成一个从 0 到 n-2 的序列：<br><img src="http://wiki.jikexueyuan.com/project/for-offer/images/63.png" alt=""> 　　<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static int lastRemaining2(int n, int m) &#123;</div><div class="line">     <span class="keyword">if</span> (n &lt; 1 || m &lt; 1) &#123;</div><div class="line">         <span class="built_in">return</span> -1;</div><div class="line">     &#125;</div><div class="line">     int last = 0;</div><div class="line">     <span class="keyword">for</span> (int i = 2; i &lt;=n ; i++) &#123;</div><div class="line">         last = (last + m)%i;</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">return</span> last;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求出这个圈圈里剩下的最后一个数字。&quot;&gt;&lt;a href=&quot;#问题：0-1-…-n-1-这-n-个数字排成一个圈圈，从数字-0-开始每次从圆圏里删除第-m-个数字。求
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/25/hello-world/"/>
    <id>http://yoursite.com/2017/03/25/hello-world/</id>
    <published>2017-03-25T02:30:03.000Z</published>
    <updated>2017-05-31T11:52:20.379Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
