<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java并发," />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="java中的线程池线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:  降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。  线">
<meta name="keywords" content="java并发">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池和Executor">
<meta property="og:url" content="http://yoursite.com/2018/01/10/线程池和Executor/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="java中的线程池线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:  降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。  线">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/线程池流程.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/线程池执行.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/执行任务.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/二级调度.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/class.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/#x.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/execute.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/single.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/cached_execute.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/scheduled任务传递.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/schedule.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/schedule任务执行.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/scheduled_condition.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/schedule-delay.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/FutureTask状态.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/cancel.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/future.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/FutureTask设计.png">
<meta property="og:image" content="http://yoursite.com/2018/01/10/线程池和Executor/级联唤醒.png">
<meta property="og:updated_time" content="2018-01-14T09:12:54.013Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程池和Executor">
<meta name="twitter:description" content="java中的线程池线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:  降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。  线">
<meta name="twitter:image" content="http://yoursite.com/2018/01/10/线程池和Executor/线程池流程.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/10/线程池和Executor/"/>





  <title>线程池和Executor | 博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/线程池和Executor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程池和Executor</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T09:53:55+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h1><p>线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。线程池的好处如下:</p>
<ul>
<li>降低资源损耗；通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度；当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性；线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>1）线程池判断核心线程池是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已满。如果工作队列没有满，则新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<br><img src="/2018/01/10/线程池和Executor/线程池流程.png" alt=""></p>
<p><img src="/2018/01/10/线程池和Executor/线程池执行.png" alt=""><br>ThreadPoolExecutor执行execute分下面四种情况：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则新建新的线程来执行任务，执行这一步需要全局锁。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务。执行这一步骤需要获取全局锁</li>
<li>如果创建新的线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>采用上述步骤的总体思路是，是为了在执行execute方法时，尽量避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前的运行线程数大于等于corePoolSize），几乎所有的execute方法都是执行步骤2，而步骤2不需要获取全局锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable <span class="built_in">command</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">command</span> == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    // 如果线程数小于基本线程数，则创建线程并执行当前任务</div><div class="line">    <span class="keyword">if</span>(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(<span class="built_in">command</span>)) &#123;</div><div class="line">        // 如线程数大于等于核心线程数或线程创建失败，则将当前任务放到工作队列中。</div><div class="line">        <span class="keyword">if</span>(runState == RUNNING &amp;&amp; workQueue.offer(<span class="built_in">command</span>)) &#123;</div><div class="line">            <span class="keyword">if</span>(runState != RUNNING || poolSize == 0)</div><div class="line">                ensureQueuedTaskHandled(<span class="built_in">command</span>);</div><div class="line">        &#125;</div><div class="line">        // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!addIfUnderMaximumPoolSize(<span class="built_in">command</span>))</div><div class="line">            // 抛出RejectedExecutionException异常</div><div class="line">            reject(<span class="built_in">command</span>); // is shutdown or saturated</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程worker，woker在执行完任务后，还会循环获取工作队列里的任务来执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            try &#123;</div><div class="line">                Runnable task = firstTask;</div><div class="line">                firstTask = null;</div><div class="line">                <span class="keyword">while</span>(task != null || (task =getTask()) != null) &#123;</div><div class="line">                    runTask(task);</div><div class="line">                    task = null;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                workerDone(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/执行任务.png" alt=""><br>线程池执行任务分两种情况：1.在execute方法中创建一个线程时，会让这个线程执行当前任务。2.这个线程执行完任务后，会反复从BlockingQueue获取任务来执行。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>
<ol>
<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，及时其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用prestartAllCoreThreads方法，线程池会提前创建并启动所有线程。</li>
<li>runnableTaskQueue（任务队列）:用于保存等待执行任务的阻塞队列。可选择以下几个阻塞队列：<br>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另外一个线程调用移除操作，否则操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，Executors.newCachedThreadPool使用了这个队列<br>PriorityBlockingQueue：一个具有优先队列的无限阻塞队列</li>
<li>maximumPoolSize（线程池最大数量）：线程允许创建的最大线程数，如果队列满了并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用无界的任务队列这个参数就没意义。</li>
<li><p>ThreadFactory：用来创建线程的工厂，可以通过线程工厂给每个创建的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速地给线程池里的线程设置有意义的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</div></pre></td></tr></table></figure>
</li>
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池满时，说明线程池处于饱和状态，那么必须采用一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理任务时抛异常。<br>AbortPolicy：直接抛出异常<br>CallerRunsPolicy：只用调用者所在线程来运行任务<br>DiscardOldestPolicy：丢弃队列里最后一个任务，来执行当前任务<br>DiscardPolicy：不处理，丢弃掉</p>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行时间都比较短，，可以调大时间，提高cpu的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的时间有Days、HOUSRS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS</li>
</ol>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute和submit方法。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>()&#123;</div><div class="line">  public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>submit方法用于提交需要返回值的任务，线程池会返回一个Future对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成。而使用get(long timeout,TimeUnit unit)则会阻塞当前线程一段时间后立即返回，这时候有可能任务还未执行完。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future=executor.submit(harReturnValuetask);</div><div class="line">try&#123;</div><div class="line">  Object s=future.get();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line"></div><div class="line">&#125;finally&#123;</div><div class="line">  executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他的原理是遍历线程池中的工作线程，然后逐个调用线程的interupt方法来中断线程，所以无法中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow是先把线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。而shoutdown只是将线程池的状态设置为shutdown状态，然后中断所有没有正在执行任务的线程。<br>只要调用这两个关闭方法中的其中一个，isshutdown方法就会返回true，当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。<br>任务的性质：CPU密集任务、IO密集任务、混合型任务<br>任务的优先级：高、中、低<br>任务执行的时间：长、中、短<br>任务的依赖性：是否依赖其他系统资源，如数据库连接<br>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应该配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。对于混合型任务，如果可以拆分，将其拆分成CPU密集型任务和IO密集型任务，只要这两个任务执行时间相差不是很大，那么拆分后的吞吐量将高于串行的执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRunTime().availableProcessors()方法获取当前设备的cpu数量。<br>优先级不同可以使用PriorityBlockingQueue来处理，它可以让优先级高的任务先执行。<br>执行时间不同交给不同规模的线程池来处理或者可以使用优先级队列，让执行时间段的任务先执行。<br>依赖数据库连接池任务，因为线程提交SQl后需要等待数据库返回结果，等待的时间越长，cpu的空余时间越长，那么线程数应该设置越大，才能更好地利用cpu。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便出现问题时定位。监控线程池可使用如下属性<br>taskCount：线程需要执行的任务数量<br>completedTaskCount：线程池在运行过程时已完成的任务数量，小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量<br>getPoolSize：线程池的线程数量<br>getActiveCount：获取活动线程数<br>通过扩展线程池进行监控，可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间。这几个方法在线程池里是空方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void beforeExecute(Thread t, Runnable r)&#123; &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>java线程被一对一映射为本地操作系统线程。java线程启动时会创建一个本地操作系统线程；当该线程终止时，这个操作系统线程会被回收。操作系统会调度所有线程并将它们分配给可用的cpu。<br>在上层，java多线程程序通常把应用分解为若干个任务，然后使用用户级调度器(Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。简单的说，应用程序通过Executor框架控制上层的调度，下层的调度通过操作系统内核控制，下层的调度不受应用程序的控制。<br><img src="/2018/01/10/线程池和Executor/二级调度.png" alt=""></p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><h4 id="Executor框架的架构"><a href="#Executor框架的架构" class="headerlink" title="Executor框架的架构"></a>Executor框架的架构</h4><p>Executor框架主要由3大部分组成。</p>
<ul>
<li>任务，包括被执行任务需要实现的接口Runnable或Callable接口。</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口，包括ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>
<p>Executor是一个接口，它是Executor框架的基础，它将任务的提交和任务的执行分离开来。<br>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。比Timer更灵活，功能更强大。<br>Future接口和实现Future接口的实现类FutureTask，代表异步计算的结果。<br>Runnable和Callable的实现类，都可以被ThreadPoolExecutor和ScheduledThreadPoolExecutor执行<br><img src="/2018/01/10/线程池和Executor/class.png" alt=""><br><img src="/2018/01/10/线程池和Executor/#x.png" alt=""><br>主线程首先要创建实现Runnable或者Callable接口的任务对象，工具类Executors可以把一个Runnable对象封装成Callable对象(Executors.callable(Runnble task)或Executors.callable(Runnable task,Object result))。<br>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runable command)),或者可以把Ruunable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit(Callable task))。<br>如果执行ExecutorService.submit(…)，ExecutorService将返回一个Future对象，（目前jdk返回的是FutureTask对象），由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService运行。<br>最后，主线程可以调用FutureTask.get()方法等待任务执行完成，主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)取消任务的运行。</p>
<h4 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h4><p>主要成员有：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建三种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</p>
<h6 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h6><p>创建固定线程数的FixedThreadPool。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h6><p>创建单个线程的SingleThreadExecutor的API<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h6 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h6><p>创建一个会根据需要创建新线程的CachedThreadPool<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>通常使用Executors创建，可以创建两种类型的ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor.包含若干线程的ScheduledThreadPoolExecutor<br>SingleThreadScheduledExecutor.包含一个线程的ScheduledThreadPoolExecutor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果，当我们把Callable接口或Runnable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会返回一个FutureTask对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</div><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</div><div class="line">Future&lt;&gt; submit(Runnable task)</div></pre></td></tr></table></figure></p>
<p>目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。在将来的JDK实现中，返回的可能不一定是FutureTask。</p>
<h5 id="Runnable和Callable接口"><a href="#Runnable和Callable接口" class="headerlink" title="Runnable和Callable接口"></a>Runnable和Callable接口</h5><p>Runnable和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。区别是Runnable不会返回结果，而Callable可以返回结果。除了可以创建实现Callable接口的对象外，还可以使用工厂类Executors把一个Runnable接口包装成Callable接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static Callable&lt;Object&gt; callable(Runnable task) // 假设返回对象Callable1</div><div class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) // 假设返回对象Callable2</div></pre></td></tr></table></figure></p>
<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。例如，如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p>可重用固定线程数的线程池。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<br>当线程池的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多于的线程将被终止。这里设置为0，意味着多余的线程会被立即终止。<br><img src="/2018/01/10/线程池和Executor/execute.png" alt=""><br>说明：<br>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。<br>2）在线程池预热后，将任务加入LinkedBlockingQueue<br>3）线程执行完1任务后，会在循环中反复从LinkedBlockingQueue获取任务执行<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE)，使用无界队列作为工作队列将会对线程池带来如下影响<br>1）当线程池中的线程数达到corePoolSize，新任务将在无界队列中等待，因此线程池的线程数不会超过corePoolSize，<br>2）由于1，使用无界队列时maximumPoolSize将是无效参数。<br>3）由于1和2，keepAlive将是无效参数<br>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown或shutdownNow）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</p>
<h3 id="SingleThreadExecutor-1"><a href="#SingleThreadExecutor-1" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newSingleThreadExecutor</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()</div><div class="line">));&#125;</div></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize都设为1，其他参数与fixedThreadPool一样。SingleThreadExecutor使用无界队列LinkedBlickedQueue。<br><img src="/2018/01/10/线程池和Executor/single.png" alt=""></p>
<h3 id="CachedThreadPool-1"><a href="#CachedThreadPool-1" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService <span class="function"><span class="title">newCachedThreadPool</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()</div><div class="line">);&#125;</div></pre></td></tr></table></figure></p>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界，这里把keepalive的时间设置为60L，意味着CachedThreadPool的空余线程等待新任务的最长时间为60s，空余线程超过60s会被终止。<br>CachedThreadPool采用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPoolSize是无界的，这意味者如果主线程提交的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新线程，极端情况下，CachedThreadPool会因为创建过多线程而耗尽cpu和内存资源。<br><img src="/2018/01/10/线程池和Executor/cached_execute.png" alt=""><br>1）首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有空余的时间正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行的offer操作与poll操作配对成功，主线程把任务交给空余的线程执行，execute方法执行完成；否则执行步骤2<br>2）当初始maximumPool为空时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），这种情况下步骤1）将会失败，将会创建一个新线程来执行任务。<br>3）在步骤2新建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空余线程最多在SynchronousQueue中等待60秒，如果60秒内主线程提交了一个任务，这个空余线程将执行主线程提交的任务，否则这个空余线程将会终止。<br>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。</p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承来自ThreadPoolExecutor，它主要用来给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor与Timer类似，但功能更强大且更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义。<br><img src="/2018/01/10/线程池和Executor/scheduled任务传递.png" alt=""><br>ScheduledThreadPoolExecutor的执行分为两个部分：<br>1）当调用scheduleAtFixRate方法或者scheduleWithFixedDelay时，会向DelayQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask<br>2）线程池中的线程从DelayQueue获取ScheduleFutureTask，然后执行任务。<br><img src="/2018/01/10/线程池和Executor/schedule.png" alt=""><br>ScheduleThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了修改：使用DelayQueue作为任务队列；获取任务的方式不同；执行周期任务后，增加了额外处理。</p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduleThreadPoolExecutor会把待调度的任务（ScheduledFutureTask）放到一个DelayQueue里。<br>ScheduledFutureTask有三个参数：<br>long型成员变量time，标识这个任务被执行的时间；<br>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor的序号；<br>long型成员变量period，表示任务执行的周期；<br>DelayQueue封装了一个PriorityQueue，它会对ScheduledFutureTask按照time的大小进行排序，如果time一样，就比较SequenceNumber。<br><img src="/2018/01/10/线程池和Executor/schedule任务执行.png" alt=""><br>1）线程1从DelayQueue中获取已到期的ScheduledFutureTask(delayQueue.take())，到期任务指的是time小于等于当前时间。<br>2）线程1执行这个ScheduledFutureTask<br>3）线程1修改time为下次将要被执行时间<br>4）修改time后将ScheduledFutureTask放回到DelayQueue中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lockInterruptibly(); //1</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            E first = q.peek();</div><div class="line">            <span class="keyword">if</span>(first == null) &#123;</div><div class="line">                available.await();//2.1</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                long delay =  first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                <span class="keyword">if</span>(delay &gt; 0) &#123;</div><div class="line">                    long tl = available.awaitNanos(delay);//2.2</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    E x = q.poll();  //2.3.1</div><div class="line">                    assert x != null;</div><div class="line">                    <span class="keyword">if</span>(q.size() != 0)</div><div class="line">                        available.signalAll(); //2.3.2 wake up other takers</div><div class="line">                    <span class="built_in">return</span> x;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/scheduled_condition.png" alt=""><br>1)获取Lock<br>2）获取周期任务；<br>如果PriorityQueue为空，当前线程到Condition等待，否则执行下面2.2<br>如果如果Priority的头元素的时间比当前时间大，到condition等待time时间，否则执行2.3<br>3）释放锁<br>ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。<br>最后，让我们看看ScheduledThreadPoolExecutor中的线程执行任务的步骤4，把ScheduledFutureTask放入DelayQueue中的过程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();//1</div><div class="line">    try &#123;</div><div class="line">        E first = q.peek();</div><div class="line">        q.offer(e);//2.1</div><div class="line">        <span class="keyword">if</span>(first == null || e.compareTo(first) &lt; 0)</div><div class="line">            available.signalAll();//2.2</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();//3</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/schedule-delay.png" alt=""><br>1)获取锁<br>2）添加任务；向PriorityQueue添加任务，如果添加的是头元素，则唤醒其他线程<br>3）释放锁</p>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现类FutureTask，代表异步计算的结果</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口还实现了Runnable接口。FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行时机，FutureTask可以处于下面三种状态。<br>1）未启动。FutureTask.run还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，在没有执行run方法之前，处于未启动状态。<br>2）已启动。run方法被执行过程，处于已启动状态<br>3）已完成。执行完正常结束，或被取消(FutureTask.cancel())，或执行run方法过程中抛出异常而异常结束。<br><img src="/2018/01/10/线程池和Executor/FutureTask状态.png" alt=""><br>但FutureTask处于未启动或已启动状态时，执行FutureTask.get()会导致线程阻塞，当FutureTask处于已完成状态，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<br>当FutureTask处于未启动状态时，FutureTask.cancel()将导致任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成)；当FutureTask处于已完成状态时，执行FutureTask.cancel()方法将返回false。<br><img src="/2018/01/10/线程池和Executor/cancel.png" alt=""></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<br>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final  ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = new ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</div><div class="line">	private static String executionTask(final String taskName)</div><div class="line">			throws ExecutionException, InterruptedException &#123;</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">			Future&lt;String&gt; future = taskCache.get(taskName);// 1.1,2.1</div><div class="line">			<span class="keyword">if</span>(future == null) &#123;</div><div class="line">				Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;</div><div class="line">					public String call() throws InterruptedException &#123;</div><div class="line">						<span class="built_in">return</span> taskName;</div><div class="line">					&#125;</div><div class="line">				&#125;; // 1.2创建任务</div><div class="line">				FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(task);</div><div class="line">				future = taskCache.putIfAbsent(taskName, futureTask);// 1.3</div><div class="line">				<span class="keyword">if</span>(future == null) &#123;</div><div class="line">					future = futureTask;</div><div class="line">					futureTask.run();// 1.4执行任务</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				<span class="built_in">return</span> future.get();// 1.5,2.2线程在此等待任务执行完成</div><div class="line">			&#125; catch (CancellationException e) &#123;</div><div class="line">				taskCache.remove(taskName, future);</div><div class="line">			&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/01/10/线程池和Executor/future.png" alt=""><br>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread 2将在2.2等待，直到Thread 1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现是基于AQS，concurrent包中很多阻塞类(ReentrantLock)都是基于阻塞类实现的.AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程。基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、FutureTask<br>每一个基于AQS实现的同步器都会包含两种类型的操作，如下。<br>至少一个acquire操作。这个操作阻塞调用线程，除非直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get/get（long timeout，TimeUnit unit）方法调用。<br>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run方法和cancel（…）方法。<br>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。<br>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br><img src="/2018/01/10/线程池和Executor/FutureTask设计.png" alt=""><br>Sync是一个内部私有类，它继承自AQS，创建FutureTask时会创建Sync，FutureTask的所有共有方法都委托给Sync。<br>FutureTask.get()会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法执行过程如下<br>1）首先会回调在子类Sync的tryAcquireShared方法来判断是否可以成功，acquire成功的条件为：state为执行成功状态或已取消状态，且runner不为null。<br>2）如果成功则在get方法中立即返回，失败了就在等待队列中去等待其他线程执行release操作。<br>3）当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel()）唤醒当前线程。当前线程再次执行tryAcquireShared将返回正值1，当前线程将离开等待队列并且唤醒他的后继线程。<br>4）最后返回计算结果或返回抛出异常。<br>FutureTask.run()执行过程如下：<br>FutureTask.run()的执行过程如下。<br>1）执行在构造函数中指定的任务（Callable.call()）。<br>2）以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。<br>3）AQS.releaseShared（int arg）首先会回调在子类Sync中实的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。<br>4）调用FutureTask.done()。<br>当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程<br><img src="/2018/01/10/线程池和Executor/级联唤醒.png" alt=""><br>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从<br>队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java并发/" rel="tag"># java并发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/05/java并发编程6-8/" rel="next" title="java并发编程6~8">
                <i class="fa fa-chevron-left"></i> java并发编程6~8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/16/springboot/" rel="prev" title="springboot">
                springboot <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java中的线程池"><span class="nav-number">1.</span> <span class="nav-text">java中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理"><span class="nav-number">1.1.</span> <span class="nav-text">线程池的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的使用"><span class="nav-number">1.2.</span> <span class="nav-text">线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程池的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向线程池提交任务"><span class="nav-number">1.2.2.</span> <span class="nav-text">向线程池提交任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭线程池"><span class="nav-number">1.2.3.</span> <span class="nav-text">关闭线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合理配置线程池"><span class="nav-number">1.2.4.</span> <span class="nav-text">合理配置线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的监控"><span class="nav-number">1.2.5.</span> <span class="nav-text">线程池的监控</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor框架"><span class="nav-number">2.</span> <span class="nav-text">Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor框架简介"><span class="nav-number">2.1.</span> <span class="nav-text">Executor框架简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的两级调度模型"><span class="nav-number">2.1.1.</span> <span class="nav-text">Executor框架的两级调度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架的结构与成员"><span class="nav-number">2.1.2.</span> <span class="nav-text">Executor框架的结构与成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor框架的架构"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">Executor框架的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor框架的成员"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">Executor框架的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">2.1.2.2.1.1.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">2.1.2.2.1.2.</span> <span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">2.1.2.2.1.3.</span> <span class="nav-text">CachedThreadPool</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Future接口"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">Future接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Runnable和Callable接口"><span class="nav-number">2.1.2.2.4.</span> <span class="nav-text">Runnable和Callable接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor详解"><span class="nav-number">2.2.</span> <span class="nav-text">ThreadPoolExecutor详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FixedThreadPool详解"><span class="nav-number">2.2.1.</span> <span class="nav-text">FixedThreadPool详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadExecutor-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CachedThreadPool-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">CachedThreadPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ScheduledThreadPoolExecutor详解"><span class="nav-number">2.3.</span> <span class="nav-text">ScheduledThreadPoolExecutor详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPoolExecutor的运行机制"><span class="nav-number">2.3.1.</span> <span class="nav-text">ScheduledThreadPoolExecutor的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPoolExecutor的实现"><span class="nav-number">2.3.2.</span> <span class="nav-text">ScheduledThreadPoolExecutor的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask详解"><span class="nav-number">2.4.</span> <span class="nav-text">FutureTask详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask简介"><span class="nav-number">2.4.1.</span> <span class="nav-text">FutureTask简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask的使用"><span class="nav-number">2.4.2.</span> <span class="nav-text">FutureTask的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask的实现"><span class="nav-number">2.4.3.</span> <span class="nav-text">FutureTask的实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
