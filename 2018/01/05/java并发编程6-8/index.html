<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java并发," />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="java并发容器和框架ConcurrentHashMap实现原理与使用为什么要使用ConcurrentHashMapConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来">
<meta name="keywords" content="java并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程6~8">
<meta property="og:url" content="http://yoursite.com/2018/01/05/java并发编程6-8/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="java并发容器和框架ConcurrentHashMap实现原理与使用为什么要使用ConcurrentHashMapConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来">
<meta property="og:image" content="http://yoursite.com/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png">
<meta property="og:image" content="http://yoursite.com/2018/01/05/java并发编程6-8/添加元素.png">
<meta property="og:image" content="http://yoursite.com/2018/01/05/java并发编程6-8/出队.png">
<meta property="og:updated_time" content="2018-01-11T09:28:02.338Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发编程6~8">
<meta name="twitter:description" content="java并发容器和框架ConcurrentHashMap实现原理与使用为什么要使用ConcurrentHashMapConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来">
<meta name="twitter:image" content="http://yoursite.com/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/05/java并发编程6-8/"/>





  <title>java并发编程6~8 | 博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/05/java并发编程6-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发编程6~8</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T21:51:00+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java并发容器和框架"><a href="#java并发容器和框架" class="headerlink" title="java并发容器和框架"></a>java并发容器和框架</h1><h2 id="ConcurrentHashMap实现原理与使用"><a href="#ConcurrentHashMap实现原理与使用" class="headerlink" title="ConcurrentHashMap实现原理与使用"></a>ConcurrentHashMap实现原理与使用</h2><h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p>
<h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">concurrencyLevel = MAX_SEGMENTS;</div><div class="line">int sshift = 0;</div><div class="line">int ssize = 1;</div><div class="line"><span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123;</div><div class="line">++sshift;</div><div class="line">ssize = ssize&lt;&lt;1;</div><div class="line">&#125;</div><div class="line">segmentShift = 32 - sshift;</div><div class="line">segmentMask = ssize - 1;</div><div class="line">this.segments = Segment.newArray(ssize);</div></pre></td></tr></table></figure>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16</p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。SegmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个Segment"><a href="#初始化每个Segment" class="headerlink" title="初始化每个Segment"></a>初始化每个Segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadFactor是每个Segment的负载因子。在构造方法里需要通过这两个参数来初始化数组中的每个Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">int c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">++c;</div><div class="line">int <span class="built_in">cap</span> = 1;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cap</span> &lt; c)</div><div class="line"><span class="built_in">cap</span> &lt;&lt;= 1;</div><div class="line"><span class="keyword">for</span> (int i = 0; i &lt; this.segments.length; ++i)</div><div class="line">this.segments[i] = new Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</div></pre></td></tr></table></figure></p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取数据的时候，必须先通过散列算法定位到Segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static int <span class="built_in">hash</span>(int h) &#123;</div><div class="line">h += (h &lt;&lt; 15) ^ 0xffffcd7d;</div><div class="line">h ^= (h &gt;&gt;&gt; 10);</div><div class="line">h += (h &lt;&lt; 3);</div><div class="line">h ^= (h &gt;&gt;&gt; 6);</div><div class="line">h += (h &lt;&lt; 2) + (h &lt;&lt; 14);</div><div class="line"><span class="built_in">return</span> h ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以进行再散列，目的是减少哈希冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存储效率。通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Segment&lt;K,V&gt; segmentFor(int <span class="built_in">hash</span>) &#123;</div><div class="line"><span class="built_in">return</span> segments[(<span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int <span class="built_in">hash</span> = <span class="built_in">hash</span>(key.hashCode());</div><div class="line"><span class="built_in">return</span> segmentFor(<span class="built_in">hash</span>).get(key, <span class="built_in">hash</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get的高效就在于整个get过程中不用加锁，除非读到的值是空的才会加锁重读，ConcurrentHashMap在它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值。但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">transient volatile int count;</div><div class="line">volatile V value;</div></pre></td></tr></table></figure></p>
<p>定位HashEntry和定位Segment的算法虽然一样，都与数组长度减1，定位Segment使用的是元素Hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是hashcode的值，其目的是避免两次散列的值一样。虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">hash</span> &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的<span class="built_in">hash</span>算法</div><div class="line">int index = <span class="built_in">hash</span> &amp; (tab.length - 1);　　// 定位HashEntry所使用的<span class="built_in">hash</span>算法</div></pre></td></tr></table></figure></p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法需要对共享变量进行写操作，为了线程安全，操作共享变量时必须加锁。put首先定位到Segment，然后在Segment里进行插入操作，插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二部定位添加元素的位置，然后将其放入HashEntry数组中。<br>（1）是否扩容<br>在插入元素前会先判断Segment的HashEntry数组是否超过容量（threadhold），如果超过阈值，则对数组进行扩容。Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量的，如果到达就进行扩容，但是很可能扩容之后没有新元素插入，这时HashMap进行了一次无效的扩容。<br>（2）如何扩容<br>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组中，为了高效，ConcurrentHashMap不会对整个容器扩容，而只对某个Segment进行扩容。</p>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>在并发过程中有时候需要线程安全的队列，如果要实现一个线程安全队列有两种方式：一种是阻塞算法，另一种是非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队使用同一把锁）或者两个锁等方式实现。非阻塞算法可以使用循环CAS方式来实现。<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到尾部，当我们获取一个元素时，它会返回队列头部的元素，。它采用CAS算法实现。<br><img src="/2018/01/05/java并发编程6-8/concurrentLinkedQueue.png" alt=""><br>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient volatile Node&lt;E&gt; tail = head;</div></pre></td></tr></table></figure></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><ol>
<li>入队列的过程</li>
</ol>
<p>入队列就是将入队节点添加到队列尾部。<br><img src="/2018/01/05/java并发编程6-8/添加元素.png" alt=""><br>入队主要做两件事：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null) throw new NullPointerException();</div><div class="line">// 入队前，创建一个入队节点</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line">retry:</div><div class="line">// 死循环，入队不成功反复入队。</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">// 创建一个指向tail节点的引用</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line">// p用来表示队列的尾节点，默认情况下等于tail节点。</div><div class="line">Node&lt;E&gt; p = t;</div><div class="line"><span class="keyword">for</span> (int hops = 0; ; hops++) &#123;</div><div class="line">// 获得p节点的下一个节点。</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</div><div class="line"><span class="keyword">if</span> (next != null) &#123;</div><div class="line">// 循环了两次及其以上，并且当前节点还是不等于尾节点</div><div class="line"><span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</div><div class="line"><span class="built_in">continue</span> retry;</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line">// 如果p是尾节点，则设置p节点的next节点为入队节点。</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(null, n)) &#123;</div><div class="line">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</div><div class="line">更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</div><div class="line">casTail(t, n); // 更新tail节点，允许失败</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">p = succ(p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<ol>
<li>定位尾节点</li>
</ol>
<p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123;</div><div class="line">Node&lt;E&gt; next = p.getNext();</div><div class="line"><span class="built_in">return</span> (p == next) head : next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>设置入队节点为尾节点</li>
</ol>
<p>p.casNext(null,n)方法用于将入队节点设置为当前队列尾节点的next节点，如果当前尾节点的next节点是null时，则代表当前节点为尾节点，如果不为null时，则需要重新获取当前队列的尾节点</p>
<ol>
<li>Hops的设计意图</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line"><span class="keyword">if</span> (e == null)</div><div class="line">throw new NullPointerException();</div><div class="line">Node&lt;E&gt; n = new Node&lt;E&gt;(e);</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line"><span class="keyword">if</span> (t.casNext(null, n) &amp;&amp; casTail(t, n)) &#123;</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让tail节点永远作为尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列是从队列返回一个节点元素，并清空该节点对该元素的引用。并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。<br><img src="/2018/01/05/java并发编程6-8/出队.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public E <span class="function"><span class="title">poll</span></span>() &#123;</div><div class="line">Node&lt;E&gt; h = head;</div><div class="line">// p表示头节点，需要出队的节点</div><div class="line">Node&lt;E&gt; p = h;</div><div class="line"><span class="keyword">for</span> (int hops = 0;; hops++) &#123;</div><div class="line">// 获取p节点的元素</div><div class="line">E item = p.getItem();</div><div class="line">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</div><div class="line">// 如果成功则返回p节点的元素。</div><div class="line"><span class="keyword">if</span> (item != null &amp;&amp; p.casItem(item, null)) &#123;</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS) &#123;</div><div class="line">// 将p节点下一个节点设置成head节点</div><div class="line">Node&lt;E&gt; q = p.getNext();</div><div class="line">updateHead(h, (q != null) q : p);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> item;</div><div class="line">&#125;</div><div class="line">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</div><div class="line">// 一个线程修改了。那么获取p节点的下一个节点</div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line">// 如果p的下一个节点也为空，说明这个队列已经空了</div><div class="line"><span class="keyword">if</span> (next == null) &#123;</div><div class="line">// 更新头节点。</div><div class="line">updateHead(h, p);</div><div class="line"><span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先获取头节点元素，然后判断头结点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点元素取走，如果不为空，则使用CAS方式将头结点引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列是支持两个附加操作的队列。附加操作指的是支持阻塞的插入和移除。<br>1）支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者消费者场景。生产者是向队列里添加的线程，消费者是从队列里取元素的线程。阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常:当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
<h3 id="java的阻塞队列"><a href="#java的阻塞队列" class="headerlink" title="java的阻塞队列"></a>java的阻塞队列</h3><p>jdk7提供了7个阻塞队列<br>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列<br>DelayBlockingQueue：一个使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：一个不存储元素的阻塞队列<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是用一个数组实现有界的阻塞队列，此队列按照先进先出原则对元素进行排序。默认情况下不保证线程公平访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue fairQueue=new ArrayBlockingQueue(100,<span class="literal">true</span>);</div><div class="line">//公平性是使用可重入锁</div><div class="line">public ArrayBlockingQueue(int capacity,boolean fair)&#123;</div><div class="line">  <span class="keyword">if</span>(capacity&lt;0)&#123;</div><div class="line">    throw  new IllegalArgumentException();</div><div class="line">  &#125;</div><div class="line">  this.items=new Object[capacity];</div><div class="line">  lock=new ReentrantLock(fair);</div><div class="line">  notEmpty=lock.newCondition();</div><div class="line">  notFull=lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，此队列默认最大长度为Integer.MAX_VALUE，此队列按照先进先出的原则。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue来实现。队列中的元素必须实现Delay接口，在创建元素时，可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列提取元素。<br>DelayQueue使用场景：1.缓存系统的设计；可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素，说明缓存有效期到了；2.定时任务调度，使用DelayQueue保存当天会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的<br>如何实现DelayQueue,参考ScheduledThreadPoolExecutor里ScheduledFutureTask：<br>1）在对象创建时候，初始化基本数据，使用time记录当前记录延迟到什么时候可以使用，使用SequenceNumber来标识元素在队列中的先后顺序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static final AtomicLong sequencer = new AtomicLong(0);</div><div class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</div><div class="line">super(r, result);</div><div class="line">this.time = ns;</div><div class="line">this.period = period;</div><div class="line">this.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）实现delay方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public long getDelay(TimeUnit unit) &#123;</div><div class="line">    <span class="built_in">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>3)实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int compareTo(Delayed other) &#123;</div><div class="line">     <span class="keyword">if</span> (other == this) // compare zero ONLY <span class="keyword">if</span> same object</div><div class="line">         <span class="built_in">return</span> 0;</div><div class="line">     <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</div><div class="line">         ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</div><div class="line">         long diff = time - x.time;</div><div class="line">         <span class="keyword">if</span> (diff &lt; 0)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; 0)</div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</div><div class="line">             <span class="built_in">return</span> -1;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             <span class="built_in">return</span> 1;</div><div class="line">     &#125;</div><div class="line">     long d = (getDelay(TimeUnit.NANOSECONDS) -</div><div class="line">               other.getDelay(TimeUnit.NANOSECONDS));</div><div class="line">     <span class="built_in">return</span> (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如何实现延时阻塞队列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                   <span class="keyword">if</span> (delay &lt;= 0)</div><div class="line">                       <span class="built_in">return</span> q.poll();</div><div class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != null)</div><div class="line">                       available.await();</div><div class="line">                   <span class="keyword">else</span> &#123;</div><div class="line">                       Thread thisThread = Thread.currentThread();</div><div class="line">                       leader = thisThread;</div><div class="line">                       try &#123;</div><div class="line">                           available.awaitNanos(delay);</div><div class="line">                       &#125; finally &#123;</div><div class="line">                           <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                               leader = null;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div></pre></td></tr></table></figure></p>
<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能添加。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。<br>SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
<h4 id="LinkedTransformQueue"><a href="#LinkedTransformQueue" class="headerlink" title="LinkedTransformQueue"></a>LinkedTransformQueue</h4><p>LinkedTransformQueue是一个由链表结构组成的无界阻塞TransformQueue队列。，相比较其他阻塞队列，增加了tryTransform和transform方法如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node pred = tryAppend(s, haveData);</div><div class="line"><span class="built_in">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</div></pre></td></tr></table></figure></p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用通知模式实现，所谓的通知模式，就是生产者往满的队列添加元素时会阻塞住生产者，当消费者消费一个队列后，会通知生产者当前队列可用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private final Condition notFull;</div><div class="line">private final Condition notEmpty;</div><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">// 省略其他代码</div><div class="line">notEmpty = lock.newCondition();</div><div class="line">notFull = lock.newCondition();</div><div class="line">&#125;</div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">checkNotNull(e);</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == items.length)</div><div class="line">notFull.await();</div><div class="line">insert(e);</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">final ReentrantLock lock = this.lock;</div><div class="line">lock.lockInterruptibly();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span> (count == 0)</div><div class="line">notEmpty.await();</div><div class="line"><span class="built_in">return</span> extract();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">private void insert(E x) &#123;</div><div class="line">items[putIndex] = x;</div><div class="line">putIndex = inc(putIndex);</div><div class="line">++count;</div><div class="line">notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当队列插入一个元素，如果队列不可用，那么阻塞生产者主要通过Locksupport.park实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(this);</div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="built_in">set</span>Blocker(t, blocker);</div><div class="line">    unsafe.park(<span class="literal">false</span>, 0L);</div><div class="line">    <span class="built_in">set</span>Blocker(t, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.park是个native方法</p>
<h2 id="fork-join任务"><a href="#fork-join任务" class="headerlink" title="fork/join任务"></a>fork/join任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class CountNumber extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private static final int THRESHOLD = 2;</div><div class="line">	private int start;</div><div class="line">	private int end;</div><div class="line"></div><div class="line">	public CountNumber(int start, int end) &#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer <span class="function"><span class="title">compute</span></span>() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		// 如果任务足够小就计算任务</div><div class="line">		boolean canCompute = (end - start) &lt;= THRESHOLD;</div><div class="line">		<span class="keyword">if</span> (canCompute) &#123;</div><div class="line">			<span class="keyword">for</span> (int i = start; i &lt;= end; i++) &#123;</div><div class="line">				sum += i;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 如果任务大于阈值，就分裂成两个子任务计算</div><div class="line">			int middle = (start + end) / 2;</div><div class="line">			CountNumber leftTask = new CountNumber(start, middle);</div><div class="line">			CountNumber rightTask = new CountNumber(middle + 1, end);</div><div class="line">			// 执行子任务</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			// 等待子任务执行完，并得到其结果</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			// 合并子任务</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> sum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		// 生成一个计算任务，负责计算1+2+3+4</div><div class="line">		CountNumber task = new CountNumber(1, 4);</div><div class="line">		// 执行一个任务</div><div class="line">		Future&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ForkJoinTask与一般任务的区别是它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常<br>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>1）当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。<br>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final ForkJoinTask&lt;V&gt; <span class="function"><span class="title">fork</span></span>() &#123;</div><div class="line">((ForkJoinWorkerThread) Thread.currentThread())</div><div class="line">.pushTask(this);</div><div class="line"><span class="built_in">return</span> this;</div><div class="line">&#125;</div><div class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;</div><div class="line">ForkJoinTask&lt;&gt;[] q; int s, m;</div><div class="line"><span class="keyword">if</span> ((q = queue) != null) &#123;　　　　// ignore <span class="keyword">if</span> queue removed</div><div class="line">long u = (((s = queueTop) &amp; (m = q.length - 1)) &lt;&lt; ASHIFT) + ABASE;</div><div class="line">UNSAFE.putOrderedObject(q, u, t);</div><div class="line">queueTop = s + 1;　　　　　　// or use putOrderedInt</div><div class="line"><span class="keyword">if</span> ((s -= queueBase) &lt;= 2)</div><div class="line">pool.signalWork();</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == m)</div><div class="line">growQueue();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)ForkJoinTask的join实现原理<br>join方法主要是阻塞当前线程并等待获取结果,它调用了doJoin()方法，通过doJoin()方法到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public final V <span class="function"><span class="title">join</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">do</span>Join() != NORMAL)</div><div class="line"><span class="built_in">return</span> reportResult();</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private V <span class="function"><span class="title">reportResult</span></span>() &#123;</div><div class="line">int s; Throwable ex;</div><div class="line"><span class="keyword">if</span> ((s = status) == CANCELLED)</div><div class="line">throw new CancellationException();</div><div class="line"><span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)</div><div class="line">UNSAFE.throwException(ex);</div><div class="line"><span class="built_in">return</span> getRawResult();</div><div class="line">&#125;</div><div class="line">private int <span class="function"><span class="title">doJoin</span></span>() &#123;</div><div class="line">Thread t; ForkJoinWorkerThread w; int s; boolean completed;</div><div class="line"><span class="keyword">if</span> ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &#123;</div><div class="line"><span class="keyword">if</span> ((s = status) &lt; 0)</div><div class="line"><span class="built_in">return</span> s;</div><div class="line"><span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(this)) &#123;</div><div class="line">try &#123;</div><div class="line">completed = <span class="built_in">exec</span>();</div><div class="line">&#125; catch (Throwable rex) &#123;</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>ExceptionalCompletion(rex);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (completed)</div><div class="line"><span class="built_in">return</span> <span class="built_in">set</span>Completion(NORMAL);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> w.joinTask(this);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">return</span> externalA<span class="built_in">wait</span>Done();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h1 id="java中的13个原子操作类"><a href="#java中的13个原子操作类" class="headerlink" title="java中的13个原子操作类"></a>java中的13个原子操作类</h1><p>java.util.concurrent.atomic提供了一种用法简单、性能高效、线程安全地更新一个变量的方式，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>AtomicBoolean:原子更新布尔类型<br>AtomicInteger：原子更新整数类型<br>AtomicLong：原子更新长整型<br>这三个类提供的方法几乎一模一样，以AtomicInteger为例<br>int addAndGet(int delta)：以原子方式将输入的数值与实例的值相加，并返回结果。<br>boolean compareAndSet(int expect,intupdate):如果输入的值等于预期，则以原子的方式将该值设为输入的值。<br>int getAndIncrement():以原子的方式将当前值加1，这里返回的值是自增前的值。<br>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。<br>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final int <span class="function"><span class="title">getAndIncrement</span></span>() &#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line"><span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line"><span class="built_in">return</span> current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line"><span class="built_in">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。<br>Atomic包提供了3种基本类型的原子更新，但是java基本类型还有char、float、double，Atomic包是使用unsafe实现的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapObject(Object o,</div><div class="line">long offset,</div><div class="line">Object expected,</div><div class="line">Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">int expected,</div><div class="line">int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,</div><div class="line">long expected,</div><div class="line">long x);</div></pre></td></tr></table></figure></p>
<p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。</p>
<h2 id="原子数组更新"><a href="#原子数组更新" class="headerlink" title="原子数组更新"></a>原子数组更新</h2><p>AtomicIntegerArray：原子更新整型数组里的元素<br>AtomicLongArray：原子更新长整型数组里的元素<br>AtomicReferenceArray：原子更新引用数组里的元素<br>·int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。<br>·boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerArratTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		int[] value=new int[]&#123;1,2,3&#125;;</div><div class="line">		AtomicIntegerArray atomicIntegerArray=new AtomicIntegerArray(value);</div><div class="line">		atomicIntegerArray.set(0, 3);</div><div class="line">		System.out.println(atomicIntegerArray.get(0));</div><div class="line">		System.out.println(value[0]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//3</div><div class="line">//1</div></pre></td></tr></table></figure></p>
<p>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，需要使用这个原子更新引用类型提供的类，Atomic包括以下几个类：<br>AtomicReference：原子更新引用类型<br>AtomicReferenceFieldUpdater：原子更新引用类型的字段<br>AtomicMarkableReference：原子更新带有标记位的引用类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AtomicRefernceTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicReference&lt;User&gt; atomicReference=new AtomicReference&lt;&gt;();</div><div class="line">		User user=new User(<span class="string">"student"</span>, 15);</div><div class="line">		atomicReference.set(user);</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">		atomicReference.compareAndSet(user, new User(<span class="string">"teacher"</span>, 30));</div><div class="line">		System.out.println(atomicReference.get());</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		private int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>AtomicIntegerFieldUpdater：原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicStampedReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可用于原子更新数据和数据的版本号，可以解决使用CAS进行原子更新时出现的ABA问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerFieldUpdaterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</div><div class="line">        User user=new User(<span class="string">"lr"</span>, 10);</div><div class="line">        atomicIntegerFieldUpdater.getAndIncrement(user);</div><div class="line">        System.out.println(atomicIntegerFieldUpdater.get(user));</div><div class="line">	&#125;</div><div class="line">	static class User &#123;</div><div class="line">		private String name;</div><div class="line">		public volatile int old;</div><div class="line"></div><div class="line">		public User(String name, int old) &#123;</div><div class="line">			this.name = name;</div><div class="line">			this.old = old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int <span class="function"><span class="title">getOld</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> old;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">"User [name="</span> + name + <span class="string">", old="</span> + old + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="java中并发工具类"><a href="#java中并发工具类" class="headerlink" title="java中并发工具类"></a>java中并发工具类</h1><h2 id="等待多线程完成countDownLatch"><a href="#等待多线程完成countDownLatch" class="headerlink" title="等待多线程完成countDownLatch"></a>等待多线程完成countDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。要实现主线程等待所有线程完成任务，最简单的做法是使用join<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class JoinCountDownLatchTest &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * @throws S</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread task1=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        Thread task2=new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">        task1.start();</div><div class="line">        task2.start();</div><div class="line">        task1.join();</div><div class="line">        task2.join();</div><div class="line">        System.out.println(<span class="string">"total task finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>join用于执行线程等待join执行结束，原理是不同地检查线程是否存活，如果join线程存活则让当前线程永远等待，其中wait（0）是永远等待<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(isAlive())&#123;</div><div class="line">  <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>知道join线程终止后，线程的this.notifyAll()方法会被调用，调用notifyAll方法是在JVM实现的，在JDK看不到<br>并发包CountDownLatch可以实现join功能，并且比join功能更多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		final CountDownLatch countDownLatch = new CountDownLatch(2);</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task1 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				System.out.println(<span class="string">"task2 finish"</span>);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		countDownLatch.await();</div><div class="line">		System.out.println(<span class="string">"all finish"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CountDownLatch构造函数接收一个int类型的参数作为计数器，如果你想等N个点完成，就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变为0。我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier字面意思是可循环使用的屏障，它要做的事情是让一组线程到达屏障时被阻塞，直到最后一个线程到达屏障时，屏障才开门，所有被屏障拦截的线程才会继续运行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障要拦截的线程数，每个线程调用await方法告诉CyclicBarrier我已经到达屏障，然后当前线程阻塞<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException, BrokenBarrierException&#123;</div><div class="line">	final CyclicBarrier cyclicBarrier=new CyclicBarrier(2);</div><div class="line">	new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			try &#123;</div><div class="line">				cyclicBarrier.await();</div><div class="line">			&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"1"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">	cyclicBarrier.await();</div><div class="line">	System.out.println(<span class="string">"2"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CyclicBarrier还提供了一个更高级的构造函数，CyclicBarrier(int parties,Runnable action)，用于在线程到达屏障时，优先执行action，方便处理更复杂的业务场景。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2, new A());</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class A implements Runnable &#123;</div><div class="line">		@Override</div><div class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">			System.out.println(3);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier应用场景"><a href="#CyclicBarrier应用场景" class="headerlink" title="CyclicBarrier应用场景"></a>CyclicBarrier应用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BankWaterService implements Runnable&#123;</div><div class="line">	/**</div><div class="line">	* 创建4个屏障，处理完之后执行当前类的run方法</div><div class="line">	*/</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	/**</div><div class="line">	* 假设只有4个sheet，所以只启动4个线程</div><div class="line">	*/</div><div class="line">	private ExecutorService executor = Executors.newFixedThreadPool(4);</div><div class="line">	/**</div><div class="line">	* 保存每个sheet计算出的银流结果</div><div class="line">	*/</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt;sheetBankWaterCount = new</div><div class="line">	ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	public void <span class="function"><span class="title">count</span></span>()&#123;</div><div class="line">		<span class="keyword">for</span>(int i=0;i&lt;4;i++)&#123;</div><div class="line">		executor.submit(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		&#125;</div><div class="line">		executor.shutdown();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		int result = 0;</div><div class="line">		<span class="keyword">for</span>(Entry&lt;String,Integer&gt; entry:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result=result+entry.getValue();</div><div class="line">		&#125;</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		new BankWaterService().count();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody>
</table>
<p>CyclicBarrier计数器可以使用reset方法重置，而CountDownLatch的计数器只能使用一次，所以CyclicBarrier可以用在更复杂的业务场景。例如计算错误了，可以重置计数器，让线程重算。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting可以获得阻塞的线程数量，isbroken可以用来了解阻塞的线程是否中断。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">importjava.util.concurrent.BrokenBarrierException;</div><div class="line">importjava.util.concurrent.CyclicBarrier;</div><div class="line">public class CyclicBarrierTest3 &#123;</div><div class="line">staticCyclicBarrier c = new CyclicBarrier(2);</div><div class="line">public static void main(String[] args) throws InterruptedException，</div><div class="line">BrokenBarrierException &#123;</div><div class="line">Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">thread.interrupt();</div><div class="line">try &#123;</div><div class="line">c.await();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">System.out.println(c.isBroken());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class SemophoreTest &#123;</div><div class="line"></div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	private static ExecutorService threadPool = Executors</div><div class="line">			.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</div><div class="line">			final int num=i;</div><div class="line">			threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">				@Override</div><div class="line">				public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						System.out.println(<span class="string">"save data"</span>+num);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Semaphore还提供一些其他方法，具体如下。<br>·int availablePermits()：返回此信号量中当前可用的许可证数。<br>·int getQueueLength()：返回正在等待获取许可证的线程数。<br>·boolean hasQueuedThreads()：是否有线程正在等待获取许可证。<br>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。<br>·Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</p>
<h2 id="线程之间的交换"><a href="#线程之间的交换" class="headerlink" title="线程之间的交换"></a>线程之间的交换</h2><p>Exchanger是一个线程间协作工具类，Exchanger可用来线程间的数据交换。它提供一个同步点，在这个同步点，线程间可以交换彼此的数据，两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程执行exchange方法，当两个线程都到达同步点，这两个线程就可以交换数据，将本线程生产的数据传递给对方。<br>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = <span class="string">"银行流水A"</span>;// A录入银行流水数据</div><div class="line">					exgr.exchange(A);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">			@Override</div><div class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = <span class="string">"银行流水B"</span>;// B录入银行流水数据</div><div class="line">					String A = exgr.exchange(<span class="string">"B"</span>);</div><div class="line">					System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></div><div class="line">							+ A + <span class="string">"，B录入是："</span> + B);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java并发/" rel="tag"># java并发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/01/MySQL性能管理及架构设计/" rel="next" title="MySQL性能管理及架构设计">
                <i class="fa fa-chevron-left"></i> MySQL性能管理及架构设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/10/线程池和Executor/" rel="prev" title="线程池和Executor">
                线程池和Executor <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">54</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java并发容器和框架"><span class="nav-number">1.</span> <span class="nav-text">java并发容器和框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap实现原理与使用"><span class="nav-number">1.1.</span> <span class="nav-text">ConcurrentHashMap实现原理与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用ConcurrentHashMap"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么要使用ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化Segment数组"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">初始化Segment数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化segmentShift和segmentMask"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">初始化segmentShift和segmentMask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化每个Segment"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">初始化每个Segment</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位Segment"><span class="nav-number">1.1.2.</span> <span class="nav-text">定位Segment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的操作"><span class="nav-number">1.1.3.</span> <span class="nav-text">ConcurrentHashMap的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get操作"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">get操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put操作"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">put操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size操作"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">size操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">1.2.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#入队列"><span class="nav-number">1.2.1.</span> <span class="nav-text">入队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出队列"><span class="nav-number">1.2.2.</span> <span class="nav-text">出队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的阻塞队列"><span class="nav-number">1.3.</span> <span class="nav-text">java中的阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是阻塞队列"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java的阻塞队列"><span class="nav-number">1.3.2.</span> <span class="nav-text">java的阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DelayQueue"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">DelayQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedTransformQueue"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">LinkedTransformQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedBlockingDeque"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">LinkedBlockingDeque</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列的实现原理"><span class="nav-number">1.3.3.</span> <span class="nav-text">阻塞队列的实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork-join任务"><span class="nav-number">1.4.</span> <span class="nav-text">fork/join任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">1.4.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-number">1.4.2.</span> <span class="nav-text">实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java中的13个原子操作类"><span class="nav-number">2.</span> <span class="nav-text">java中的13个原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子更新基本类型"><span class="nav-number">2.1.</span> <span class="nav-text">原子更新基本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子数组更新"><span class="nav-number">2.2.</span> <span class="nav-text">原子数组更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子更新引用类型"><span class="nav-number">2.2.1.</span> <span class="nav-text">原子更新引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子更新字段类"><span class="nav-number">2.2.2.</span> <span class="nav-text">原子更新字段类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java中并发工具类"><span class="nav-number">3.</span> <span class="nav-text">java中并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#等待多线程完成countDownLatch"><span class="nav-number">3.1.</span> <span class="nav-text">等待多线程完成countDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步屏障CyclicBarrier"><span class="nav-number">3.2.</span> <span class="nav-text">同步屏障CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">3.2.1.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier应用场景"><span class="nav-number">3.2.2.</span> <span class="nav-text">CyclicBarrier应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier和CountDownLatch的区别"><span class="nav-number">3.2.3.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">3.3.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程之间的交换"><span class="nav-number">3.4.</span> <span class="nav-text">线程之间的交换</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
