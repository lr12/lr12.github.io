<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="设计模式," />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之禅">
<meta property="og:url" content="http://yoursite.com/2017/12/06/设计模式之禅/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责2.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责2.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责3.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责3.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/里氏替换1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/接口隔离原则1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/接口隔离原则1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特2.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特2.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/开闭1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/开闭1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/工厂模式1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/工厂模式通用类图.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/多个工厂类.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/抽象1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/抽象工厂模式类图.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板4.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造0.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/原型1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者4.png">
<meta property="og:updated_time" content="2017-12-09T14:02:09.238Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式之禅">
<meta name="twitter:description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta name="twitter:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/06/设计模式之禅/"/>





  <title>设计模式之禅 | 博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/设计模式之禅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式之禅</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T23:21:46+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一职责-SRP"><a href="#单一职责-SRP" class="headerlink" title="单一职责(SRP)"></a>单一职责(SRP)</h2><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更.<br><img src="/2017/12/06/设计模式之禅/单一职责1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.2.png" alt=""><br>单一职责的优点：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义</li>
<li>可读性提高</li>
<li>可维护性提高</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>继承的优点：</p>
<ul>
<li>代码共享，减少创建类的工作量</li>
<li>提高代码的重用性</li>
<li>提高代码的扩展性</li>
<li>提高产品和项目的开放性<br>缺点：</li>
<li>继承是侵入性的，拥有父类的所有方法和属性</li>
<li>降低代码的灵活性</li>
<li>增强了耦合性</li>
</ul>
<p>里氏替换定义<br>定义一：如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。<br>定义二：所有引用基类的地方都必须能透明的引用其子类对象。第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。<br>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义:</p>
<ol>
<li>子类必须完全实现父类的方法<br><img src="/2017/12/06/设计模式之禅/里氏替换1.1.png" alt=""><br>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
<li>子类可以有自己个性<br>子类当然可以有自己的行为和外观了，也就是方法和属性。但是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</li>
<li>覆盖或实现父类的方法时输入参数可以被放大<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">public Collection <span class="keyword">do</span>Something(HashMap map)&#123;</div><div class="line">System.out.println(<span class="string">"父类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Son extends Father &#123;</div><div class="line">//放大输入参数类型</div><div class="line">public Collection <span class="keyword">do</span>Something(Map map)&#123;</div><div class="line">System.out.println(<span class="string">"子类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Father f = new Father();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div><div class="line">Son f =new Son();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>与父类的方法名相同，但又不是覆写（Override）父类的方法。是重载（Overload）。用子类替换父类，子类代替父类传递到调用者中，子类的方法永远都不会被执行。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。<br>如果你把父类参数放宽变为map，子类的参数变为Hashmap，根据里氏替换子类替换父类，子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</p>
<ol>
<li>覆盖或实现父类方法输出结果可以被缩小<br>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的</li>
</ol>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。依赖倒置原则在Java语言中的表现就是：<br>● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过<br>接口或抽象类产生的；<br>● 接口或抽象类不依赖于实现类；<br>● 实现类依赖接口或抽象类<br>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设<br>计）的精髓之一<br><img src="/2017/12/06/设计模式之禅/依赖倒置1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.3.png" alt=""><br>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，<br>不互相影响，实现模块间的松耦合。只要遵循以下几个规则</p>
<ul>
<li>每个类都尽量有抽象类或者接口</li>
<li>表面类型尽量是接口或者抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆盖父类的方法</li>
<li>结合里氏替换原则使用</li>
</ul>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><p><img src="/2017/12/06/设计模式之禅/接口隔离原则1.1.png" alt=""><br>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探<br>AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。<br>接口隔离原则包含四层含义：</p>
<ul>
<li>接口要尽量小<br>是接口隔离原则的核心定义，不出现臃肿的接口。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</li>
<li>接口要高内聚<br>具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li>
<li>定制服务<br>定制服务就是单独为一个个体提供优良的服务。<br><img src="/2017/12/06/设计模式之禅/接口隔离原则1.2.png" alt=""></li>
<li>接口设计时有粒度的<br>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构<br>的复杂化，开发难度增加，可维护性降低。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多的public方法，我就调用这么多，其他的我一概不关心。</p>
<ol>
<li>只和朋友类交流<br>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类<br><img src="/2017/12/06/设计模式之禅/迪米特1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特1.2.png" alt=""><br>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象</li>
<li>朋友间也是有距离的<br><img src="/2017/12/06/设计模式之禅/迪米特2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特2.2.png" alt=""></li>
<li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ol>
<h2 id="开闭原则-DIP"><a href="#开闭原则-DIP" class="headerlink" title="开闭原则(DIP)"></a>开闭原则(DIP)</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br><img src="/2017/12/06/设计模式之禅/开闭1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/开闭1.2.png" alt=""><br>开闭的好处:</p>
<ol>
<li>开闭对测试有影响</li>
<li>提高复用性</li>
<li>可以提高可维护性</li>
<li>面向对象开发要求</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下：<br>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。<br>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。<br>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。<br>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）<br>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。<br>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h3><ul>
<li>由于单例模式在内存只有一个实例，减少了内存的开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁的性能又无法优化时，单例模式的优势非常明显</li>
<li>由于单例只生成一个实例，较少了系统性能开销，当一个对象产生需要比较多的资源时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>单例模式一般没有接口，扩展很困难</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li>
<li>单例模式与单一职责原则有冲突。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">	private static  volatile Singleton singleton;</div><div class="line"></div><div class="line">	private <span class="function"><span class="title">Singleton</span></span>()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">		<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">			synchronized (this) &#123;</div><div class="line">				<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">					singleton=new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Human &#123;</div><div class="line"></div><div class="line">	public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123;</div><div class="line">		Human human=(Human) Class.forName(c.getName()).newInstance();</div><div class="line">		<span class="built_in">return</span> (T) human;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/06/设计模式之禅/工厂模式1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/工厂模式通用类图.png" alt=""></p>
<h3 id="工厂方法模式优点："><a href="#工厂方法模式优点：" class="headerlink" title="工厂方法模式优点："></a>工厂方法模式优点：</h3><ul>
<li>良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。</li>
<li>屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li>
<li>工厂方法模式是典型的解耦框架。</li>
</ul>
<h3 id="工厂方法的扩展"><a href="#工厂方法的扩展" class="headerlink" title="工厂方法的扩展"></a>工厂方法的扩展</h3><ol>
<li>缩小为简单工厂模式一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了</li>
<li>多个工厂类<br><img src="/2017/12/06/设计模式之禅/多个工厂类.png" alt=""></li>
<li><p>替代单例模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SingletonFactory &#123;</div><div class="line">private static Singleton singleton;</div><div class="line"> static&#123;</div><div class="line">  try &#123;</div><div class="line">    Class cl= Class.forName(Singleton.class.getName());</div><div class="line">    //获得无参构造</div><div class="line">    Constructor constructor=cl.getDeclaredConstructor();</div><div class="line">    //设置无参构造是可访问的</div><div class="line">    constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">    //产生一个实例对象</div><div class="line">    singleton = (Singleton)constructor.newInstance();</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">    //异常处理</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> public static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> singleton;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>延迟初始化<br>一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ProductFactory &#123;</div><div class="line">private static final Map&lt;String,Product&gt; prMap = new HashMap();</div><div class="line">public static synchronized Product createProduct(String <span class="built_in">type</span>) throws Exception&#123;</div><div class="line">Product product =null;</div><div class="line">//如果Map中已经有这个对象</div><div class="line"><span class="keyword">if</span>(prMap.containsKey(<span class="built_in">type</span>))&#123;</div><div class="line">product = prMap.get(<span class="built_in">type</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(type.equals(<span class="string">"Product1"</span>))&#123;</div><div class="line">product = new ConcreteProduct1();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">product = new ConcreteProduct2();</div><div class="line">&#125;</div><div class="line">//同时把对象放到缓存容器中</div><div class="line">prMap.put(<span class="built_in">type</span>,product);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> product;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/2017/12/06/设计模式之禅/抽象1.png" alt=""><br>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：<br>（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）<br><img src="/2017/12/06/设计模式之禅/抽象工厂模式类图.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public abstract class AbstractCreator &#123;</div><div class="line">//创建A产品家族</div><div class="line">public abstract AbstractProductA createProductA();</div><div class="line">//创建B产品家族</div><div class="line">public abstract AbstractProductB createProductB();</div><div class="line">&#125;</div><div class="line">public class Creator1 extends AbstractCreator &#123;</div><div class="line">//只生产产品等级为1的A产品</div><div class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductA1();</div><div class="line">&#125;</div><div class="line">//只生产产品等级为1的B产品</div><div class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductB1();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务</p>
<h3 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h3><p>1.封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。<br>2.产品族内的约束为非公开状态。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码<br>为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序<br>有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><img src="/2017/12/06/设计模式之禅/模板1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/模板2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public abstract class HummerModel &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * 首先，这个模型要能发动起来，别管是手摇发动，还是电力发动，反正 是要能够发动起来，那这个实现要在实现类里了</div><div class="line">	 */</div><div class="line">	public abstract void start();</div><div class="line"></div><div class="line">	// 能发动，还要能停下来，那才是真本事</div><div class="line">	public abstract void stop();</div><div class="line"></div><div class="line">	// 喇叭会出声音，是滴滴叫，还是哔哔叫</div><div class="line">	public abstract void alarm();</div><div class="line"></div><div class="line">	// 引擎会轰隆隆地响，不响那是假的</div><div class="line">	public abstract void engineBoom();</div><div class="line"></div><div class="line">	// 那模型应该会跑吧，别管是人推的，还是电力驱动，总之要会跑</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		// 先发动汽车</div><div class="line">		this.start();</div><div class="line">		// 引擎开始轰鸣</div><div class="line">		this.engineBoom();</div><div class="line">		// 然后就开始跑了，跑的过程中遇到一条狗挡路，就按喇叭</div><div class="line">		this.alarm();</div><div class="line">		// 到达目的地就停车</div><div class="line">		this.stop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class HummerH1Model extends HummerModel&#123;</div><div class="line"></div><div class="line">	//H1型号的悍马车鸣笛</div><div class="line">	public void <span class="function"><span class="title">alarm</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1鸣笛..."</span>);</div><div class="line">	&#125;</div><div class="line">	//引擎轰鸣声</div><div class="line">	public void <span class="function"><span class="title">engineBoom</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1引擎声音是这样的..."</span>);</div><div class="line">	&#125;</div><div class="line">	//汽车发动</div><div class="line">	public void <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1发动..."</span>);</div><div class="line">	&#125;</div><div class="line">	//停车</div><div class="line">	public void <span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1停车..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/2017/12/06/设计模式之禅/模板4.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.封装不变的部分，扩展可变部分<br>2.提取公共部分代码，便于维护<br>3.行为由父类控制，子类实现</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h3 id="模板方法模式使用场景"><a href="#模板方法模式使用场景" class="headerlink" title="模板方法模式使用场景"></a>模板方法模式使用场景</h3><p>● 多个子类有公有的方法，并且逻辑基本相同时。<br>● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。<br>● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/2017/12/06/设计模式之禅/建造0.png" alt=""><br>建造者模式（Builder Pattern）也叫做生成器模式，其定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示<br><img src="/2017/12/06/设计模式之禅/建造1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/建造2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">		//独立业务处理</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Builder &#123;</div><div class="line">	// 设置产品的不同部分，以获得不同的产品</div><div class="line">	public abstract void <span class="built_in">set</span>Part();</div><div class="line"></div><div class="line">	// 建造产品</div><div class="line">	public abstract Product buildProduct();</div><div class="line">&#125;</div><div class="line">public class ConcreteProduct extends Builder &#123;</div><div class="line">	private Product product = new Product();</div><div class="line"></div><div class="line">	// 设置产品零件</div><div class="line">	public void <span class="function"><span class="title">setPart</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 产品类内的逻辑处理</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 组建一个产品</div><div class="line">	public Product <span class="function"><span class="title">buildProduct</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> product;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Director &#123;</div><div class="line">	private Builder builder = new ConcreteProduct();</div><div class="line"></div><div class="line">	// 构建不同的产品</div><div class="line">	public Product <span class="function"><span class="title">getAProduct</span></span>() &#123;</div><div class="line">		builder.setPart();</div><div class="line">		/*</div><div class="line">		 * 设置不同的零件，产生不同的产品</div><div class="line">		 */</div><div class="line">		<span class="built_in">return</span> builder.buildProduct();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>● 封装性<br>使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。<br>● 建造者独立，容易扩展<br>BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。<br>● 便于控制细节风险<br>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。<br>● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。<br>● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。<br>● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</p>
<p><em>建造者模式关注的是零件类型和装配工艺（顺序）</em>。建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义为：为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/2017/12/06/设计模式之禅/代理1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	public void request();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	//实现方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">	//业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Proxy implements Subject &#123;</div><div class="line"></div><div class="line">	// 要代理哪个实现类</div><div class="line">	private Subject subject = null;</div><div class="line"></div><div class="line">	// 默认被代理者</div><div class="line">	public <span class="function"><span class="title">Proxy</span></span>() &#123;</div><div class="line">		this.subject = new RealSubject();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过构造函数传递代理者</div><div class="line">	public Proxy(Object... objects) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 实现接口中定义的方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.before();</div><div class="line">		this.subject.request();</div><div class="line">		this.after();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 预处理</div><div class="line">	private void <span class="function"><span class="title">before</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 善后处理</div><div class="line">	private void <span class="function"><span class="title">after</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><img src="/2017/12/06/设计模式之禅/代理2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/代理3.png" alt=""><br>要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下前面的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/2017/12/06/设计模式之禅/原型1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PrototypeClass implements Cloneable&#123;</div><div class="line">//覆写父类Object方法</div><div class="line">@Override</div><div class="line">public PrototypeClass <span class="function"><span class="title">clone</span></span>()&#123;</div><div class="line">PrototypeClass prototypeClass = null;</div><div class="line">try &#123;</div><div class="line">prototypeClass = (PrototypeClass)super.clone();</div><div class="line">&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">//异常处理</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> prototypeClass;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>● 性能优良<br>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。<br>● 逃避构造函数的约束<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 资源优化场景<br>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>● 性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>● 一个对象多个修改者的场景<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable &#123;</div><div class="line">	// 定义一个私有变量</div><div class="line">	private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Thing <span class="function"><span class="title">clone</span></span>() &#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			thing.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用clone方法，类的成员变量上不要增加final关键字</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p><img src="/2017/12/06/设计模式之禅/中介者1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者3.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractMediator &#123;</div><div class="line">	protected Purchase purchase;</div><div class="line">	protected Sale sale;</div><div class="line">	protected Stock stock;</div><div class="line"></div><div class="line">	// 构造函数</div><div class="line">	public <span class="function"><span class="title">AbstractMediator</span></span>() &#123;</div><div class="line">		purchase = new Purchase(this);</div><div class="line">		sale = new Sale(this);</div><div class="line">		stock = new Stock(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中介者最重要的方法叫做事件方法，处理多个对象之间的关系</div><div class="line">	public abstract void execute(String str, Object... objects);</div><div class="line">&#125;</div><div class="line">public class Mediator extends AbstractMediator &#123;</div><div class="line">	// 中介者最重要的方法</div><div class="line">	public void execute(String str, Object... objects) &#123;</div><div class="line">		<span class="keyword">if</span> (str.equals(<span class="string">"purchase.buy"</span>)) &#123; // 采购电脑</div><div class="line">			this.buyComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.sell"</span>)) &#123; // 销售电脑</div><div class="line">			this.sellComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.offsell"</span>)) &#123; // 折价销售</div><div class="line">			this.offSell();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"stock.clear"</span>)) &#123; // 清仓处理</div><div class="line">			this.clearStock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购电脑</div><div class="line">	private void buyComputer(int number) &#123;</div><div class="line">		int saleStatus = super.sale.getSaleStatus();</div><div class="line">		<span class="keyword">if</span> (saleStatus &gt; 80) &#123; // 销售情况良好</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑:"</span> + number + <span class="string">"台"</span>);</div><div class="line">			super.stock.increase(number);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 销售情况不好</div><div class="line">			int buyNumber = number / 2; // 折半采购</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑："</span> + buyNumber + <span class="string">"台"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售电脑</div><div class="line">	private void sellComputer(int number) &#123;</div><div class="line">		<span class="keyword">if</span> (super.stock.getStockNumber() &lt; number) &#123; // 库存数量不够销售</div><div class="line">			super.purchase.buyIBMcomputer(number);</div><div class="line">		&#125;</div><div class="line">		super.stock.decrease(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价销售电脑</div><div class="line">	private void <span class="function"><span class="title">offSell</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"折价销售IBM电脑"</span> + stock.getStockNumber() + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清仓处理</div><div class="line">	private void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		// 要求清仓销售</div><div class="line">		super.sale.offSale();</div><div class="line">		// 要求采购人员不要采购</div><div class="line">		super.purchase.refuseBuyIBM();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class AbstractColleague &#123;</div><div class="line">	protected AbstractMediator mediator;</div><div class="line"></div><div class="line">	public AbstractColleague(AbstractMediator _mediator) &#123;</div><div class="line">		this.mediator = _mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Purchase extends AbstractColleague &#123;</div><div class="line">	public Purchase(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购IBM电脑</div><div class="line">	public void buyIBMcomputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"purchase.buy"</span>, number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 不再采购IBM电脑</div><div class="line">	public void <span class="function"><span class="title">refuseBuyIBM</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"不再采购IBM电脑"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Sale extends AbstractColleague &#123;</div><div class="line">	public Sale(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售IBM电脑</div><div class="line">	public void sellIBMComputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.sell"</span>, number);</div><div class="line">		System.out.println(<span class="string">"销售IBM电脑"</span> + number + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 反馈销售情况，0～100变化，0代表根本就没人买，100代表非常畅销，出一个卖一个</div><div class="line">	public int <span class="function"><span class="title">getSaleStatus</span></span>() &#123;</div><div class="line">		Random rand = new Random(System.currentTimeMillis());</div><div class="line">		int saleStatus = rand.nextInt(100);</div><div class="line">		System.out.println(<span class="string">"IBM电脑的销售情况为："</span> + saleStatus);</div><div class="line">		<span class="built_in">return</span> saleStatus;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价处理</div><div class="line">	public void <span class="function"><span class="title">offSale</span></span>() &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.offsell"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Stock extends AbstractColleague &#123;</div><div class="line">	public Stock(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 刚开始有100台电脑</div><div class="line">	private static int COMPUTER_NUMBER = 100;</div><div class="line"></div><div class="line">	// 库存增加</div><div class="line">	public void increase(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER + number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 库存降低</div><div class="line">	public void decrease(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER - number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得库存数量</div><div class="line">	public int <span class="function"><span class="title">getStockNumber</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> COMPUTER_NUMBER;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售</div><div class="line">	public void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"清理存货数量为："</span> + COMPUTER_NUMBER);</div><div class="line">		super.mediator.execute(<span class="string">"stock.clear"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/2017/12/06/设计模式之禅/中介者4.png" alt=""><br>● Mediator 抽象中介者角色<br>抽象中介者角色定义统一的接口，用于各同事角色之间的通信。<br>● Concrete Mediator 具体中介者角色<br>具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。<br>● Colleague 同事角色<br>每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/02/java8/" rel="next" title="java8">
                <i class="fa fa-chevron-left"></i> java8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计原则"><span class="nav-number">1.</span> <span class="nav-text">设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一职责-SRP"><span class="nav-number">1.1.</span> <span class="nav-text">单一职责(SRP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#里氏替换原则-LSP"><span class="nav-number">1.2.</span> <span class="nav-text">里氏替换原则(LSP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖倒置原则（DIP）"><span class="nav-number">1.3.</span> <span class="nav-text">依赖倒置原则（DIP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口隔离原则-ISP"><span class="nav-number">1.4.</span> <span class="nav-text">接口隔离原则(ISP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迪米特法则"><span class="nav-number">1.5.</span> <span class="nav-text">迪米特法则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开闭原则-DIP"><span class="nav-number">1.6.</span> <span class="nav-text">开闭原则(DIP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合成复用原则"><span class="nav-number">1.7.</span> <span class="nav-text">合成复用原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">2.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">2.1.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例的优点"><span class="nav-number">2.1.1.</span> <span class="nav-text">单例的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">2.1.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">2.1.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.2.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式优点："><span class="nav-number">2.2.1.</span> <span class="nav-text">工厂方法模式优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法的扩展"><span class="nav-number">2.2.2.</span> <span class="nav-text">工厂方法的扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">2.3.</span> <span class="nav-text">抽象工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式的优点"><span class="nav-number">2.3.1.</span> <span class="nav-text">抽象工厂模式的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板方法模式"><span class="nav-number">2.4.</span> <span class="nav-text">模板方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">2.4.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板方法模式使用场景"><span class="nav-number">2.4.4.</span> <span class="nav-text">模板方法模式使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建造者模式"><span class="nav-number">2.5.</span> <span class="nav-text">建造者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-1"><span class="nav-number">2.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-number">2.6.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理"><span class="nav-number">2.6.1.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">2.7.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-2"><span class="nav-number">2.7.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-2"><span class="nav-number">2.7.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝和深拷贝"><span class="nav-number">2.7.3.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中介者模式"><span class="nav-number">2.8.</span> <span class="nav-text">中介者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">2.8.1.</span> <span class="nav-text">定义</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
