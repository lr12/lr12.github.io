<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="设计模式," />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之禅">
<meta property="og:url" content="http://yoursite.com/2017/12/06/设计模式之禅/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责2.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责2.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责3.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责3.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/里氏替换1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/依赖倒置1.3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/接口隔离原则1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/接口隔离原则1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特2.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迪米特2.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/开闭1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/开闭1.2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/工厂模式1.1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/工厂模式通用类图.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/多个工厂类.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/抽象1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/抽象工厂模式类图.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/模板4.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造0.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/建造2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/代理3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/原型1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者2.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者3.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/中介者4.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/命令1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/责任.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/装饰1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/策略1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/适配器1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/迭代器1.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/组合模式.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/观察者模式.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/门面.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/备忘录.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/访问.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/解释器.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/享元模式.png">
<meta property="og:image" content="http://yoursite.com/2017/12/06/设计模式之禅/桥梁.png">
<meta property="og:updated_time" content="2017-12-11T08:02:44.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式之禅">
<meta name="twitter:description" content="设计原则单一职责(SRP)单一职责原则的定义是：应该有且仅有一个原因引起类的变更.单一职责的优点：  类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。  里氏替换原则(LSP)继承的优点：  代码共享，减少创建类">
<meta name="twitter:image" content="http://yoursite.com/2017/12/06/设计模式之禅/单一职责1.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/06/设计模式之禅/"/>





  <title>设计模式之禅 | 博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/设计模式之禅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式之禅</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T23:21:46+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一职责-SRP"><a href="#单一职责-SRP" class="headerlink" title="单一职责(SRP)"></a>单一职责(SRP)</h2><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更.<br><img src="/2017/12/06/设计模式之禅/单一职责1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责2.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/单一职责3.2.png" alt=""><br>单一职责的优点：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义</li>
<li>可读性提高</li>
<li>可维护性提高</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>继承的优点：</p>
<ul>
<li>代码共享，减少创建类的工作量</li>
<li>提高代码的重用性</li>
<li>提高代码的扩展性</li>
<li>提高产品和项目的开放性<br>缺点：</li>
<li>继承是侵入性的，拥有父类的所有方法和属性</li>
<li>降低代码的灵活性</li>
<li>增强了耦合性</li>
</ul>
<p>里氏替换定义<br>定义一：如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。<br>定义二：所有引用基类的地方都必须能透明的引用其子类对象。第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。<br>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义:</p>
<ol>
<li>子类必须完全实现父类的方法<br><img src="/2017/12/06/设计模式之禅/里氏替换1.1.png" alt=""><br>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
<li>子类可以有自己个性<br>子类当然可以有自己的行为和外观了，也就是方法和属性。但是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</li>
<li>覆盖或实现父类的方法时输入参数可以被放大<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">public Collection <span class="keyword">do</span>Something(HashMap map)&#123;</div><div class="line">System.out.println(<span class="string">"父类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Son extends Father &#123;</div><div class="line">//放大输入参数类型</div><div class="line">public Collection <span class="keyword">do</span>Something(Map map)&#123;</div><div class="line">System.out.println(<span class="string">"子类被执行..."</span>);</div><div class="line"><span class="built_in">return</span> map.values();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Father f = new Father();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div><div class="line">Son f =new Son();</div><div class="line">HashMap map = new HashMap();</div><div class="line">f.doSomething(map);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>与父类的方法名相同，但又不是覆写（Override）父类的方法。是重载（Overload）。用子类替换父类，子类代替父类传递到调用者中，子类的方法永远都不会被执行。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。<br>如果你把父类参数放宽变为map，子类的参数变为Hashmap，根据里氏替换子类替换父类，子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</p>
<ol>
<li>覆盖或实现父类方法输出结果可以被缩小<br>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的</li>
</ol>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。依赖倒置原则在Java语言中的表现就是：<br>● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过<br>接口或抽象类产生的；<br>● 接口或抽象类不依赖于实现类；<br>● 实现类依赖接口或抽象类<br>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设<br>计）的精髓之一<br><img src="/2017/12/06/设计模式之禅/依赖倒置1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/依赖倒置1.3.png" alt=""><br>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，<br>不互相影响，实现模块间的松耦合。只要遵循以下几个规则</p>
<ul>
<li>每个类都尽量有抽象类或者接口</li>
<li>表面类型尽量是接口或者抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆盖父类的方法</li>
<li>结合里氏替换原则使用</li>
</ul>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><p><img src="/2017/12/06/设计模式之禅/接口隔离原则1.1.png" alt=""><br>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探<br>AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。<br>接口隔离原则包含四层含义：</p>
<ul>
<li>接口要尽量小<br>是接口隔离原则的核心定义，不出现臃肿的接口。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</li>
<li>接口要高内聚<br>具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li>
<li>定制服务<br>定制服务就是单独为一个个体提供优良的服务。<br><img src="/2017/12/06/设计模式之禅/接口隔离原则1.2.png" alt=""></li>
<li>接口设计时有粒度的<br>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构<br>的复杂化，开发难度增加，可维护性降低。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多的public方法，我就调用这么多，其他的我一概不关心。</p>
<ol>
<li>只和朋友类交流<br>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类<br><img src="/2017/12/06/设计模式之禅/迪米特1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特1.2.png" alt=""><br>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象</li>
<li>朋友间也是有距离的<br><img src="/2017/12/06/设计模式之禅/迪米特2.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/迪米特2.2.png" alt=""></li>
<li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ol>
<h2 id="开闭原则-DIP"><a href="#开闭原则-DIP" class="headerlink" title="开闭原则(DIP)"></a>开闭原则(DIP)</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br><img src="/2017/12/06/设计模式之禅/开闭1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/开闭1.2.png" alt=""><br>开闭的好处:</p>
<ol>
<li>开闭对测试有影响</li>
<li>提高复用性</li>
<li>可以提高可维护性</li>
<li>面向对象开发要求</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下：<br>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。<br>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。<br>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。<br>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）<br>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。<br>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h3><ul>
<li>由于单例模式在内存只有一个实例，减少了内存的开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁的性能又无法优化时，单例模式的优势非常明显</li>
<li>由于单例只生成一个实例，较少了系统性能开销，当一个对象产生需要比较多的资源时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>单例模式一般没有接口，扩展很困难</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li>
<li>单例模式与单一职责原则有冲突。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">	private static  volatile Singleton singleton;</div><div class="line"></div><div class="line">	private <span class="function"><span class="title">Singleton</span></span>()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">		<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">			synchronized (this) &#123;</div><div class="line">				<span class="keyword">if</span>(singleton==null)&#123;</div><div class="line">					singleton=new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Human &#123;</div><div class="line"></div><div class="line">	public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123;</div><div class="line">		Human human=(Human) Class.forName(c.getName()).newInstance();</div><div class="line">		<span class="built_in">return</span> (T) human;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/06/设计模式之禅/工厂模式1.1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/工厂模式通用类图.png" alt=""></p>
<h3 id="工厂方法模式优点："><a href="#工厂方法模式优点：" class="headerlink" title="工厂方法模式优点："></a>工厂方法模式优点：</h3><ul>
<li>良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。</li>
<li>屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li>
<li>工厂方法模式是典型的解耦框架。</li>
</ul>
<h3 id="工厂方法的扩展"><a href="#工厂方法的扩展" class="headerlink" title="工厂方法的扩展"></a>工厂方法的扩展</h3><ol>
<li>缩小为简单工厂模式一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了</li>
<li>多个工厂类<br><img src="/2017/12/06/设计模式之禅/多个工厂类.png" alt=""></li>
<li><p>替代单例模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SingletonFactory &#123;</div><div class="line">private static Singleton singleton;</div><div class="line"> static&#123;</div><div class="line">  try &#123;</div><div class="line">    Class cl= Class.forName(Singleton.class.getName());</div><div class="line">    //获得无参构造</div><div class="line">    Constructor constructor=cl.getDeclaredConstructor();</div><div class="line">    //设置无参构造是可访问的</div><div class="line">    constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">    //产生一个实例对象</div><div class="line">    singleton = (Singleton)constructor.newInstance();</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">    //异常处理</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> public static Singleton <span class="function"><span class="title">getSingleton</span></span>()&#123;</div><div class="line">  <span class="built_in">return</span> singleton;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>延迟初始化<br>一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ProductFactory &#123;</div><div class="line">private static final Map&lt;String,Product&gt; prMap = new HashMap();</div><div class="line">public static synchronized Product createProduct(String <span class="built_in">type</span>) throws Exception&#123;</div><div class="line">Product product =null;</div><div class="line">//如果Map中已经有这个对象</div><div class="line"><span class="keyword">if</span>(prMap.containsKey(<span class="built_in">type</span>))&#123;</div><div class="line">product = prMap.get(<span class="built_in">type</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(type.equals(<span class="string">"Product1"</span>))&#123;</div><div class="line">product = new ConcreteProduct1();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">product = new ConcreteProduct2();</div><div class="line">&#125;</div><div class="line">//同时把对象放到缓存容器中</div><div class="line">prMap.put(<span class="built_in">type</span>,product);</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> product;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/2017/12/06/设计模式之禅/抽象1.png" alt=""><br>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：<br>（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）<br><img src="/2017/12/06/设计模式之禅/抽象工厂模式类图.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public abstract class AbstractCreator &#123;</div><div class="line">//创建A产品家族</div><div class="line">public abstract AbstractProductA createProductA();</div><div class="line">//创建B产品家族</div><div class="line">public abstract AbstractProductB createProductB();</div><div class="line">&#125;</div><div class="line">public class Creator1 extends AbstractCreator &#123;</div><div class="line">//只生产产品等级为1的A产品</div><div class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductA1();</div><div class="line">&#125;</div><div class="line">//只生产产品等级为1的B产品</div><div class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> new ProductB1();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务</p>
<h3 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h3><p>1.封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。<br>2.产品族内的约束为非公开状态。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码<br>为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序<br>有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><img src="/2017/12/06/设计模式之禅/模板1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/模板2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public abstract class HummerModel &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * 首先，这个模型要能发动起来，别管是手摇发动，还是电力发动，反正 是要能够发动起来，那这个实现要在实现类里了</div><div class="line">	 */</div><div class="line">	public abstract void start();</div><div class="line"></div><div class="line">	// 能发动，还要能停下来，那才是真本事</div><div class="line">	public abstract void stop();</div><div class="line"></div><div class="line">	// 喇叭会出声音，是滴滴叫，还是哔哔叫</div><div class="line">	public abstract void alarm();</div><div class="line"></div><div class="line">	// 引擎会轰隆隆地响，不响那是假的</div><div class="line">	public abstract void engineBoom();</div><div class="line"></div><div class="line">	// 那模型应该会跑吧，别管是人推的，还是电力驱动，总之要会跑</div><div class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">		// 先发动汽车</div><div class="line">		this.start();</div><div class="line">		// 引擎开始轰鸣</div><div class="line">		this.engineBoom();</div><div class="line">		// 然后就开始跑了，跑的过程中遇到一条狗挡路，就按喇叭</div><div class="line">		this.alarm();</div><div class="line">		// 到达目的地就停车</div><div class="line">		this.stop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class HummerH1Model extends HummerModel&#123;</div><div class="line"></div><div class="line">	//H1型号的悍马车鸣笛</div><div class="line">	public void <span class="function"><span class="title">alarm</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1鸣笛..."</span>);</div><div class="line">	&#125;</div><div class="line">	//引擎轰鸣声</div><div class="line">	public void <span class="function"><span class="title">engineBoom</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1引擎声音是这样的..."</span>);</div><div class="line">	&#125;</div><div class="line">	//汽车发动</div><div class="line">	public void <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1发动..."</span>);</div><div class="line">	&#125;</div><div class="line">	//停车</div><div class="line">	public void <span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line">	System.out.println(<span class="string">"悍马H1停车..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/2017/12/06/设计模式之禅/模板4.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.封装不变的部分，扩展可变部分<br>2.提取公共部分代码，便于维护<br>3.行为由父类控制，子类实现</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h3 id="模板方法模式使用场景"><a href="#模板方法模式使用场景" class="headerlink" title="模板方法模式使用场景"></a>模板方法模式使用场景</h3><p>● 多个子类有公有的方法，并且逻辑基本相同时。<br>● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。<br>● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/2017/12/06/设计模式之禅/建造0.png" alt=""><br>建造者模式（Builder Pattern）也叫做生成器模式，其定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示<br><img src="/2017/12/06/设计模式之禅/建造1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/建造2.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">		//独立业务处理</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Builder &#123;</div><div class="line">	// 设置产品的不同部分，以获得不同的产品</div><div class="line">	public abstract void <span class="built_in">set</span>Part();</div><div class="line"></div><div class="line">	// 建造产品</div><div class="line">	public abstract Product buildProduct();</div><div class="line">&#125;</div><div class="line">public class ConcreteProduct extends Builder &#123;</div><div class="line">	private Product product = new Product();</div><div class="line"></div><div class="line">	// 设置产品零件</div><div class="line">	public void <span class="function"><span class="title">setPart</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 产品类内的逻辑处理</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 组建一个产品</div><div class="line">	public Product <span class="function"><span class="title">buildProduct</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> product;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Director &#123;</div><div class="line">	private Builder builder = new ConcreteProduct();</div><div class="line"></div><div class="line">	// 构建不同的产品</div><div class="line">	public Product <span class="function"><span class="title">getAProduct</span></span>() &#123;</div><div class="line">		builder.setPart();</div><div class="line">		/*</div><div class="line">		 * 设置不同的零件，产生不同的产品</div><div class="line">		 */</div><div class="line">		<span class="built_in">return</span> builder.buildProduct();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>● 封装性<br>使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。<br>● 建造者独立，容易扩展<br>BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。<br>● 便于控制细节风险<br>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。<br>● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。<br>● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。<br>● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</p>
<p><em>建造者模式关注的是零件类型和装配工艺（顺序）</em>。建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义为：为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/2017/12/06/设计模式之禅/代理1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line"></div><div class="line">	public void request();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class RealSubject implements Subject &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	//实现方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">	//业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Proxy implements Subject &#123;</div><div class="line"></div><div class="line">	// 要代理哪个实现类</div><div class="line">	private Subject subject = null;</div><div class="line"></div><div class="line">	// 默认被代理者</div><div class="line">	public <span class="function"><span class="title">Proxy</span></span>() &#123;</div><div class="line">		this.subject = new RealSubject();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过构造函数传递代理者</div><div class="line">	public Proxy(Object... objects) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 实现接口中定义的方法</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.before();</div><div class="line">		this.subject.request();</div><div class="line">		this.after();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 预处理</div><div class="line">	private void <span class="function"><span class="title">before</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 善后处理</div><div class="line">	private void <span class="function"><span class="title">after</span></span>() &#123;</div><div class="line">		// <span class="keyword">do</span> something</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><img src="/2017/12/06/设计模式之禅/代理2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/代理3.png" alt=""><br>要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下前面的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/2017/12/06/设计模式之禅/原型1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PrototypeClass implements Cloneable&#123;</div><div class="line">//覆写父类Object方法</div><div class="line">@Override</div><div class="line">public PrototypeClass <span class="function"><span class="title">clone</span></span>()&#123;</div><div class="line">PrototypeClass prototypeClass = null;</div><div class="line">try &#123;</div><div class="line">prototypeClass = (PrototypeClass)super.clone();</div><div class="line">&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">//异常处理</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> prototypeClass;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>● 性能优良<br>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。<br>● 逃避构造函数的约束<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 资源优化场景<br>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>● 性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>● 一个对象多个修改者的场景<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable &#123;</div><div class="line">	// 定义一个私有变量</div><div class="line">	private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Thing <span class="function"><span class="title">clone</span></span>() &#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			thing.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用clone方法，类的成员变量上不要增加final关键字</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p><img src="/2017/12/06/设计模式之禅/中介者1.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者2.png" alt=""><br><img src="/2017/12/06/设计模式之禅/中介者3.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractMediator &#123;</div><div class="line">	protected Purchase purchase;</div><div class="line">	protected Sale sale;</div><div class="line">	protected Stock stock;</div><div class="line"></div><div class="line">	// 构造函数</div><div class="line">	public <span class="function"><span class="title">AbstractMediator</span></span>() &#123;</div><div class="line">		purchase = new Purchase(this);</div><div class="line">		sale = new Sale(this);</div><div class="line">		stock = new Stock(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中介者最重要的方法叫做事件方法，处理多个对象之间的关系</div><div class="line">	public abstract void execute(String str, Object... objects);</div><div class="line">&#125;</div><div class="line">public class Mediator extends AbstractMediator &#123;</div><div class="line">	// 中介者最重要的方法</div><div class="line">	public void execute(String str, Object... objects) &#123;</div><div class="line">		<span class="keyword">if</span> (str.equals(<span class="string">"purchase.buy"</span>)) &#123; // 采购电脑</div><div class="line">			this.buyComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.sell"</span>)) &#123; // 销售电脑</div><div class="line">			this.sellComputer((Integer) objects[0]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"sale.offsell"</span>)) &#123; // 折价销售</div><div class="line">			this.offSell();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">"stock.clear"</span>)) &#123; // 清仓处理</div><div class="line">			this.clearStock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购电脑</div><div class="line">	private void buyComputer(int number) &#123;</div><div class="line">		int saleStatus = super.sale.getSaleStatus();</div><div class="line">		<span class="keyword">if</span> (saleStatus &gt; 80) &#123; // 销售情况良好</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑:"</span> + number + <span class="string">"台"</span>);</div><div class="line">			super.stock.increase(number);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 销售情况不好</div><div class="line">			int buyNumber = number / 2; // 折半采购</div><div class="line">			System.out.println(<span class="string">"采购IBM电脑："</span> + buyNumber + <span class="string">"台"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售电脑</div><div class="line">	private void sellComputer(int number) &#123;</div><div class="line">		<span class="keyword">if</span> (super.stock.getStockNumber() &lt; number) &#123; // 库存数量不够销售</div><div class="line">			super.purchase.buyIBMcomputer(number);</div><div class="line">		&#125;</div><div class="line">		super.stock.decrease(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价销售电脑</div><div class="line">	private void <span class="function"><span class="title">offSell</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"折价销售IBM电脑"</span> + stock.getStockNumber() + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清仓处理</div><div class="line">	private void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		// 要求清仓销售</div><div class="line">		super.sale.offSale();</div><div class="line">		// 要求采购人员不要采购</div><div class="line">		super.purchase.refuseBuyIBM();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class AbstractColleague &#123;</div><div class="line">	protected AbstractMediator mediator;</div><div class="line"></div><div class="line">	public AbstractColleague(AbstractMediator _mediator) &#123;</div><div class="line">		this.mediator = _mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Purchase extends AbstractColleague &#123;</div><div class="line">	public Purchase(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 采购IBM电脑</div><div class="line">	public void buyIBMcomputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"purchase.buy"</span>, number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 不再采购IBM电脑</div><div class="line">	public void <span class="function"><span class="title">refuseBuyIBM</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"不再采购IBM电脑"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Sale extends AbstractColleague &#123;</div><div class="line">	public Sale(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 销售IBM电脑</div><div class="line">	public void sellIBMComputer(int number) &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.sell"</span>, number);</div><div class="line">		System.out.println(<span class="string">"销售IBM电脑"</span> + number + <span class="string">"台"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 反馈销售情况，0～100变化，0代表根本就没人买，100代表非常畅销，出一个卖一个</div><div class="line">	public int <span class="function"><span class="title">getSaleStatus</span></span>() &#123;</div><div class="line">		Random rand = new Random(System.currentTimeMillis());</div><div class="line">		int saleStatus = rand.nextInt(100);</div><div class="line">		System.out.println(<span class="string">"IBM电脑的销售情况为："</span> + saleStatus);</div><div class="line">		<span class="built_in">return</span> saleStatus;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 折价处理</div><div class="line">	public void <span class="function"><span class="title">offSale</span></span>() &#123;</div><div class="line">		super.mediator.execute(<span class="string">"sale.offsell"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Stock extends AbstractColleague &#123;</div><div class="line">	public Stock(AbstractMediator _mediator) &#123;</div><div class="line">		super(_mediator);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 刚开始有100台电脑</div><div class="line">	private static int COMPUTER_NUMBER = 100;</div><div class="line"></div><div class="line">	// 库存增加</div><div class="line">	public void increase(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER + number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 库存降低</div><div class="line">	public void decrease(int number) &#123;</div><div class="line">		COMPUTER_NUMBER = COMPUTER_NUMBER - number;</div><div class="line">		System.out.println(<span class="string">"库存数量为："</span> + COMPUTER_NUMBER);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得库存数量</div><div class="line">	public int <span class="function"><span class="title">getStockNumber</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> COMPUTER_NUMBER;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售</div><div class="line">	public void <span class="function"><span class="title">clearStock</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"清理存货数量为："</span> + COMPUTER_NUMBER);</div><div class="line">		super.mediator.execute(<span class="string">"stock.clear"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/2017/12/06/设计模式之禅/中介者4.png" alt=""><br>● Mediator 抽象中介者角色<br>抽象中介者角色定义统一的接口，用于各同事角色之间的通信。<br>● Concrete Mediator 具体中介者角色<br>具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。<br>● Colleague 同事角色<br>每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br><img src="/2017/12/06/设计模式之禅/命令1.png" alt=""><br>Receive接收者角色<br>该角色就是干活的角色，命令传递到这里是应该被执行的。<br>● Command命令角色<br>需要执行的所有命令都在这里声明。<br>● Invoker调用者角色<br>接收到命令，并执行命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public abstract class Receiver &#123;</div><div class="line">	// 抽象接收者，定义每个接收者都必须完成的业务</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteReciver1 extends Receiver &#123;</div><div class="line">	// 每个接收者都必须处理一定的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"ConcreteReciver1:dosomething"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Command &#123;</div><div class="line">	// 每个命令类都必须有一个执行命令的方法</div><div class="line">	public abstract void execute();</div><div class="line">&#125;</div><div class="line">public class ConcreteCommand1 extends Command &#123;</div><div class="line">	// 对哪个Receiver类进行命令处理</div><div class="line">	private Receiver receiver;</div><div class="line"></div><div class="line">	// 构造函数传递接收者</div><div class="line">	public ConcreteCommand1(Receiver _receiver) &#123;</div><div class="line">		this.receiver = _receiver;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 必须实现一个命令</div><div class="line">	public void <span class="function"><span class="title">execute</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">		this.receiver.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Invoker &#123;</div><div class="line">	private Command <span class="built_in">command</span>;</div><div class="line"></div><div class="line">	// 受气包，接受命令</div><div class="line">	public void <span class="built_in">set</span>Command(Command _command) &#123;</div><div class="line">		this.command = _command;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 执行命令</div><div class="line">	public void <span class="function"><span class="title">action</span></span>() &#123;</div><div class="line">		this.command.execute();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 首先声明调用者Invoker</div><div class="line">		Invoker invoker = new Invoker();</div><div class="line">		// 定义接收者</div><div class="line">		Receiver receiver = new ConcreteReciver1();</div><div class="line">		// 定义一个发送给接收者的命令</div><div class="line">		Command <span class="built_in">command</span> = new ConcreteCommand1(receiver);</div><div class="line">		// 把命令交给调用者去执行</div><div class="line">		invoker.setCommand(<span class="built_in">command</span>);</div><div class="line">		invoker.action();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>● 类间解耦<br>调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。<br>● 可扩展性<br>Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。<br>● 命令模式结合其他模式会更优秀<br>命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。<br><img src="/2017/12/06/设计模式之禅/责任.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Level &#123;</div><div class="line">	// 定义一个请求和处理等级</div><div class="line">&#125;</div><div class="line">public class Request &#123;</div><div class="line">	// 请求的等级</div><div class="line">	public Level <span class="function"><span class="title">getRequestLevel</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Response &#123;</div><div class="line">	// 处理者返回的数据</div><div class="line">&#125;</div><div class="line">public abstract class Handler &#123;</div><div class="line">	private Handler nextHandler;</div><div class="line"></div><div class="line">	// 每个处理者都必须对请求做出处理</div><div class="line">	public final Response handleMessage(Request request) &#123;</div><div class="line">		Response response = null;</div><div class="line">		// 判断是否是自己的处理级别</div><div class="line">		<span class="keyword">if</span> (this.getHandlerLevel().equals(request.getRequestLevel())) &#123;</div><div class="line">			response = this.echo(request);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; // 不属于自己的处理级别</div><div class="line">		// 判断是否有下一个处理者</div><div class="line">			<span class="keyword">if</span> (this.nextHandler != null) &#123;</div><div class="line">				response = this.nextHandler.handleMessage(request);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				// 没有适当的处理者，业务自行处理</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> response;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置下一个处理者是谁</div><div class="line">	public void <span class="built_in">set</span>Next(Handler _handler) &#123;</div><div class="line">		this.nextHandler = _handler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 每个处理者都有一个处理级别</div><div class="line">	protected abstract Level getHandlerLevel();</div><div class="line"></div><div class="line">	// 每个处理者都必须实现处理任务</div><div class="line">	protected abstract Response <span class="built_in">echo</span>(Request request);</div><div class="line">&#125;</div><div class="line">public class ConcreteHandler1 extends Handler &#123;</div><div class="line">	// 定义自己的处理逻辑</div><div class="line">	protected Response <span class="built_in">echo</span>(Request request) &#123;</div><div class="line">		// 完成处理逻辑</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置自己的处理级别</div><div class="line">	protected Level <span class="function"><span class="title">getHandlerLevel</span></span>() &#123;</div><div class="line">		// 设置自己的处理级别</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><p>责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活<br><img src="/2017/12/06/设计模式之禅/装饰1.png" alt=""><br>● Component抽象构件<br>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当<br>Component抽象构件。<br>● ConcreteComponent 具体构件<br>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。<br>● Decorator装饰角色<br>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。<br>● 具体装饰角色<br>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 抽象的方法</div><div class="line">	public abstract void operate();</div><div class="line">&#125;</div><div class="line">public class ConcreteComponent extends Component &#123;</div><div class="line">	// 具体实现</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"do Something"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public abstract class Decorator extends Component &#123;</div><div class="line">	private Component component = null;</div><div class="line"></div><div class="line">	// 通过构造函数传递被修饰者</div><div class="line">	public Decorator(Component _component) &#123;</div><div class="line">		this.component = _component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 委托给被修饰者执行</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.component.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteDecorator1 extends Decorator &#123;</div><div class="line">	// 定义被修饰者</div><div class="line">	public ConcreteDecorator1(Component _component) &#123;</div><div class="line">		super(_component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义自己的修饰方法</div><div class="line">	private void <span class="function"><span class="title">method1</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"method1 修饰"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 重写父类的Operation方法</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		this.method1();</div><div class="line">		super.operate();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Component component = new ConcreteComponent();</div><div class="line">		//第一次修饰</div><div class="line">		component = new ConcreteDecorator1(component);</div><div class="line">		component.operate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><p>● 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道 Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。<br>● 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。<br>● 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如<br>此。</p>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>多层的装饰是比较复杂的</p>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>● 需要扩展一个类的功能，或给一个类增加附加功能。<br>● 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。<br>● 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。<br><img src="/2017/12/06/设计模式之禅/策略1.png" alt=""><br>● Context封装角色<br>它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。<br>● Strategy抽象策略角色<br>策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。<br>● ConcreteStrategy具体策略角色<br>实现抽象策略中的操作，该类含有具体的算法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">	// 策略模式的运算法则</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"具体策略1的运算法则"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 抽象策略</div><div class="line">	private Strategy strategy = null;</div><div class="line"></div><div class="line">	// 构造函数设置具体策略</div><div class="line">	public Context(Strategy _strategy) &#123;</div><div class="line">		this.strategy = _strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 封装后的策略方法</div><div class="line">	public void <span class="function"><span class="title">doAnythinig</span></span>() &#123;</div><div class="line">		this.strategy.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 声明一个具体的策略</div><div class="line">		Strategy strategy = new ConcreteStrategy1();</div><div class="line">		// 声明上下文对象</div><div class="line">		Context context = new Context(strategy);</div><div class="line">		// 执行封装后的方法</div><div class="line">		context.doAnythinig();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><p>● 算法可以自由切换<br>这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。<br>● 避免使用多重条件判断<br>如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</p>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><p>● 策略类数量增多<br>每一个策略都是一个类，复用的可能性很小，类数量增多。<br>● 所有的策略类都需要对外暴露<br>上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式</p>
<h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>● 多个类只有在算法或行为上稍有不同的场景。<br>● 算法需要自由切换的场景。<br>● 需要屏蔽算法规则的场景。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。<br><img src="/2017/12/06/设计模式之禅/适配器1.png" alt=""><br>● Target目标角色<br>该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口就是目标角色。<br>● Adaptee源角色<br>你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。<br>● Adapter适配器角色<br>适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Target &#123;</div><div class="line">	// 目标角色有自己的方法</div><div class="line">	public void request();</div><div class="line">&#125;</div><div class="line">public class ConcreteTarget implements Target &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(<span class="string">"if you need any help,pls call me!"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Adaptee &#123;</div><div class="line">	// 原有的业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"I'm kind of busy,leave me alone,pls!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Adapter extends Adaptee implements Target &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		super.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 原有的业务逻辑</div><div class="line">		Target target = new ConcreteTarget();</div><div class="line">		target.request();</div><div class="line">		// 现在增加了适配器角色后的业务逻辑</div><div class="line">		Target target2 = new Adapter();</div><div class="line">		target2.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><p>● 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。<br>● 增加了类的透明性<br>想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。<br>● 提高了类的复用度<br>当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员<br>● 灵活性非常好<br>某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</p>
<h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>适配器应用的场景只要记住一点就足够了：比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节<br><img src="/2017/12/06/设计模式之禅/迭代器1.png" alt=""><br>● Iterator抽象迭代器<br>抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法：first获得第一个元素，next访问下一个元素，isDone是否已经访问到底部。<br>● ConcreteIterator具体迭代器<br>具体迭代器角色要实现迭代器接口，完成容器元素的遍历。<br>● Aggregate抽象容器<br>容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator这样的方法，在Java中一般是iterator方法。<br>● Concrete Aggregate具体容器<br>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">	// 遍历到下一个元素</div><div class="line">	public Object next();</div><div class="line"></div><div class="line">	// 是否已经遍历到尾部</div><div class="line">	public boolean hasNext();</div><div class="line"></div><div class="line">	// 删除当前指向的元素</div><div class="line">	public boolean remove();</div><div class="line">&#125;</div><div class="line">public class ConcreteIterator implements Iterator &#123;</div><div class="line"></div><div class="line">	private Vector vector = new Vector();</div><div class="line">	// 定义当前游标</div><div class="line">	public int cursor = 0;</div><div class="line"></div><div class="line">	@SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">	public ConcreteIterator(Vector _vector) &#123;</div><div class="line">		this.vector = _vector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否到达尾部</div><div class="line">	public boolean <span class="function"><span class="title">hasNext</span></span>() &#123;</div><div class="line">		<span class="keyword">if</span> (this.cursor == this.vector.size()) &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回下一个元素</div><div class="line">	public Object <span class="function"><span class="title">next</span></span>() &#123;</div><div class="line">		Object result = null;</div><div class="line">		<span class="keyword">if</span> (this.hasNext()) &#123;</div><div class="line">			result = this.vector.get(this.cursor++);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			result = null;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除当前元素</div><div class="line">	public boolean <span class="function"><span class="title">remove</span></span>() &#123;</div><div class="line">		this.vector.remove(this.cursor);</div><div class="line">		<span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public interface Aggregate &#123;</div><div class="line"></div><div class="line">	// 是容器必然有元素的增加</div><div class="line">	public void add(Object object);</div><div class="line"></div><div class="line">	// 减少元素</div><div class="line">	public void remove(Object object);</div><div class="line"></div><div class="line">	// 由迭代器来遍历所有的元素</div><div class="line">	public Iterator iterator();</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class ConcreteAggregate implements Aggregate &#123;</div><div class="line"></div><div class="line">	// 容纳对象的容器</div><div class="line">	private Vector vector = new Vector();</div><div class="line"></div><div class="line">	// 增加一个元素</div><div class="line">	public void add(Object object) &#123;</div><div class="line">		this.vector.add(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 返回迭代器对象</div><div class="line">	public Iterator <span class="function"><span class="title">iterator</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new ConcreteIterator(this.vector);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个元素</div><div class="line">	public void remove(Object object) &#123;</div><div class="line">		this.remove(object);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性<br><img src="/2017/12/06/设计模式之禅/组合模式.png" alt=""><br>● Component抽象构件角色<br>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>● Leaf叶子构件<br>叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>● Composite树枝构件<br>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	// 个体和整体都具有的共享</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 编写业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Composite extends Component &#123;</div><div class="line">	// 构件容器</div><div class="line">	private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</div><div class="line"></div><div class="line">	// 增加一个叶子构件或树枝构件</div><div class="line">	public void add(Component component) &#123;</div><div class="line">		this.componentArrayList.add(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个叶子构件或树枝构件</div><div class="line">	public void remove(Component component) &#123;</div><div class="line">		this.componentArrayList.remove(component);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得分支下的所有叶子构件和树枝构件</div><div class="line">	public ArrayList&lt;Component&gt; <span class="function"><span class="title">getChildren</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> this.componentArrayList;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Leaf extends Component &#123;</div><div class="line">	/*</div><div class="line">	 * 可以覆写父类方法 public void <span class="function"><span class="title">doSomething</span></span>()&#123;</div><div class="line">	 *</div><div class="line">	 * &#125;</div><div class="line">	 */</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个根节点</div><div class="line">		Composite root = new Composite();</div><div class="line">		root.doSomething();</div><div class="line">		// 创建一个树枝构件</div><div class="line">		Composite branch = new Composite();</div><div class="line">		// 创建一个叶子节点</div><div class="line">		Leaf leaf = new Leaf();</div><div class="line">		// 建立整体</div><div class="line">		root.add(branch);</div><div class="line">		branch.add(leaf);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通过递归遍历树</div><div class="line">	public static void display(Composite root) &#123;</div><div class="line">		<span class="keyword">for</span> (Component c : root.getChildren()) &#123;</div><div class="line">			<span class="keyword">if</span> (c instanceof Leaf) &#123; // 叶子节点</div><div class="line">				c.doSomething();</div><div class="line">			&#125; <span class="keyword">else</span> &#123; // 树枝节点</div><div class="line">				display((Composite) c);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><p>● 高层模块调用简单<br>一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br>● 节点自由增加<br>使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</p>
<h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>● 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。<br>● 从一个整体中能够独立出部分模块或功能的场景。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。<br><img src="/2017/12/06/设计模式之禅/观察者模式.png" alt=""><br>● Subject被观察者<br>定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。<br>● Observer观察者<br>观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。<br>● ConcreteSubject具体的被观察者<br>定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。<br>● ConcreteObserver具体的观察者<br>每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public abstract class Subject &#123;</div><div class="line">	// 定义一个观察者数组</div><div class="line">	private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</div><div class="line"></div><div class="line">	// 增加一个观察者</div><div class="line">	public void addObserver(Observer o) &#123;</div><div class="line">		this.obsVector.add(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 删除一个观察者</div><div class="line">	public void delObserver(Observer o) &#123;</div><div class="line">		this.obsVector.remove(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 通知所有观察者</div><div class="line">	public void <span class="function"><span class="title">notifyObservers</span></span>() &#123;</div><div class="line">		<span class="keyword">for</span> (Observer o : this.obsVector) &#123;</div><div class="line">			o.update();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line">&#125;</div><div class="line">public class ConcreteSubject extends Subject &#123;</div><div class="line">	// 具体的业务</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * <span class="keyword">do</span> something</div><div class="line">		 */</div><div class="line">		super.notifyObservers();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface Observer &#123;</div><div class="line">	// 更新方法</div><div class="line">	public void update();</div><div class="line">&#125;</div><div class="line">public class ConcreteObserver implements Observer &#123;</div><div class="line">	// 实现更新方法</div><div class="line">	public void <span class="function"><span class="title">update</span></span>() &#123;</div><div class="line">		System.out.println(<span class="string">"接收到信息，并进行处理！"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 创建一个被观察者</div><div class="line">		Subject subject = new ConcreteSubject();</div><div class="line">		// 定义一个观察者</div><div class="line">		Observer obs = new ConcreteObserver();</div><div class="line">		// 观察者观察被观察者</div><div class="line">		subject.addObserver(obs);</div><div class="line">		// 观察者开始活动了</div><div class="line">		subject.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><p>● 观察者和被观察者之间是抽象耦合<br>如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实现的抽象层级的定义，在系统扩展方面更是得心应手。<br>● 建立一套触发机制</p>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。多级触发时的效率更是让人担忧，大家在设计时注意考虑</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>● 广播链的问题<br>如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表A上写了一个触发器，内容是一个字段更新后更新表B的一条数据，而表B上也有个触发器，要更新表C，表C也有触发器……完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，既是观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次）这还是比较好控制的。注意它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。<br>● 异步处理问题<br>这个EJB是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。</p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。<br>● Facade门面角色<br>客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。<br>● subsystem子系统角色<br>可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。<br><img src="/2017/12/06/设计模式之禅/门面.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ClassA &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingA</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ClassB &#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomethingB</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ClassC &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomethingC</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Facade &#123;</div><div class="line">	// 被委托的对象</div><div class="line">	private ClassA a = new ClassA();</div><div class="line">	private ClassB b = new ClassB();</div><div class="line">	private ClassC c = new ClassC();</div><div class="line"></div><div class="line">	// 提供给外部访问的方法</div><div class="line">	public void <span class="function"><span class="title">methodA</span></span>() &#123;</div><div class="line">		this.a.doSomethingA();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodB</span></span>() &#123;</div><div class="line">		this.b.doSomethingB();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">methodC</span></span>() &#123;</div><div class="line">		this.c.doSomethingC();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><p>● 减少系统的相互依赖<br>想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模<br>式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。<br>● 提高了灵活性<br>依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。<br>● 提高安全性<br>想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到</p>
<h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><p>门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。</p>
<h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><p>● 为一个复杂的模块或子系统提供一个供外界访问的接口<br>● 子系统相对独立——外界对子系统的访问只要黑箱操作即可<br>比如利息的计算问题，没有深厚的业务知识和扎实的技术水平是不可能开发出该子系统的，但是对于使用该系统的开发人员来说，他需要做的就是输入金额以及存期，其他的都不用关心，返回的结果就是利息，这时候，门面模式是非使用不可了。<br>● 预防低水平人员带来的风险扩散</p>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br><img src="/2017/12/06/设计模式之禅/备忘录.png" alt=""><br>● Originator发起人角色<br>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。<br>● Memento备忘录角色<br>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。<br>● Caretaker备忘录管理员角色<br>对备忘录进行管理、保存和提供备忘录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 创建一个备忘录</div><div class="line">	public Memento <span class="function"><span class="title">createMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> new Memento(this.state);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 恢复一个备忘录</div><div class="line">	public void restoreMemento(Memento _memento) &#123;</div><div class="line">		this.setState(_memento.getState());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Memento &#123;</div><div class="line">	// 发起人的内部状态</div><div class="line">	private String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">	// 构造函数传递参数</div><div class="line">	public Memento(String _state) &#123;</div><div class="line">		this.state = _state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String <span class="function"><span class="title">getState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> state;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>State(String state) &#123;</div><div class="line">		this.state = state;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Caretaker &#123;</div><div class="line">	// 备忘录对象</div><div class="line">	private Memento memento;</div><div class="line"></div><div class="line">	public Memento <span class="function"><span class="title">getMemento</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> memento;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Memento(Memento memento) &#123;</div><div class="line">		this.memento = memento;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义出发起人</div><div class="line">		Originator originator = new Originator();</div><div class="line">		// 定义出备忘录管理员</div><div class="line">		Caretaker caretaker = new Caretaker();</div><div class="line">		// 创建一个备忘录</div><div class="line">		caretaker.setMemento(originator.createMemento());</div><div class="line">		// 恢复一个备忘录</div><div class="line">		originator.restoreMemento(caretaker.getMemento());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 需要保存和恢复数据的相关状态场景。<br>● 提供一个可回滚（rollback）的操作；比如Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。<br>● 需要监控的副本场景中。例如要监控一个对象的属性，但是监控又不应该作为系统=的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。<br>● 数据库连接的事务管理就是用的备忘录模式</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br><img src="/2017/12/06/设计模式之禅/访问.png" alt=""><br>● Visitor——抽象访问者<br>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。<br>● ConcreteVisitor——具体访问者<br>它影响访问者访问到一个类后该怎么干，要做什么事情。<br>● Element——抽象元素<br>接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。<br>● ConcreteElement——具体元素<br>实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了。<br>● ObjectStruture——结构对象<br>元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目中，一般很少抽象出这个角色。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public abstract class Element &#123;</div><div class="line">	// 定义业务逻辑</div><div class="line">	public abstract void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	// 允许谁来访问</div><div class="line">	public abstract void accept(IVisitor visitor);</div><div class="line">&#125;</div><div class="line">public class ConcreteElement1 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteElement2 extends Element &#123;</div><div class="line">	// 完善业务逻辑</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 允许那个访问者访问</div><div class="line">	public void accept(IVisitor visitor) &#123;</div><div class="line">		visitor.visit(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public interface IVisitor &#123;</div><div class="line">	// 可以访问哪些对象</div><div class="line">	public void visit(ConcreteElement1 el1);</div><div class="line"></div><div class="line">	public void visit(ConcreteElement2 el2);</div><div class="line">&#125;</div><div class="line">public class Visitor implements IVisitor &#123;</div><div class="line">	// 访问el1元素</div><div class="line">	public void visit(ConcreteElement1 el1) &#123;</div><div class="line">		el1.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 访问el2元素</div><div class="line">	public void visit(ConcreteElement2 el2) &#123;</div><div class="line">		el2.doSomething();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ObjectStruture &#123;</div><div class="line">	// 对象生成器，这里通过一个工厂方法模式模拟</div><div class="line">	public static Element <span class="function"><span class="title">createElement</span></span>() &#123;</div><div class="line">		Random rand = new Random();</div><div class="line">		<span class="keyword">if</span> (rand.nextInt(100) &gt; 50) &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement1();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">return</span> new ConcreteElement2();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		<span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			// 获得元素对象</div><div class="line">			Element el = ObjectStruture.createElement();</div><div class="line">			// 接受访问者访问</div><div class="line">			el.accept(new Visitor());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><p>● 符合单一职责原则<br>具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。<br>● 优秀的扩展性<br>由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。<br>● 灵活性非常高<br>例如，数据汇总，就以刚刚我们说的Employee的例子，如果我现在要统计所有员工的工资之和，怎么计算？把所有人的工资for循环加一遍？是个办法，那我再提个问题，员工工资×1.2，部门经理×1.4，总经理×1.8，然后把这些工资加起来，你怎么处理？1.2，1.4，1.8是什么？不是吧？！你没看到领导不论什么时候都比你拿得多，工资奖金就不说了，就是过节发个慰问券也比你多，就是这个系数在作祟。我们继续说你想怎么统计？使用for循环，然后使用instanceof来判断是员工还是经理？这可以解决，但不是个好办法，好办法是通过访问者模式来实现，把数据扔给访问者，由访问者来进行统计计算。</p>
<h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><p>● 具体元素对访问者公布细节<br>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。<br>● 具体元素变更比较困难<br>具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？<br>● 违背了依赖倒置转原则<br>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>● 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖=于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。<br>● 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。<br>总结一下，在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。访问者模式还有一个用途，就是充当拦截器（Interceptor）角色。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。<br>● State——抽象状态角色<br>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。<br>● ConcreteState——具体状态角色<br>每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。<br>● Context——环境角色<br>定义客户端需要的接口，并且负责具体状态的切换。<br>环境角色有两个不成文的约束：<br>● 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。<br>● 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public abstract class State &#123;</div><div class="line">	// 定义一个环境角色，提供子类访问</div><div class="line">	protected Context context;</div><div class="line"></div><div class="line">	// 设置环境角色</div><div class="line">	public void <span class="built_in">set</span>Context(Context _context) &#123;</div><div class="line">		this.context = _context;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为1</div><div class="line">	public abstract void handle1();</div><div class="line"></div><div class="line">	// 行为2</div><div class="line">	public abstract void handle2();</div><div class="line">&#125;</div><div class="line">public class ConcreteState1 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 设置当前状态为<span class="built_in">stat</span>2</div><div class="line">		super.context.setCurrentState(Context.STATE2);</div><div class="line">		// 过渡到state2状态，由Context实现</div><div class="line">		super.context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteState2 extends State &#123;</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		// 设置当前状态为state1</div><div class="line">		super.context.setCurrentState(Context.STATE1);</div><div class="line">		// 过渡到state1状态，由Context实现</div><div class="line">		super.context.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		// 本状态下必须处理的逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line">	// 定义状态</div><div class="line">	public final static State STATE1 = new ConcreteState1();</div><div class="line">	public final static State STATE2 = new ConcreteState2();</div><div class="line">	// 当前状态</div><div class="line">	private State CurrentState;</div><div class="line"></div><div class="line">	// 获得当前状态</div><div class="line">	public State <span class="function"><span class="title">getCurrentState</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> CurrentState;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置当前状态</div><div class="line">	public void <span class="built_in">set</span>CurrentState(State currentState) &#123;</div><div class="line">		this.CurrentState = currentState;</div><div class="line">		// 切换状态</div><div class="line">		this.CurrentState.setContext(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 行为委托</div><div class="line">	public void <span class="function"><span class="title">handle1</span></span>() &#123;</div><div class="line">		this.CurrentState.handle1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">handle2</span></span>() &#123;</div><div class="line">		this.CurrentState.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义环境角色</div><div class="line">		Context context = new Context();</div><div class="line">		// 初始化状态</div><div class="line">		context.setCurrentState(new ConcreteState1());</div><div class="line">		// 行为执行</div><div class="line">		context.handle1();</div><div class="line">		context.handle2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><p>● 结构清晰<br>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性,提高系统的可维护性。<br>● 遵循设计原则<br>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。<br>● 封装性非常好<br>这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</p>
<h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><p>子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。</p>
<h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><p>● 行为随状态改变而改变的场景<br>这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。<br>● 条件、分支判断语句的替代者<br>在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变<br>化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）是一种按照规定语法进行解析的方案，在现在项目中使用较少。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br><img src="/2017/12/06/设计模式之禅/解释器.png" alt=""><br>● AbstractExpression——抽象解释器<br>具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和 Non-terminalExpression完成。<br>● TerminalExpression——终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达<br>式，但有多个实例，对应不同的终结符。具体到我们例子就是VarExpression类，表达式中的每个终结符都在栈中产生了一个VarExpression对象。<br>● NonterminalExpression——非终结符表达式<br>文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。<br>● Context——环境角色<br>具体到我们的例子中是采用HashMap代替。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public abstract class Expression &#123;</div><div class="line">	// 每个表达式必须有一个解析任务</div><div class="line">	public abstract Object interpreter(Context ctx);</div><div class="line">&#125;</div><div class="line">public class NonterminalExpression extends Expression &#123;</div><div class="line">	// 每个非终结符表达式都会对其他表达式产生依赖</div><div class="line">	public NonterminalExpression(Expression... expression) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		// 进行文法处理</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class TerminalExpression extends Expression &#123;</div><div class="line">	// 通常终结符表达式只有一个，但是有多个对象</div><div class="line">	public Object interpreter(Context ctx) &#123;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Context &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p>
<h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><p>● 解释器模式会引起类膨胀<br>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。<br>● 解释器模式采用递归调用方法<br>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下使用的，它导致调试非常复杂。想想看，如果要排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。<br>● 效率问题<br>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。</p>
<h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><p>● 重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。<br>● 一个简单语法需要解释的场景</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）是池技术的重要实现方式。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>使用共享对象可有效地支持大量的细粒度的对象。<br><img src="/2017/12/06/设计模式之禅/享元模式.png" alt=""><br>● Flyweight——抽象享元角色<br>它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。<br>● ConcreteFlyweight——具体享元角色<br>具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。<br>● unsharedConcreteFlyweight——不可共享的享元角色<br>不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。<br>● FlyweightFactory——享元工厂<br>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public abstract class Flyweight &#123;</div><div class="line">	// 内部状态</div><div class="line">	private String intrinsic;</div><div class="line">	// 外部状态</div><div class="line">	protected final String Extrinsic;</div><div class="line"></div><div class="line">	// 要求享元角色必须接受外部状态</div><div class="line">	public Flyweight(String _Extrinsic) &#123;</div><div class="line">		this.Extrinsic = _Extrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 定义业务操作</div><div class="line">	public abstract void operate();</div><div class="line"></div><div class="line">	// 内部状态的getter/setter</div><div class="line">	public String <span class="function"><span class="title">getIntrinsic</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> intrinsic;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="built_in">set</span>Intrinsic(String intrinsic) &#123;</div><div class="line">		this.intrinsic = intrinsic;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight1(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</div><div class="line">	// 接受外部状态</div><div class="line">	public ConcreteFlyweight2(String _Extrinsic) &#123;</div><div class="line">		super(_Extrinsic);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 根据外部状态进行逻辑处理</div><div class="line">	public void <span class="function"><span class="title">operate</span></span>() &#123;</div><div class="line">		// 业务逻辑</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class FlyweightFactory &#123;</div><div class="line">	// 定义一个池容器</div><div class="line">	private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;String, Flyweight&gt;();</div><div class="line"></div><div class="line">	// 享元工厂</div><div class="line">	public static Flyweight getFlyweight(String Extrinsic) &#123;</div><div class="line">		// 需要返回的对象</div><div class="line">		Flyweight flyweight = null;</div><div class="line">		// 在池中没有该对象</div><div class="line">		<span class="keyword">if</span> (pool.containsKey(Extrinsic)) &#123;</div><div class="line">			flyweight = pool.get(Extrinsic);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			// 根据外部状态创建享元对象</div><div class="line">			flyweight = new ConcreteFlyweight1(Extrinsic);</div><div class="line">			// 放置到池中</div><div class="line">			pool.put(Extrinsic, flyweight);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> flyweight;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><p>元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存<br>的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h3 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h3><p>● 系统中存在大量的相似对象。<br>● 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>● 需要缓冲池的场景。</p>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><p>桥梁模式（Bridge Pattern）也叫做桥接模式，是一个比较简单的模式</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>将抽象和实现解耦，使得两者可以独立地变化。<br><img src="/2017/12/06/设计模式之禅/桥梁.png" alt=""><br>● Abstraction——抽象化角色<br>它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。<br>● Implementor——实现化角色<br>它是接口或者抽象类，定义角色必需的行为和属性。<br>● RefinedAbstraction——修正抽象化角色<br>它引用实现化角色对抽象化角色进行修正。<br>● ConcreteImplementor——具体实现化角色<br>它实现接口或抽象类定义的方法和属性。<br>桥梁模式中的几个名词比较拗口，大家只要记住一句话就成：抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public interface Implementor &#123;</div><div class="line">	// 基本方法</div><div class="line">	public void <span class="keyword">do</span>Something();</div><div class="line"></div><div class="line">	public void <span class="keyword">do</span>Anything();</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor1 implements Implementor &#123;</div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class ConcreteImplementor2 implements Implementor&#123;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doSomething</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">doAnything</span></span>() &#123;</div><div class="line">		// 业务逻辑处理</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public abstract class Abstraction &#123;</div><div class="line">	// 定义对实现化角色的引用</div><div class="line">	private Implementor imp;</div><div class="line"></div><div class="line">	// 约束子类必须实现该构造函数</div><div class="line">	public Abstraction(Implementor _imp) &#123;</div><div class="line">		this.imp = _imp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 自身的行为和属性</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		this.imp.doSomething();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得实现化角色</div><div class="line">	public Implementor <span class="function"><span class="title">getImp</span></span>() &#123;</div><div class="line">		<span class="built_in">return</span> imp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class RefinedAbstraction extends Abstraction &#123;</div><div class="line">	// 覆写构造函数</div><div class="line">	public RefinedAbstraction(Implementor _imp) &#123;</div><div class="line">		super(_imp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 修正父类的行为</div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">request</span></span>() &#123;</div><div class="line">		/*</div><div class="line">		 * 业务处理...</div><div class="line">		 */</div><div class="line">		super.request();</div><div class="line">		super.getImp().doAnything();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 定义一个实现化角色</div><div class="line">		Implementor imp = new ConcreteImplementor1();</div><div class="line">		// 定义一个抽象化角色</div><div class="line">		Abstraction abs = new RefinedAbstraction(imp);</div><div class="line">		// 执行行文</div><div class="line">		abs.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h3><p>● 抽象和实现分离<br>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。<br>● 优秀的扩充能力<br>看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。<br>● 实现细节对客户透明<br>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p>
<h3 id="场景-8"><a href="#场景-8" class="headerlink" title="场景"></a>场景</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/02/java8/" rel="next" title="java8">
                <i class="fa fa-chevron-left"></i> java8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计原则"><span class="nav-number">1.</span> <span class="nav-text">设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一职责-SRP"><span class="nav-number">1.1.</span> <span class="nav-text">单一职责(SRP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#里氏替换原则-LSP"><span class="nav-number">1.2.</span> <span class="nav-text">里氏替换原则(LSP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖倒置原则（DIP）"><span class="nav-number">1.3.</span> <span class="nav-text">依赖倒置原则（DIP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口隔离原则-ISP"><span class="nav-number">1.4.</span> <span class="nav-text">接口隔离原则(ISP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迪米特法则"><span class="nav-number">1.5.</span> <span class="nav-text">迪米特法则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开闭原则-DIP"><span class="nav-number">1.6.</span> <span class="nav-text">开闭原则(DIP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合成复用原则"><span class="nav-number">1.7.</span> <span class="nav-text">合成复用原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">2.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">2.1.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例的优点"><span class="nav-number">2.1.1.</span> <span class="nav-text">单例的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">2.1.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">2.1.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.2.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式优点："><span class="nav-number">2.2.1.</span> <span class="nav-text">工厂方法模式优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法的扩展"><span class="nav-number">2.2.2.</span> <span class="nav-text">工厂方法的扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">2.3.</span> <span class="nav-text">抽象工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式的优点"><span class="nav-number">2.3.1.</span> <span class="nav-text">抽象工厂模式的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板方法模式"><span class="nav-number">2.4.</span> <span class="nav-text">模板方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">2.4.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板方法模式使用场景"><span class="nav-number">2.4.4.</span> <span class="nav-text">模板方法模式使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建造者模式"><span class="nav-number">2.5.</span> <span class="nav-text">建造者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-1"><span class="nav-number">2.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-number">2.6.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理"><span class="nav-number">2.6.1.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">2.7.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-2"><span class="nav-number">2.7.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-2"><span class="nav-number">2.7.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝和深拷贝"><span class="nav-number">2.7.3.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中介者模式"><span class="nav-number">2.8.</span> <span class="nav-text">中介者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">2.8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-3"><span class="nav-number">2.8.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-3"><span class="nav-number">2.8.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景"><span class="nav-number">2.8.4.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式"><span class="nav-number">2.9.</span> <span class="nav-text">命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">2.9.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-4"><span class="nav-number">2.9.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-4"><span class="nav-number">2.9.3.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#责任链"><span class="nav-number">2.10.</span> <span class="nav-text">责任链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-3"><span class="nav-number">2.10.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-5"><span class="nav-number">2.10.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-5"><span class="nav-number">2.10.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">2.10.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰者模式"><span class="nav-number">2.11.</span> <span class="nav-text">装饰者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-4"><span class="nav-number">2.11.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-6"><span class="nav-number">2.11.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-6"><span class="nav-number">2.11.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-1"><span class="nav-number">2.11.4.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-number">2.12.</span> <span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-5"><span class="nav-number">2.12.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-7"><span class="nav-number">2.12.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-7"><span class="nav-number">2.12.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-2"><span class="nav-number">2.12.4.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器模式"><span class="nav-number">2.13.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-6"><span class="nav-number">2.13.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-8"><span class="nav-number">2.13.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-3"><span class="nav-number">2.13.3.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器模式"><span class="nav-number">2.14.</span> <span class="nav-text">迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-7"><span class="nav-number">2.14.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合模式"><span class="nav-number">2.15.</span> <span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-9"><span class="nav-number">2.15.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-8"><span class="nav-number">2.15.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">2.15.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者模式"><span class="nav-number">2.16.</span> <span class="nav-text">观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-10"><span class="nav-number">2.16.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-9"><span class="nav-number">2.16.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项-1"><span class="nav-number">2.16.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#门面模式"><span class="nav-number">2.17.</span> <span class="nav-text">门面模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-11"><span class="nav-number">2.17.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-10"><span class="nav-number">2.17.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-4"><span class="nav-number">2.17.3.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备忘录"><span class="nav-number">2.18.</span> <span class="nav-text">备忘录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-8"><span class="nav-number">2.18.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-3"><span class="nav-number">2.18.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问者模式"><span class="nav-number">2.19.</span> <span class="nav-text">访问者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-12"><span class="nav-number">2.19.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-11"><span class="nav-number">2.19.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-4"><span class="nav-number">2.19.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态模式"><span class="nav-number">2.20.</span> <span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-9"><span class="nav-number">2.20.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-13"><span class="nav-number">2.20.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-12"><span class="nav-number">2.20.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-5"><span class="nav-number">2.20.4.</span> <span class="nav-text">场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项-2"><span class="nav-number">2.20.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器模式"><span class="nav-number">2.21.</span> <span class="nav-text">解释器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-10"><span class="nav-number">2.21.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-14"><span class="nav-number">2.21.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-13"><span class="nav-number">2.21.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-6"><span class="nav-number">2.21.4.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#享元模式"><span class="nav-number">2.22.</span> <span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-11"><span class="nav-number">2.22.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-15"><span class="nav-number">2.22.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-7"><span class="nav-number">2.22.3.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桥梁模式"><span class="nav-number">2.23.</span> <span class="nav-text">桥梁模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-12"><span class="nav-number">2.23.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-16"><span class="nav-number">2.23.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景-8"><span class="nav-number">2.23.3.</span> <span class="nav-text">场景</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
