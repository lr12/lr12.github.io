<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java并发," />





  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="java并发编程基础线程简介什么是线程资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 为什么使用多线程 更多的处理器核心 更快的响应时间 更好的编程模型  线程的优先级现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个">
<meta name="keywords" content="java并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程4~5">
<meta property="og:url" content="http://yoursite.com/2017/12/31/java并发编程4-6/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="java并发编程基础线程简介什么是线程资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 为什么使用多线程 更多的处理器核心 更快的响应时间 更好的编程模型  线程的优先级现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/java线程状态变迁.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/通知机制.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/wait_notify.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/lock特性.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/lock-api.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/同步器重写.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/模板方法.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/节点属性.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/同步队列结构.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/cas设置尾节点.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/首节点设置.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/共享与独占.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/独占超时.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/读写锁监控.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/locksupport.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/对比.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/condition.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/等待队列基本结构.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/同步与等待.png">
<meta property="og:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/唤醒.png">
<meta property="og:updated_time" content="2018-01-05T13:34:18.278Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发编程4~5">
<meta name="twitter:description" content="java并发编程基础线程简介什么是线程资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 为什么使用多线程 更多的处理器核心 更快的响应时间 更好的编程模型  线程的优先级现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个">
<meta name="twitter:image" content="http://yoursite.com/2017/12/31/java并发编程4-6/java线程状态变迁.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/31/java并发编程4-6/"/>





  <title>java并发编程4~5 | 博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/31/java并发编程4-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发编程4~5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-31T15:25:57+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java并发编程艺术读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">java并发编程艺术读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java并发编程基础"><a href="#java并发编程基础" class="headerlink" title="java并发编程基础"></a>java并发编程基础</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>资源分配的最小单元是进程，线程是CPU调度的最小单位。现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>现在操作系统采用时分的形式调用调度运行的程序，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程时间片用完了就会发生线程调度，等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。<br>Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。<br>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>java线程在运行的生命周期可能处于6中不同的状态，在给定的一个时刻线程只能处于其中一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用start方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，java线程将操作系统中的就绪和运行两种状态笼统地称作运行中</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITTING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（如通知或者中断）</td>
</tr>
<tr>
<td>TIME_WAITTING</td>
<td>超时等待状态，该状态不同于WAITTING，它是可以在指定的时间返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jps <span class="_">-l</span></div><div class="line">jstack pid//查看线程情况</div></pre></td></tr></table></figure>
<p><img src="/2017/12/31/java并发编程4-6/java线程状态变迁.png" alt=""><br>注意　Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个java虚拟机不存在非Daemon线程时，java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个标记位，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了招呼，其他线程调用了该线程的interrupt方法对其进行了中断。<br>线程通过检查自身是否被中断进行响应，通过调用isInterrupted来判断是否被中断，也可以调用静态方法Thread.interrupted对当前线程进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。<br>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<h3 id="过期的suspend、resume、stop"><a href="#过期的suspend、resume、stop" class="headerlink" title="过期的suspend、resume、stop"></a>过期的suspend、resume、stop</h3><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。<br>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="volatile和synchronize关键字"><a href="#volatile和synchronize关键字" class="headerlink" title="volatile和synchronize关键字"></a>volatile和synchronize关键字</h3><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。<br>简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(value != desire) &#123;</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125;</div><div class="line"><span class="keyword">do</span>Something();</div></pre></td></tr></table></figure></p>
<p>1）难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时<br>发现条件已经变化，也就是及时性难以保证。<br>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现<br>条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。<br>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br><img src="/2017/12/31/java并发编程4-6/通知机制.png" alt=""><br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>wait、notify和notifyAll注意细节：</p>
<ul>
<li>使用wait、notify、notifyAll时需要先对对象加锁</li>
<li>调用wait后，线程状态由RUNNING变为WAITING，并将当前线程放到等待队列中</li>
<li>notify和notifyAll调用后，等待线程不会从wait返回，需要等待notify和notifyAll释放锁后，等待线程才有机会从wait中返回。</li>
<li>notify方法将等待队列中的一个线程从等待队列中移出到同步队列，notifyAll是将等待队列中的所有线程移到同步队列中，被移动的线程从waiting变为blocked。</li>
<li>从wait方法中返回前提是获得调用对象锁</li>
</ul>
<p><img src="/2017/12/31/java并发编程4-6/wait_notify.png" alt=""></p>
<h3 id="等待通知的经典范式"><a href="#等待通知的经典范式" class="headerlink" title="等待通知的经典范式"></a>等待通知的经典范式</h3><p>该范式分为两个部分：分别针对等待方和通知方</p>
<h4 id="等待方"><a href="#等待方" class="headerlink" title="等待方"></a>等待方</h4><p>等待方遵守如下规则：</p>
<ol>
<li>获取对象的锁</li>
<li>如果不满足条件，那么调用对象的wait方法，被通知后仍然检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  <span class="keyword">while</span>(条件不满足)&#123;</div><div class="line">    对象.wait();</div><div class="line">  &#125;</div><div class="line">  对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通知方"><a href="#通知方" class="headerlink" title="通知方"></a>通知方</h4><ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(对象)&#123;</div><div class="line">  改变条件</div><div class="line">  对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。<br>管道输入输出流包括了如下四种具体实现：PipedOutputStream、PipedInputStream、PipedReader、PipedWriter，前两种面向字节，后两种面向字符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Piped &#123;</div><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">PipedWriter out = new PipedWriter();</div><div class="line">PipedReader <span class="keyword">in</span> = new PipedReader();</div><div class="line">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</div><div class="line">out.connect(<span class="keyword">in</span>);</div><div class="line">Thread <span class="built_in">print</span>Thread = new Thread(new Print(<span class="keyword">in</span>), <span class="string">"PrintThread"</span>);</div><div class="line"><span class="built_in">print</span>Thread.start();</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = System.in.read()) != -1) &#123;</div><div class="line">out.write(receive);</div><div class="line">&#125;</div><div class="line">&#125; finally &#123;</div><div class="line">out.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">static class Print implements Runnable &#123;</div><div class="line">private PipedReader <span class="keyword">in</span>;</div><div class="line">public Print(PipedReader <span class="keyword">in</span>) &#123;</div><div class="line">this.in =<span class="keyword">in</span>;</div><div class="line">&#125;</div><div class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">int receive = 0;</div><div class="line">try &#123;</div><div class="line"><span class="keyword">while</span>((receive = in.read()) != -1) &#123;</div><div class="line">System.out.print((char) receive);</div><div class="line">&#125;</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><p>如果一个线程执行了thread.join语句，其含义是当前线程A等待thread线程终止后才从thread.join返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 加锁当前线程对象</div><div class="line">public final synchronized void join() throws InterruptedException &#123;</div><div class="line">// 条件不满足，继续等待</div><div class="line"><span class="keyword">while</span>(isAlive()) &#123;</div><div class="line"> <span class="built_in">wait</span>(0);</div><div class="line">&#125;</div><div class="line">// 条件符合，方法返回</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal是线程变量，是一个以ThreadLocal为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程的值。<br>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p>开发人员经常遇到：调用一个方法等待一段时间后，如果该方法能够在给定时间段内得到结果，那么将结果返回，反之超时返回默认结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 对当前对象加锁</div><div class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line">// 当超时大于0并且result返回值不满足要求</div><div class="line"><span class="keyword">while</span>((result == null) &amp;&amp; remaining &gt; 0) &#123;</div><div class="line"><span class="built_in">wait</span>(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ConnectionPool &#123;</div><div class="line">private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</div><div class="line">public ConnectionPool(int initialSize) &#123;</div><div class="line"><span class="keyword">if</span>(initialSize &gt; 0) &#123;</div><div class="line"><span class="keyword">for</span>(int i = 0; i &lt; initialSize; i++) &#123;</div><div class="line">pool.addLast(ConnectionDriver.createConnection());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void releaseConnection(Connection connection) &#123;</div><div class="line"><span class="keyword">if</span>(connection != null) &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</div><div class="line">pool.addLast(connection);</div><div class="line">pool.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 在mills内无法获取到连接，将会返回null</div><div class="line">public Connection fetchConnection(long mills) throws InterruptedException &#123;</div><div class="line">synchronized (pool) &#123;</div><div class="line">// 完全超时</div><div class="line"><span class="keyword">if</span>(mills &lt;= 0) &#123;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty()) &#123;</div><div class="line">pool.wait();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> pool.removeFirst();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">long future = System.currentTimeMillis() + mills;</div><div class="line">long remaining = mills;</div><div class="line"><span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</div><div class="line">pool.wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">Connection result = null;</div><div class="line"><span class="keyword">if</span>(!pool.isEmpty()) &#123;</div><div class="line">result = pool.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h1><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock=new ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。<br><img src="/2017/12/31/java并发编程4-6/lock特性.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/lock-api.png" alt=""></p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer是用来构建锁或者其他组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程排队工作。<br>同步器的主要使用方式是继承，子类通过继承父类同步器并实现他的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这就需要对同步器提供的三个方法（getState、setState、compareAndSetState）来进行操作，因为它能保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。<br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方<br>法，而这些模板方法将会调用使用者重写的方法。<br>·getState()：获取当前同步状态。<br>·setState(int newState)：设置当前同步状态。<br>·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。<br><img src="/2017/12/31/java并发编程4-6/同步器重写.png" alt=""></p>
<p><img src="/2017/12/31/java并发编程4-6/模板方法.png" alt=""><br>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><p>同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，同步器将当前线程以及等待状态等信息构造称为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。<br><img src="/2017/12/31/java并发编程4-6/节点属性.png" alt=""><br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部<br><img src="/2017/12/31/java并发编程4-6/同步队列结构.png" alt=""><br>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="/2017/12/31/java并发编程4-6/cas设置尾节点.png" alt=""><br>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点<br><img src="/2017/12/31/java并发编程4-6/首节点设置.png" alt=""><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line"><span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">    selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">  Node node = new Node(Thread.currentThread(), mode);</div><div class="line">  // 快速尝试在尾部添加</div><div class="line">  Node pred = tail;</div><div class="line">  <span class="keyword">if</span>(pred != null) &#123;</div><div class="line">    node.prev = pred;</div><div class="line">    <span class="keyword">if</span>(compareAndSetTail(pred, node)) &#123;</div><div class="line">      pred.next = node;</div><div class="line">      <span class="built_in">return</span> node;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  enq(node);</div><div class="line">  <span class="built_in">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">  <span class="keyword">for</span>(;;)&#123;</div><div class="line">    Node t = tail;</div><div class="line">    <span class="keyword">if</span>(t==null)&#123;</div><div class="line">      Node temp=new Node();</div><div class="line">      <span class="keyword">if</span>(compareAndSetHead(temp))</div><div class="line">        tail = head;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      node.prev = t;</div><div class="line">      <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</div><div class="line">        t.next = node;</div><div class="line">        <span class="built_in">return</span> t;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码通过使用compareAndSetTail(Node expect,Node update)方法来确保节点能够被线程安全添加。试想一下：如果使用一个普通的LinkedList来维护节点之间的关系，那么当一个线程获取了同步状态，而其他多个线程由于调用tryAcquire(int arg)方法获取同步状态失败而并发地被添加到LinkedList时，LinkedList将难以保证Node的正确添加，最终的结果可能是节点的数量有偏差，而且顺序也是混乱的。<br>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变得“串行化”了。<br>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">    boolean failed=<span class="literal">true</span>;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(;;)&#123;</div><div class="line">          final Node p = node.predecessor();</div><div class="line">          <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">              <span class="built_in">set</span>Head(node);</div><div class="line">              p.next = null;</div><div class="line">              failed=<span class="literal">false</span>;</div><div class="line">              <span class="built_in">return</span> interrupted;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt)</div><div class="line">              interrupted = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        <span class="keyword">if</span>(failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。<br>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为<br>适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</div><div class="line">      Node h = head;</div><div class="line">      <span class="keyword">if</span>(h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">       unparkSuccessor(h);</div><div class="line">       <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">     <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="共享同步状态获取与释放"><a href="#共享同步状态获取与释放" class="headerlink" title="共享同步状态获取与释放"></a>共享同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况<br><img src="/2017/12/31/java并发编程4-6/共享与独占.png" alt=""><br>左半部分，共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞，右半部分是独占式访问资源时，同一时刻其他访问均被阻塞。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; 0)</div><div class="line">           <span class="keyword">do</span>AcquireShared(arg);</div><div class="line">   &#125;</div><div class="line">private void <span class="keyword">do</span>AcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                final Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= 0) &#123;</div><div class="line">                        <span class="built_in">set</span>HeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        <span class="built_in">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            <span class="keyword">if</span>(failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。<br>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line"><span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">      <span class="keyword">do</span>ReleaseShared();</div><div class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。在分析该方法的实现前，先介绍一下响应中断的同步状态获取过程。在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private boolean <span class="keyword">do</span>AcquireNanos(int arg, long nanosTimeout)</div><div class="line">     throws InterruptedException &#123;</div><div class="line">     long lastTime = System.nanoTime();</div><div class="line">     final Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">     boolean failed = <span class="literal">true</span>;</div><div class="line">     try &#123;</div><div class="line">         <span class="keyword">for</span> (;;) &#123;</div><div class="line">             final Node p = node.predecessor();</div><div class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                 <span class="built_in">set</span>Head(node);</div><div class="line">                 p.next = null; // <span class="built_in">help</span> GC</div><div class="line">                 failed = <span class="literal">false</span>;</div><div class="line">                 <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= 0)</div><div class="line">                 <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                 nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                 LockSupport.parkNanos(this, nanosTimeout);</div><div class="line">             long now = System.nanoTime();</div><div class="line">             nanosTimeout -= now - lastTime;</div><div class="line">             lastTime = now;</div><div class="line">             <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                 throw new InterruptedException();</div><div class="line">         &#125;</div><div class="line">     &#125; finally &#123;</div><div class="line">         <span class="keyword">if</span> (failed)</div><div class="line">             cancelAcquire(node);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object blocker,long nanos)方法返回）。如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，同步器会进入无条件的快速自旋。<br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑。acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态，而doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。<br><img src="/2017/12/31/java并发编程4-6/独占超时.png" alt=""></p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，支持重新进入的锁，表示该锁能够支持一个线程对一个资源的重复加锁。该锁还支持获取锁的公平性和非公平性的选择。<br>当一个线程调用Mutex的lock方法获取锁之后，如果再次调用lock方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。简单地说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。<br>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。<br>如果在决定时间下，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之则是不公平的。公平锁也就是等待时间最长的线程最优先获取到锁.ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。公平锁往往没有不公平锁效率高，但是并非任何场景下都是以TPS作为唯一指标，公平锁能够减少饥饿发生的概率，等待越久的线程越是能够得到优先满足。<br>1.实现重进入<br>重进入是是指任意线程获取到锁后再次获取到该锁不会被该锁所阻塞，该特性需要解决两个问题：<br>1）线程再次获取到锁，锁需要去识别获取锁的线程是否是当前占据锁的线程，如果是，再次成功获取<br>2）锁的最终释放，线程重复n次获取到锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。<br>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">int c = getState() - releases;</div><div class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">boolean free = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line">free = <span class="literal">true</span>;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(null);</div><div class="line">&#125;</div><div class="line"><span class="built_in">set</span>State(c);</div><div class="line"><span class="built_in">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。<br>2.公平锁与非公平锁的区别<br>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>回顾nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">final Thread current = Thread.currentThread();</div><div class="line">int c = getState();</div><div class="line"><span class="keyword">if</span> (c == 0) &#123;</div><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</div><div class="line"><span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">int nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; 0)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="built_in">set</span>State(nextc);</div><div class="line"><span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>为什么会出现线程连续获取锁的情况呢？回顾nonfairTryAcquire(int acquires)方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待.<br>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>之前提到的锁基本都是排他锁，这些锁同一时刻只能由一个线程进行访问，而读写锁在同一时刻只允许一个线程进行访问，而读写锁同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了提升。<br>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务、（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。<br>一般情况下，读写锁的性能都会比排它锁性能好，因为大多数场景读是多于写。读写锁比排它锁有更好的并发量和吞吐量。java并发包提供读写锁ReentrantReadWriteLock</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平和公平，吞吐量非公平优于公平</td>
</tr>
<tr>
<td>重进入</td>
<td>该锁支持重进入，以读写线程为例，读线程获取读锁后，能够再次获取读锁，写线程获取写锁后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级称为读锁</td>
</tr>
</tbody>
</table>
<h3 id="读写锁接口与示例"><a href="#读写锁接口与示例" class="headerlink" title="读写锁接口与示例"></a>读写锁接口与示例</h3><p>仅定义了获取读锁和写锁两个方法，即readLock和writeLock<br><img src="/2017/12/31/java并发编程4-6/读写锁监控.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">	static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">	static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">	static Lock r = rwl.readLock();</div><div class="line">	static Lock w = rwl.writeLock();</div><div class="line"></div><div class="line">	// 获取一个key对应的value</div><div class="line">	public static final Object get(String key) &#123;</div><div class="line">		r.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.get(key);</div><div class="line">		&#125; finally &#123;</div><div class="line">			r.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 设置key对应的value，并返回旧的value</div><div class="line">	public static final Object put(String key, Object value) &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			<span class="built_in">return</span> map.put(key, value);</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 清空所有的内容</div><div class="line">	public static final void <span class="function"><span class="title">clear</span></span>() &#123;</div><div class="line">		w.lock();</div><div class="line">		try &#123;</div><div class="line">			map.clear();</div><div class="line">		&#125; finally &#123;</div><div class="line">			w.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性</p>
<h3 id="读写锁实现设计"><a href="#读写锁实现设计" class="headerlink" title="读写锁实现设计"></a>读写锁实现设计</h3><p>主要包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级</p>
<h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果一个整形变量维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量分为两个部分，前十六位表示读，低十六位表示写。<br>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。<br>当S等于零时说明没有锁，当S不等于零时，当写状态(S&amp;0x0000FFFF)等于0时，则读状态不等于0，即读锁已被获取。</p>
<h4 id="写状态的获取与释放"><a href="#写状态的获取与释放" class="headerlink" title="写状态的获取与释放"></a>写状态的获取与释放</h4><p>写锁是一个支持可重入的排它锁，如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">           Thread current = Thread.currentThread();</div><div class="line">           int c = getState();</div><div class="line">           int w = exclusiveCount(c);</div><div class="line">           <span class="keyword">if</span> (c != 0) &#123;</div><div class="line">               // (Note: <span class="keyword">if</span> c != 0 and w == 0 <span class="keyword">then</span> shared count != 0)</div><div class="line">               <span class="keyword">if</span> (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                   <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                   throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">               // Reentrant acquire</div><div class="line">               <span class="built_in">set</span>State(c + acquires);</div><div class="line">               <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">               !compareAndSetState(c, c + acquires))</div><div class="line">               <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="built_in">set</span>ExclusiveOwnerThread(current);</div><div class="line">           <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。<br>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount()方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">int c = getState();</div><div class="line">int nextc = c + (1 &lt;&lt; 16);</div><div class="line"><span class="keyword">if</span> (nextc &lt; c)</div><div class="line">throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</div><div class="line"><span class="built_in">return</span> -1;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line"><span class="built_in">return</span> 1;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。<br>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。<br>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void <span class="function"><span class="title">processData</span></span>() &#123;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 必须先释放读锁</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">// 锁降级从写锁获取到开始</div><div class="line">writeLock.lock();</div><div class="line">try &#123;</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line">// 准备数据的流程（略）</div><div class="line">update = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">read</span>Lock.lock();</div><div class="line">&#125; finally &#123;</div><div class="line">writeLock.unlock();</div><div class="line">&#125;</div><div class="line">// 锁降级完成，写锁降级为读锁</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">// 使用数据的流程（略）</div><div class="line">&#125; finally &#123;</div><div class="line"><span class="built_in">read</span>Lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。<br>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类完成相应工作。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程<br><img src="/2017/12/31/java并发编程4-6/locksupport.png" alt=""><br>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<h2 id="condition接口"><a href="#condition接口" class="headerlink" title="condition接口"></a>condition接口</h2><p>任意一个java对象，都拥有一组监视器方法，主要包括wait、notify、notifyAll方法，这些方法与synchronize同步关键字配合，可以实现等待、通知模式。Condition接口也提供了类似Object监视器方法，与lock配合实现等待通知模式。<br><img src="/2017/12/31/java并发编程4-6/对比.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Lock lock=new ReentrantLock();</div><div class="line">	static Condition condition=lock.newCondition();</div><div class="line">	public static void <span class="function"><span class="title">wait_1</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.await();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void <span class="function"><span class="title">singal</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			condition.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/12/31/java并发编程4-6/condition.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class BoundedQueue&lt;T&gt; &#123;</div><div class="line">    T[] itemsObjects;</div><div class="line">	int addindex,removeIndex,count;</div><div class="line">	Lock lock=new ReentrantLock();</div><div class="line">	Condition notFull=lock.newCondition();</div><div class="line">	Condition notEmpty=lock.newCondition();</div><div class="line">	public void add(T t)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==itemsObjects.length)&#123;</div><div class="line">				notFull.await();</div><div class="line">			&#125;</div><div class="line">			itemsObjects[addindex]=t;</div><div class="line">			addindex++;</div><div class="line">			<span class="keyword">if</span>(addindex==itemsObjects.length)&#123;</div><div class="line">				addindex=0;</div><div class="line">			&#125;</div><div class="line">			count++;</div><div class="line">			notEmpty.signal();</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public T <span class="function"><span class="title">remove</span></span>()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>(count==0)&#123;</div><div class="line">				notEmpty.await();</div><div class="line">			&#125;</div><div class="line">			T t=itemsObjects[removeIndex];</div><div class="line">			<span class="keyword">if</span>(++removeIndex==itemsObjects.length)</div><div class="line">				removeIndex=0;</div><div class="line">			count--;</div><div class="line">			notFull.signal();</div><div class="line">			<span class="built_in">return</span> t;</div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="condition的实现分析"><a href="#condition的实现分析" class="headerlink" title="condition的实现分析"></a>condition的实现分析</h3><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是FIFO的操作，在队列中的每个节点都包含一个线程的引用，该线程就是在Condition对象等待的线程，如果一个对象调用Condition.await，那么线程会释放锁，构造成节点加入等待队列并进入等待状态。点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node<br>一个Condition包含一个等待队列，Condition拥有首节点和尾节点，当前线程调用Condition.await，将会以当前线程构造节点，并将节点从尾部加入等待队列。<br><img src="/2017/12/31/java并发编程4-6/等待队列基本结构.png" alt=""><br>Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向他，并且更新尾节点。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br>在Object的监视器模型上，一个对象拥有一个同步队列和同步队列，而并发包中的Lock拥有一个同步队列和多个等待队列。<br><img src="/2017/12/31/java并发编程4-6/同步与等待.png" alt=""></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await方法中返回时，当前线程一定获取了Condition的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        throw new InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    long savedState = fullyRelease(node);</div><div class="line">    int interruptMode = 0;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != null) // clean up <span class="keyword">if</span> cancelled</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != 0)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步状态中的后继节点，然后当前线程会进入等待</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal方法，将会唤醒等待队列中等待最长的节点，在唤醒节点前，会将节点移到同步队列中。<br><img src="/2017/12/31/java并发编程4-6/唤醒.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void <span class="function"><span class="title">signal</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">throw new IllegalMonitorStateException();</div><div class="line">Node first = firstWaiter;</div><div class="line"><span class="keyword">if</span> (first != null)</div><div class="line"><span class="keyword">do</span>Signal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。<br>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。<br>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java并发/" rel="tag"># java并发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/26/java并发编程前三章/" rel="next" title="java并发编程前三章">
                <i class="fa fa-chevron-left"></i> java并发编程前三章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/01/MySQL性能管理及架构设计/" rel="prev" title="MySQL性能管理及架构设计">
                MySQL性能管理及架构设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pic23.nipic.com/20120808/4549724_124753431000_2.jpg"
               alt="李睿" />
          <p class="site-author-name" itemprop="name">李睿</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java并发编程基础"><span class="nav-number">1.</span> <span class="nav-text">java并发编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程简介"><span class="nav-number">1.1.</span> <span class="nav-text">线程简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用多线程"><span class="nav-number">1.1.2.</span> <span class="nav-text">为什么使用多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的优先级"><span class="nav-number">1.1.3.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的状态"><span class="nav-number">1.1.4.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon线程"><span class="nav-number">1.1.5.</span> <span class="nav-text">Daemon线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动和终止线程"><span class="nav-number">1.2.</span> <span class="nav-text">启动和终止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造线程"><span class="nav-number">1.2.1.</span> <span class="nav-text">构造线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动线程"><span class="nav-number">1.2.2.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解中断"><span class="nav-number">1.2.3.</span> <span class="nav-text">理解中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过期的suspend、resume、stop"><span class="nav-number">1.2.4.</span> <span class="nav-text">过期的suspend、resume、stop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全地终止线程"><span class="nav-number">1.2.5.</span> <span class="nav-text">安全地终止线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间通信"><span class="nav-number">1.3.</span> <span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile和synchronize关键字"><span class="nav-number">1.3.1.</span> <span class="nav-text">volatile和synchronize关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待-通知机制"><span class="nav-number">1.3.2.</span> <span class="nav-text">等待/通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待通知的经典范式"><span class="nav-number">1.3.3.</span> <span class="nav-text">等待通知的经典范式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待方"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">等待方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通知方"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">通知方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道输入输出流"><span class="nav-number">1.3.4.</span> <span class="nav-text">管道输入输出流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-join的使用"><span class="nav-number">1.3.5.</span> <span class="nav-text">Thread.join的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal的使用"><span class="nav-number">1.3.6.</span> <span class="nav-text">ThreadLocal的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程应用实例"><span class="nav-number">1.4.</span> <span class="nav-text">线程应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等待超时模式"><span class="nav-number">1.4.1.</span> <span class="nav-text">等待超时模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个简单的数据库连接池示例"><span class="nav-number">1.4.2.</span> <span class="nav-text">一个简单的数据库连接池示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java中的锁"><span class="nav-number">2.</span> <span class="nav-text">java中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock接口"><span class="nav-number">2.1.</span> <span class="nav-text">Lock接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列同步器"><span class="nav-number">2.2.</span> <span class="nav-text">队列同步器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#队列同步器的接口与示例"><span class="nav-number">2.2.1.</span> <span class="nav-text">队列同步器的接口与示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列同步器实现分析"><span class="nav-number">2.2.2.</span> <span class="nav-text">队列同步器实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步队列"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">同步队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#独占式同步状态获取与释放"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">独占式同步状态获取与释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享同步状态获取与释放"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">共享同步状态获取与释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#独占式超时获取同步状态"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">独占式超时获取同步状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重入锁"><span class="nav-number">2.3.</span> <span class="nav-text">重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁"><span class="nav-number">2.4.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁接口与示例"><span class="nav-number">2.4.1.</span> <span class="nav-text">读写锁接口与示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁实现设计"><span class="nav-number">2.4.2.</span> <span class="nav-text">读写锁实现设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#读写状态的设计"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">读写状态的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写状态的获取与释放"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">写状态的获取与释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读锁的获取与释放"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">读锁的获取与释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁降级"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">锁降级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport工具"><span class="nav-number">2.5.</span> <span class="nav-text">LockSupport工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#condition接口"><span class="nav-number">2.6.</span> <span class="nav-text">condition接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#condition的实现分析"><span class="nav-number">2.6.1.</span> <span class="nav-text">condition的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待队列"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等待"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通知"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">通知</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李睿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
